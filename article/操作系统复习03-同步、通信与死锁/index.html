<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统复习03-同步、通信与死锁, 代码段小站">
    <meta name="description" content="1 并发进程
1.1 顺序程序设计顺序程序设计是把一个程序设计成一个顺序执行的程序模块，顺序的含义不但指一个程序模块内部，也指两个程序模块之间。
顺序程序设计的特点：

程序执行的顺序性
程序环境的封闭性：运行程序独占全部资源，除初始状态外">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>操作系统复习03-同步、通信与死锁 | 代码段小站</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
    
    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/code.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">代码段小站</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/runcode" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>写代码</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/code.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">代码段小站</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/runcode" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			写代码
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统复习03-同步、通信与死锁</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/" class="post-category">
                                计算机相关
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-22
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.9k
                </div>
                

                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="并发进程">1 并发进程</h1><p><img src="https://api.codetool.top/img/15874794302366.png" alt></p>
<h2 id="顺序程序设计">1.1 顺序程序设计</h2><p>顺序程序设计是把一个程序设计成一个顺序执行的程序模块，顺序的含义不但指一个程序模块内部，也指两个程序模块之间。</p>
<p>顺序程序设计的特点：</p>
<ul>
<li><strong>程序执行的顺序性</strong></li>
<li><strong>程序环境的封闭性</strong>：运行程序独占全部资源，除初始状态外，其所处的环境由程序本身决定，只有程序本身的动作才能改变其环境</li>
<li><strong>执行结果的确定性</strong>：程序执行过程中允许被中断，但这种中断对程序的最终结果无影响，也即程序的执行结果与它的执行速率无关</li>
<li><strong>计算过程的可再现性</strong>：在同一个数据集合上重复执行一个程序会得到相同结果，因而错误也可以重现，便于分析</li>
</ul>
<h2 id="并发程序设计">1.2 并发程序设计</h2><h3 id="程序并发机制">1.2.1 程序并发机制</h3><p><strong>进程执行的并发性：</strong> 一组进程的执行在时间上是重叠的。（和并行区分开）</p>
<p>从宏观上看，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态。</p>
<p>从微观上看，任一时刻仅有一个进程在处理器上运行。</p>
<p>并发的实质是一个处理器在几个进程之间的多路复用，并发是<strong>对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</strong></p>
<h3 id="并发进程的特性">1.2.2 并发进程的特性</h3><p>并发进程之间的关系分为两类：无关的和交互的</p>
<p><strong>无关的并发进程：</strong> 一组并发进程分别<strong>在不同的变量集合上操作</strong>，一个进程的执行与其他并发进程的进展无关，即一个并发，进程不会改变另一个并发进程的变量值。</p>
<p><strong>交互的并发进程：</strong> 一组并发进程<strong>共享某些变量</strong>，一个进程的执行可能影响其他并发进程的执行结果。<strong>交互的并发进程之间具有制约关系</strong>，这种交互必须是有控制的,否则会出现不正确的结果。</p>
<p>对于一组交互的并发进程，若执行的相对速度无法相互控制，则各种与时间有关的错误就可能出现。与时间有关的错误有两种表现形式:</p>
<ul>
<li>结果不唯一</li>
<li>永远等待</li>
</ul>
<p>并发多道程序的优点：</p>
<ul>
<li>对于单处理器系统，可让处理器和各I/O设备同时工作,发挥硬部件的并行能力。</li>
<li><strong>对于多处理器系统，可让各进程在不同处理器上物理地并行，加快计算速度。</strong></li>
<li>简化程序设计任务。 </li>
</ul>
<p>并发程序设计的特征：</p>
<ol>
<li>并行性：进程的执行在时间上可以重叠，<strong>在单处理器系统中可以并发执行，在多处理器环境中可以并行执行</strong></li>
<li>共享性：并发进程<strong>通过引用共享变量交换信号</strong>，从而，程序运行的环境不再是封闭的</li>
<li>制约性：进程并发执行或协同<strong>完成同一任务时，会产生相互制约关系</strong>，必须对它们并发执行的次序加以协调</li>
<li>交互性：由于并发进程共享某些变量，所以，一个进程的执行可能影响其他进程的执行结果，<strong>程序运行结果可能不确定，计算过程具有不可再现性。</strong>因此，这种交互必须是有控制的，否则会出现不正确的结果</li>
</ol>
<h3 id="进程的交互">1.2.3 进程的交互</h3><p>交互进程有两种关系：</p>
<ul>
<li><strong>竞争关系</strong>：系统中的多个进程之间<strong>彼此无关，相互并不知道其它进程的存在</strong>，相互之间并不交换信息。但是<strong>由于这些进程共用了一套计算机系统资源,因而必然产生竞争资源的问题</strong>，一个进程的执行可能影响到同其竞争资源的其它进程。操作系统必须协调好诸进程对资源的争用。一旦一个进程要使用已分配给另一个进程的资源，则该进程必须等待。资源竞争产生两个问题:<ul>
<li>一个是<strong>死锁(Deadlock)问题</strong>，就是一组进程如果都获得了部分资源，还想要得到其他进程所占用的资源，最终所有进程都将陷入死锁</li>
<li>一个是<strong>饥饿(Starvation)问题</strong>，是指一个进程由于其它进程总是优先于它而被无限期拖延</li>
<li>既要解决饥饿问题，又要解决死锁问题。解决饥饿问题的最简单策略是FCFS资源分配策略</li>
<li>竞争关系的进程使用同一资源时，同一时刻最多只允许一个进程使用，其他进程必须等待，我们称这种现象为<strong>进程互斥</strong>。</li>
</ul>
</li>
<li><strong>协作关系</strong>：某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。<strong>当协作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后才被唤醒并继续执行</strong>。这种<strong>协作进程之间相互等待对方消息或信号的协调关系称为进程同步</strong><ul>
<li>进程间的协作可以是双方不知道对方名字的间接协作（如多个进程通过访问一个公共缓冲区进行松散式协作），也可以是双方知道对方名字的直接协作，进程间通过通信机制紧密协作。</li>
</ul>
</li>
</ul>
<h1 id="临界区管理">2 临界区管理</h1><p><img src="https://api.codetool.top/img/15874814349435.png" alt></p>
<h2 id="互斥与临界区">2.1 互斥与临界区</h2><p>并发进程中<strong>与共享变量有关的程序段叫“临界区”</strong>， 共享变量代表的资源叫“临界资源”。 </p>
<p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预知。<strong>如果能保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误</strong></p>
<h2 id="临界区调度原则">2.2 临界区调度原则</h2><ul>
<li><strong>一次至多一个进程能够进入临界区内执行</strong></li>
<li>如果<strong>已有进程在临界区，其他试图进入的进程应等待</strong></li>
<li>进入临界区内的进程<strong>应在有限时间内退出</strong>，以便让等待进程中的一个进入</li>
</ul>
<p>临界区调度原则可总结为：</p>
<p>互斥使用、有空让进，<br>忙则等待、有限等待，<br>择一而入、算法可行。</p>
<p>算法可行是指<strong>不能因为所选的调度策略造成进程饥饿甚至死锁</strong>。</p>
<h2 id="软件管理临界区">2.3 软件管理临界区</h2><p>软件方法是为在具有一个处理器或共享主存的多处理器上执行的并发进程实现的，这种方法<strong>假定对主存中同一个单元的同时访问必定由存储器进行仲裁，使其串行化。</strong></p>
<p>临界区管理的尝试：（下面是一段伪代码，非C语言）</p>
<pre class=" language-c"><code class="language-c">bool inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P1不在其临界区内*/</span>
bool inside2<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P2不在其临界区内*/</span>
cobegin             <span class="token comment" spellcheck="true">/*cobegin和coend表示括号中的进程是一组并发进程*/</span>
process <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                
    <span class="token keyword">while</span><span class="token punctuation">(</span>inside2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*等待*/</span>  
    inside1<span class="token operator">=</span>true<span class="token punctuation">;</span>                  
    <span class="token comment" spellcheck="true">/*临界区*/</span>                      
    inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>                 
<span class="token punctuation">}</span>

process <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>inside1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*等待*/</span>
    inside2<span class="token operator">=</span>true<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>
    inside2<span class="token operator">=</span>false<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
coend </code></pre>
<p>这种方法看似没有问题，实则是错误的，</p>
<p><img src="https://api.codetool.top/img/15874826788391.png" alt></p>
<p>如上图所示，由于P1执行的时候将inside1设为true存在一定的时间延迟（和上一个操作不是原子的），在这段延迟的时间内，P2发现inside1仍为false，于是也进入临界区执行。出现了两个进程同时进入临界区的情况。</p>
<p>此外还有可能P1在临界区内失败（异常），导致无法将inside1置为false，使得其他进程再也无法进入临界区。</p>
<p>除此之外还出现了许多尝试，但仍存在一些无法解决的问题。</p>
<p>后来出现了两个真正实现了临界区管理的软件方法：Dekker算法和Peterson算法。由于软件实现临界区管理也不是主流，这里不重点研究了。</p>
<p>Dekker算法的实现：（下面两段代码来自 <a href="https://blog.csdn.net/JustJavaC2016/article/details/78660768）" target="_blank" rel="noopener">https://blog.csdn.net/JustJavaC2016/article/details/78660768）</a></p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span>
<span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  
<span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> turn<span class="token punctuation">;</span>  
<span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"P%d is visting\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用关键区。  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//检查P1是不是也想用？  </span>
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果P1想用，则查看P1是否具有访问权限？  </span>
            <span class="token punctuation">{</span>  
                flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果有，则P0放弃。  </span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>
                flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用。  </span>
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>
        turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P1。  </span>
        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0结束使用。  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1想使用关键区。  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//检查P0是不是也想用？  </span>
        <span class="token punctuation">{</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果P0想用，则查看P0是否具有访问权限？  </span>
            <span class="token punctuation">{</span>  
                flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果有，则P1放弃。  </span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>
                flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// P1想使用。  </span>
            <span class="token punctuation">}</span>  

        <span class="token punctuation">}</span>  
            <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>
        turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P0。  </span>
        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1结束使用。  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>  
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>  
    err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  </code></pre>
<p>Peterson算法的实现：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span>
<span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span>
<span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  
<span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token keyword">int</span> turn<span class="token punctuation">;</span>  
<span class="token keyword">void</span> <span class="token function">procedure0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
        turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">//退出while循环的条件就是，要么另一个线程  </span>
        <span class="token comment" spellcheck="true">//不想要使用关键区，要么此线程拥有访问权限。  </span>
        <span class="token punctuation">{</span>  
                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure0 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment" spellcheck="true">//critical section  </span>
        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">procedure1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
            turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
            <span class="token punctuation">{</span>  
                    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure1 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token comment" spellcheck="true">//critical section  </span>
            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>  
    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>  
    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  </code></pre>
<h2 id="硬件管理临界区">2.4 硬件管理临界区</h2><p>使用软件方法实现进程互斥使用临界资源是很困难的，他们通常能实现两个进程之间的互斥，很难控制多个进程的互斥。</p>
<h3 id="关中断">2.4.1 关中断</h3><p>关中断是实现互斥的最简单方法之一。</p>
<p>进程在测试标志之前，首先关中断，直到测试完并设置标志之后才开中断。进程在临界区执行期间，<strong>计算机系统不响应中断。因此不会转向调度，也就不会引起进程或线程切换，正在执行标志测试和设置的进程或线程不会被打断，从而保证了互斥。</strong></p>
<p>关中断方法的缺点:</p>
<ul>
<li>关中断时间过长会影响系统效率，限制处理器交叉执行程序的能力</li>
<li>关中断方法也不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其他处理器上执行相同临界区代码</li>
</ul>
<h3 id="测试并设置指令">2.4.2 测试并设置指令</h3><p>其实就是<code>TestAndSet</code>，Java CAS的原理，操作系统层面提供的原子操作指令。</p>
<p>因为该指令是原子的，就可以使用该指令管理一个互斥量，从而实现临界区管理。</p>
<p>TS指令实现临界区管理的算法如下：（自旋锁）</p>
<pre class=" language-c"><code class="language-c">bool s<span class="token operator">=</span>true<span class="token punctuation">;</span>
cobegin
process <span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i=1,2,...,n</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TS</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*上锁*/</span>
    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>
    s<span class="token operator">=</span>true<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/*开锁*/</span>
<span class="token punctuation">}</span>
coend</code></pre>
<h3 id="对换指令">2.4.3 对换指令</h3><p>对换指令（swap）交换两个字的内容，在Intel 80x86中，对换指令称为<code>XCHG</code>指令</p>
<p>swap指令也可以看作是同时设置两个值的原子指令实现，所以也可以用于临界区管理，思想类似。</p>
<p><strong>软件方法和硬件方法都存在忙等问题（当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环测试一个变量直到某个值出现为止），浪费了处理器的时间，不会成为一种通用的方法。</strong></p>
<h1 id="信号量与PV操作">3 信号量与PV操作</h1><p><img src="https://api.codetool.top/img/15874850424979.png" alt></p>
<h2 id="信号量机制">3.1 信号量机制</h2><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以<strong>用一个信号量来表示系统中某种资源的数量</strong>，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p>一对原语：<code>wait(S)</code>原语和<code>signal(S)</code>原语，常简称为P、V操作。</p>
<p><code>wait(S)</code>相当于占用一个S资源，<code>signal(S)</code>相当于释放一个S资源。</p>
<h3 id="整型信号量">3.1.1 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。下面是P、V原语的实现思想：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//初始化整型信号量S，表示当前系统中可用的打印机数</span>

<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果资源数不够，就一直循环等待</span>
    S <span class="token operator">=</span> S<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果资源数够，则占用一个资源</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>
    S <span class="token operator">=</span> S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>进程Pn：</p>
<pre class=" language-c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//使用打印机资源...</span>
<span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="记录型信号量">3.1.2 记录型信号量</h3><p>（思维导图中的二值信号量和一般信号量都是属于这里的记录型信号量）</p>
<p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*记录型信号量的定义*/</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//剩余资源数</span>
    <span class="token keyword">struct</span> process <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待队列</span>
<span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>
    S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//如果剩余资源数不够</span>
        <span class="token comment" spellcheck="true">//使用block原语使进程从运行态进入阻塞</span>
        <span class="token comment" spellcheck="true">//并把进程挂到信号量S的等待队列(即阻塞队列)中</span>
        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>
    S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//释放资源后，若还有别的进程在等待这种资源</span>
        <span class="token comment" spellcheck="true">//则使用wakeup原语唤醒等待队列中的个进程</span>
        <span class="token comment" spellcheck="true">//该进程从阻塞态变为就绪态</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里信号量的语义就是资源的个数，并且实现了让权等待，不会形成忙等。</p>
<h2 id="信号量机制实现进程互斥">3.2 信号量机制实现进程互斥</h2><p>我们可以把临界区看作一种特殊的资源，为临界区抽象出一个互斥信号量<code>mutex</code>，<strong>它是二值的，初值为1</strong>，代表同一个时间只能有一个进程进入临界区。</p>
<ul>
<li>在进入临界区之前执行<code>P(mutex)</code></li>
<li>在退出临界区之后执行<code>V(mutex)</code></li>
</ul>
<h2 id="信号量机制实现进程同步">3.3 信号量机制实现进程同步</h2><p>进程同步问题要求多个进程按一定次序先后执行一段代码。这个前驱关系可能是较复杂的，如下图所示，可以<strong>为每一对前驱关系各设置一个同步信号量</strong>，初值为0，<strong>要执行某操作前需要对前驱操作对应的信号量进行P操作，当完成了前驱操作时对对应的信号量执行V操作。</strong></p>
<p><img src="https://api.codetool.top/img/15874890505885.png" alt></p>
<pre><code>semaphore a = 0,b = 0,c = 0,d = 0,e = 0,f = 0,g = 0;

P1(){
    ...
    S1;
    V(a);
    V(b);
    ...
}

P2(){
    ...
    P(a);
    S2;
    V(c);
    V(d);
    ...
}

P3(){
    ...
    P(b);
    S3;
    V(g);
    ...
}

P4(){
    ...
    P(c);
    S4;
    V(e);
    ...
}

P5(){
    ...
    P(d);
    S5;
    V(f);
    ...
}

P6(){
    ...
    P(e);
    P(f);
    P(g);
    S6;
    ...
}</code></pre><h1 id="管程">4 管程</h1><p><img src="https://api.codetool.top/img/15875338871013.png" alt></p>
<h2 id="管程和条件变量">4.1 管程和条件变量</h2><h3 id="为什么要引入管程">4.1.1 为什么要引入管程</h3><p>信号量机制存在的问题：编写程序困难、易出错。</p>
<p>管程：</p>
<ul>
<li>把分散在各进程中的临界区集中起来进行管理 </li>
<li>防止进程有意或无意的违法同步操作</li>
<li>便于用高级语言来书写程序，也便于程序正确性验证</li>
</ul>
<h3 id="管程的定义">4.1.2 管程的定义</h3><p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。 </p>
<p>管程的基本特征:</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li><strong>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</strong></li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>
</ol>
<p>管程的属性:</p>
<ul>
<li>共享性</li>
<li>安全性</li>
<li>互斥性</li>
</ul>
<h3 id="管程的结构">4.1.3 管程的结构</h3><p>管程是一种特殊的软件模块，有这些部分组成:</p>
<ol>
<li>局部于管程的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程有一个名字</li>
</ol>
<p>例如：(使用类C语言语法模拟管程结构)</p>
<pre class=" language-cpp"><code class="language-cpp">type ProducerConsumer <span class="token operator">=</span> monitor<span class="token punctuation">{</span>
    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//条件变量用来实现同步排队</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//缓冲区中的产品数</span>
    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//把产品item放入缓冲区</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span>N<span class="token punctuation">)</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从缓冲区中取出一个产品</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>N<span class="token number">-1</span><span class="token punctuation">)</span>
            <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//生产者进程</span>
<span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        item <span class="token operator">=</span> 生产一个产品<span class="token punctuation">;</span>
        ProducerConsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//消费者进程</span>
<span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        消费产品item   
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="管程的条件变量">4.1.4 管程的条件变量</h3><p>条件变量是出现在管程内的一种数据结构，且<strong>只有在管程中才能被访问</strong>，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它。</p>
<ul>
<li><code>wait()</code>：挂起调用进程并释放管程，直到另一个进程在该条件变量上执行<code>signal()</code>。</li>
<li><code>signal( )</code>：如果存在其他进程由于对条件变量执行<code>wait()</code>而被挂起，便释放之；如果没有进程在等待，那么，信号不被保存。</li>
</ul>
<h1 id="死锁">5 死锁</h1><p><img src="https://api.codetool.top/img/15875359806127.png" alt></p>
<h2 id="死锁的产生">5.1 死锁的产生</h2><p>操作系统中的死锁指：如果<strong>在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件</strong>，则称一组进程或系统此时发生死锁。</p>
<p>死锁产生的例子：</p>
<p>设系统有打印机、读卡机各一台，被进程Ｐ和Ｑ共享。两个进程并发执行，按下列次序请求和释放资源：</p>
<table>
<thead>
<tr>
<th align="center">进程Ｐ</th>
<th align="center">进程Ｑ</th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求读卡机</td>
<td align="center">请求打印机</td>
</tr>
<tr>
<td align="center"><strong>请求打印机</strong></td>
<td align="center"><strong>请求读卡机</strong></td>
</tr>
<tr>
<td align="center">释放读卡机</td>
<td align="center">释放读卡机</td>
</tr>
<tr>
<td align="center">释放打印机</td>
<td align="center">释放打印机</td>
</tr>
</tbody></table>
<p>在PV操作中对应</p>
<table>
<thead>
<tr>
<th align="center">进程Q1</th>
<th align="center">进程Q2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P(S1)</td>
<td align="center">P(S2)</td>
</tr>
<tr>
<td align="center"><strong>P(S2)</strong></td>
<td align="center"><strong>P(S1)</strong></td>
</tr>
<tr>
<td align="center">使用r1和r2</td>
<td align="center">使用r1和r2</td>
</tr>
<tr>
<td align="center">V(S1)</td>
<td align="center">V(S2);</td>
</tr>
<tr>
<td align="center">V(S2)</td>
<td align="center">V(S1);</td>
</tr>
</tbody></table>
<p>在第一步中，双方都拿到了请求的资源，但是第二步中请求的资源都被对方所持有，于是都在等待对方释放资源，从而陷入死锁。</p>
<p>若系统中有m个资源被n个进程共享，每个进程都要求Ｋ个资源，而m &lt; n·K时，即<strong>资源数小于进程所要求的总数时，如果分配不得当就可能引起死锁。</strong></p>
<p>在著名的哲学家就餐问题中，若五个哲学家同时拿起右手边的餐具，此时左手边的的餐具就被另外一个哲学家占用，所有哲学家都陷入了无止境的等待资源释放状态，即死锁。</p>
<h2 id="死锁产生的必要条件">5.2 死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li><strong>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</strong>（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li>
<li><strong>不剥夺条件：</strong> 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件：</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件：</strong> 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>归根结底，循环等待条件是前三种条件导致的结果。</p>
<h2 id="解决方法">5.3 解决方法</h2><h3 id="死锁防止">5.3.1 死锁防止</h3><p>死锁防止就是要破坏死锁产生的必要条件。</p>
<p><strong>破坏互斥条件：</strong> 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备</strong>。例如使用SPOOLing技术将打印机改造为共享设备。</p>
<p><strong>破坏不剥夺条件：</strong></p>
<ul>
<li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li>
<li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li>
</ul>
<p>该策略的缺点：</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ol>
<p><strong>破坏请求和保持条件：</strong><br>可以采用静态分配方法，即进程<strong>在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。</strong> 一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>该策略的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都–直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p>
<p><strong>破坏循环等待条件：</strong> 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<p>该策略的缺点:</p>
<ol>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户编程麻烦</li>
</ol>
<h3 id="死锁避免">5.3.2 死锁避免</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p>
<p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p>
<p>死锁避免就是避免系统进入不安全状态。</p>
<p>银行家算法的数据结构：</p>
<p>一个系统有n个进程和m种不同类型的资源,定义包含以下向量和矩阵的数据结构：</p>
<ul>
<li>系统每类资源总数：该m个元素的向量为<strong>系统中每类资源数量</strong><code>Resource=(R1,R2,…,Rm)</code></li>
<li>每类资源未分配数量：该m个元素的向量为<strong>系统中每类资源尚可供分配数量</strong><code>Avilable=(V1,V2,…,Vm)</code></li>
<li>最大需求矩阵：<strong>每个进程对每类资源的最大需求量</strong>，<code>Claim[I,j]</code>表示进程Pi需Rj类资源最大数</li>
<li>分配矩阵：表示<strong>进程当前已分得的资源数</strong>，<code>Allocation[i,j]</code>表示进程Pi已分到Rj类资源个数</li>
<li>尚需矩阵：表示<strong>进程当前尚需资源数</strong>，<code>Need[i,j]</code>表示进程Pi尚需Rj类资源个数</li>
</ul>
<p>银行家算法中下列关系式确保成立：</p>
<ul>
<li><code>Ri=Vi+∑Allocation[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>所有资源要么已被分配、要么尚可分配</strong></li>
<li><code>Claim[k,i]≤Rj</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请资源数不能超过系统拥有的资源总数</strong></li>
<li><code>Allocation[k,i] ≤ Claim[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请任何类资源数不能超过声明的最大资源需求数</strong></li>
</ul>
<p>系统中若要启动一个新进程工作,其对资源Ri的需求仅当满足下列不等式：</p>
<p><code>Ri ≥ C[(n+1),i]+ ∑C[k,i]</code>  对i=1,..,m,k=1,..,n; </p>
<p>即应满足<strong>当前系统中所有进程对资源Ri的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</strong></p>
<p>系统安全性定义：在时刻T0系统是安全的,仅当存在一个进程序列P1,..,Pn,对进程Pk满足公式：</p>
<p><code>Need[k,i] ≤Available [i]+ ∑Allocation[j,i]</code> 对于k=1,…,n;i=1,…,m; </p>
<p>即对任何一个进程都能满足其所需要的资源。</p>
<p>银行家算法的基本思想：</p>
<ul>
<li>系统中的所有进程进入进程集合,</li>
<li>在安全状态下系统收到进程的资源请求后,先把资源<strong>试探性分配</strong>给它。</li>
<li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到<strong>剩余资源能满足最大需求量的进程</strong>,从而,保证<strong>这个进程运行完毕并归还全部资源</strong>。</li>
<li>把这个进程从集合中去掉, 系统的剩余资源更多了,<strong>反复执行上述步骤</strong>。</li>
<li>最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。 </li>
</ul>
<h3 id="死锁的检测和解除">5.3.3 死锁的检测和解除</h3><p>该部分参考自：<a href="http://www.360doc.com/content/16/0421/16/478627_552610896.shtml" target="_blank" rel="noopener">死锁的检测和解除</a></p>
<p>解决死锁问题的一条途径是死锁检测和解除，这种方法<strong>对资源的分配不加任何限制，也不采取死锁避免措施</strong>，但系统定时地运行一个“死锁检测”程序，判断系统内是否已出现死锁，<strong>如果检测到系统已发性了死锁，再采取措施解除它</strong>。</p>
<p>进程-资源分配图：</p>
<p>如图所示，用<strong>圆圈代表一个进程</strong>，用<strong>框代表一类资源</strong>。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。<strong>从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</strong></p>
<p><img src="https://api.codetool.top/img/15875408526262.jpg" alt="初始资源分配图"></p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁。</li>
<li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程。</li>
<li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。可以使用将资源分配图简化的方法来检测系统是否处于死锁状态：</li>
</ol>
<p>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且<strong>该有向边对应资源的申请数量小于等于系统中已有空闲资源数量</strong>。如上图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。<strong>消去它所有的请求边和分配边</strong>，使之称为孤立的结点。在上图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p>
<p><strong>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程</strong>，原来的阻塞进程可能变为非阻塞进程。在上图中，P2 就满足这样的条件。根据上面的方法进行一系列简化后，<strong>若能消去途中所有的边，则称该图是可完全简化的</strong>。</p>
<p><img src="https://api.codetool.top/img/15875411733947.jpg" alt="资源分配图的化简"></p>
<p>一旦检测出死锁，就应立即釆取相应的措施。死锁解除算法有：</p>
<ol>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.codetool.top" rel="external nofollow noreferrer">Rhett Peng</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。参考的网络来源均已尽可能地注明，部分参考来自他人的整理资料，无法标注，在此感谢！
                    <a href="https://www.codetool.top" target="_blank">Rhett Peng</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'VUmN3m0ICuwaL4jNPnxBRln8-gzGzoHsz',
        appKey: 'QH8FVT32jvi4qBllLg6Cf0dU',
        notify: 'false' === 'true',
        verify: 'true' === 'true',
        meta: ['nick','mail'],
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '说点什么吧'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/article/leetcode199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="leetcode199-二叉树的右视图">
                        
                        <span class="card-title">leetcode199-二叉树的右视图</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 原题给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例：
输入:&nbsp;[1,2,3,null,5,null,4]
输出:&nbsp;[1, 3, 4]
解释:

   1       
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-04-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-category">
                                    算法/数据结构
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/leetcode/">
                        <span class="chip bg-color">leetcode</span>
                    </a>
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/article/leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="leetcode239-滑动窗口最大值">
                        
                        <span class="card-title">leetcode239-滑动窗口最大值</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1 原题给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。
进阶：
你能在线性时间复杂度内解决此题吗？
示例 
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-04-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-category">
                                    算法/数据结构
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/leetcode/">
                        <span class="chip bg-color">leetcode</span>
                    </a>
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019-2020</span>
            <a href="https://www.codetool.top" target="_blank">Rhett Peng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">606.4k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://beian.miit.gov.cn/" target="_blank">赣ICP备19011928号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/codeband-top" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:pctdyx@qq.net" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=995632825" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 995632825" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":200,"hOffset":20,"vOffset":100},"mobile":{"show":false},"dialog":{"enable":true,"hitokoto":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
<div id="chat_input"><input id="question" type="text" placeholder="陪我聊聊天吧" onkeypress="return onKeyPress(event)"/></div>
</html>

<!--动态线条背景-->
<script type="text/javascript"
color="0,0,0" opacity='0.5' zIndex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<script>

//聊天框按回车
function onKeyPress(e){
    var keyCode = null;
    if(e.which)
        keyCode = e.which;
    else if(e.keyCode)
        keyCode = e.keyCode;
        
    //如果按下回车
    if(keyCode == 13) {
        // 1.获取界面上的元素value
        var question_box = document.getElementById('question')
        var question = question_box.value
        question_box.value = ""
        question_box.setAttribute("disabled","disabled")
        var api_key = "78c33a07808c7b9e1905c89c88b3be14"
        var api_secret = "q707tevnk00f"

        // 2.通过XHR发送一个POST请求
        var xhr = new XMLHttpRequest()
        xhr.open('GET','https://api.codetool.top/robottalk?question='+encodeURIComponent(question)+"&api_key="+api_key+"&api_secret="+api_secret)
		xhr.send(null)
		xhr.onload = function(){
            question_box.removeAttribute('disabled');
            var live2d_dialog = document.getElementsByClassName("live2d-widget-dialog")[0]
            live2d_dialog.style.opacity=1
            live2d_dialog.innerHTML = this.responseText
            window.setTimeout(()=>{
                live2d_dialog.style.opacity=0
            }, 5000);
		}
    }

}

</script>

<style> 
#chat_input{
    width: 200px;
    height: 40px;
    position: fixed;
    right: 0px;
    bottom: 80px;
    right: 20px;
} 

#question{
    border: none;
    border-bottom: 1px #aaaaaa solid;
    background-color: transparent;
    padding: 5px;
}

@media screen and (max-width: 601px) {
    #chat_input{
        display: none;
    }
    #live2d-widget{
        display: none;
    }
}
</style>