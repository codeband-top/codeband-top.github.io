<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-05-01T06:01:44.821Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode39-组合总和</title>
    <link href="https://www.codetool.top/article/leetcode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode39-组合总和/</id>
    <published>2020-05-01T05:20:51.000Z</published>
    <updated>2020-05-01T06:01:44.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> candidates = <code>[2,3,6,7], </code>target = <code>7</code>,<strong>所求解集为:</strong>[  [7],  [2,2,3]]</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> candidates = [2,3,5]<code>, </code>target = 8,<strong>所求解集为:</strong>[&nbsp; [2,2,2,2],&nbsp; [2,3,3],&nbsp; [3,5]]</pre><h1 id="解法">2 解法</h1><p>本题解同步发于leetcode题解：<a href="https://leetcode-cn.com/problems/combination-sum/solution/java-dfsrang-ni-zhi-dao-zu-he-zen-yao-qu-zhong-jia/" target="_blank" rel="noopener">Java DFS，让你知道组合怎么去重&amp;剪枝&amp;回溯到底是什么</a></p><h2 id="思想">2.1 思想</h2><p>该题难点在于组合的去重，如果直接不加条件的dfs很容易找到相同的组合，例如示例一可以找出<code>[2,2,3]</code>和<code>[2,3,2]</code>、<code>[3,2,2]</code>，它们实质上是同一个组合。<strong>如果要进行去重，可以考虑给组合添加一个限制条件，例如我们要求，找到的组合中前面的数必须大于等于后面的数。</strong></p><p>那么为了只找到满足条件的组合，可以先将<code>candidates</code>数组从小到大排序，每次dfs选取一个元素之后，我们就不再选取比它大的元素（即后面只在下标小于等于它的元素中查找）。这样就可以做到查找到的组合满足前面的数总是大于等于后面的数。</p><p>这样的dfs查找，如果画出树状图的话，会看到这个搜索树<strong>因为某些部分条件不满足，于是不再向下查找，称为“剪枝”。</strong></p><p><img src="https://api.codetool.top/img/15883122816465.png" alt></p><p><img src="https://api.codetool.top/img/15883122947821.png" alt></p><p>那么其他题解说的“回溯算法”是什么呢，其实<strong>用递归实现的DFS就必然会经过回溯，当条件不满足时，递归函数需要返回到上一层节点，继续查找，称为“回溯”。</strong></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先对candidates从小到大排序</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>candidates <span class="token operator">=</span> candidates<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>target<span class="token punctuation">,</span>candidates<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//maxIndex表示允许在candidates搜索到的最大下标</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">,</span><span class="token keyword">int</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>maxIndex<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> copyList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                copyList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>copyList<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//当选取下标为i的节点后，下一步只允许在下标小于等于i的元素中查找</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>copyList<span class="token punctuation">,</span>target<span class="token operator">-</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;无重复元素&lt;/strong&gt;的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Handler dispatch failed; nested exception is java.lang.NoSuchMethodError</title>
    <link href="https://www.codetool.top/article/%E5%B0%8F%E5%BF%83%E6%9B%B4%E6%96%B0%E5%88%B0Idea-2020-01%E3%80%82%E3%80%82%E3%80%82/"/>
    <id>https://www.codetool.top/article/小心更新到Idea-2020-01。。。/</id>
    <published>2020-04-30T13:53:43.000Z</published>
    <updated>2020-04-30T14:17:04.845Z</updated>
    
    <content type="html"><![CDATA[<p>【原文】</p><p>idea前段时间不是出了2020.01嘛。。我很快就装了</p><p>这段时间一直用着lombok，今天运行项目lombok注解都失效了 <strong>（事实证明不是lombok失效了）</strong> ，检查了一下注解也在，依赖也在，插件也在，配置也配置了，可就是没有用。</p><p>不知道是为什么，反正我就是归为Idea新版bug的原因。。</p><p>我现在就一个一个的给那些实体类加getter/setter，太浪费时间了/(ㄒoㄒ)/~~</p><hr><p><strong>事后：可能并不是lombok注解失效，我错怪IDEA了</strong></p><p>我一开始运行项目用到某一个方法报错：</p><pre><code>Handler dispatch failed; nested exception is java.lang.NoSuchMethodError</code></pre><p>然后后面是什么get、set方法没找到，我还以为是<code>@Data</code>失效了，后面我把所有的实体类加了一遍getter/setter发现还是不行😀</p><p>最后百度了一下发现是因为<strong>maven项目重复依赖</strong>：</p><blockquote><p>造成这个错误的原因可能为: A-module的pom依赖了B-module和C-module, 然而B-module的pom也依赖了C-module导致</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【原文】&lt;/p&gt;
&lt;p&gt;idea前段时间不是出了2020.01嘛。。我很快就装了&lt;/p&gt;
&lt;p&gt;这段时间一直用着lombok，今天运行项目lombok注解都失效了 &lt;strong&gt;（事实证明不是lombok失效了）&lt;/strong&gt; ，检查了一下注解也在，依赖也在，插件也在
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode38-外观数列</title>
    <link href="https://www.codetool.top/article/leetcode38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode38-外观数列/</id>
    <published>2020-04-30T05:45:04.000Z</published>
    <updated>2020-04-30T05:50:42.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><pre>1.     12.     113.     214.     12115.     111221</pre><p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  <code>&quot;one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> 1<br><strong>输出:</strong> “1”<br><strong>解释：</strong> 这是一个基本样例。  </p></blockquote><p>示例 2:</p><blockquote><p><strong>输入:</strong> 4<br><strong>输出:</strong> “1211”<br><strong>解释：</strong> 当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，比较简单。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">countAndSay</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        strings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> strings<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>chars<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            strings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> strings<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：&lt;/p&gt;
&lt;pre&gt;1.     1
2.     11
3.     21
4.     1211
5.     111221
&lt;/pre
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OpenFeign使用Hystrix报错：Ambiguous mapping. Cannot map xx method...</title>
    <link href="https://www.codetool.top/article/OpenFeign%E6%8A%A5%E9%94%99%EF%BC%9AAmbiguous-mapping-Cannot-map-xx-method/"/>
    <id>https://www.codetool.top/article/OpenFeign报错：Ambiguous-mapping-Cannot-map-xx-method/</id>
    <published>2020-04-29T14:06:31.000Z</published>
    <updated>2020-04-29T14:17:32.617Z</updated>
    
    <content type="html"><![CDATA[<p>今天做项目的时候，feign调用的时候写了一个Hystrix的服务降级处理类，但是运行时报了以下错误：</p><pre><code>Ambiguous mapping. Cannot map &#39;com.guli.vod.feign.VodFeign&#39; method com.guli.vod.feign.VodFeign#removeVideo(String)to {DELETE /vod/video/{id}}: There is already &#39;vodFallback&#39; bean methodcom.guli.vod.fallback.VodFallback#removeVideo(String) mapped.</code></pre><p>原来写的FeignClient：(这里吐槽一下，Restful api根本没办法设计批量删除的路径嘛，DELETE方法又不推荐使用请求体，而且将资源id放在请求体里也不符合Restful url的语义)</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"service-vod"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> VodFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/vod"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">VodFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/video/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String videoId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/video/delete-batch"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideoList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"videoIdList"</span><span class="token punctuation">)</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> videoIdList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>服务降级处理类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VodFallback</span> <span class="token keyword">implements</span> <span class="token class-name">VodFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideo</span><span class="token punctuation">(</span>String videoId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Result<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token string">"time out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideoList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> videoIdList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Result<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token string">"time out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>原因在于<code>VodFallback</code>实现了<code>VodFeign</code>接口后，把<code>@RequestMapping</code>的路径映射也继承了过去，而两个类都会注册bean实例对象，就会出现映射冲突的问题，最后我是将FeignClient的<code>@RequestMapping</code>都写在了方法上，成功解决：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"service-vod"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> VodFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">VodFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/vod/video/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String videoId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/vod/video/delete-batch"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideoList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"videoIdList"</span><span class="token punctuation">)</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> videoIdList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做项目的时候，feign调用的时候写了一个Hystrix的服务降级处理类，但是运行时报了以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ambiguous mapping. Cannot map &amp;#39;com.guli.vod.feign.VodFeign&amp;#39; me
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="Hystrix" scheme="https://www.codetool.top/tags/Hystrix/"/>
    
      <category term="OpenFeign" scheme="https://www.codetool.top/tags/OpenFeign/"/>
    
  </entry>
  
  <entry>
    <title>leetcode74-搜索二维矩阵</title>
    <link href="https://www.codetool.top/article/leetcode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.codetool.top/article/leetcode74-搜索二维矩阵/</id>
    <published>2020-04-29T12:46:39.000Z</published>
    <updated>2020-04-29T12:48:19.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例1:</strong></p><pre><strong>输入:</strong>matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 3<strong>输出:</strong> true</pre><p><strong>示例2:</strong></p><pre><strong>输入:</strong>matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13<strong>输出:</strong> false</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>先进行行的二分搜索，找出在哪一行之后再对列进行二分搜索。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">||</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> width <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> row <span class="token operator">=</span> start<span class="token punctuation">;</span>        start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        end <span class="token operator">=</span> width<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1095-山脉数组中查找目标值</title>
    <link href="https://www.codetool.top/article/leetcode1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode1095-山脉数组中查找目标值/</id>
    <published>2020-04-29T06:32:06.000Z</published>
    <updated>2020-04-29T06:51:09.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>（这是一个 <strong>交互式问题</strong> ）</p><p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p><p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p><p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p><p><strong>首先</strong>，<code>A.length &gt;= 3</code></p><p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 i 使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p><ul><li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li><li><code>MountainArray.length()</code> - 会返回该数组的长度</li></ul><p><strong>注意：</strong>  </p><p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> <strong>不是一个正确答案</strong>。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> array = [1,2,3,4,5,3,1], target = 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> array = [0,1,2,4,2,1], target = 3<br><strong>输出：</strong> -1<br><strong>解释：</strong> 3 在数组中没有出现，返回 -1。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li><li><code>0 &lt;= target &lt;= 10^9</code></li><li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>超过 <code>100</code> 次调用的提交将被视为错误答案，数据规模又小于等于一万，很明显是要用<code>logn</code>的时间复杂度求解，因为是有序数组，也很容易想到二分查找。由于这个数组不是完全有序的，可以分成升序和降序的两部分，则可以先找出峰顶值，然后对两部分进行二分查找。</p><h2 id="代码">2.2 代码</h2><p>（作者：liweiwei1419）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findInMountainArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> MountainArray mountainArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> mountainArr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤 1：先找到山顶元素所在的索引</span>        <span class="token keyword">int</span> mountaintop <span class="token operator">=</span> <span class="token function">findMountaintop</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤 2：在前有序且升序数组中找 target 所在的索引</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">findFromSortedArr</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mountaintop<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 步骤 3：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引</span>        <span class="token keyword">return</span> <span class="token function">findFromInversedArr</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> mountaintop <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回山顶元素</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findMountaintop</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 取左中位数，因为进入循环，数组一定至少有 2 个元素</span>            <span class="token comment" spellcheck="true">// 因此，左中位数一定有右边元素，数组下标不会发生越界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果当前的数比右边的数小，它一定不是山顶</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFromSortedArr</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFromInversedArr</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;（这是一个 &lt;strong&gt;交互式问题&lt;/strong&gt; ）&lt;/p&gt;
&lt;p&gt;给你一个 &lt;strong&gt;山脉数组&lt;/strong&gt; &lt;code&gt;mountainArr&lt;/code&gt;，请你返回能够使得 &lt;code&gt;mountainArr
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习05-设备管理</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A005-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://www.codetool.top/article/操作系统复习05-文件管理/</id>
    <published>2020-04-28T14:58:05.000Z</published>
    <updated>2020-04-29T09:15:13.476Z</updated>
    
    <content type="html"><![CDATA[<p>设备管理的功能：</p><ul><li>外围设备中断处理</li><li>缓冲区管理</li><li>外围设备的分配和去配     </li><li>外围设备驱动调度</li><li>虚拟设备及其实现</li></ul><h1 id="I-O硬件原理">1 I/O硬件原理</h1><p><img src="https://api.codetool.top/img/15880927472084.png" alt></p><h2 id="IO系统">1.1 IO系统</h2><p>I/O系统是<strong>I/O设备及其接口线路、控制部件、通道和管理软件的总称。</strong> <code>I/O</code>就是“输入/输出”(Input/Output)</p><h3 id="I-O设备">1.1.1 I/O设备</h3><p>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p>I/O设备按使用特性分类：</p><ul><li>人机交互类外设：鼠标、键盘、打印机等——用于人机交互，数据传输速度慢。</li><li>存储设备：移动硬盘、光盘等——用于数据存储，数据传输速度快。</li><li>网络通信设备：调制解调器等——用于网络通信，数据传输速度介于上述二者之间。</li></ul><p>I/O设备按信息交换的单位分类：</p><ul><li>块设备：如磁盘等——<strong>数据传输的基本单位是“块”，传输速率较高，可寻址</strong>，即对它可随机地读/写任一块。</li><li>字符设备：鼠标、键盘等——<strong>数据传输的基本单位是字符，传输速率较慢，不可寻址</strong>，在输入/输出时常采用中断驱动方式</li></ul><h2 id="设备控制器">1.2 设备控制器</h2><p>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件（称设备控制器或适配器）作为CPU和I/O设备机械部件之间的“中介”，<strong>用于实现CPU对设备的控制</strong>。</p><p>如果没有控制器，复杂操作必须由操作系统来解决，引入控制器后，通过传递简单参数就可进行I/O操作，大大简化系统的设计，<strong>有利于计算机系统对各类控制器和设备的兼容性</strong>。</p><p>主要功能:</p><ol><li><strong>接收和识别CPU或通道发来的命令</strong>：如CPU发来的<code>read/write</code>命令，I/O控制器中会有相应的<strong>控制寄存器来存放命令和参数</strong>。</li><li>实现<strong>数据交换</strong>,包括设备和控制器间的数据传输：I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</li><li><strong>发现和记录设备及自身的状态信息</strong>，供CPU处理：I/O控制器中会有相应的状态寄存器，用于记录I/O设备的当前状态。如:1表示空闲，0表示忙碌。</li><li><strong>设备地址识别</strong>：类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</li></ol><p>它是一个可编址设备,当它连接多台设备时,则应具有多个设备地址。</p><h2 id="I-O控制方式">1.3 I/O控制方式</h2><h3 id="轮询方式">1.3.1 轮询方式</h3><p>又称<strong>程序直接控制方式</strong>，使用<strong>查询指令</strong>测试设备控制器的<strong>忙闲状态位</strong>，决定内存和设备是否能交换数据。</p><p><img src="https://api.codetool.top/img/15880934336329.png" alt></p><p>轮询程序中用到的三种指令：</p><ol><li>查询指令：查询设备是否就绪</li><li>读/写指令：当设备就绪时，执行数据交换</li><li>转移指令：当设备未就绪时，执行转移指令转向查询指令继续查询。</li></ol><p>特点：</p><ul><li>CPU干预的频率很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。</li><li>每次读写一个字</li><li>需要CPU的帮助</li></ul><p>缺点:<br>CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。</p><h3 id="中断方式">1.3.2 中断方式</h3><p>中断方式要求<strong>CPU与设备控制器及设备之间有中断请求线</strong>，控制器的状态寄存器有相应<strong>中断允许位</strong>。</p><p>在CPU发出读/写命令后，可<strong>将等待I/O的进程阻塞</strong>，先切换到别的进程执行。<strong>当I/O完成后，控制器会向CPU发出一个中断信号</strong>，CPU检测到中断信号后，会<strong>保存当前进程的运行环境信息，转去执行中断处理程序处理该中断</strong>。处理中断的过程中，CPU<strong>从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。</strong>接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行</p><p><img src="https://api.codetool.top/img/15880937593363.png" alt></p><p>注意：</p><ol><li><strong>CPU会在每个指令周期的末尾检查中断</strong></li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，<strong>如果中断发生的频率太高，也会降低系统性能</strong></li></ol><p>特点：</p><ul><li>每次I/O操作开始之前、完成之后需要CPU介入。等待I/O完成的过程中CPU可以切换到别的进程执行。</li><li>每次读写一个字</li><li>需要CPU的帮助</li></ul><p>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</p><h3 id="DMA方式">1.3.3 DMA方式</h3><p>与“中断驱动方式”相比，DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的I/0控制）有这样几个改进:</p><ol><li><strong>数据的传送单位是“块”</strong>。不再是一一个字、一个字的传送</li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备。<strong>不再需要CPU的帮助</strong>。</li><li><strong>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</strong></li></ol><p>步骤：</p><ol><li>CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</li><li>控制器会根据CPU提出的要求完成数据的读/写工作，<strong>整块数据的传输完成后，才向CPU发出中断信号</strong></li></ol><p><img src="https://api.codetool.top/img/15880942153789.png" alt></p><p>DMA方式需以下设施：</p><ol><li>内存地址寄存器：在输入时表示数据应放到内存中的什么位置，输出时表示要输出的数据放在内存中的什么位置中。</li><li>数据计数器：表示剩余要读/写的字节数。</li><li>数据缓冲寄存器或数据缓冲区：暂存从设备到内存，或从内存到设备的数据。</li><li>设备地址寄存器：暂存存储设备中的地址。</li><li>中断机制和控制逻辑：通过中断机制通知CPU</li></ol><p>特点：</p><ul><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li><li>每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</li><li>数据传输不再需要经过CPU</li></ul><p>缺点: CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。<strong>如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</strong></p><h3 id="通道方式">1.3.4 通道方式</h3><p>为获得CPU和外围设备间更高的并行工作能力，为让种类繁多，物理特性各异的外围设备能以标准的接口连接到系统中，计算机系统引入了自成独立体系的通道结构。</p><p><strong>通道也是一种硬件，可以识别并执行一系列通道指令，完成一部分CPU的工作。</strong></p><p>采用通道后的I/O操作过程：</p><ol><li>CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备，之后CPU就切换到其他进程执行了。</li><li><strong>通道执行内存中的通道程序</strong>（其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息）</li><li><strong>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</strong></li></ol><p>特点：</p><ul><li><strong>CPU干预的频率极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</strong></li><li>每次读/写一组数据块</li><li>CPU、通道、I/O设备可并行工作，<strong>资源利用率很高</strong>。</li></ul><p>缺点：需要专门的通道硬件支持。</p><h1 id="I-O软件原理">2 I/O软件原理</h1><p><img src="https://api.codetool.top/img/15880927712226.png" alt></p><h2 id="I-O软件设计目标和原则">2.1 I/O软件设计目标和原则</h2><p>I/O软件总体设计目标:</p><ul><li>高效率</li><li>通用性</li></ul><p>I/O软件总体设计要考虑的问题： </p><ul><li>设备无关性</li><li>出错处理</li><li>同步（阻塞）—异步（中断驱动）传输</li><li>独占性外围设备和共享性外围设备</li></ul><h2 id="I-O软件组织成四个层次">2.2 I/O软件组织成四个层次</h2><ul><li>I/O中断处理程序。</li><li>I/O设备驱动程序。</li><li>独立于设备的操作系统I/O软件。</li><li>用户空间的I/O软件。</li></ul><p>越往上越接近硬件，越往下越靠近用户</p><h3 id="I-O中断处理程序">2.2.1 I/O中断处理程序</h3><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p><p>I/O中断的类型和功能：</p><ul><li>通知用户程序<strong>I/O操作沿链推进程度</strong></li><li>通知用户程序<strong>I/O操作正常结束</strong></li><li>通知用户程序发现的<strong>I/O操作异常</strong></li><li>通知程序<strong>外围设备上重要的异步信号</strong></li></ul><p>I/O中断的处理原则：（根据不同的中断原因做相应的处理）</p><ul><li>操作正常结束处理</li><li>操作发生故障或特殊事件的中断处理</li><li>人为要求而产生的中断处理</li><li>外围设备的异步信号处理</li></ul><h3 id="设备驱动程序">2.2.2 设备驱动程序</h3><p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p><p>设备驱动程序<strong>包括与设备相关的代码</strong>，其工作是：<strong>把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行</strong>，如设备名转化为端口地址、逻辑记录转化为物理记录、逻辑操作转化为物理操作等。</p><p>设备驱动程序主要功能：</p><ol><li>设备初始化</li><li>执行设备驱动例程</li><li>执行中断处理例程</li></ol><h3 id="独立于设备的操作系统I-O软件">2.2.3 独立于设备的操作系统I/O软件</h3><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>设备无关软件完成的功能：</p><ul><li>对设备驱动程序的统一接口（向用户提供，如read/write系统调用）</li><li>设备命名</li><li>设备保护：<strong>在unix系统中，设备被看做是一种特殊的文件</strong>，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</li><li>提供独立于设备的块大小</li><li>缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li><li>块设备的存储分配</li><li>独占性外围设备的分配和释放</li><li>错误报告</li><li>文件和I/O设备的命名方式</li><li>如何保护对设备的未授权访问 </li><li>屏蔽不同磁盘扇区大小并向高层软件提供统一大小的逻辑块</li><li>块设备和字符设备需要缓冲技术</li><li>设备分配和状态跟踪</li></ul><p>错误处理多数由驱动程序完成，设备独立性软件需要对一些设备的错误进行处理。</p><p>缓冲技术、驱动调度技术、设备分配会在后面讲到。</p><h3 id="用户空间的I-O软件">2.2.4 用户空间的I/O软件</h3><p>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。</p><ul><li>用户空间的I/O软件：I/O系统调用通常先是库函数调用<code>count=write(fd，buffer，nbytes)；</code></li><li>非库函数实现的I/O系统调用：SPOOLing系统 </li></ul><p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用(Windows API)</p><h2 id="I-O操作过程总览">2.3 I/O操作过程总览</h2><ol><li>进程对已打开文件的文件描述符执行读库函数；</li><li>独立设备I/O软件检查参数正确性。<strong>高速缓存中有要读的信息块，从缓冲区直接读到用户区，完成I/O请求；</strong></li><li>若数据不在缓冲区，执行物理I/O，实现<strong>将设备逻辑名转换成物理名，检查对设备操作的权限，将I/O请求排队，阻塞进程且等待I/O完成</strong>；</li><li>内核<strong>启动设备驱动程序，分配存放读出块的缓冲区，准备接收数据，且向设备控制寄存器发启动命令，或建立DMA传输</strong>，启动I/O；</li><li><strong>设备控制器操作设备，执行数据传输</strong>；</li><li><strong>DMA控制器控制一块传输完成，硬件产生I/O结束中断</strong>；</li><li><strong>CPU响应中断，转向磁盘中断处理程序</strong>。</li><li>当应用进程被再次调度执行时，从I/O系统调用的断点恢复执行。 </li></ol><h1 id="缓冲技术">3 缓冲技术</h1><p><img src="https://api.codetool.top/img/15880927834414.png" alt></p><h2 id="缓冲技术概念">3.1 缓冲技术概念</h2><p>缓冲区是一个存储区域，<strong>可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</strong></p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合(如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。</p><p>引入缓冲技术的目的：</p><ul><li>改善中央处理器与外围设备之间速度不配的矛盾，</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>协调逻辑记录大小与物理记录大小不一致</li><li>提高CPU和I/O设备的并行性</li></ul><p>实现缓冲技术的基本思想：</p><ul><li>进程执行写操作输出数据时，向系统申请一个缓冲区，<strong>若为顺序写请求，则不断把数据填到缓冲区，直到被装满。</strong>此后，进程继续它的计算，系统将缓冲区内容写到I/O设备上。</li><li>进程执行操作输入数据时，向系统申请一个缓冲区，<strong>系统将一个物理记录的内容读到缓冲区，根据进程要求，把当前需要的逻辑记录从缓冲区中选出并传送给进程。</strong></li><li>在输出数据时，只有在系统还来不及腾空缓冲而进程又要写数据时，它才需要等待；</li><li>在输入数据时，仅当缓冲区空而进程又要从中读取数据时，它才被迫等待。</li></ul><h1 id="驱动调度技术">4 驱动调度技术</h1><p><img src="https://api.codetool.top/img/15880928021600.png" alt></p><h2 id="驱动调度技术的概念">4.1 驱动调度技术的概念</h2><p>驱动调度能<strong>减少为若干个I/O请求服务所需的总时间</strong>，提高系统效率、除了<strong>I/O请求的优化排</strong>序外，<strong>信息在辅助存储器上的排列方式</strong>，<strong>存储空间分配方法</strong>都能影响存取访问速度。</p><h2 id="存储设备的物理结构">4.2 存储设备的物理结构</h2><p>顺序存取存储设备是严格依赖信息的物理位置进行定位和读写的存储设备，具有存储容量大、稳定可靠、卷可装卸和便于保存等优点。</p><p>磁盘是一种直接(随机)存取存储设备。每个物理记录有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置。</p><p><strong>访问磁盘记录参数：盘面号、磁道号、扇区号。</strong></p><p><img src="https://api.codetool.top/img/15881495266638.jpg" alt="磁盘结构"></p><h2 id="移臂调度的算法">4.3 移臂调度的算法</h2><ul><li>“先来先服务” 算法：磁盘臂是随机移动的，<strong>按照I/O请求的次序寻道</strong>，不考虑各 I/O 请求间的相对次序和移动臂当前所处位置，进程等待 I/O 请求时间会很长，寻道性能较差。</li><li>“最短查找时间优先”算法：<strong>每次选择离当前磁头最近的磁道</strong>，与FIFO 算法相比有较好寻道性能。</li><li>“扫描”算法：<strong>磁盘臂每次沿一个方向移动，扫过所有柱面，遇到最近的I/O请求便进行处理，直到最后一个柱面后，再向相反方向移动回来。</strong></li><li>“分步扫描”算法：<strong>进程重复请求访问同一柱面会垄断设备，造成“磁臂粘性”，导致其他柱面访问请求长时间得不到服务</strong>，采用“分步扫描”算法可以避免这类问题。具体做法是：将 I/O 请求分为长度为N的子队列，<strong>按FIFO算法依次处理每个子队列，而每个子队列采用扫描算法</strong>，处理完一个后再服务下一个子队列，以避免出现磁臂粘住现象。这种调度算法能保证每个I/O请求的等待时间不致太长，当 N 值很大时，接近于“扫描”算法性能；当N＝１时，接近于 FIFO算法性能。</li><li>“电梯调度”算法：<strong>是扫描算法的一种改进，无访问请求时，移动臂停止不动</strong>，有访问请求时，移动臂按电梯规律移动。</li><li>“循环扫描”算法：为适应有大量柱面均匀分布的存取请求进入系统而设计的扫描方式。移动臂总是从０柱面至最大号柱面顺序扫描，<strong>然后，直接返回０柱面重复进行，归途中不再提供服务</strong>，构成一个循环，缩短处理新来请求的最大延迟。</li></ul><h1 id="设备分配">5 设备分配</h1><p><img src="https://api.codetool.top/img/15880928246319.png" alt></p><h2 id="设备独立性">5.1 设备独立性</h2><p>用户不指定特定设备，指定逻辑设备，使得用户作业和物理设备独立开来，通过其它途径建立逻辑设备和物理设备之间对应关系，这种特性为“设备独立性”。</p><p>好处：用户与物理的外围设备无关，系统增减或变更外围设备时程序不必修改；易于对付输入输出设备的故障。</p><p>从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类，相应的管理和分配外围设备的技术可分成：独占方式、共享方式和虚拟方式。</p><p>从进程运行的安全性上考虑，设备分配有两种方式:</p><ul><li>安全分配方式:为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。</li></ul><p>优点:破坏了“请求和保持”条件，不会死锁<br>缺点:对于一个进程来说，CPU和I/O设备只能串行工作</p><ul><li>不安全分配方式:进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。</li></ul><p>优点:进程的计算任务和I/O任务可以并行处理，使进程迅速推进<br>缺点:有可能发生死锁(需要考虑死锁避免、死锁的检测和解除)</p><h2 id="设备分配的数据结构">5.2 设备分配的数据结构</h2><p>设备分配的数据结构：设备类表和设备表。</p><p>系统中拥有一张<strong>设备类表</strong>，每类设备对应于表中一栏，包括内容有：<strong>设备类、总台数、空闲台数和设备表起始地址等。</strong></p><p>每一类设备都有各自的<strong>设备表</strong>，用来登记这类设备中每一台设备的状态，包含的内容有：<strong>物理设备名、逻辑设备名、占有设备的进程号、已分配/未分配、好/坏等。</strong></p><p>采用通道结构的系统中，设备分配的数据结构设置：系统设备表、通道控制表、控制器控制表和设备控制表。</p><p>常用的I/O设备分配算法有先请求先服务，优先级高者先服务等。此外，在多进程请求I/O设备分配时，应防止因循环等待对方所占用的设备而产生死锁，应预先进行性检查。</p><h1 id="虚拟设备">6 虚拟设备</h1><p><img src="https://api.codetool.top/img/15880928415734.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设备管理的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外围设备中断处理&lt;/li&gt;
&lt;li&gt;缓冲区管理&lt;/li&gt;
&lt;li&gt;外围设备的分配和去配     &lt;/li&gt;
&lt;li&gt;外围设备驱动调度&lt;/li&gt;
&lt;li&gt;虚拟设备及其实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;I-O硬件原理&quot;&gt;1 
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode260-只出现一次的数字III</title>
    <link href="https://www.codetool.top/article/leetcode260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
    <id>https://www.codetool.top/article/leetcode260-只出现一次的数字III/</id>
    <published>2020-04-28T04:55:15.000Z</published>
    <updated>2020-04-28T06:24:45.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong> [1,2,1,3,2,5]<br><strong>输出:</strong> [3,5]</p></blockquote><p><strong>注意：</strong></p><ol><li>结果输出的顺序并不重要，对于上面的例子， <code>[5, 3]</code> 也是正确答案。</li><li>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>如果不限制常数空间复杂度用哈希表计数可以很容易做出来，但是限制了空间复杂度，可以用位运算：</p><p>只看题目，和<a href="../leetcode136-只出现一次的数字">leetcode136-只出现一次的数字</a>很相似，对于唯一一个只出现一次的数字，我们可以通过异或将其找出，这道题有两个只出现一次的数字，如果将所有的数字异或，结果并不能显示是哪两个数字只出现一次。可以想办法将这些数字分为两组，并将两个不同的数字分到不同的组中，再进行查找。</p><p>那么如何将两个不同的数字分到两个不同的组中呢，可以使用第一次将全部数字异或的结果，得到的结果其实就是这两个数字异或的结果。因为这两个数字不一样，得到的异或结果也必定有至少一位是1。只要将这一位是1的数字分为一组，是0的数字分为一组，就能将所有数字分为两组，而这两组中只有一个只出现一次的数字，异或的结果就是这个数字。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">singleNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            k <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到k中最靠近低位的1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用掩码进行与运算，结果是0分为一组，结果是1分为一组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                a <span class="token operator">^=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                b <span class="token operator">^=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中序遍历-折纸问题</title>
    <link href="https://www.codetool.top/article/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/二叉树中序遍历-折纸问题/</id>
    <published>2020-04-27T15:16:19.000Z</published>
    <updated>2020-04-27T15:28:58.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。</p><p>给定折的次数n,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 1<br><strong>输出:</strong> [“down”]</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一次折叠，会在现有折痕的上方产生一个下的折痕，在折痕的下方产生一个上的折痕。（可以动手尝试理解）</p><p>这样就会形成一个二叉树：</p><p><img src="https://api.codetool.top/img/15880011961390.png" alt></p><p>从纸的上面到下面打印就是二叉树的 RVL 的遍历（右根左，特殊的中序遍历）。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoldPaper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">foldPaper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"down"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fold</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> String type<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fold</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"down"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fold</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"up"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode86-分隔链表</title>
    <link href="https://www.codetool.top/article/leetcode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/leetcode86-分隔链表/</id>
    <published>2020-04-27T06:36:11.000Z</published>
    <updated>2020-04-27T06:39:10.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br><strong>输出:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>双指针法，因为某些节点可能称为新的头节点，需要设置哨兵节点。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">partition</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode before_head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode before <span class="token operator">=</span> before_head<span class="token punctuation">;</span>        ListNode after_head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode after <span class="token operator">=</span> after_head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                before<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                before <span class="token operator">=</span> before<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                after<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                after <span class="token operator">=</span> after<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        after<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        before<span class="token punctuation">.</span>next <span class="token operator">=</span> after_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> before_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组元素左右两边最近较小元素</title>
    <link href="https://www.codetool.top/article/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E6%9C%80%E8%BF%91%E8%BE%83%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/数组元素左右两边最近较小元素/</id>
    <published>2020-04-26T05:40:33.000Z</published>
    <updated>2020-04-26T06:19:06.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。</p><p><strong>实例：</strong></p><blockquote><p><strong>输入:</strong> arr = {3,4,1,5,6,2,7}<br><strong>输出</strong><br>{<br>&nbsp;&nbsp;{-1,&nbsp;2},<br>&nbsp;&nbsp;{&nbsp;0,&nbsp;2},<br>&nbsp;&nbsp;{-1,-1},<br>&nbsp;&nbsp;{&nbsp;2,&nbsp;5},<br>&nbsp;&nbsp;{&nbsp;3,&nbsp;5},<br>&nbsp;&nbsp;{&nbsp;2,-1},<br>&nbsp;&nbsp;{&nbsp;5,-1}<br>}  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>单调栈，或使用动态规划的方式做，都可以达到线性时间复杂度。</p><h2 id="代码">2.2 代码</h2><p>动态规划：（其实也是单调栈的思想）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNearLessNoRepeat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从左到右扫描</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                left <span class="token operator">=</span> res<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从右到左扫描</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                right <span class="token operator">=</span> res<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>单调栈：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNearLessNoRepeat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果当前遍历到的数组的值小，需要弹出</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> popIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> leftLessIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftLessIndex<span class="token punctuation">;</span>                res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> popIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> leftLessIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftLessIndex<span class="token punctuation">;</span>            res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124-二叉树中的最大路径和</title>
    <link href="https://www.codetool.top/article/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode124-二叉树中的最大路径和/</id>
    <published>2020-04-26T05:03:04.000Z</published>
    <updated>2020-04-26T05:15:41.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个节点</strong>，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,2,3]       <strong>1</strong>      <strong>/ \</strong>     <strong>2</strong>   <strong>3</strong><strong>输出:</strong> 6</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [-10,9,20,null,null,15,7]&nbsp;  -10&nbsp; &nbsp;/ \&nbsp; 9 &nbsp;<strong>20</strong>&nbsp; &nbsp; <strong>/ &nbsp;\</strong>&nbsp; &nbsp;<strong>15 &nbsp; 7</strong><strong>输出:</strong> 42</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设计一个函数<code>max_gain</code>，用于返回一个节点与它的左子树或右子树连成的最长路径。</p><p>使用一个全局变量记录递归回溯过程中出现的最大路径长，对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:</p><ol><li>其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径（即递归函数返回的值）</li><li>左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径（在函数中与上面的情况产生的值进行比较，更新最大值）</li></ol><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max_sum <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">max_gain</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left_gain <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max_gain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right_gain <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max_gain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> price_newpath <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> left_gain <span class="token operator">+</span> right_gain<span class="token punctuation">;</span>        max_sum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_sum<span class="token punctuation">,</span> price_newpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left_gain<span class="token punctuation">,</span> right_gain<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">max_gain</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max_sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径&lt;strong&gt;至少包含一个节点&lt;/strong&gt;，且不一定经过根节点。&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>net.ipv4.ip_local_port_range的含义</title>
    <link href="https://www.codetool.top/article/net-ipv4-ip-local-port-range%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://www.codetool.top/article/net-ipv4-ip-local-port-range的含义/</id>
    <published>2020-04-25T15:55:45.000Z</published>
    <updated>2020-04-25T17:18:58.440Z</updated>
    
    <content type="html"><![CDATA[<p>在《深入分析Java Web技术内幕》一书中看到下面这段话：</p><blockquote><p>要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位操作系统的端口号通常由两个字节表示，也就是只有2<sup>16</sup>=65535个，所以一台主机能够同时建立的连接数是有限的，当然操作系统还有一些端口0~1024是受保护的，如80端口、22端口，这些端口都不能被随意占用。  </p><p>在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。</p></blockquote><p>看完这段话我对几个地方都有点质疑：</p><ol><li><code>32位操作系统的端口号通常由两个字节表示</code>，难道64位机器的端口号还能超过两个字节？大于65535的端口从来没见过。应该是和协议规定的有关系，我在<a href="../计网复习05-传输层">计网复习05-传输层</a>中对TCP和UDP的报文格式都有描述，无论是TCP还是UDP的报文头部都有一个两字节的源端口号和两字节的目的端口号，这应该是TCP/IP协议对端口号长度做出的规定。</li><li><code>所以一台主机能够同时建立的连接数是有限的</code>，原因讲的很模糊，他提到和端口的数量有关系，但实际上我们说一个socket连接是由一个四元组唯一标识的，即两个socket（两台主机的ip和端口号），这四个属性中任何一个不一样都可以是的socket连接，而另一台主机是不确定的，所以应该说<code>两台主机之间能够同时建立的连接数是有限的</code>，这里可能上下文是这个意思，但没有表述清楚。</li><li><code>操作系统还有一些端口0~1024是受保护的，如80端口、22端口，这些端口都不能被随意占用</code>和<code>在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。</code>，显然作者对端口号的划分没有很好的理解，后面这句话也有很明显的错误。我在<a href="../计网复习05-传输层">计网复习05-传输层</a>的第一节的思维导图中有总结端口号的分类，但当时没有详谈，看到这段话之后查阅了相关资料，这里详细介绍一下。</li></ol><h1 id="端口的分类">1 端口的分类</h1><p><a href="../计网复习05-传输层">计网复习05-传输层</a>这一篇的思维导图中先把端口号分为了服务端使用的端口（0-49151）和客户端使用的端口（49151-65535）。实际上这是不一定的，没有强制要求服务端和客户端只能使用这个端口范围，这应该是tcp/ip协议的建议，并且很明显这个建议也被广泛采纳，这不意味着服务器就不可以使用（49151-65535）中的端口作为长期服务端口。</p><p>下面介绍的端口分类对应的范围是由IANA（互联网数字分配机构）规定的。</p><h2 id="熟知端口">1.1 熟知端口</h2><p>熟知端口（WellKnown Ports），数值一般为 <code>0 ~ 1023</code>。</p><p>0端口是保留端口，在编程API中（特别是linux socket编程）作为请求系统分配的（动态）端口。</p><p>很多知名的应用层协议会选择这个端口范围内的端口号，例如HTTP服务默认的端口号是80，HTTPS是443，DNS是53、FTP是20、21，SSH是22等。所以一般不推荐没有熟知端口号的应用程序使用这部分的端口号，否则很容易冲突，但<strong>不意味着只有这些应用程序才能使用这部分的端口号，只要不冲突，其他服务也能使用这些端口，但是linux中root权限用户的才可以启用1~1023的服务。</strong></p><h2 id="登记端口号">1.2 登记端口号</h2><p>登记端口号（Registered Ports），数值为 <code>1024 ~ 49151</code>，为没有熟知端口号的应用程序使用的。</p><h2 id="短暂端口号">1.3 短暂端口号</h2><p>短暂端口号（Ephemeral Ports），也被称为动态端口（Dynamic Ports），IANA推荐使用 <code>49152 ~ 65535</code>，留给客户进程选择暂时使用。这是什么意思呢？<strong>客户端使用TCP、UDP协议与服务端进行连接时，通常会从这个端口范围内被随机分配一个未使用的端口，从而与服务端建立socket连接。</strong>这个分配的端口是临时的，仅在通信会话期间有效，所以称为“短暂端口”，与服务器上长期服务的端口区分开。</p><p>虽然说推荐是客户端使用的，但实际上服务器也能使用这一部分的端口号做长期服务。</p><p><code>49152 ~ 65535</code>是IANA推荐使用的短暂端口号范围，而<strong>linux默认使用的短暂端口号范围实际上是32768到60999</strong>，也就是我们使用命令<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>或<code>sysctl -a|grep ip_local_port_range</code>看到的两个数字。linux严格遵守这个配置，作为客户端建立socket连接时只会从这个端口范围获取动态分配的端口。</p><p>下面谈谈如何修改这个值，显然修改这个值能明显提高linux作为客户端能建立的并发连接数。因为tcp常常因为<code>time_wait</code>状态占用大量短暂端口，适当提高这个范围也可以减少端口不够用的影响。</p><p>linux修改方法：</p><pre><code>vi /etc/sysctl.conf</code></pre><p>修改</p><pre><code>net.ipv4.ip_local_port_range = 1024 65535</code></pre><p>然后</p><pre><code>sysctl -p</code></pre><p>生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在《深入分析Java Web技术内幕》一书中看到下面这段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位操作系统的端口号通常由两个字节表示，也就是只有2&lt;sup&gt;16&lt;/sup&gt;=65535个，所以
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode13-罗马数字转整数</title>
    <link href="https://www.codetool.top/article/leetcode13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode13-罗马数字转整数/</id>
    <published>2020-04-25T03:47:19.000Z</published>
    <updated>2020-04-25T04:23:05.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><pre><strong>字符</strong>          <strong>数值</strong>I             1V             5X             10L             50C             100D             500M             1000</pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> “III”<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> “IV”<br><strong>输出：</strong> 4  </p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入：</strong> “IX”<br><strong>输出：</strong> 9  </p></blockquote><p><strong>示例4:</strong></p><blockquote><p><strong>输入：</strong> “LVIII”<br><strong>输出：</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.  </p></blockquote><p><strong>示例5:</strong></p><blockquote><p><strong>输入：</strong> “MCMXCIV”<br><strong>输出：</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于字符串中从左到右每个字符，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">!=</span>chars<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                ans <span class="token operator">+=</span> <span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanChartoNum</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习04-存储管理</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A004-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://www.codetool.top/article/操作系统复习04-存储管理/</id>
    <published>2020-04-24T13:58:15.000Z</published>
    <updated>2020-04-25T13:09:28.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关概念">1 相关概念</h1><p><img src="https://api.codetool.top/img/15877892594926.png" alt></p><h2 id="从写程序到程序运行">1.1 从写程序到程序运行</h2><ul><li>编辑源代码文件</li><li>编译：由源代码文件生成目标模块(高级语言“翻译“为机器语言)</li><li>链接：由目标模块生成装入模块，链接后形成完整的<strong>逻辑地址</strong></li><li>装入：将装入模块装入内存，装入后形成<strong>物理地址</strong></li></ul><p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址。在装入运行后，才会将逻辑地址转换为物理地址。</p><h2 id="链接的三种方式">1.2 链接的三种方式</h2><ul><li>静态链接：<strong>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）</strong>，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式。</li><li>运行时动态链接：<strong>在程序执行中需要该目标模块时，才对它进行链接</strong>。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul><h2 id="装入（装载）的三种方式">1.3 装入（装载）的三种方式</h2><ul><li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，<strong>编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</strong>绝对装入只适用于单道程序环境。</li><li>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</strong><ul><li>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。<strong>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</strong></li></ul></li><li>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此<strong>装入内存后所有的地址依然是逻辑地址</strong>。这种方式需要一个<strong>重定位寄存器</strong>的支持。采用动态重定位时允许程序在内存中发生移动。<ul><li>可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ul></li></ul><h1 id="存储管理的功能">2 存储管理的功能</h1><p><img src="https://api.codetool.top/img/15877892733377.png" alt></p><ul><li>定位(存储分配)：为具体的程序和数据等分配存储单元或存储区工作。</li><li>地址映射：将逻辑地址转换为相应的物理地址。地址空间是程序用来访问信息所用地址单元的集合。</li><li>存储共享：两个或多个进程共用内存中相同区域。目的：节省内存空间，提高内存利用率、实现<strong>进程通信</strong>(数据共享)。</li><li>存储保护：<strong>各道程序只能访问自己的内存区而不能互相干扰</strong>，必须对内存中的程序和数据进行保护，以免受到其他程序有意或无意的破坏。可对进程执行时所产生的所有内存访问地址进行检查，确保进程仅访问它自己的内存区，这就是<strong>地址越界保护</strong>，越界保护依赖于硬件设施，常用的有：界地址寄存器和存储键。</li><li>存储扩充：用户在编制程序时，不应该受内存容量限制，所以要采用一定技术来“扩充”内存的容量，<strong>使用户得到比实际内存容量大的多的内存空间</strong>。<ul><li>覆盖技术：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)。这种实现方式需要程序员手动声明覆盖区，不便于实现。</li><li>交换技术：交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)，换到外存中的进程就称为<strong>挂起态</strong>，<strong>即使进程被换出内存，PCB必须常驻内存</strong>。</li><li>虚拟存储技术：具体实现是在硬件支持下，软硬件相互协作，将内存和外存结合起来统一使用。 </li></ul></li></ul><p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对<strong>文件区空间的管理采用离散分配方式</strong>；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此<strong>通常对换区采用连续分配方式</strong>。总之，对换区的I/O速度比文件区的更快。</p><h1 id="实存管理">3 实存管理</h1><p><img src="https://api.codetool.top/img/15877893676624.png" alt></p><h2 id="连续分配管理方式（分区）">3.1 连续分配管理方式（分区）</h2><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><h3 id="单一连续分配">3.1.1 单一连续分配</h3><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。<strong>内存中只能有一道用户程序，用户程序独占整个用户区空间。</strong></p><p>优点：</p><ul><li>实现简单</li><li>无外部碎片</li><li>可以采用覆盖技术扩充内存</li><li>不一定需要采取内存保护</li></ul><h3 id="固定分区分配">3.1.2 固定分区分配</h3><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是<strong>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>可分为大小相同的分区和大小不同的分区，但依然缺乏灵活性。</p><p>固定分区分配会产生内部碎片：</p><blockquote><p>内部碎片，分配给某进程的内存区域中，有些部分没有用上。<br>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</p></blockquote><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)</p><h3 id="动态分区分配">3.1.3 动态分区分配</h3><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><p>分配与回收方案：</p><ul><li>当作业装入内存时：<ul><li>若有足够空间，分割一个分区给该作业（具体选择策略由分配算法决定）</li><li>若没有足够空间，等待内存资源</li></ul></li><li>空间回收：若两端有空闲区，和空闲区合并</li></ul><p><strong>动态分区会产生外部碎片</strong>：</p><p>动态分区分配算法：</p><ul><li><strong>首次适应算法</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。会出现低地址空闲区用得较频繁的情况，内存各区域使用频率不均。但优点是通常能保留高地址区域的较大分区，更不容易产生外部碎片。<ul><li>为了解决首次适应算法的缺点，可以使用改进后的“<strong>下次适应算法</strong>”，它会接着上一次扫描到的位置继续往下扫描，不会导致各区域使用频率不均。</li></ul></li><li><strong>最佳适应算法</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。缺点：<strong>会产生较多外部碎片</strong>。</li><li><strong>最坏适应算法</strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时<strong>优先使用最大的连续空闲区</strong>，这样分配后剩余的空闲区就不会太小，更方便使用。缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式<strong>会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong></li></ul><h2 id="非连续分配管理方式（分页）">3.2 非连续分配管理方式（分页）</h2><p>程序存放到若不相邻的空间块中。</p><p>将<strong>内存空间分为一个个大小相等的分区</strong>(比如：每个分区4KB)，每个分区就是一个<strong>“页框”</strong>，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)。页框号从0开始。</p><p><strong>将用户进程的地址空间也分为与页框大小相等的一个个区域</strong>，称为<strong>“页”</strong>或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。</p><p>逻辑地址由页号（<code>逻辑地址/页的大小</code>）和页内偏移（<code>逻辑地址%页的大小</code>）构成，<strong><code>物理地址=页号对应的页框号×块长+页内地址</code></strong>。为了方便计算页号、页内偏移量，<strong>页面大小一般设为2的整数幂</strong></p><p>那么如何知道页号对应的页框号？为了能知道进程的每个页面在内存中存放的位置，操作系统要<strong>为每个进程建立一张页表</strong>。</p><p><strong>进程的页表在进程运行的时候也会被装载到页框中。</strong></p><ol><li>进程的每一页对应一个页表项</li><li>每个页表项由<code>“页号”</code>和<code>“块号”</code>（页框号）组成</li><li>页表记录进程页面和实际存放的内存块之间的对应关系</li></ol><h3 id="基本地址变换机构">3.2.1 基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<strong>页表寄存器(PTR)</strong>，存放<strong>页表在内存中的起始地址F和页表长度M。</strong></p><p>进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>地址变换过程：</p><ol><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界，如果越界会触发越界中断（如果页号大于或等于页表长度）</li><li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li><li>用内存块号和页内偏移量得到物理地址</li></ol><p>由于页表中的页表项都是连续存储的，而页表项的大小是相等的，因此页号可以隐含（从0开始的连续计数），只存储块号。</p><h3 id="翻译快表">3.2.2 翻译快表</h3><p>由上述内容我们可以知道，访问进程中的一个逻辑地址需要经过两次访存（第一次查询页表，第二次才是真正的访问逻辑地址对应的物理地址），那有没有办法减少访存次数呢？</p><p>快表（TLB）是一种特殊的高速缓冲存储器（Cache），<strong>内容是页表中的一部分或全部内容</strong>。在操作系统中引入快表是为了加快地址映射速度。</p><p>地址变换过程：</p><ol><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界，如果越界会触发越界中断（如果页号大于或等于页表长度）</li><li>查询快表<ol><li>若快表中没有目标页表项，则需要查询内存中的页表，并将查询到的页表项放入快表</li><li>若查询快表命中，就获取了页号对应的页表项</li></ol></li><li>用内存块号和页内偏移量得到物理地址</li></ol><p>因此，如果查询快表命中，则访问某个逻辑地址仅需一次访存即可。有的系统还支持快表和慢表（对应内存中的页表）同时查找，减少平均耗时。</p><h3 id="多级页表">3.2.3 多级页表</h3><p>如果程序使用空间很大，它的页表也会很大，需要占用很多个连续的页框。我们可以利用索引的思想，为页表也建立索引，使其可以离散存储于内存的各个页框中，称为多级页表。</p><p>系统为每个进程建一张<strong>页目录表</strong>，它的<strong>每个表项对应一个页表页</strong>，而<strong>页表页的每个表项给出了页面和页框的对应关系</strong>，<strong>页目录表是一级页表，页表页是二级页表</strong>。</p><p>使用二级页表后的逻辑地址结构由三部分组成：<strong>一级页号、二级页号和页内偏移</strong></p><p>注意：各级页表的大小不能超过一个页面。</p><h2 id="基本分段存储管理">3.3 基本分段存储管理</h2><p>与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同</p><p><strong>分页存储管理是一维地址结构，分段存储管理是二维地址结构。</strong></p><p>进程的地址空间<strong>按照程序自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p><p>分段系统的<strong>逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成</strong>。段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。</p><p>段表：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能<strong>从物理内存中找到各个逻辑段的存放位置</strong>。为此，需为每个进程建立一张段映射表，简称<strong>段表</strong>。每个段对应一个段表项，其中<strong>记录了该段在内存中的起始位置(又称“基址”)和段的长度。</strong></p><p>分页和分段的区别：</p><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li></ul><h2 id="段页式存储管理">3.4 段页式存储管理</h2><table><thead><tr><th>管理方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table><p>段页式存储管理结合了分页管理和分段管理的优缺点，将进程按逻辑模块分段，再将各段分页(如每个页面4KB)。内存依然按页的大小分为各个页框。</p><p>段页式系统的逻辑地址结构由<strong>段号、页号、页内地址</strong>(页内偏移量)组成。段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少</p><p>因此段页式管理的地址结构也是二维的。</p><p>段页式管理中的段表存储的就不是基址了，而是<strong>页表长度和页表的存放块号</strong>。地址转换时先查询段表，再查询页表。</p><h1 id="虚存管理">4 虚存管理</h1><p><img src="https://api.codetool.top/img/15877894059649.png" alt></p><h2 id="相关概念-1">4.1 相关概念</h2><p>有的时候可以在进程运行时<strong>实时将所需要的页装入内存</strong>，而不需要一次性全部装入，称为<strong>部分装入</strong>。当内存已满而又有新的“部分”需要装入时，要把已在内存的某一“部分”换出去，称为<strong>部分对换</strong></p><p>程序局部性原理：</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</li></ul><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>分页虚存系统的硬件支撑：<strong>内存管理单元MMU</strong>完成逻辑地址到物理地址的转换功能，它接受逻辑地址作为输入，物理地址作为输出，直接送到总线上，对内存单元进行寻址。 MMU的主要功能：</p><ol><li>管理硬件页表基址寄存器。</li><li>分解逻辑地址。</li><li>管理快表TLB。</li><li>访问页表。</li><li>发出缺页中断或越界中断，并将控制权交给内核存储管理处理。</li><li>设置和检查页表中各个特征位。</li></ol><p>虚拟内存的实际容量= <code>min(内存和外存容量之和，CPU寻址范围)</code></p><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统<strong>需要知道每个页面是否已经调入内存</strong>。如果还没调入，那么也需要知道该页面在外存中存放的位置。当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面。<strong>有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖</strong>，因此，操作系统也<strong>需要记录各个页面是否被修改的信息</strong>。</p><p>于是，请求分页存储管理的页表除了对应的内存块号外，还记录了<strong>状态位（是否已调入内存，1为是，0为否）、引用位（可记录最近被访问过几次，或记录上次访问的时间，供置换算法参考）、修改位（页面调入内存后是否被修改过）、外存地址</strong></p><p>在请求分页系统中，每<strong>当要访问的页面不在内存时，便产生一个缺页中断</strong>，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><h2 id="页面置换算法">4.2 页面置换算法</h2><p><strong>最佳页面置换算法OPT：</strong>调入一页而必须淘汰一个旧页时，所淘汰的页应该是<strong>以后不再访问的页或距现在最长时间后再访问的页。</strong>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。<strong>操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</strong></p><p><strong>先进先出页面替换算法FIFO：</strong>基于程序总是按线性顺序来访问物理空间这一假设。算法<strong>淘汰最先调入内存的页，或者说在内存中驻留时间最长的页。</strong>该算法可以使用固定大小的队列实现，队列的大小为系统为进程分配的内存块数。并且该算法的性能不是很好，即使最先调入内存的页面也可能经常用到。</p><p><strong>最近最少用页面替换算法LRU：</strong>算法淘汰的页面是在<strong>最近一段时间里较久未被访问的那页。</strong> 该算法的性能较好，最接近最佳页面置换算法。实现方法：</p><ul><li>该算法可以用固定大小的链表实现，当使用某个页的时候将其连接到链表的尾部。</li><li>引用位法：每页设置一个引用位R，访问某页时，由硬件将页标志位R置1，隔一定时间t将所有页的标志R均清0。发生缺页中断时，从标志位R为0的页中挑选一页淘汰。挑选到要淘汰的页后，也将所有页的标志位R清0。</li><li>计数法：每个页面设置一个多位计数器，又叫最不常用页面替换算法LFU。每当访问一页时，就使它对应的计数器加１。当发生缺页中断时，可选择计数值最小的对应页面淘汰，并将所有计数器全部清０。</li><li>计时法：为每个页面设置一个多位计时器，每当页面被访问时，系统的绝对时间记入计时器。淘汰时比较各页面的计时器的值，选最小值的未使用的页面淘汰。</li><li>老化算法：为每个页设置一个多位寄存器r。当页面被访问时，对应寄存器的最左边位置1；每隔时间t，将r寄存器右移一位；在发生缺页中断时，找最小数值的r寄存器对应的页面淘汰。</li></ul><p><strong>第二次机会页面替换算法SCR：</strong>改进FIFO算法，把FIFO与页表中的”引用位”结合起来使用：  </p><ul><li>检查FIFO中的队首页面(最早进入内存页面)，如果它的”引用位”是0，这个页面既老又没有用，选择该页面淘汰； </li><li>如果”引用位”是1，说明它进入内存较早，但最近仍在使用。把它的”引用位”清0，并把这个页面移到队尾，把它看作是一个新调入的页。</li></ul><p><strong>时钟页面替换算法Clock：</strong>一个页面首次装入内存，其“引用位”置1。内存中的任何页面被访问时， ”引用位”置1。淘汰页面时，从指针当前指向的页面开始扫描循环队列，把迁到的”引用位”是1的页面的”引用位”清0，跳过这个页面；<strong>把所迁到的”引用位”是0的页面淘汰掉</strong>，指针推进一步。扫描循环队列时，如果迁到的所有页面的”引用位”为1，指针就会绕整个循环队列一圈，把碰到的所有页面的”引用位”清0；指针停在起始位置，并淘汰掉这一页，然后，指针推进一步。</p><ul><li>可以结合修改位对时钟页面替换算法进行改进。若用(访问位，修改位)的形式表述，则<ul><li>第一轮：淘汰(0, 0)</li><li>第二轮：淘汰(0, 1) ，并将扫描过的页面访问位都置为0</li><li>第三轮：淘汰(0, 0)</li><li>第四轮：淘汰(0, 1)</li></ul></li></ul><h2 id="页面分配策略">4.3 页面分配策略</h2><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p>分配策略：</p><ul><li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。只要有一个缺页中断产生,进程就会有一页被替换。</li><li>可变分配：先为每个进程分一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。进程执行的某阶段缺页率较高,说明目前局部性较差，系统可多分些页框以降低缺页率，反之说明进程目前的局部性较好,可减少分给进程的页框数。</li></ul><p>置换策略：</p><ul><li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul><p>从何处调入页面：</p><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的<br>部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关概念&quot;&gt;1 相关概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15877892594926.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;从写程序到程序运行&quot;&gt;1.1 从写程序到程序运行&lt;/h2&gt;&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer51-数组中的逆序对</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>https://www.codetool.top/article/剑指offer51-数组中的逆序对/</id>
    <published>2020-04-24T02:01:16.000Z</published>
    <updated>2020-04-24T03:11:34.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> [7,5,6,4]<br><strong>输出：</strong> 5</p></blockquote><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>暴力：双重循环检查，leetcode中超时</p><p>分治思想：使用归并排序的算法，每次给左右两个数组合并的时候，若右边数组中指向的元素小于左边数组指向的元素，则也小于左边数组指向的元素后面的任何一个元素（归并排序合并的时候左右两个数组都是有序的），则此时加上左边数组剩余的元素个数即可。</p><h2 id="代码">2.2 代码</h2><p>归并排序大复习，这里提供两种写法：</p><p>下面是归并排序较简单的写法，就是每次将数组均分成两个子数组，分到不能再分的时候开始合并相邻的两个子数组。这种写法递归中会创建新数组并拷贝，因此时间成本会略高些。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局变量计数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">MergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">+=</span>left<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加上左边数组剩余的元素个数</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是一种递归过程中不用创建数组的归并排序写法，只使用两个和原数组相同大小的数组来回交换数据（做对方的缓存），在局部上操作，时间成本会比上面创建数组的方法更低些，但是是一个量级的，在leetcode中能取得更好的成绩：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个和原数组相同大小的数组</span>        <span class="token keyword">return</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//[start,end]确定一个数组范围，即递归中要排序的范围，返回值为合并过程中的计数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left <span class="token operator">+</span> right <span class="token operator">+</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//[left,right)和[right,end]确定数组的两部分，合并temp数组中的这两部分到nums数组</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> leftSize <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为直接使用left和right作为后面使用的双指针，这里保存right原位置作为left指针能移动到的最远处</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//合并过程中计数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">==</span>leftSize<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">==</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count <span class="token operator">+=</span> <span class="token punctuation">(</span>leftSize <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加上左边部分剩余的元素个数</span>                nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>npm安装node-sass速度慢，卡死的解决方案</title>
    <link href="https://www.codetool.top/article/npm%E5%AE%89%E8%A3%85node-sass%E9%80%9F%E5%BA%A6%E6%85%A2%EF%BC%8C%E5%8D%A1%E6%AD%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://www.codetool.top/article/npm安装node-sass速度慢，卡死的解决方案/</id>
    <published>2020-04-23T05:54:09.000Z</published>
    <updated>2020-04-23T06:05:18.281Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在用npm install安装一个前端项目依赖的时候浪费了我好长时间，即使注册了淘宝镜像，但中间还是会去<code>node.org</code>和<code>github.com</code>上面下载一些东西，中间经常卡死，导致我不停的中止、删node_modules、重新安装。</p><p>日志就是gyp什么什么的错误。</p><p>后来注意到是它在安装node-sass，并且一开始依赖的是python2（我电脑上装的python3），所以会报错python版本问题，语法识别错误什么的，可以用管理员权限打开powershell，使用下面命令安装<code>windows-build-tools</code></p><pre><code>npm install -g windows-build-tools</code></pre><p>或者自己安装python2并配置环境变量</p><p>然后中途卡死的问题主要还是去外网下载的，配置npm的镜像没有用，需要指定一个环境变量：</p><pre><code>npm install --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre><p>做到这一步如果还是失败可能是nodejs和node-gyp的版本不搭，我昨天就是因为一开始用了<code>nodejs14.0.0</code>，版本太高了，后来中间安装的时候又卡死。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天在用npm install安装一个前端项目依赖的时候浪费了我好长时间，即使注册了淘宝镜像，但中间还是会去&lt;code&gt;node.org&lt;/code&gt;和&lt;code&gt;github.com&lt;/code&gt;上面下载一些东西，中间经常卡死，导致我不停的中止、删node_modules
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典08.11-硬币</title>
    <link href="https://www.codetool.top/article/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B808-11-%E7%A1%AC%E5%B8%81/"/>
    <id>https://www.codetool.top/article/程序员面试金典08-11-硬币/</id>
    <published>2020-04-23T05:36:28.000Z</published>
    <updated>2020-04-23T05:42:59.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> n = 5<br><strong>输出:</strong> 2<br><strong>解释:</strong> 有两种方式可以凑成总金额:<br>5=5<br>5=1+1+1+1+1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 4<br><strong>解释:</strong> 有四种方式可以凑成总金额:<br>10=10<br>10=5+5<br>10=5+1+1+1+1+1<br>10=1+1+1+1+1+1+1+1+1+1   </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，不过需要注意排列组合去重</p><h2 id="代码">2.2 代码</h2><p>常见<strong>错误</strong>是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然而却忽略了重复的情况，例如6可以由<code>1+5</code>组合来，也可以由<code>5+1</code>组合来。</p><p>正确的答案其实只是将内外循环换了个顺序，<strong>保证这些数字是按递增的方式组合的</strong>，就能做到去重。：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199-二叉树的右视图</title>
    <link href="https://www.codetool.top/article/leetcode199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>https://www.codetool.top/article/leetcode199-二叉树的右视图/</id>
    <published>2020-04-22T04:20:57.000Z</published>
    <updated>2020-04-22T05:01:54.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例：</strong></p><pre><strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]<strong>输出:</strong>&nbsp;[1, 3, 4]<strong>解释:</strong>   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</pre><style>pre,pre>*{    color:#e8eaf6;}</style><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>dfs，注意查找顺序即可，用list存储答案下标代表层数，后找到的不会覆盖先找到的</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt;&amp;nbsp;[1,2,3,
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习03-同步、通信与死锁</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A003-%E5%90%8C%E6%AD%A5%E3%80%81%E9%80%9A%E4%BF%A1%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>https://www.codetool.top/article/操作系统复习03-同步、通信与死锁/</id>
    <published>2020-04-21T17:02:02.000Z</published>
    <updated>2020-04-22T07:41:59.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发进程">1 并发进程</h1><p><img src="https://api.codetool.top/img/15874794302366.png" alt></p><h2 id="顺序程序设计">1.1 顺序程序设计</h2><p>顺序程序设计是把一个程序设计成一个顺序执行的程序模块，顺序的含义不但指一个程序模块内部，也指两个程序模块之间。</p><p>顺序程序设计的特点：</p><ul><li><strong>程序执行的顺序性</strong></li><li><strong>程序环境的封闭性</strong>：运行程序独占全部资源，除初始状态外，其所处的环境由程序本身决定，只有程序本身的动作才能改变其环境</li><li><strong>执行结果的确定性</strong>：程序执行过程中允许被中断，但这种中断对程序的最终结果无影响，也即程序的执行结果与它的执行速率无关</li><li><strong>计算过程的可再现性</strong>：在同一个数据集合上重复执行一个程序会得到相同结果，因而错误也可以重现，便于分析</li></ul><h2 id="并发程序设计">1.2 并发程序设计</h2><h3 id="程序并发机制">1.2.1 程序并发机制</h3><p><strong>进程执行的并发性：</strong> 一组进程的执行在时间上是重叠的。（和并行区分开）</p><p>从宏观上看，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态。</p><p>从微观上看，任一时刻仅有一个进程在处理器上运行。</p><p>并发的实质是一个处理器在几个进程之间的多路复用，并发是<strong>对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</strong></p><h3 id="并发进程的特性">1.2.2 并发进程的特性</h3><p>并发进程之间的关系分为两类：无关的和交互的</p><p><strong>无关的并发进程：</strong> 一组并发进程分别<strong>在不同的变量集合上操作</strong>，一个进程的执行与其他并发进程的进展无关，即一个并发，进程不会改变另一个并发进程的变量值。</p><p><strong>交互的并发进程：</strong> 一组并发进程<strong>共享某些变量</strong>，一个进程的执行可能影响其他并发进程的执行结果。<strong>交互的并发进程之间具有制约关系</strong>，这种交互必须是有控制的,否则会出现不正确的结果。</p><p>对于一组交互的并发进程，若执行的相对速度无法相互控制，则各种与时间有关的错误就可能出现。与时间有关的错误有两种表现形式:</p><ul><li>结果不唯一</li><li>永远等待</li></ul><p>并发多道程序的优点：</p><ul><li>对于单处理器系统，可让处理器和各I/O设备同时工作,发挥硬部件的并行能力。</li><li><strong>对于多处理器系统，可让各进程在不同处理器上物理地并行，加快计算速度。</strong></li><li>简化程序设计任务。 </li></ul><p>并发程序设计的特征：</p><ol><li>并行性：进程的执行在时间上可以重叠，<strong>在单处理器系统中可以并发执行，在多处理器环境中可以并行执行</strong></li><li>共享性：并发进程<strong>通过引用共享变量交换信号</strong>，从而，程序运行的环境不再是封闭的</li><li>制约性：进程并发执行或协同<strong>完成同一任务时，会产生相互制约关系</strong>，必须对它们并发执行的次序加以协调</li><li>交互性：由于并发进程共享某些变量，所以，一个进程的执行可能影响其他进程的执行结果，<strong>程序运行结果可能不确定，计算过程具有不可再现性。</strong>因此，这种交互必须是有控制的，否则会出现不正确的结果</li></ol><h3 id="进程的交互">1.2.3 进程的交互</h3><p>交互进程有两种关系：</p><ul><li><strong>竞争关系</strong>：系统中的多个进程之间<strong>彼此无关，相互并不知道其它进程的存在</strong>，相互之间并不交换信息。但是<strong>由于这些进程共用了一套计算机系统资源,因而必然产生竞争资源的问题</strong>，一个进程的执行可能影响到同其竞争资源的其它进程。操作系统必须协调好诸进程对资源的争用。一旦一个进程要使用已分配给另一个进程的资源，则该进程必须等待。资源竞争产生两个问题:<ul><li>一个是<strong>死锁(Deadlock)问题</strong>，就是一组进程如果都获得了部分资源，还想要得到其他进程所占用的资源，最终所有进程都将陷入死锁</li><li>一个是<strong>饥饿(Starvation)问题</strong>，是指一个进程由于其它进程总是优先于它而被无限期拖延</li><li>既要解决饥饿问题，又要解决死锁问题。解决饥饿问题的最简单策略是FCFS资源分配策略</li><li>竞争关系的进程使用同一资源时，同一时刻最多只允许一个进程使用，其他进程必须等待，我们称这种现象为<strong>进程互斥</strong>。</li></ul></li><li><strong>协作关系</strong>：某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。<strong>当协作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后才被唤醒并继续执行</strong>。这种<strong>协作进程之间相互等待对方消息或信号的协调关系称为进程同步</strong><ul><li>进程间的协作可以是双方不知道对方名字的间接协作（如多个进程通过访问一个公共缓冲区进行松散式协作），也可以是双方知道对方名字的直接协作，进程间通过通信机制紧密协作。</li></ul></li></ul><h1 id="临界区管理">2 临界区管理</h1><p><img src="https://api.codetool.top/img/15874814349435.png" alt></p><h2 id="互斥与临界区">2.1 互斥与临界区</h2><p>并发进程中<strong>与共享变量有关的程序段叫“临界区”</strong>， 共享变量代表的资源叫“临界资源”。 </p><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预知。<strong>如果能保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误</strong></p><h2 id="临界区调度原则">2.2 临界区调度原则</h2><ul><li><strong>一次至多一个进程能够进入临界区内执行</strong></li><li>如果<strong>已有进程在临界区，其他试图进入的进程应等待</strong></li><li>进入临界区内的进程<strong>应在有限时间内退出</strong>，以便让等待进程中的一个进入</li></ul><p>临界区调度原则可总结为：</p><p>互斥使用、有空让进，<br>忙则等待、有限等待，<br>择一而入、算法可行。</p><p>算法可行是指<strong>不能因为所选的调度策略造成进程饥饿甚至死锁</strong>。</p><h2 id="软件管理临界区">2.3 软件管理临界区</h2><p>软件方法是为在具有一个处理器或共享主存的多处理器上执行的并发进程实现的，这种方法<strong>假定对主存中同一个单元的同时访问必定由存储器进行仲裁，使其串行化。</strong></p><p>临界区管理的尝试：（下面是一段伪代码，非C语言）</p><pre class=" language-c"><code class="language-c">bool inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P1不在其临界区内*/</span>bool inside2<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P2不在其临界区内*/</span>cobegin             <span class="token comment" spellcheck="true">/*cobegin和coend表示括号中的进程是一组并发进程*/</span>process <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>inside2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*等待*/</span>      inside1<span class="token operator">=</span>true<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">/*临界区*/</span>                          inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>process <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>inside1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*等待*/</span>    inside2<span class="token operator">=</span>true<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>    inside2<span class="token operator">=</span>false<span class="token punctuation">;</span><span class="token punctuation">}</span>coend </code></pre><p>这种方法看似没有问题，实则是错误的，</p><p><img src="https://api.codetool.top/img/15874826788391.png" alt></p><p>如上图所示，由于P1执行的时候将inside1设为true存在一定的时间延迟（和上一个操作不是原子的），在这段延迟的时间内，P2发现inside1仍为false，于是也进入临界区执行。出现了两个进程同时进入临界区的情况。</p><p>此外还有可能P1在临界区内失败（异常），导致无法将inside1置为false，使得其他进程再也无法进入临界区。</p><p>除此之外还出现了许多尝试，但仍存在一些无法解决的问题。</p><p>后来出现了两个真正实现了临界区管理的软件方法：Dekker算法和Peterson算法。由于软件实现临界区管理也不是主流，这里不重点研究了。</p><p>Dekker算法的实现：（下面两段代码来自 <a href="https://blog.csdn.net/JustJavaC2016/article/details/78660768）" target="_blank" rel="noopener">https://blog.csdn.net/JustJavaC2016/article/details/78660768）</a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span><span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> turn<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"P%d is visting\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用关键区。  </span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//检查P1是不是也想用？  </span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果P1想用，则查看P1是否具有访问权限？  </span>            <span class="token punctuation">{</span>                  flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果有，则P0放弃。  </span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>                flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用。  </span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>        turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P1。  </span>        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0结束使用。  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1想使用关键区。  </span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//检查P0是不是也想用？  </span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果P0想用，则查看P0是否具有访问权限？  </span>            <span class="token punctuation">{</span>                  flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果有，则P1放弃。  </span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>                flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// P1想使用。  </span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>              <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>        turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P0。  </span>        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1结束使用。  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> err<span class="token punctuation">;</span>      err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>Peterson算法的实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span><span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> turn<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">procedure0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//退出while循环的条件就是，要么另一个线程  </span>        <span class="token comment" spellcheck="true">//不想要使用关键区，要么此线程拥有访问权限。  </span>        <span class="token punctuation">{</span>                  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure0 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//critical section  </span>        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">procedure1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>              flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span>                      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure1 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//critical section  </span>            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> err<span class="token punctuation">;</span>      turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><h2 id="硬件管理临界区">2.4 硬件管理临界区</h2><p>使用软件方法实现进程互斥使用临界资源是很困难的，他们通常能实现两个进程之间的互斥，很难控制多个进程的互斥。</p><h3 id="关中断">2.4.1 关中断</h3><p>关中断是实现互斥的最简单方法之一。</p><p>进程在测试标志之前，首先关中断，直到测试完并设置标志之后才开中断。进程在临界区执行期间，<strong>计算机系统不响应中断。因此不会转向调度，也就不会引起进程或线程切换，正在执行标志测试和设置的进程或线程不会被打断，从而保证了互斥。</strong></p><p>关中断方法的缺点:</p><ul><li>关中断时间过长会影响系统效率，限制处理器交叉执行程序的能力</li><li>关中断方法也不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其他处理器上执行相同临界区代码</li></ul><h3 id="测试并设置指令">2.4.2 测试并设置指令</h3><p>其实就是<code>TestAndSet</code>，Java CAS的原理，操作系统层面提供的原子操作指令。</p><p>因为该指令是原子的，就可以使用该指令管理一个互斥量，从而实现临界区管理。</p><p>TS指令实现临界区管理的算法如下：（自旋锁）</p><pre class=" language-c"><code class="language-c">bool s<span class="token operator">=</span>true<span class="token punctuation">;</span>cobeginprocess <span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i=1,2,...,n</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TS</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*上锁*/</span>    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>    s<span class="token operator">=</span>true<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/*开锁*/</span><span class="token punctuation">}</span>coend</code></pre><h3 id="对换指令">2.4.3 对换指令</h3><p>对换指令（swap）交换两个字的内容，在Intel 80x86中，对换指令称为<code>XCHG</code>指令</p><p>swap指令也可以看作是同时设置两个值的原子指令实现，所以也可以用于临界区管理，思想类似。</p><p><strong>软件方法和硬件方法都存在忙等问题（当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环测试一个变量直到某个值出现为止），浪费了处理器的时间，不会成为一种通用的方法。</strong></p><h1 id="信号量与PV操作">3 信号量与PV操作</h1><p><img src="https://api.codetool.top/img/15874850424979.png" alt></p><h2 id="信号量机制">3.1 信号量机制</h2><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以<strong>用一个信号量来表示系统中某种资源的数量</strong>，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>一对原语：<code>wait(S)</code>原语和<code>signal(S)</code>原语，常简称为P、V操作。</p><p><code>wait(S)</code>相当于占用一个S资源，<code>signal(S)</code>相当于释放一个S资源。</p><h3 id="整型信号量">3.1.1 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。下面是P、V原语的实现思想：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//初始化整型信号量S，表示当前系统中可用的打印机数</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果资源数不够，就一直循环等待</span>    S <span class="token operator">=</span> S<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果资源数够，则占用一个资源</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S <span class="token operator">=</span> S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>进程Pn：</p><pre class=" language-c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用打印机资源...</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="记录型信号量">3.1.2 记录型信号量</h3><p>（思维导图中的二值信号量和一般信号量都是属于这里的记录型信号量）</p><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*记录型信号量的定义*/</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//剩余资源数</span>    <span class="token keyword">struct</span> process <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待队列</span><span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果剩余资源数不够</span>        <span class="token comment" spellcheck="true">//使用block原语使进程从运行态进入阻塞</span>        <span class="token comment" spellcheck="true">//并把进程挂到信号量S的等待队列(即阻塞队列)中</span>        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//释放资源后，若还有别的进程在等待这种资源</span>        <span class="token comment" spellcheck="true">//则使用wakeup原语唤醒等待队列中的个进程</span>        <span class="token comment" spellcheck="true">//该进程从阻塞态变为就绪态</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里信号量的语义就是资源的个数，并且实现了让权等待，不会形成忙等。</p><h2 id="信号量机制实现进程互斥">3.2 信号量机制实现进程互斥</h2><p>我们可以把临界区看作一种特殊的资源，为临界区抽象出一个互斥信号量<code>mutex</code>，<strong>它是二值的，初值为1</strong>，代表同一个时间只能有一个进程进入临界区。</p><ul><li>在进入临界区之前执行<code>P(mutex)</code></li><li>在退出临界区之后执行<code>V(mutex)</code></li></ul><h2 id="信号量机制实现进程同步">3.3 信号量机制实现进程同步</h2><p>进程同步问题要求多个进程按一定次序先后执行一段代码。这个前驱关系可能是较复杂的，如下图所示，可以<strong>为每一对前驱关系各设置一个同步信号量</strong>，初值为0，<strong>要执行某操作前需要对前驱操作对应的信号量进行P操作，当完成了前驱操作时对对应的信号量执行V操作。</strong></p><p><img src="https://api.codetool.top/img/15874890505885.png" alt></p><pre><code>semaphore a = 0,b = 0,c = 0,d = 0,e = 0,f = 0,g = 0;P1(){    ...    S1;    V(a);    V(b);    ...}P2(){    ...    P(a);    S2;    V(c);    V(d);    ...}P3(){    ...    P(b);    S3;    V(g);    ...}P4(){    ...    P(c);    S4;    V(e);    ...}P5(){    ...    P(d);    S5;    V(f);    ...}P6(){    ...    P(e);    P(f);    P(g);    S6;    ...}</code></pre><h1 id="管程">4 管程</h1><p><img src="https://api.codetool.top/img/15875338871013.png" alt></p><h2 id="管程和条件变量">4.1 管程和条件变量</h2><h3 id="为什么要引入管程">4.1.1 为什么要引入管程</h3><p>信号量机制存在的问题：编写程序困难、易出错。</p><p>管程：</p><ul><li>把分散在各进程中的临界区集中起来进行管理 </li><li>防止进程有意或无意的违法同步操作</li><li>便于用高级语言来书写程序，也便于程序正确性验证</li></ul><h3 id="管程的定义">4.1.2 管程的定义</h3><p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。 </p><p>管程的基本特征:</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问</li><li><strong>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</strong></li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li></ol><p>管程的属性:</p><ul><li>共享性</li><li>安全性</li><li>互斥性</li></ul><h3 id="管程的结构">4.1.3 管程的结构</h3><p>管程是一种特殊的软件模块，有这些部分组成:</p><ol><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><p>例如：(使用类C语言语法模拟管程结构)</p><pre class=" language-cpp"><code class="language-cpp">type ProducerConsumer <span class="token operator">=</span> monitor<span class="token punctuation">{</span>    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//条件变量用来实现同步排队</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//缓冲区中的产品数</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//把产品item放入缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span>N<span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从缓冲区中取出一个产品</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>N<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//生产者进程</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        item <span class="token operator">=</span> 生产一个产品<span class="token punctuation">;</span>        ProducerConsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//消费者进程</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        消费产品item       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="管程的条件变量">4.1.4 管程的条件变量</h3><p>条件变量是出现在管程内的一种数据结构，且<strong>只有在管程中才能被访问</strong>，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它。</p><ul><li><code>wait()</code>：挂起调用进程并释放管程，直到另一个进程在该条件变量上执行<code>signal()</code>。</li><li><code>signal( )</code>：如果存在其他进程由于对条件变量执行<code>wait()</code>而被挂起，便释放之；如果没有进程在等待，那么，信号不被保存。</li></ul><p>这不就是Java <code>sychronized</code>的<code>monitorenter</code>和<code>monitorexit</code>吗！！！</p><h1 id="死锁">5 死锁</h1><p><img src="https://api.codetool.top/img/15875359806127.png" alt></p><h2 id="死锁的产生">5.1 死锁的产生</h2><p>操作系统中的死锁指：如果<strong>在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件</strong>，则称一组进程或系统此时发生死锁。</p><p>死锁产生的例子：</p><p>设系统有打印机、读卡机各一台，被进程Ｐ和Ｑ共享。两个进程并发执行，按下列次序请求和释放资源：</p><table><thead><tr><th align="center">进程Ｐ</th><th align="center">进程Ｑ</th></tr></thead><tbody><tr><td align="center">请求读卡机</td><td align="center">请求打印机</td></tr><tr><td align="center"><strong>请求打印机</strong></td><td align="center"><strong>请求读卡机</strong></td></tr><tr><td align="center">释放读卡机</td><td align="center">释放读卡机</td></tr><tr><td align="center">释放打印机</td><td align="center">释放打印机</td></tr></tbody></table><p>在PV操作中对应</p><table><thead><tr><th align="center">进程Q1</th><th align="center">进程Q2</th></tr></thead><tbody><tr><td align="center">P(S1)</td><td align="center">P(S2)</td></tr><tr><td align="center"><strong>P(S2)</strong></td><td align="center"><strong>P(S1)</strong></td></tr><tr><td align="center">使用r1和r2</td><td align="center">使用r1和r2</td></tr><tr><td align="center">V(S1)</td><td align="center">V(S2);</td></tr><tr><td align="center">V(S2)</td><td align="center">V(S1);</td></tr></tbody></table><p>在第一步中，双方都拿到了请求的资源，但是第二步中请求的资源都被对方所持有，于是都在等待对方释放资源，从而陷入死锁。</p><p>若系统中有m个资源被n个进程共享，每个进程都要求Ｋ个资源，而m &lt; n·K时，即<strong>资源数小于进程所要求的总数时，如果分配不得当就可能引起死锁。</strong></p><p>在著名的哲学家就餐问题中，若五个哲学家同时拿起右手边的餐具，此时左手边的的餐具就被另外一个哲学家占用，所有哲学家都陷入了无止境的等待资源释放状态，即死锁。</p><h2 id="死锁产生的必要条件">5.2 死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</strong>（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li><li><strong>不剥夺条件：</strong> 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件：</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件：</strong> 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>归根结底，循环等待条件是前三种条件导致的结果。</p><h2 id="解决方法">5.3 解决方法</h2><h3 id="死锁防止">5.3.1 死锁防止</h3><p>死锁防止就是要破坏死锁产生的必要条件。</p><p><strong>破坏互斥条件：</strong> 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备</strong>。例如使用SPOOLing技术将打印机改造为共享设备。</p><p><strong>破坏不剥夺条件：</strong></p><ul><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul><p>该策略的缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><p><strong>破坏请求和保持条件：</strong><br>可以采用静态分配方法，即进程<strong>在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。</strong> 一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都–直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><p><strong>破坏循环等待条件：</strong> 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p><p>该策略的缺点:</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="死锁避免">5.3.2 死锁避免</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>死锁避免就是避免系统进入不安全状态。</p><p>银行家算法的数据结构：</p><p>一个系统有n个进程和m种不同类型的资源,定义包含以下向量和矩阵的数据结构：</p><ul><li>系统每类资源总数：该m个元素的向量为<strong>系统中每类资源数量</strong><code>Resource=(R1,R2,…,Rm)</code></li><li>每类资源未分配数量：该m个元素的向量为<strong>系统中每类资源尚可供分配数量</strong><code>Avilable=(V1,V2,…,Vm)</code></li><li>最大需求矩阵：<strong>每个进程对每类资源的最大需求量</strong>，<code>Claim[I,j]</code>表示进程Pi需Rj类资源最大数</li><li>分配矩阵：表示<strong>进程当前已分得的资源数</strong>，<code>Allocation[i,j]</code>表示进程Pi已分到Rj类资源个数</li><li>尚需矩阵：表示<strong>进程当前尚需资源数</strong>，<code>Need[i,j]</code>表示进程Pi尚需Rj类资源个数</li></ul><p>银行家算法中下列关系式确保成立：</p><ul><li><code>Ri=Vi+∑Allocation[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>所有资源要么已被分配、要么尚可分配</strong></li><li><code>Claim[k,i]≤Rj</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请资源数不能超过系统拥有的资源总数</strong></li><li><code>Allocation[k,i] ≤ Claim[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请任何类资源数不能超过声明的最大资源需求数</strong></li></ul><p>系统中若要启动一个新进程工作,其对资源Ri的需求仅当满足下列不等式：</p><p><code>Ri ≥ C[(n+1),i]+ ∑C[k,i]</code>  对i=1,..,m,k=1,..,n; </p><p>即应满足<strong>当前系统中所有进程对资源Ri的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</strong></p><p>系统安全性定义：在时刻T0系统是安全的,仅当存在一个进程序列P1,..,Pn,对进程Pk满足公式：</p><p><code>Need[k,i] ≤Available [i]+ ∑Allocation[j,i]</code> 对于k=1,…,n;i=1,…,m; </p><p>即对任何一个进程都能满足其所需要的资源。</p><p>银行家算法的基本思想：</p><ul><li>系统中的所有进程进入进程集合,</li><li>在安全状态下系统收到进程的资源请求后,先把资源<strong>试探性分配</strong>给它。</li><li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到<strong>剩余资源能满足最大需求量的进程</strong>,从而,保证<strong>这个进程运行完毕并归还全部资源</strong>。</li><li>把这个进程从集合中去掉, 系统的剩余资源更多了,<strong>反复执行上述步骤</strong>。</li><li>最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。 </li></ul><h3 id="死锁的检测和解除">5.3.3 死锁的检测和解除</h3><p>该部分参考自：<a href="http://www.360doc.com/content/16/0421/16/478627_552610896.shtml" target="_blank" rel="noopener">死锁的检测和解除</a></p><p>解决死锁问题的一条途径是死锁检测和解除，这种方法<strong>对资源的分配不加任何限制，也不采取死锁避免措施</strong>，但系统定时地运行一个“死锁检测”程序，判断系统内是否已出现死锁，<strong>如果检测到系统已发性了死锁，再采取措施解除它</strong>。</p><p>进程-资源分配图：</p><p>如图所示，用<strong>圆圈代表一个进程</strong>，用<strong>框代表一类资源</strong>。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。<strong>从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</strong></p><p><img src="https://api.codetool.top/img/15875408526262.jpg" alt="初始资源分配图"></p><ol><li>如果进程-资源分配图中无环路，则此时系统没有发生死锁。</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程。</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。可以使用将资源分配图简化的方法来检测系统是否处于死锁状态：</li></ol><p>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且<strong>该有向边对应资源的申请数量小于等于系统中已有空闲资源数量</strong>。如上图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。<strong>消去它所有的请求边和分配边</strong>，使之称为孤立的结点。在上图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p><p><strong>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程</strong>，原来的阻塞进程可能变为非阻塞进程。在上图中，P2 就满足这样的条件。根据上面的方法进行一系列简化后，<strong>若能消去途中所有的边，则称该图是可完全简化的</strong>。</p><p><img src="https://api.codetool.top/img/15875411733947.jpg" alt="资源分配图的化简"></p><p>一旦检测出死锁，就应立即釆取相应的措施。死锁解除算法有：</p><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发进程&quot;&gt;1 并发进程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15874794302366.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;顺序程序设计&quot;&gt;1.1 顺序程序设计&lt;/h2&gt;&lt;p&gt;顺序程序设计是把一个
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
