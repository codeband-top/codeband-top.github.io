<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeBand CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2019-11-25T13:16:24.326Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AVL树-自平衡的二叉搜索树</title>
    <link href="https://www.codetool.top/article/AVL%E6%A0%91-%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/AVL树-自平衡的二叉搜索树/</id>
    <published>2019-11-25T11:11:29.000Z</published>
    <updated>2019-11-25T13:16:24.326Z</updated>
    
    <content type="html"><![CDATA[<p>本文图片来源：<a href="https://www.cnblogs.com/coding-nerver-die/p/10975599.html" target="_blank" rel="noopener">手把手教，手写AVL树 - 不止是编程 - 博客园</a></p><h1 id="AVL树的概念"><a href="#AVL树的概念" class="headerlink" title="AVL树的概念"></a>AVL树的概念</h1><h2 id="自平衡"><a href="#自平衡" class="headerlink" title="自平衡"></a>自平衡</h2><p>当二叉搜索树处于平衡状态的时候，其操作时间复杂度为<em>O</em>(log<em>N</em>)，但当二叉搜索树是单支树的时候，其搜索效率则为<em>O</em>(<em>N</em>)。可见，二叉搜索树的平衡性是影响其操作效率的关键。<br>由此出发，学者们设计了第一个平衡二叉搜索树，即<strong>AVL树</strong>。AVL树作为第一个平衡的二叉搜索树，其影响非常深远，后来的很多平衡结构都借鉴了AVL树的设计思想。</p><h2 id="AVL树的定义"><a href="#AVL树的定义" class="headerlink" title="AVL树的定义"></a>AVL树的定义</h2><p>一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树：</p><ul><li>它的左子树和右子树都是AVL树。</li><li>左子树和右子树的高度之差的<strong>绝对值不超过1</strong>。</li></ul><p>要注意，AVL的平衡性是一种相对的平衡，并非一种绝对的平衡。它不要求左子树和右子树的高度绝对相等，而仅仅是左子树和右子树的高度之差的绝对值不超过1即可。因为绝对的平衡难以实现。</p><p>如果给AVL树中的每一个节点都附加一个数字，该数字指示该节点右子树的高度减去左子树的高度所得的高度差，那么这个数字即为该节点的<strong>平衡因子</strong>。根据AVL树的定义，任一节点的平衡因子只能取-1、0或1。</p><h2 id="AVL树的旋转"><a href="#AVL树的旋转" class="headerlink" title="AVL树的旋转"></a>AVL树的旋转</h2><p>在一个平衡的二叉搜索树中插入一个新节点，就会造成其失衡，需要从插入位置沿通向根的路径回溯，检查各节点的平衡因子，在某一节点发现高度不平衡，则停止回溯。然后<strong>从发生不平衡的节点起，往下取三层</strong>，可以归纳为四种情况：</p><ol><li>向某节点的左子树中插入一个左孩子。</li><li>向某节点的右子树中插入一个右孩子。</li><li>向某节点的左子树中插入一个右孩子。</li><li>向某节点的右子树中插入一个左孩子。</li></ol><p>对应的处理方式：</p><h3 id="单旋"><a href="#单旋" class="headerlink" title="单旋"></a>单旋</h3><ol><li>右旋操作  </li></ol><p>以中间节点为轴，进行顺时针旋转，该中间节点的原父节点将变成该节点的右子节点，该中间节点的右子树则变成其原父节点的左子树。<br><img src="https://img2018.cnblogs.com/blog/1666803/201906/1666803-20190605203022939-1625356603.png" alt="img" title="基本情况">  </p><p><img src="https://img2018.cnblogs.com/blog/1666803/201906/1666803-20190610145355050-144623903.png" alt="img" title="中间节点含有右子树"></p><ol start="2"><li>左旋操作</li></ol><p>对应的，左旋的方法是以三个呈直线排列的节点的中间节点为轴，进行逆时针旋转。该中间节点的原父节点将变成该节点的左子节点，该中间节点的左子树则变成其原父节点的右子树</p><h3 id="双旋"><a href="#双旋" class="headerlink" title="双旋"></a>双旋</h3><ol start="3"><li>先左后右双旋转</li></ol><p>以3个成折线排列的节点中的末节点为轴，进行逆时针旋转。使末节点代替中间节点的位置，也就是让末节点成为原中间节点的父节点，这时，三个节点将成一直线排列，再以新的中间节点为旋转轴做右旋操作，即可完成平衡化操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img2018.cnblogs.com/blog/1666803/201906/1666803-20190610153510014-654706320.png" alt="img" title="基本情况">                </div>                <div class="image-caption">基本情况</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/834468/201611/834468-20161126193432190-11477464.png" alt="img" title="复杂情况">                </div>                <div class="image-caption">复杂情况</div>            </figure><ol start="4"><li>先右后左双旋转</li></ol><p>以3个成折线排列的节点中的末节点为轴，进行顺时针旋转。使末节点代替中间节点的位置，也就是让末节点成为原中间节点的父节点，这时，三个节点将成一直线排列，再以新的中间节点为旋转轴做左旋操作，即可完成平衡化操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文图片来源：&lt;a href=&quot;https://www.cnblogs.com/coding-nerver-die/p/10975599.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手把手教，手写AVL树 - 不止是编程 - 博客园&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树形搜索" scheme="https://www.codetool.top/tags/%E6%A0%91%E5%BD%A2%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200-岛屿数量</title>
    <link href="https://www.codetool.top/article/leetcode200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://www.codetool.top/article/leetcode200-岛屿数量/</id>
    <published>2019-11-24T14:18:01.000Z</published>
    <updated>2019-11-24T14:27:18.511Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说这种题确实麻烦。大一做过一遍C++版本的了今天做一遍JAVA的还是搞了好久。C++还有数据结构pair可以用，java还得存储偏移地址然后手算x、y。</p><h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong><br>11110<br>11010<br>11000<br>00000  <br/><br><strong>输出:</strong> 1 </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong><br>11000<br>11000<br>00100<br>00011  <br/><br><strong>输出:</strong> 3 </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><blockquote><p>BFS：<br>线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动广度优先搜索。将其放入队列中，并将值设为 0 以标记访问过该结点。迭代地搜索队列中的每个结点，直到队列为空。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] marked;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> width = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;height;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    queue.offer(i*width+j);</span><br><span class="line">                    <span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">                        <span class="keyword">int</span> index_x = index/width;</span><br><span class="line">                        <span class="keyword">int</span> index_y = index%width;</span><br><span class="line">                        <span class="keyword">if</span>(index_x!=height-<span class="number">1</span> &amp;&amp; grid[index_x+<span class="number">1</span>][index_y]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer((index_x+<span class="number">1</span>)*width+index_y);</span><br><span class="line">                            grid[index_x+<span class="number">1</span>][index_y] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(index_x!=<span class="number">0</span> &amp;&amp; grid[index_x-<span class="number">1</span>][index_y]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer((index_x-<span class="number">1</span>)*width+index_y);</span><br><span class="line">                            grid[index_x-<span class="number">1</span>][index_y] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(index_y!=<span class="number">0</span> &amp;&amp; grid[index_x][index_y-<span class="number">1</span>]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer(index_x*width+index_y-<span class="number">1</span>);</span><br><span class="line">                            grid[index_x][index_y-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(index_y!=width-<span class="number">1</span> &amp;&amp; grid[index_x][index_y+<span class="number">1</span>]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer(index_x*width+index_y+<span class="number">1</span>);</span><br><span class="line">                            grid[index_x][index_y+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不得不说这种题确实麻烦。大一做过一遍C++版本的了今天做一遍JAVA的还是搞了好久。C++还有数据结构pair可以用，java还得存储偏移地址然后手算x、y。&lt;/p&gt;
&lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode622-设计循环队列</title>
    <link href="https://www.codetool.top/article/leetcode622-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode622-设计循环队列/</id>
    <published>2019-11-24T11:22:09.000Z</published>
    <updated>2019-11-24T11:34:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><ul><li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code>isEmpty()</code>: 检查循环队列是否为空。</li><li><code>isFull()</code>: 检查循环队列是否已满。</li></ul><p><strong>示例:</strong></p><blockquote><p>MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3<br/><br>circularQueue.enQueue(1);  // 返回 true<br/><br>circularQueue.enQueue(2);  // 返回 true<br/><br>circularQueue.enQueue(3);  // 返回 true<br/><br>circularQueue.enQueue(4);  // 返回 false，队列已满<br/><br>circularQueue.Rear();  // 返回 3<br/><br>circularQueue.isFull();  // 返回 true<br/><br>circularQueue.deQueue();  // 返回 true<br/><br>circularQueue.enQueue(4);  // 返回 true<br/><br>circularQueue.Rear();  // 返回 4<br/>  </p></blockquote><p><strong>提示:</strong></p><ul><li>所有的值都在 0 至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>根据循环队列的定义来实现，理解head指针和tail指针指向的位置。<br><strong>通常情况下：</strong><br>添加元素，tail++。<br>删除元素，head++。<br><strong>当tail或head处于数组的最末端的时候：</strong><br>操作之后应该指向下标0。<br><strong>当数组为空：</strong><br>不能移除元素。<br><strong>当数组满了：</strong><br>不能添加元素。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = -<span class="number">1</span>;</span><br><span class="line">        tail = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tail == queue.length-<span class="number">1</span>) &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">            queue[<span class="number">0</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> queue[++tail] = value; </span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span>(head==-<span class="number">1</span>) head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">            tail = -<span class="number">1</span>;</span><br><span class="line">            head = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head == queue.length-<span class="number">1</span>)&#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == queue.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.enQueue(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.Rear();</span></span><br><span class="line"><span class="comment"> * boolean param_5 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_6 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://www.codetool.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode283-移动零</title>
    <link href="https://www.codetool.top/article/leetcode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>https://www.codetool.top/article/leetcode283-移动零/</id>
    <published>2019-11-23T12:01:11.000Z</published>
    <updated>2019-11-23T12:14:19.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [0,1,0,3,12]<br><strong>输出:</strong> [1,3,12,0,0]  </p></blockquote><p><strong>说明:</strong></p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>双指针解法，i始终不经过0，如果j遍历到了非0元素，i++，并把非0元素赋值给i。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                nums[i++]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            nums[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26-删除排序数组中的重复项</title>
    <link href="https://www.codetool.top/article/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://www.codetool.top/article/leetcode26-删除排序数组中的重复项/</id>
    <published>2019-11-23T11:37:25.000Z</published>
    <updated>2019-11-23T12:17:02.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><blockquote><p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 <code>nums</code> = <code>[0,0,1,1,1,2,2,3,3,4]</code>,<br>函数应该返回新的长度 <strong>5</strong>, 并且原数组 nums 的前五个元素被修改为 <strong>0, 1, 2, 3, 4</strong>。<br>你不需要考虑数组中超出新长度后面的元素。 </p></blockquote><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);  <br/><br>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>双指针解法，i始终停留在第一个出现的重复元素上，j一旦遇到不重复的元素，i++，然后将不重复的元素赋给<code>nums[i]</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i])</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个排序数组，你需要在&lt;strong&gt;原地&lt;/strong&gt;删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode557-反转字符串中的单词III</title>
    <link href="https://www.codetool.top/article/leetcode557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/"/>
    <id>https://www.codetool.top/article/leetcode557-反转字符串中的单词III/</id>
    <published>2019-11-23T11:12:52.000Z</published>
    <updated>2019-11-23T11:20:42.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> “Let’s take LeetCode contest”<br><strong>输出:</strong> “s’teL ekat edoCteeL tsetnoc” </p></blockquote><p><strong>注意：</strong> 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>翻转字符串可以用StringBuffer的reverse方法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            sb.append(<span class="keyword">new</span> StringBuffer(word).reverse().toString());</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/stron
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="https://www.codetool.top/article/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/ArrayList源码分析/</id>
    <published>2019-11-22T09:17:44.000Z</published>
    <updated>2019-11-23T15:54:49.398Z</updated>
    
    <content type="html"><![CDATA[<p>这是我最后一次这么详细地把所有方法列出来了。。。以后只记录重点。。。</p><p>这篇文章虽然贼长但是总结下来重点只有：</p><ol><li>如果使用无参构造函数建立ArrayList，在添加第一个元素的时候会分配10个元素的空间。</li><li>ArrayList的扩容是以1.5倍为基准的。</li></ol><p>以下为原文</p><hr><p>先来看看ArrayList的Hierarchy：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/12/M8MmnI.png" alt="img" title="ArrayList层次结构">                </div>                <div class="image-caption">ArrayList层次结构</div>            </figure><p>父类们：<br><a href="https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/">Collection接口研究</a><br><a href="https://www.codetool.top/article/AbstractCollection%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AbstractCollection源码分析</a>  </p><p>先来看看List接口：</p><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>相比Collection接口增加的方法：</p><h2 id="boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="boolean addAll(int index, Collection&lt;? extends E&gt; c);"></a>boolean addAll(int index, Collection&lt;? extends E&gt; c);</h2><p>将给定集合中所有的元素插入到指定位置上。</p><h2 id="default-void-replaceAll-UnaryOperator-operator"><a href="#default-void-replaceAll-UnaryOperator-operator" class="headerlink" title="default void replaceAll(UnaryOperator operator);"></a>default void replaceAll(UnaryOperator<E> operator);</h2><p>以指定的方法替换List中的所有元素，<code>UnaryOperator</code>是一个函数式接口，输入一个类型对象，返回一个同类型对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">        li.set(operator.apply(li.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.replaceAll(a-&gt;a+<span class="number">1</span>); <span class="comment">//list = [2,4,6]</span></span><br></pre></td></tr></table></figure><h2 id="default-void-sort-Comparator-lt-super-E-gt-c"><a href="#default-void-sort-Comparator-lt-super-E-gt-c" class="headerlink" title="default void sort(Comparator&lt;? super E&gt; c);"></a>default void sort(Comparator&lt;? super E&gt; c);</h2><p>根据排序方法排序。还是先转为了Array再使用Arrays的sort方法进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-get-int-index"><a href="#E-get-int-index" class="headerlink" title="E get(int index);"></a>E get(int index);</h2><p>根据index返回一个元素。</p><h2 id="E-set-int-index-E-element"><a href="#E-set-int-index-E-element" class="headerlink" title="E set(int index, E element);"></a>E set(int index, E element);</h2><p>将element替换index上的元素。返回原来index位置上的元素。</p><h2 id="void-add-int-index-E-element"><a href="#void-add-int-index-E-element" class="headerlink" title="void add(int index, E element);"></a>void add(int index, E element);</h2><p>在index处添加元素。</p><h2 id="E-remove-int-index"><a href="#E-remove-int-index" class="headerlink" title="E remove(int index);"></a>E remove(int index);</h2><p>删除index处的元素，并<strong>返回该元素。</strong></p><h2 id="int-indexOf-Object-o"><a href="#int-indexOf-Object-o" class="headerlink" title="int indexOf(Object o);"></a>int indexOf(Object o);</h2><p>得到某个元素在List中第一次出现的index，如果不存在该元素，返回-1。</p><h2 id="int-lastIndexOf-Object-o"><a href="#int-lastIndexOf-Object-o" class="headerlink" title="int lastIndexOf(Object o);"></a>int lastIndexOf(Object o);</h2><p>得到某个元素在List中最后一次出现的index，如果不存在该元素，返回-1。</p><h2 id="ListIterator-listIterator"><a href="#ListIterator-listIterator" class="headerlink" title="ListIterator listIterator();"></a>ListIterator<E> listIterator();</h2><p>得到该List的迭代器。</p><h2 id="ListIterator-listIterator-int-index"><a href="#ListIterator-listIterator-int-index" class="headerlink" title="ListIterator listIterator(int index);"></a>ListIterator<E> listIterator(int index);</h2><p>返回一个从指定index处开始的迭代器。（迭代器第一次next操作会得到index处的元素）。</p><h2 id="List-subList-int-fromIndex-int-toIndex"><a href="#List-subList-int-fromIndex-int-toIndex" class="headerlink" title="List subList(int fromIndex, int toIndex);"></a>List<E> subList(int fromIndex, int toIndex);</h2><p>返回一个包含fromIndex下标但不包含toIndex下标元素的子List。<br>这个函数和<code>indexOf()</code>、<code>lastIndexOf()</code>结合起来有妙用。</p><h2 id="default-Spliterator-spliterator"><a href="#default-Spliterator-spliterator" class="headerlink" title="default Spliterator spliterator();"></a>default Spliterator<E> spliterator();</h2><blockquote><p>Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.ORDERED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><h3 id="核心：transient-Object-elementData"><a href="#核心：transient-Object-elementData" class="headerlink" title="核心：transient Object[] elementData;"></a>核心：transient Object[] elementData;</h3><p>ArrayList的元素底层还是存储在这个数组中。</p><h3 id="private-int-size"><a href="#private-int-size" class="headerlink" title="private int size;"></a>private int size;</h3><p>记录空间大小。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="public-ArrayList"><a href="#public-ArrayList" class="headerlink" title="public ArrayList();"></a>public ArrayList();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中宏<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>是一个空数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="public-ArrayList-int-initialCapacity"><a href="#public-ArrayList-int-initialCapacity" class="headerlink" title="public ArrayList(int initialCapacity);"></a>public ArrayList(int initialCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个初始容量初始化ArrayList。<br>如果传入的参数大于0，则分配一个这么大的数组。<br>如果等于0，令其等于一个空数组。<br>其中宏<code>EMPTY_ELEMENTDATA</code>也是一个空数组，至于为什么要区分EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA，注释解释的是：</p><blockquote><p>We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.</p></blockquote><p>当第一个元素被加进来的时候能知道应该扩容多少。（与后文的calculateCapacity方法有关）</p><h3 id="public-ArrayList-Collection-lt-extends-E-gt-c"><a href="#public-ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="public ArrayList(Collection&lt;? extends E&gt; c);"></a>public ArrayList(Collection&lt;? extends E&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法使得ArrayList可以由其他Collection子类的对象生成，但也取决于它的toArray方法是怎么实现的。</p><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="E-elementData-int-index"><a href="#E-elementData-int-index" class="headerlink" title="E elementData(int index);"></a>E elementData(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取元素,这个方法没有访问修饰符，也就是包内所有的类都可以访问，说明jdk给ArrayList不进行边界检查去元素的方法也留了后路。</p><h3 id="private-void-rangeCheck-int-index"><a href="#private-void-rangeCheck-int-index" class="headerlink" title="private void rangeCheck(int index);"></a>private void rangeCheck(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边界检查。</p><blockquote><p>rangeCheck方法是提供给get,remove，set之类的方法检查的,是给已经存在元素的集合操作的，范围0至size-1,这个方法把检查负责的职责交给了数组的访问,像get(-1)时会报异常ArrayIndexOutOfBoundsException。</p></blockquote><h3 id="private-void-rangeCheckForAdd-int-index"><a href="#private-void-rangeCheckForAdd-int-index" class="headerlink" title="private void rangeCheckForAdd(int index);"></a>private void rangeCheckForAdd(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是提供给add和addAll的，会检查负数。因为如果扩容了数组再抛出异常就白扩容了。</p><h3 id="private-void-ensureCapacityInternal-int-minCapacity"><a href="#private-void-ensureCapacityInternal-int-minCapacity" class="headerlink" title="private void ensureCapacityInternal(int minCapacity);"></a>private void ensureCapacityInternal(int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需保证ArrayList能容纳minCapacity个元素，数组的大小可能需要扩容。</p><h3 id="private-static-int-calculateCapacity-Object-elementData-int-minCapacity"><a href="#private-static-int-calculateCapacity-Object-elementData-int-minCapacity" class="headerlink" title="private static int calculateCapacity(Object[] elementData, int minCapacity);"></a>private static int calculateCapacity(Object[] elementData, int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于计算数组应该具有多少空间，其中<code>DEFAULT_CAPACITY=10</code>。<br>这说明：如果ArrayList是以<strong>无参构造方法</strong>建立的，在添加第一个元素时会直接分配<strong>10个</strong>元素的空间。</p><h3 id="private-void-ensureExplicitCapacity-int-minCapacity"><a href="#private-void-ensureExplicitCapacity-int-minCapacity" class="headerlink" title="private void ensureExplicitCapacity(int minCapacity);"></a>private void ensureExplicitCapacity(int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于确保数组的容量大于minCapacity<br><code>modCount</code>用于计数数组的大小被改变了多少次。<br>如果minCapacity大于内部数组的大小，调用grow方法扩容</p><h3 id="private-void-grow-int-minCapacity"><a href="#private-void-grow-int-minCapacity" class="headerlink" title="private void grow(int minCapacity);"></a>private void grow(int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//即newCapacity = 1.5*oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出数组是以1.5倍为基准扩容的，如果1.5倍后大于<code>MAX_ARRAY_SIZE (Integer.MAX_VALUE - 8)</code>，则使用<code>hugeCapacity(minCapacity)</code>确认。</p><h3 id="private-static-int-hugeCapacity-int-minCapacity"><a href="#private-static-int-hugeCapacity-int-minCapacity" class="headerlink" title="private static int hugeCapacity(int minCapacity)"></a>private static int hugeCapacity(int minCapacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和AbstractCollection类似。。。</p><h2 id="List实现方法"><a href="#List实现方法" class="headerlink" title="List实现方法"></a>List实现方法</h2><h3 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size();"></a>public int size();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明size是实时的size</p><h3 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty();"></a>public boolean isEmpty();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过size判断</p><h3 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o);"></a>public boolean contains(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>indexOf()</code>方法判断（如果不存在该元素indexOf返回-1）</p><h3 id="public-int-indexOf-Object-o"><a href="#public-int-indexOf-Object-o" class="headerlink" title="public int indexOf(Object o);"></a>public int indexOf(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历内部数组，比较是否存在对象o，<code>null</code>要分开判断，<strong>如果不存在返回-1。</strong></p><h3 id="public-int-lastIndexOf-Object-o"><a href="#public-int-lastIndexOf-Object-o" class="headerlink" title="public int lastIndexOf(Object o);"></a>public int lastIndexOf(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和indexOf类似，从尾部开始遍历。</p><h3 id="public-Object-toArray"><a href="#public-Object-toArray" class="headerlink" title="public Object[] toArray();"></a>public Object[] toArray();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接复制返回内部数组。</p><h3 id="public-T-toArray-T-a"><a href="#public-T-toArray-T-a" class="headerlink" title="public  T[] toArray(T[] a);"></a>public <T> T[] toArray(T[] a);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了Arrays.copyOf转类型的重载方法。<br>在数组大小大于List大小的情况下，使用了System.arraycopy拷贝连续内存空间，然后将a[size]设成了null，可见原数组index&gt;size的元素并没有被清空，只是访问不到了。</p><h3 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index);"></a>public E get(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只检查index是不是大于数组大小减一，负数异常交给数组处理。</p><h3 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element);"></a>public E set(int index, E element);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置元素，负数异常也交给数组处理。</p><h3 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先保证能容纳size+1个元素，再添加元素。</p><h3 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element);"></a>public void add(int index, E element);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index后面的先整体后移，然后设置元素。</p><h3 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index);"></a>public E remove(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>System.arraycopy</code>这个native方法真的很常用。</p><h3 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o);"></a>public boolean remove(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fastRemove</code>是<code>public E remove(int index)</code>的精简版，移除方法一致。</p><h3 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear();"></a>public void clear();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环设为null</p><h3 id="public-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c);"></a>public boolean addAll(Collection&lt;? extends E&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是arraycopy的使用，确实省事</p><h3 id="public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c);"></a>public boolean addAll(int index, Collection&lt;? extends E&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的方法类似。</p><h3 id="public-boolean-removeAll-Collection-lt-gt-c"><a href="#public-boolean-removeAll-Collection-lt-gt-c" class="headerlink" title="public boolean removeAll(Collection&lt;?&gt; c);"></a>public boolean removeAll(Collection&lt;?&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>batchRemove</code>：false:删除c中包含的元素，true：删除c中不包含的元素。</p><h3 id="public-boolean-retainAll-Collection-lt-gt-c"><a href="#public-boolean-retainAll-Collection-lt-gt-c" class="headerlink" title="public boolean retainAll(Collection&lt;?&gt; c)"></a>public boolean retainAll(Collection&lt;?&gt; c)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是使用了<code>batchRemove</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我最后一次这么详细地把所有方法列出来了。。。以后只记录重点。。。&lt;/p&gt;
&lt;p&gt;这篇文章虽然贼长但是总结下来重点只有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果使用无参构造函数建立ArrayList，在添加第一个元素的时候会分配10个元素的空间。&lt;/li&gt;
&lt;li&gt;ArrayLi
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码研究" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"/>
    
      <category term="集合" scheme="https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode151-翻转字符串里的单词</title>
    <link href="https://www.codetool.top/article/leetcode151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>https://www.codetool.top/article/leetcode151-翻转字符串里的单词/</id>
    <published>2019-11-22T09:01:15.000Z</published>
    <updated>2019-11-22T09:09:50.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong>   “the sky is blue”<br><strong>输出:</strong>  “blue is sky the”   </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong>  “&nbsp;&nbsp;hello world!&nbsp;&nbsp;”<br><strong>输出:</strong> “world! hello”<br><strong>解释:</strong> 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong>  “a good&nbsp;&nbsp;&nbsp;example”<br><strong>输出:</strong> “example good a”<br><strong>解释:</strong> 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p><strong>说明:</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接使用jdk中String的<code>trim()</code>和<code>split()</code>方法得到单词的数组，或者遍历字符串字符，记录单词数组。再反向遍历输出。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"\\s+"代表正则表达式1个或多个空白字符</span></span><br><span class="line">        String[] words = s.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">        <span class="keyword">int</span> size = words.length;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            str.append(words[size-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=size-<span class="number">1</span>) str.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode119-杨辉三角II</title>
    <link href="https://www.codetool.top/article/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/"/>
    <id>https://www.codetool.top/article/leetcode119-杨辉三角II/</id>
    <published>2019-11-22T08:54:01.000Z</published>
    <updated>2019-11-22T09:00:06.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。<br><img src="https://s2.ax1x.com/2019/11/15/Mdetds.gif" alt="img"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> [1,3,3,1]</p></blockquote><p><strong>进阶：</strong></p><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>可以利用<a href="https://www.codetool.top/article/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/">leetcode118-杨辉三角</a>中的函数来解决。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rowIndex == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">return</span> getRowByPrev(rowIndex,getRow(rowIndex-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上一行计算第n行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRowByPrev</span><span class="params">(<span class="keyword">int</span> n,List&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        ret.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(n+<span class="number">2</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            ret.add(nums.get(i-<span class="number">1</span>)+nums.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            ret.add(ret.get(size-i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个非负索引 &lt;em&gt;k&lt;/em&gt;，其中 &lt;em&gt;k&lt;/em&gt; ≤ 33，返回杨辉三角的第 &lt;em&gt;k&lt;/em&gt; 行。&lt;br&gt;&lt;img 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode189-旋转数组</title>
    <link href="https://www.codetool.top/article/leetcode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode189-旋转数组/</id>
    <published>2019-11-22T08:45:26.000Z</published>
    <updated>2019-11-22T08:52:43.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5,6,7] 和 <em>k</em> = 3<br><strong>输出:</strong> [5,6,7,1,2,3,4]<br><strong>解释:</strong><br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> [-1,-100,3,99] 和 <em>k</em> = 2<br><strong>输出:</strong> [3,99,-1,-100]<br><strong>解释:</strong><br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]  </p></blockquote><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 原地 算法。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>将旋转点前后的部分交换。注意当k大于数组大小size的情况相当于<code>k=k%size</code>的情况</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(k==size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//k大于size的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;size) k = k%size;</span><br><span class="line">        <span class="comment">//用另一个数组暂时存放结果</span></span><br><span class="line">        <span class="keyword">int</span>[] rotate = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="comment">//将旋转点后面的部分移到新数组前面来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            rotate[i] = nums[size-k+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将旋转点前面的部分移到新数组后面去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i&lt;size;i++)&#123;</span><br><span class="line">            rotate[i] = nums[i-k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组中的值赋值回原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            nums[i] = rotate[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;em&gt;k&lt;/em&gt; 个位置，其中 &lt;em&gt;k&lt;/em&gt; 是非负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode209-长度最小的子数组</title>
    <link href="https://www.codetool.top/article/leetcode209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode209-长度最小的子数组/</id>
    <published>2019-11-20T10:06:18.000Z</published>
    <updated>2019-11-20T10:15:57.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s</strong> ，找出该数组中满足其和 ≥ <strong>s</strong> 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> s = 7, nums = [2,3,1,2,4,3]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 子数组 [4,3] 是该条件下的长度最小的连续子数组。  </p></blockquote><p><strong>进阶:</strong></p><p>如果你已经完成了O(<em>n</em>) 时间复杂度的解法, 请尝试 O(<em>n</em> log <em>n</em>) 时间复杂度的解法。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>使用两个指针i、j从下标为0处开始遍历。如果i-j内的总数小于s，将j向后移动，如果i-j内的总数大于s，将i向后移动，直到获取所有子数组的长度，并比较出最短长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;size&amp;&amp;j&lt;size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min==<span class="number">0</span>) min = j-i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> min = j-i+<span class="number">1</span>&lt;min?j-i+<span class="number">1</span>:min;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==size-<span class="number">1</span>) <span class="keyword">return</span> min;</span><br><span class="line">                sum += nums[++j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个含有 &lt;strong&gt;n&lt;/strong&gt; 个正整数的数组和一个正整数 &lt;strong&gt;s&lt;/strong&gt; ，找出该数组中满足其和
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode485-最大连续1的个数</title>
    <link href="https://www.codetool.top/article/leetcode485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode485-最大连续1的个数/</id>
    <published>2019-11-20T09:58:18.000Z</published>
    <updated>2019-11-20T10:07:47.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> [1,1,0,1,1,1]<br><strong>输出：</strong> 3<br><strong>解释：</strong> 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.  </p></blockquote><p><strong>注意：</strong></p><ul><li>输入的数组只包含<code>0</code>和<code>1</code>。</li><li>输入数组的长度是正整数，且不超过 10,000。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>使用一个数遍历数组，另一个数记录遇到的连续的1的个数，记录最大值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;max) max=j;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;max) max=j;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个二进制数组， 计算其中最大连续1的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode27-移除元素</title>
    <link href="https://www.codetool.top/article/leetcode27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode27-移除元素/</id>
    <published>2019-11-20T09:50:02.000Z</published>
    <updated>2019-11-20T09:57:52.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个数组 <em>nums</em> 和一个值 <em>val*，你需要原地移除所有数值等于 *val</em> 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地<strong>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1:</strong></p><blockquote><p>给定 <em>nums</em> = [3,2,2,3], <em>val</em> = 3,<br>函数应该返回新的长度 2, 并且 <em>nums</em> 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。  </p></blockquote><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以 <strong>“引用”</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);  <br/><br/><br>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>我们继续使用两个指针：一个仍然用于迭代，而第二个指针总是指向下一次添加的位置。 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;em&gt;nums&lt;/em&gt; 和一个值 &lt;em&gt;val*，你需要原地移除所有数值等于 *val&lt;/em&gt; 的元素，返回移除后数组
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode167-两数之和II-输入有序数组</title>
    <link href="https://www.codetool.top/article/leetcode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode167-两数之和II-输入有序数组/</id>
    <published>2019-11-20T09:44:33.000Z</published>
    <updated>2019-11-20T10:16:12.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个已按照 <strong><em>升序排列</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值<code>index1</code>和<code>index2</code>，其中<code>index1</code>必须小于<code>index2</code>。</p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong>  numbers = [2, 7, 11, 15], target = 9<br><strong>输出:</strong>   [1,2]<br><strong>解释</strong> 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>因为给的数组是有序的，可以使用双指针逼近目标数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index2 = numbers.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index1 &lt; index2) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[index1] + numbers[index2] &gt; target)</span><br><span class="line">index2--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (numbers[index1] + numbers[index2] &lt; target)</span><br><span class="line">index1++;</span><br><span class="line"><span class="comment">//找到了</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">index[<span class="number">0</span>] = index1 + <span class="number">1</span>;</span><br><span class="line">index[<span class="number">1</span>] = index2 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个已按照 &lt;strong&gt;&lt;em&gt;升序排列&lt;/em&gt;&lt;/strong&gt; 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>AbstractCollection源码分析</title>
    <link href="https://www.codetool.top/article/AbstractCollection%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/AbstractCollection源码分析/</id>
    <published>2019-11-18T13:40:38.000Z</published>
    <updated>2019-11-22T09:18:34.130Z</updated>
    
    <content type="html"><![CDATA[<p>上次谈到了<a href="https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/">Collection接口研究</a></p><p>这次来看看其中的一个子类，但也是个抽象类：<code>AbstractCollection</code>。相比<code>Collection</code>接口并没有新增公开方法，但它提供了许多方法的默认实现。</p><h2 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o);"></a>public boolean contains(Object o);</h2><p>提供了一个默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易理解，也很依赖于<code>iterator()</code>和<code>equals()</code>方法的实现</p><h2 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty();"></a>public boolean isEmpty();</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖于<code>size()</code>方法的实现</p><h2 id="public-Object-toArray"><a href="#public-Object-toArray" class="headerlink" title="public Object[] toArray();"></a>public Object[] toArray();</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class="line">    Object[] r = <span class="keyword">new</span> Object[size()];</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext()) <span class="comment">// fewer elements than expected</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">        r[i] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意该实现判断了<code>iterator</code>遍历的元素个数可能跟<code>size()</code>的结果不同的情况。<br>并且以<code>iterator</code>遍历的所有元素为准。</p><h3 id="private-static-T-finishToArray-T-r-Iterator-lt-gt-it"><a href="#private-static-T-finishToArray-T-r-Iterator-lt-gt-it" class="headerlink" title="private static  T[] finishToArray(T[] r, Iterator&lt;?&gt; it);"></a>private static <T> T[] finishToArray(T[] r, Iterator&lt;?&gt; it);</h3><p>是<code>toArray()</code>函数调用的一个私密静态方法，它将it迭代器遍历的所有元素存入一个数组，并且不依赖<code>size()</code>的实现，可以给传入的数组扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = r.length;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cap = r.length;<span class="comment">//容量capacity的概念</span></span><br><span class="line">        <span class="keyword">if</span> (i == cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCap = cap + (cap &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">// n+n/2+1扩容</span></span><br><span class="line">            <span class="comment">// overflow-conscious code</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) </span><br><span class="line">                newCap = hugeCapacity(cap + <span class="number">1</span>); <span class="comment">//新容量等于Integer.MAX_VALUE或MAX_ARRAY_SIZE</span></span><br><span class="line">            r = Arrays.copyOf(r, newCap);</span><br><span class="line">        &#125;</span><br><span class="line">        r[i++] = (T)it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trim if overallocated</span></span><br><span class="line">    <span class="keyword">return</span> (i == r.length) ? r : Arrays.copyOf(r, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-static-int-hugeCapacity-int-minCapacity"><a href="#private-static-int-hugeCapacity-int-minCapacity" class="headerlink" title="private static int hugeCapacity(int minCapacity);"></a>private static int hugeCapacity(int minCapacity);</h3><p>是<code>finishToArray()</code>函数调用的用于容量逼近<code>Integer.MAX_VALUE</code>给数组扩容的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//超出int范围</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError</span><br><span class="line">            (<span class="string">"Required array size too large"</span>);</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e);"></a>public boolean add(E e);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许单个添加元素。</p><h2 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o);"></a>public boolean remove(Object o);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>null</code>要分开来判断，因为<code>null</code>不能被<code>equals()</code>调用<br>删除的方式是通过迭代器的<code>remove()</code>方法</p><h2 id="public-boolean-containsAll-Collection-lt-gt-c"><a href="#public-boolean-containsAll-Collection-lt-gt-c" class="headerlink" title="public boolean containsAll(Collection&lt;?&gt; c);"></a>public boolean containsAll(Collection&lt;?&gt; c);</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环调用<code>contains()</code>方法判断</p><h2 id="public-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c)"></a>public boolean addAll(Collection&lt;? extends E&gt; c)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作<strong>不能保证</strong>所有元素都被添加成功了，这依赖于<code>add()</code>方法的实现，但只要有一个元素被添加成功了，就返回<code>true</code>。</p><h2 id="public-boolean-removeAll-Collection-lt-gt-c"><a href="#public-boolean-removeAll-Collection-lt-gt-c" class="headerlink" title="public boolean removeAll(Collection&lt;?&gt; c)"></a>public boolean removeAll(Collection&lt;?&gt; c)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，该操作也<strong>不能保证</strong>所有元素都被移除成功了，但只要有一个元素被移除成功了，就返回<code>true</code>。</p><h2 id="public-boolean-retainAll-Collection-lt-gt-c"><a href="#public-boolean-retainAll-Collection-lt-gt-c" class="headerlink" title="public boolean retainAll(Collection&lt;?&gt; c)"></a>public boolean retainAll(Collection&lt;?&gt; c)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>removeAll()</code>的实现相反，将c中含有的元素保留了下来。</p><h2 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear();"></a>public void clear();</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除所有元素。</p><h2 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString()"></a>public String toString()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//sb</span></span><br><span class="line">    sb.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>[*,*,*...]</code>的形式输出字符串，还考虑到了元素可能是它本身的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次谈到了&lt;a href=&quot;https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/&quot;&gt;Collection接口研究&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次来看看其中的一个子类，但也
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码研究" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"/>
    
      <category term="集合" scheme="https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode561-数组拆分I</title>
    <link href="https://www.codetool.top/article/leetcode561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/"/>
    <id>https://www.codetool.top/article/leetcode561-数组拆分I/</id>
    <published>2019-11-18T11:59:58.000Z</published>
    <updated>2019-11-18T12:12:44.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), …, (a<sub>n</sub>, b<sub>n</sub>) ，使得从1 到 n 的 min(a<sub>i</sub>, b<sub>i</sub>) 总和最大。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong>[1,4,3,2]<br><strong>输出：</strong> 4<br><strong>解释:</strong> n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p></blockquote><p><strong>提示:</strong></p><ol><li>n 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>通过观察发现，最后总和应该是所有数排完序后偶数下标的元素的值的总和。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种排序方法：因为已知数的范围都是在[-10000, 10000]中，可以利用额外的空间排序。<br>这种方法由于排序更快，时间复杂度较低，但只适用于数值范围已知且对空间复杂度要求不高的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">int</span> lim = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">            arr[num + lim]++;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">10000</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum += (arr[i + lim] + <span class="number">1</span> - d) / <span class="number">2</span> * i;</span><br><span class="line">            d = (<span class="number">2</span> + arr[i + lim] - d) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a&lt;sub&gt;1&lt;/sub&gt;, b&lt;sub&gt;1&lt;/sub&gt;), (a&lt;s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode344-反转字符串</title>
    <link href="https://www.codetool.top/article/leetcode344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode344-反转字符串/</id>
    <published>2019-11-18T11:57:35.000Z</published>
    <updated>2019-11-18T11:58:34.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组<code>char[]</code>的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地<strong>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong>[“h”,”e”,”l”,”l”,”o”]<br><strong>输出：</strong>[“o”,”l”,”l”,”e”,”h”]  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong>[“H”,”a”,”n”,”n”,”a”,”h”]<br><strong>输出：</strong>[“h”,”a”,”n”,”n”,”a”,”H”]</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>将第一个元素与末尾进行交换，再向前移动到下一个元素，并不断地交换，直到它到达中间位置。</p><p>我们可以同时使用两个指针来完成迭代：一个从第一个元素开始，另一个从最后一个元素开始。持续交换它们所指向的元素，直到这两个指针相遇。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            temp = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组&lt;code&gt;char[]&lt;/code&gt;的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode14-最长公共前缀</title>
    <link href="https://www.codetool.top/article/leetcode14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://www.codetool.top/article/leetcode14-最长公共前缀/</id>
    <published>2019-11-18T11:43:52.000Z</published>
    <updated>2019-11-18T11:57:54.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong>   [“flower”,”flow”,”flight”]<br><strong>输出:</strong> “fl”  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong>   [“dog”,”racecar”,”car”]<br><strong>输出:</strong> “”<br><strong>解释:</strong> 输入不存在公共前缀。 </p></blockquote><p><strong>说明:</strong></p><p>所有输入只包含小写字母 a-z 。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>以第一个字符串的每一个位置上的字符为基准，依次比对其余字符串对应位置上的字符，如果每个字符串对应的位置上都是这个字符，则将其append到结果上，一旦遇到一个字符不是公有的立刻将结果返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = strs.length;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];<span class="comment">//一个字符串直接返回本身</span></span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();<span class="comment">//为了避免java连接字符串的低效率使用StringBuilder</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> letter = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; size;j++)&#123;</span><br><span class="line">                <span class="comment">//依次检查其余字符串各个字符是否对应第一个字符串中的字符</span></span><br><span class="line">                <span class="comment">//为了避免其他字符串的长度小于第一个字符串，使用try捕获异常</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[j].charAt(i)!=letter) <span class="keyword">return</span> str.toString();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123; <span class="keyword">return</span> str.toString();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(letter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode28-实现strStr()</title>
    <link href="https://www.codetool.top/article/leetcode28-%E5%AE%9E%E7%8E%B0strStr/"/>
    <id>https://www.codetool.top/article/leetcode28-实现strStr/</id>
    <published>2019-11-15T10:19:05.000Z</published>
    <updated>2019-11-18T11:37:18.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strStr()</a> 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong>   haystack = “hello”, needle = “ll”<br><strong>输出:</strong> 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong>   haystack = “aaaaa”, needle = “bba”<br><strong>输出:</strong> -1</p></blockquote><p><strong>说明:</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="(https://baike.baidu.com/item/strstr/811469)">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)" target="_blank" rel="noopener">indexOf()</a> 定义相符。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="JDK-API"><a href="#JDK-API" class="headerlink" title="JDK API"></a>JDK API</h2><p>在leetcode上，当然可以投机取巧地使用String.indexof()方法，不用重复造轮子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这是一个经典的字符串精准<strong>模式匹配</strong>问题，历史上出现过很多解决这个问题的算法，掌握它们的思想还是有必要的：</p><h2 id="BF算法（朴素算法）"><a href="#BF算法（朴素算法）" class="headerlink" title="BF算法（朴素算法）"></a>BF算法（朴素算法）</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>这是最直观、最简单的算法。从主串的第start个字符起和模式的第1个字符比较，如果相等继续逐个比较后续字符。比较过程中一旦发现不相等的情况，则回溯至主串中的第start+1个字符位置处，重新与模式P的字符进行比较。该算法效率较低。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mainLen = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> subLen = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(needle.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意模式字符串为空的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mainLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;subLen;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(i+j&lt;mainLen)) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//主串下标超出</span></span><br><span class="line">                <span class="keyword">if</span>(!(haystack.charAt(i+j)==needle.charAt(j))) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == subLen-<span class="number">1</span>) <span class="keyword">return</span> i;<span class="comment">//完全匹配，返回主串下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的复杂度为O[(i-j)j]</p><h2 id="MP算法"><a href="#MP算法" class="headerlink" title="MP算法"></a>MP算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>指针不回溯，利用已得到的“部分匹配”结果，将模式向右“滑动”若干位置后继续比较。</p></blockquote><p>参考下面给出的示例：<br>haystack ：<code>&quot;cdnidnidsm&quot;</code><br>needle：<code>&quot;nidsm&quot;</code><br>按照BF算法的思想，在比较<code>haystack[2]</code>和<code>needle[0]</code>时，两个字符相等，然而比较到<code>haystack[5]</code>和<code>needle[3]</code>的时候两个字符不等，于是回溯继续向后比较<code>haystack[3]</code>和<code>needle[0]</code>。可是既然能确定<code>haystack[2]-haystack[4]</code>与<code>needle[0]-needle[2]</code>是完全对应的。那么比较<code>haystack[3]</code>和<code>needle[0]</code>实际上相当于比较<code>needle[1]</code>和<code>needle[0]</code>。并且我们知道needle中前三个字符都是不同的。所以只需要从<code>haystack[5]</code>处继续跟<code>needle[0]</code>比较就行了。并且needle中字符的这些关系完全是一开始就可以确定的。</p><p>我们称记录模式字符串中各个字符之间关系的函数为<strong>失效函数</strong>。<br>失效函数的定义域是模式字符串在“失配”前匹配的字符串个数。取值j属于<code>0~Len(P)-1</code></p><p><strong>获取失效函数的方法：</strong></p><p>失效函数的取值k满足P<sub>0</sub>P<sub>1</sub>…P<sub>k</sub> = P<sub>j-k</sub>P<sub>j-k+1</sub>…P<sub>j</sub>。如果不存在这个k值，取-1。</p><p>直观的看k就是模式字符串前j个字符是否存在前k+1位等于后k+1位。</p><p>nidsm的失效函数为：</p><table><thead><tr><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>p(j)</td><td>n</td><td>i</td><td>d</td><td>s</td><td>m</td></tr><tr><td>k</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr></tbody></table><p>再举一个例子，caatcat的失效函数为：</p><table><thead><tr><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>p(j)</td><td>c</td><td>a</td><td>a</td><td>t</td><td>c</td><td>a</td><td>t</td></tr><tr><td>k</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td><td>0</td><td>1</td><td>-1</td></tr></tbody></table><p>得到了失效函数后，即可使用MP算法进行匹配。假设在某一轮比较中，失配的情况发生在模式P的第j位，如果j=0，进行下一轮比较时，目标指针向后移动一位，模式的起始比较地址回到P<sub>0</sub>，其他情况进行下一轮比较时，目标指针不发生回溯，而模式P的起始比较地址为<strong>j-1对应的失效函数的值+1</strong>。</p><p>当然也可以把这个值提前算出来便成为了Next()函数：</p><table><thead><tr><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>p(j)</td><td>c</td><td>a</td><td>a</td><td>t</td><td>c</td><td>a</td><td>t</td><td></td></tr><tr><td>Next(j)</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><p>Next(7)可以用于继续匹配（可能要求找出所有匹配的子字符串）。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取next函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] next(String needle)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = needle.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="keyword">while</span>( j &gt; -<span class="number">1</span> &amp;&amp; needle.charAt(i)!=needle.charAt(j))</span><br><span class="line">                j = next[j];<span class="comment">//j会有一个传递的效果，必须前一个i对应的j是1，下一个i对应的j才能是2。如果遇到不同的字符则j清零</span></span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mainLen = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> subLen = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(needle.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意模式字符串为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(mainLen&lt;subLen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = next(needle);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j &lt; mainLen)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;-<span class="number">1</span> &amp;&amp; needle.charAt(i) != haystack.charAt(j))</span><br><span class="line">                i = next[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= subLen)&#123;</span><br><span class="line">                <span class="keyword">return</span> j-i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在MP算法的基础上，还要避免最长前缀之后的那个字符不等于原来失配的那个字符。<br>下面在已知mpNext表的情况下，给出建立kmpNext表的规则。这个规则分为四种情况：</p><ol><li>如果mpNext[j] = 0且P<sub>j</sub> = P<sub>0</sub>，则令kmpNext[j] = -1。</li><li>如果mpNext[j] = 0且P<sub>j</sub> ≠ P<sub>0</sub>，则令kmpNext[j] = 0。</li><li>如果mpNext[j] ≠ 0且P<sub>j</sub> ≠ P<sub>mpNext[j]</sub>，则令kmpNext[j] = mpNext[j]。</li><li>如果mpNext[j] ≠ 0且P<sub>j</sub> = P<sub>mpNext[j]</sub>，则用mpNext[j]的值替换原来mpNext[j]中的j值，直到情况转换为前3种情况的一种，进而递归地求解kmpNext[j]。</li></ol><table><thead><tr><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>p(j)</td><td>c</td><td>a</td><td>a</td><td>t</td><td>c</td><td>a</td><td>t</td><td></td></tr><tr><td>mpNext(j)</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr><tr><td>kmpNext(j)</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>-1</td><td>0</td><td>2</td><td>0</td></tr></tbody></table><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取kmpNext数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] next(String needle)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = needle.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>( j &gt; -<span class="number">1</span> &amp;&amp; needle.charAt(i)!=needle.charAt(j))</span><br><span class="line">                j = next[j];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) == needle.charAt(j))</span><br><span class="line">                next[i] = next[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mainLen = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> subLen = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(needle.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意模式字符串为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(mainLen&lt;subLen) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = next(needle);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j &lt; mainLen)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;-<span class="number">1</span> &amp;&amp; needle.charAt(i) != haystack.charAt(j))</span><br><span class="line">                i = next[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= subLen)&#123;</span><br><span class="line">                <span class="keyword">return</span> j-i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;实现 &lt;a href=&quot;https://baike.baidu.com/item/strstr/811469&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode67-二进制求和</title>
    <link href="https://www.codetool.top/article/leetcode67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode67-二进制求和/</id>
    <published>2019-11-15T09:49:29.000Z</published>
    <updated>2019-11-15T10:08:54.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> a = “11”, b = “1”<br><strong>输出:</strong> “100”  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> a = “1010”, b = “1011”<br><strong>输出:</strong> “10101”  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>通过加法规则实现，应注意进位的处理和字符的处理。<br>不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式：  </p><ul><li>第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转</li><li>第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>copy了<code>@灵魂画师牧码（guanpengchn）</code>的思路：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> ca = <span class="number">0</span>;<span class="comment">//进位值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = ca;</span><br><span class="line">            <span class="comment">//将数组长度不够的情况一般化，负数下标对应的值用0计算。</span></span><br><span class="line">            sum += i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            sum += j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            ans.append(sum % <span class="number">2</span>);</span><br><span class="line">            ca = sum / <span class="number">2</span>;<span class="comment">//得到进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans.append(ca == <span class="number">1</span> ? ca : <span class="string">""</span>);<span class="comment">//如果最后进位值还为1则添加一位</span></span><br><span class="line">        <span class="keyword">return</span> ans.reverse().toString();<span class="comment">//反转字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自己做的凌乱的思路：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取两个字符串的长度和最大值最小值</span></span><br><span class="line">        <span class="keyword">int</span> len_a = a.length();</span><br><span class="line">        <span class="keyword">int</span> len_b = b.length();</span><br><span class="line">        <span class="keyword">int</span> max,min;</span><br><span class="line">        <span class="keyword">boolean</span> carry = <span class="keyword">false</span>;<span class="comment">//进位标志</span></span><br><span class="line">        <span class="keyword">if</span>( len_a &lt;= len_b )&#123;</span><br><span class="line">            max = len_b;</span><br><span class="line">            min = len_a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max = len_a;</span><br><span class="line">            min = len_b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] ret = <span class="keyword">new</span> <span class="keyword">char</span>[max];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; max ; i++ )&#123;</span><br><span class="line">            <span class="keyword">char</span> a_now = i&lt;len_a?a.charAt(len_a-<span class="number">1</span>-i):<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">char</span> b_now = i&lt;len_b?b.charAt(len_b-<span class="number">1</span>-i):<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//列举所有情况手动计算</span></span><br><span class="line">            <span class="keyword">if</span>(a_now==<span class="string">'1'</span>&amp;&amp;b_now==<span class="string">'1'</span>)&#123;</span><br><span class="line">                ret[max-i-<span class="number">1</span>] = carry?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">                carry = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==max-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"1"</span>+ String.valueOf(ret);<span class="comment">//如果当前为首位则在前面连接一个1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a_now==<span class="string">'1'</span>&amp;&amp;b_now==<span class="string">'0'</span>||b_now==<span class="string">'1'</span>&amp;&amp;a_now==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">                    ret[max-i-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==max-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"1"</span>+ String.valueOf(ret);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ret[max-i-<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a_now==<span class="string">'0'</span>&amp;&amp;b_now==<span class="string">'0'</span>)&#123;</span><br><span class="line">                ret[max-i-<span class="number">1</span>] = carry?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">                carry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定两个二进制字符串，返回他们的和（用二进制表示）。&lt;/p&gt;
&lt;p&gt;输入为&lt;strong&gt;非空&lt;/strong&gt;字符串且只包含数字 &lt;cod
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
