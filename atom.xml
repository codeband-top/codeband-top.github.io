<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeBand CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2019-12-15T14:47:56.551Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode19-删除链表的倒数第N个节点</title>
    <link href="https://www.codetool.top/article/leetcode19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://www.codetool.top/article/leetcode19-删除链表的倒数第N个节点/</id>
    <published>2019-12-15T14:30:54.000Z</published>
    <updated>2019-12-15T14:47:56.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p><strong>示例:</strong></p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br><br/><br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p><strong>说明:</strong></p><p>给定的 n 保证是有效的。</p><p><strong>进阶:</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>使用两个指针，让快指针一开始和慢指针保持n的距离，两者一起以同样速度移动，则当快指针指向链表的最后一个节点的时候，慢指针的下一个节点就是要删除的节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>HashSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode slow;</span><br><span class="line">        ListNode fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这种情况需要删除头节点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blo
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode160-相交链表</title>
    <link href="https://www.codetool.top/article/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/leetcode160-相交链表/</id>
    <published>2019-12-14T13:31:39.000Z</published>
    <updated>2019-12-14T13:44:53.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/14/QWFV7F.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/14/QWFnh9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>输入：</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br><strong>输出：</strong> Reference of the node with value = 8<br><strong>输入解释：</strong> 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p></blockquote><p><strong>示例 2：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/14/QWFek4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>输入：</strong> intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br><strong>输出：</strong> Reference of the node with value = 2<br><strong>输入解释：</strong> 相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p></blockquote><p><strong>示例 3：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/14/QWFmtJ.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>输入：</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br><strong>输出：</strong> null<br><strong>输入解释：</strong> 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p></blockquote><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>HashSet<br> 依次将获取到的链表元素插入一个HashSet中，返回第一个重复的节点。</li><li>双指针<br> 两个指针从头走到尾的路径长度之差就是两条路径相交点前的长度之差，获取了这个差之后就可以路径短的让路径长的先走几步，然后同时出发，在相交点相遇。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>HashSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        ListNode curA = headA;</span><br><span class="line">        ListNode curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            set.add(curA);</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(curB))</span><br><span class="line">                <span class="keyword">return</span> curB;</span><br><span class="line">            set.add(curB);</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(headA == headB) <span class="keyword">return</span> headA;</span><br><span class="line">        ListNode curA = headA;</span><br><span class="line">        ListNode curB = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//两个指针先一起走一遍</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=curB &amp;&amp; (curA.next!=<span class="keyword">null</span> || curB.next!=<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                countA++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curB.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                curB = curB.next;</span><br><span class="line">                countB++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curA != curB) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取两条路径的长度只差</span></span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        ListNode longer;</span><br><span class="line">        ListNode near;</span><br><span class="line">        <span class="keyword">if</span>(countA&gt;=countB)&#123;</span><br><span class="line">            step = countA-countB;</span><br><span class="line">            longer = headA;</span><br><span class="line">            near = headB;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            step = countB-countA;</span><br><span class="line">            longer = headB;</span><br><span class="line">            near = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//近的让远的先走</span></span><br><span class="line">        <span class="keyword">while</span>(longer != near)&#123;</span><br><span class="line">            longer = longer.next;</span><br><span class="line">            <span class="keyword">if</span>(step==<span class="number">0</span>)</span><br><span class="line">                near = near.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                step --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表：&lt;/p&gt;
&lt;figure class=&quot;image-bubbl
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode142-环形链表II</title>
    <link href="https://www.codetool.top/article/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>https://www.codetool.top/article/leetcode142-环形链表II/</id>
    <published>2019-12-14T11:36:23.000Z</published>
    <updated>2019-12-14T12:16:11.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 -1，则在该链表中没有环。</p><p><strong>说明：</strong> 不允许修改给定的链表。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> head = [3,2,0,-4], pos = 1<br><strong>输出:</strong> tail connects to node index 1<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第二个节点。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/14/QRoFUg.png" alt="QRoFUg.png" title="">                </div>                <div class="image-caption">QRoFUg.png</div>            </figure><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> head = [1,2], pos = 0<br><strong>输出:</strong> tail connects to node index 0<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第一个节点。</p></blockquote><p><img src="https://s2.ax1x.com/2019/12/14/QRoiVS.png" alt="QRoiVS.png"></p><p><strong>示例3:</strong></p><blockquote><p><strong>输入:</strong> head = [1], pos = -1<br><strong>输出:</strong> no cycle<br><strong>解释:</strong> 链表中没有环。    </p></blockquote><p><img src="https://s2.ax1x.com/2019/12/14/QRoECj.png" alt="QRoECj.png"></p><p><strong>进阶：</strong></p><p>你是否可以不用额外空间解决此题？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li><p>HashSet<br> 依次将获取到的链表元素插入一个HashSet中，返回第一个重复的节点。</p></li><li><p>双指针<br> 理论上慢指针和快指针在环中相遇的位置是有规律可循的：<br> 设第一个节点入环的距离为x，环的长度为y，则快指针每次走两步，慢指针每次走一步，第一次相遇经过的次数为t,则有：<br> <code>(t-x)%y = (2t-x)%y</code><br> 它等价于：<code>(2t-x)-(t-x) = ny</code>(n为自然数，代表第几次相遇)<br> 也就可以得出<code>t = ny</code><br> 再通过第一次相遇的环上坐标为<code>(t-x)%y</code>，将<code>t = y</code>代入，得第一次相遇的环上坐标为<code>y-x</code>。<br> 此时，相遇点和出发点距入环点的距离都是<code>x</code>。于是让快指针回到出发点，两指针都以速度为1继续行走，直到相遇就是入环点。</p><p> <img src="https://s2.ax1x.com/2019/12/14/QRql9g.png" alt="QRql9g.png"></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>HashSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur)) <span class="keyword">return</span> cur;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode141-环形链表</title>
    <link href="https://www.codetool.top/article/leetcode141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/leetcode141-环形链表/</id>
    <published>2019-12-14T11:14:40.000Z</published>
    <updated>2019-12-14T11:30:39.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> head = [3,2,0,-4], pos = 1<br><strong>输出:</strong> true<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第二个节点。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/14/QRoFUg.png" alt="QRoFUg.png" title="">                </div>                <div class="image-caption">QRoFUg.png</div>            </figure><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> head = [1,2], pos = 0<br><strong>输出:</strong> true<br><strong>解释:</strong> 链表中有一个环，其尾部连接到第一个节点。</p></blockquote><p><img src="https://s2.ax1x.com/2019/12/14/QRoiVS.png" alt="QRoiVS.png"></p><p><strong>示例3:</strong></p><blockquote><p><strong>输入:</strong> head = [1], pos = -1<br><strong>输出:</strong> false<br><strong>解释:</strong> 链表中没有环。    </p></blockquote><p><img src="https://s2.ax1x.com/2019/12/14/QRoECj.png" alt="QRoECj.png"></p><p><strong>进阶：</strong></p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>HashSet<br> 依次将获取到的链表元素插入一个HashSet中，看是否有相同元素。</li><li>双指针<br> 一个快指针一个慢指针，如果有环快指针总会赶上慢指针。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>HashSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow!=<span class="keyword">null</span> &amp;&amp; fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode707-设计链表</title>
    <link href="https://www.codetool.top/article/leetcode707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/leetcode707-设计链表/</id>
    <published>2019-12-14T09:36:53.000Z</published>
    <updated>2019-12-14T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code>  的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><p><strong>示例：</strong></p><blockquote><p>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3  </p></blockquote><p><strong>提示:</strong></p><ul><li>所有val值都在 <code>[1, 1000]</code> 之内。</li><li>操作次数将在 <code>[1, 1000]</code> 之内。</li><li>请不要使用内置的 LinkedList 库。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>链表的数据结构！！ 一般会有一个size和一个head，特别注意如果有tail涉及到可能更改tail的地方一定要注意更改tail。（我调试这个bug调试了一个下午😭）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size || index&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node();</span><br><span class="line">        newHead.val = val;</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>) tail = newHead;</span><br><span class="line">        head = newHead;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Node newTail = <span class="keyword">new</span> Node();</span><br><span class="line">        newTail.val = val;</span><br><span class="line">        newTail.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>) head = newTail;</span><br><span class="line">        <span class="keyword">else</span> tail.next = newTail;</span><br><span class="line">        tail = newTail;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == size)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        node.val = val;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index-<span class="number">1</span>;i++)</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        node.next = cur.next;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size || index &lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index-<span class="number">1</span>;i++)</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="comment">//这个地方！！！ 考虑到可能会把tail删除！！！</span></span><br><span class="line">        <span class="keyword">if</span>(index == size)&#123;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：&lt;code&gt;val&lt;/code&gt; 和 &lt;code&gt;next&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode841-钥匙和房间</title>
    <link href="https://www.codetool.top/article/leetcode841-%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/"/>
    <id>https://www.codetool.top/article/leetcode841-钥匙和房间/</id>
    <published>2019-12-13T12:29:01.000Z</published>
    <updated>2019-12-13T12:37:17.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p><p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p><p>你可以自由地在房间之间来回走动。</p><p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [[1],[2],[3],[]]<br><strong>输出：</strong> true<br><strong>解释：</strong><br>我们从 0 号房间开始，拿到钥匙 1。<br>之后我们去 1 号房间，拿到钥匙 2。<br>然后我们去 2 号房间，拿到钥匙 3。<br>最后我们去了 3 号房间。<br>由于我们能够进入每个房间，我们返回 true。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [[1,3],[3,0,1],[2],[0]]<br><strong>输出：</strong> false<br><strong>解释：</strong>  我们不能进入 2 号房间。  </p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>所有房间中的钥匙数量总计不超过 3000。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>BFS搜索，记录去过哪些房间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/13/Q2Fh1x.png" alt="Q2Fh1x.png" title="对应示例2">                </div>                <div class="image-caption">对应示例2</div>            </figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = rooms.size();</span><br><span class="line">        <span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        mark[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;List&lt;Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(rooms.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; room = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i:room)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(rooms.get(i));</span><br><span class="line">                    mark[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:mark)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;有 &lt;code&gt;N&lt;/code&gt; 个房间，开始时你位于 &lt;code&gt;0&lt;/code&gt; 号房间。每个房间有不同的号码：&lt;code&gt;0，1，2，
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode542-01矩阵</title>
    <link href="https://www.codetool.top/article/leetcode542-01%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.codetool.top/article/leetcode542-01矩阵/</id>
    <published>2019-12-13T11:40:58.000Z</published>
    <updated>2019-12-13T12:06:27.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p><strong>示例1:</strong></p><p>输入:</p><blockquote><p>0 0 0<br>0 1 0<br>0 0 0  </p></blockquote><p>输出:</p><blockquote><p>0 0 0<br>0 1 0<br>0 0 0  </p></blockquote><p><strong>示例2:</strong></p><p>输入:</p><blockquote><p>0 0 0<br>0 1 0<br>1 1 1  </p></blockquote><p>输出:</p><blockquote><p>0 0 0<br>0 1 0<br>1 2 1   </p></blockquote><p><strong>注意:</strong></p><ol><li>给定矩阵的元素个数不超过 10000。</li><li>给定矩阵中至少有一个元素是 0。</li><li>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul><li>BFS：<br>先将所有0标记出，然后紧挨0未被标记出的就是1，标记所有1，紧挨1未被标记出的就是2……</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/13/Q2Cwp6.png" alt="BFS" title="">                </div>                <div class="image-caption">BFS</div>            </figure><ul><li>动态规划：<br>依次遍历每个元素，如果四周有0就是1，如果没有也不是0就根据所有相邻元素对应的值中的最小值+1获得。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>BFS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Point(sr,sc));</span><br><span class="line">        <span class="keyword">int</span> origin = image[sr][sc];</span><br><span class="line">        <span class="keyword">int</span> height = image.length;</span><br><span class="line">        <span class="keyword">int</span> width = image[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(newColor == origin) <span class="keyword">return</span> image;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Point point = queue.poll();</span><br><span class="line">            image[point.x][point.y] = newColor;</span><br><span class="line">            <span class="keyword">if</span>(point.x!=height-<span class="number">1</span> &amp;&amp; image[point.x+<span class="number">1</span>][point.y] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x+<span class="number">1</span>,point.y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(point.x!=<span class="number">0</span> &amp;&amp; image[point.x-<span class="number">1</span>][point.y] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x-<span class="number">1</span>,point.y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(point.y!=width-<span class="number">1</span> &amp;&amp; image[point.x][point.y+<span class="number">1</span>] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x,point.y+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(point.y!= <span class="number">0</span>&amp;&amp; image[point.x][point.y-<span class="number">1</span>] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x,point.y-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length ;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = dfs(matrix, dp, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> dp;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length ;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;m-<span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; n-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="comment">// 如果自身是0</span></span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果四周有0</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; matrix[i-<span class="number">1</span>][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n-<span class="number">1</span> &amp;&amp; matrix[i][j+<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m-<span class="number">1</span> &amp;&amp; matrix[i+<span class="number">1</span>][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; matrix[i][j-<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果四周没有0根据四周的dp最小值+1获取</span></span><br><span class="line">        <span class="keyword">int</span> left,bottom,right,top;</span><br><span class="line">        left=top=<span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            top = dp[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt; <span class="number">0</span> &amp;&amp; dp[i][j-<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            left = dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        bottom = dfs(matrix, dp,i+<span class="number">1</span>, j);</span><br><span class="line">        right = dfs(matrix, dp,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(left, right), Math.min(top,bottom))+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。&lt;/p&gt;
&lt;p&gt;两个相邻元素间的距离为 1 。&lt;/p&gt;
&lt;p&gt;&lt;str
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="https://www.codetool.top/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode733-图像渲染</title>
    <link href="https://www.codetool.top/article/leetcode733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/"/>
    <id>https://www.codetool.top/article/leetcode733-图像渲染/</id>
    <published>2019-12-13T10:32:56.000Z</published>
    <updated>2019-12-13T12:37:17.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong><br>image = [[1,1,1],[1,1,0],[1,0,1]]<br>sr = 1, sc = 1, newColor = 2<br><strong>输出:</strong> [[2,2,2],[2,2,0],[2,0,1]]<br><strong>解析:</strong><br>在图像的正中间，(坐标(sr,sc)=(1,1)),<br>在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，<br>因为它不是在上下左右四个方向上与初始点相连的像素点。  </p></blockquote><p><strong>注意:</strong></p><blockquote><ul><li>image 和 image[0] 的长度在范围 [1, 50] 内。</li><li>给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。</li><li>image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。</li></ul></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>图的BFS</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/13/QgLaMn.png" alt="对应示例" title="">                </div>                <div class="image-caption">对应示例</div>            </figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Point(sr,sc));</span><br><span class="line">        <span class="keyword">int</span> origin = image[sr][sc];</span><br><span class="line">        <span class="keyword">int</span> height = image.length;</span><br><span class="line">        <span class="keyword">int</span> width = image[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(newColor == origin) <span class="keyword">return</span> image;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Point point = queue.poll();</span><br><span class="line">            image[point.x][point.y] = newColor;</span><br><span class="line">            <span class="keyword">if</span>(point.x!=height-<span class="number">1</span> &amp;&amp; image[point.x+<span class="number">1</span>][point.y] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x+<span class="number">1</span>,point.y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(point.x!=<span class="number">0</span> &amp;&amp; image[point.x-<span class="number">1</span>][point.y] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x-<span class="number">1</span>,point.y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(point.y!=width-<span class="number">1</span> &amp;&amp; image[point.x][point.y+<span class="number">1</span>] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x,point.y+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(point.y!= <span class="number">0</span>&amp;&amp; image[point.x][point.y-<span class="number">1</span>] == origin)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Point(point.x,point.y-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。&lt;/p&gt;
&lt;p&gt;给你一个坐标 &lt;code
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode394-字符串解码</title>
    <link href="https://www.codetool.top/article/leetcode394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://www.codetool.top/article/leetcode394-字符串解码/</id>
    <published>2019-12-13T08:01:55.000Z</published>
    <updated>2019-12-13T10:33:26.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例:</strong></p><blockquote><p>s = “3[a]2[bc]”, 返回 “aaabcbc”.<br>s = “3[a2[c]]”, 返回 “accaccacc”.<br>s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>DFS，只处理字符串中不包含括号的，遇到带括号的将其分解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> multify(<span class="number">1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multify</span><span class="params">(<span class="keyword">int</span> repeat,String s)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//字符串中不带括号</span></span><br><span class="line">        <span class="keyword">if</span>(s.indexOf(<span class="string">'['</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;repeat;i++)&#123;</span><br><span class="line">                sb.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//未匹配括号的个数</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//第一个数字出现的index</span></span><br><span class="line">            <span class="keyword">int</span> firstNumberIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//第一个左括号出现的index</span></span><br><span class="line">            <span class="keyword">int</span> firstLeftIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> firstNumberHasShown = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">                <span class="comment">//如果是数字记录第一个数字出现的index</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;s.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(firstNumberHasShown == <span class="keyword">false</span>)&#123;  </span><br><span class="line">                        firstNumberIndex = i;</span><br><span class="line">                        firstNumberHasShown = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是左括号记录第一个左括号出现的index</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                        firstLeftIndex = i;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是右括号则未匹配的左括号数量减一，如果全部匹配完则把repeat和substring递归处理。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">']'</span>)&#123;</span><br><span class="line">                    count --;</span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstNumberHasShown = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">int</span> repeatNum = Integer.valueOf(s.substring(firstNumberIndex,firstLeftIndex));</span><br><span class="line">                        String subString = s.substring(firstLeftIndex+<span class="number">1</span>,i);</span><br><span class="line">                        sb.append(multify(repeatNum,subString));</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(s.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> multify(repeat,sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode225--用队列实现栈</title>
    <link href="https://www.codetool.top/article/leetcode225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://www.codetool.top/article/leetcode225-用队列实现栈/</id>
    <published>2019-12-13T04:58:54.000Z</published>
    <updated>2019-12-13T05:01:47.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>用一个队列进行插入操作，要得到队列的最后一个插入的元素可以将其他的元素先插入第二个队列，得到最后一个元素之后再把元素插入回来。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Queue&lt;Integer&gt; buffer;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        buffer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">            buffer.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = queue.poll();</span><br><span class="line">        <span class="keyword">while</span>(!buffer.isEmpty())&#123;</span><br><span class="line">            queue.offer(buffer.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">            buffer.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = queue.poll();</span><br><span class="line">        buffer.offer(result);</span><br><span class="line">        <span class="keyword">while</span>(!buffer.isEmpty())&#123;</span><br><span class="line">            queue.offer(buffer.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;使用队列实现栈的下列操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 元素 x 入栈&lt;/li&gt;
&lt;li&gt;pop() – 移除栈顶元素&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="队列" scheme="https://www.codetool.top/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode232-用栈实现队列</title>
    <link href="https://www.codetool.top/article/leetcode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode232-用栈实现队列/</id>
    <published>2019-12-13T04:41:48.000Z</published>
    <updated>2019-12-13T04:49:43.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>使用栈实现队列的下列操作：</p><ul><li>push(x) – 将一个元素放入队列的尾部。</li><li>pop() – 从队列首部移除元素。</li><li>peek() – 返回队列首部的元素。</li><li>empty() – 返回队列是否为空。</li></ul><p><strong>示例:</strong></p><blockquote><p>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false  </p></blockquote><p><strong>说明:</strong> </p><blockquote><ul><li>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。  </li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>用一个栈进行插入操作，要得到栈的第一个插入的元素需要再用一个栈将第一个栈中的元素次序翻转过来，得到第一个元素，再依次压栈回去。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; reverse;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        reverse = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            reverse.push(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = reverse.pop();</span><br><span class="line">        <span class="keyword">while</span>(!reverse.empty())&#123;</span><br><span class="line">            stack.push(reverse.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            reverse.push(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = reverse.peek();</span><br><span class="line">        <span class="keyword">while</span>(!reverse.empty())&#123;</span><br><span class="line">            stack.push(reverse.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 将一个元素放入队列的尾部。&lt;/li&gt;
&lt;li&gt;pop() – 从队
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="队列" scheme="https://www.codetool.top/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode94-二叉树的中序遍历</title>
    <link href="https://www.codetool.top/article/leetcode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode94-二叉树的中序遍历/</id>
    <published>2019-12-12T12:35:53.000Z</published>
    <updated>2019-12-13T04:43:46.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个二叉树，返回它的 <em>中序</em> 遍历。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [1,null,2,3]<br>&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/<br>&nbsp;&nbsp;&nbsp;3<br><strong>输出:</strong> [1,3,2]  </p></blockquote><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>DFS，递归方法着实很简单，迭代很抽象。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代，我一开始这么写的，用一个HashSet记录栈存储过的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=node.left &amp;&amp; !set.contains(node.left)) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            set.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(node.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>!=node.right) </span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看到官方的写法，这才是递归转化过来的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回它的 &lt;em&gt;中序&lt;/em&gt; 遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode494-目标和</title>
    <link href="https://www.codetool.top/article/leetcode494-%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode494-目标和/</id>
    <published>2019-12-12T11:01:45.000Z</published>
    <updated>2019-12-12T11:05:23.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> nums: [1, 1, 1, 1, 1], S: 3<br><strong>输出:</strong> 5<br><strong>解释:</strong><br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>一共有5种方法让最终目标和为3。   </p></blockquote><p><strong>注意:</strong></p><ol><li>数组非空，且长度不会超过20。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果能被32位整数存下。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>DFS比较暴力，追求时间快可以用01背包问题的动态规划思想，以后更。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numsArray;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        numsArray = nums;</span><br><span class="line">        target = S;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == numsArray.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(index+<span class="number">1</span>,sum+numsArray[index])+dfs(index+<span class="number">1</span>,sum-numsArray[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 +
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode133-克隆图</title>
    <link href="https://www.codetool.top/article/leetcode133-%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>https://www.codetool.top/article/leetcode133-克隆图/</id>
    <published>2019-12-12T07:42:25.000Z</published>
    <updated>2019-12-12T07:57:24.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><p><strong>示例:</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/12/Q6Md3j.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p><strong>输入:</strong> <code>{&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[{&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[{&quot;$ref&quot;:&quot;1&quot;},{&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[{&quot;$ref&quot;:&quot;2&quot;},{&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[{&quot;$ref&quot;:&quot;3&quot;},{&quot;$ref&quot;:&quot;1&quot;}],&quot;val&quot;:4}],&quot;val&quot;:3}],&quot;val&quot;:2},{&quot;$ref&quot;:&quot;4&quot;}],&quot;val&quot;:1}</code><br><strong>解释:</strong><br>节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>Hashmap维持原图节点和克隆节点的对应关系，如果给邻居节点赋值的时候不存在对应的克隆节点则获取对应的克隆节点，直到有一个节点的邻居节点的克隆节点都存在于map中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//hashmap维持原图和克隆图之间节点的对应关系</span></span><br><span class="line">    Map&lt;Node, Node&gt; lookup;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        lookup = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//存在对应的克隆节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (lookup.containsKey(node)) <span class="keyword">return</span> lookup.get(node);</span><br><span class="line">        <span class="comment">//先创建对应的克隆节点，邻居列表在递归返回的时候添加。</span></span><br><span class="line">        Node clone = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        lookup.put(node, clone);</span><br><span class="line">        <span class="keyword">for</span> (Node n : node.neighbors)</span><br><span class="line">            <span class="comment">//如果map中存在克隆节点就能添加了</span></span><br><span class="line">            clone.neighbors.add(dfs(n));</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 &lt;code&gt;val&lt;/code&gt;（&lt;code&gt;Int&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="图" scheme="https://www.codetool.top/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode150-逆波兰表达式求值</title>
    <link href="https://www.codetool.top/article/leetcode150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode150-逆波兰表达式求值/</id>
    <published>2019-12-12T06:08:04.000Z</published>
    <updated>2019-12-12T06:24:01.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> [“2”, “1”, “+”, “3”, “*”]<br><strong>输出:</strong> 9<br><strong>解释:</strong> ((2 + 1) * 3) = 9  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> [“4”, “13”, “5”, “/“, “+”]<br><strong>输出:</strong> 6<br><strong>解释:</strong> (4 + (13 / 5)) = 6</p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入:</strong> [“10”, “6”, “9”, “3”, “+”, “-11”, “*”, “/“, “*”, “17”, “+”, “5”, “+”]<br><strong>输出:</strong> 22<br><strong>解释:</strong><br>&nbsp;&nbsp;((10 * (6 / ((9 + 3) * -11))) + 17) + 5<br>=&nbsp;((10 * (6 / (12 * -11))) + 17) + 5<br>=&nbsp;((10 * (6 / -132)) + 17) + 5<br>=&nbsp;((10 * 0) + 17) + 5<br>=&nbsp;(0 + 17) + 5<br>=&nbsp;17 + 5<br>=&nbsp;22  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>最底层必是一个能运算的最小单元，只要将后序遍历的结果依次入栈，遇到一个运算符则让两个数字出栈，计算结果之后再将结果入栈，如此循环最后就能得到答案。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/12/QyO8jx.png" alt="QyO8jx.png" title="逆波兰表达式">                </div>                <div class="image-caption">逆波兰表达式</div>            </figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String i:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.valueOf(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.valueOf(stack.pop());</span><br><span class="line">                stack.push(num1+num2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">"-"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.valueOf(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.valueOf(stack.pop());</span><br><span class="line">                stack.push(num2-num1);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">"*"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.valueOf(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.valueOf(stack.pop());</span><br><span class="line">                stack.push(num1*num2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.valueOf(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.valueOf(stack.pop());</span><br><span class="line">                stack.push(num2/num1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;根据逆波兰表示法，求表达式的值。&lt;/p&gt;
&lt;p&gt;有效的运算符包括 &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode739-每日温度</title>
    <link href="https://www.codetool.top/article/leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>https://www.codetool.top/article/leetcode739-每日温度/</id>
    <published>2019-12-11T09:00:18.000Z</published>
    <updated>2019-12-11T09:19:59.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示：</strong> <code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>基础栈解法：<code>时间复杂度O(nlog n)</code><br> 将数组元素依次入栈，如果当前元素比栈首元素大则将栈首元素出栈，并知道了和栈首元素之间的距离。再次和下一个栈首元素比较，如此循环。</li><li>逆序跳跃：<code>时间复杂度O(n)</code><br> <a href="https://leetcode-cn.com/problems/daily-temperatures/solution/jie-ti-si-lu-by-pulsaryu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures/solution/jie-ti-si-lu-by-pulsaryu/</a></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>基础栈</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.pos = pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()&amp;&amp;T[i]&gt;stack.peek().value)&#123;</span><br><span class="line">                Node node = stack.pop();</span><br><span class="line">                ans[node.pos] = i - node.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Node(T[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            ans[node.pos] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>逆序跳跃（作者：pulsaryu）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = T.length;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从右向左遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j+= result[j]是利用已经有的结果进行跳跃</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j+= result[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[j] &gt; T[i]) &#123;</span><br><span class="line">                result[i] = j - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result[j] == <span class="number">0</span>) &#123; <span class="comment">//遇到0表示后面不会有更大的值，那当然当前值就应该也为0</span></span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;根据每日 &lt;code&gt;气温&lt;/code&gt; 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode20-有效的括号</title>
    <link href="https://www.codetool.top/article/leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://www.codetool.top/article/leetcode20-有效的括号/</id>
    <published>2019-12-11T08:51:26.000Z</published>
    <updated>2019-12-11T08:56:38.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> “()”<br><strong>输出:</strong> true</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> “()[]{}”<br><strong>输出:</strong> true</p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入:</strong> “(]”<br><strong>输出:</strong> false</p></blockquote><p><strong>示例4:</strong></p><blockquote><p><strong>输入:</strong> “([)]”<br><strong>输出:</strong> false</p></blockquote><p><strong>示例5:</strong></p><blockquote><p><strong>输入:</strong> “{[]}”<br><strong>输出:</strong> true</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>左括号全部入栈，如果是右括号寻找栈首是否为对应的左括号，存在就将左括号出栈，直到栈元素全部清空。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>||c==<span class="string">'['</span>||c==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek().equals(<span class="string">'('</span>)) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek().equals(<span class="string">'['</span>)) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.empty()&amp;&amp;stack.peek().equals(<span class="string">'&#123;'</span>)) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;{
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode155-最小栈</title>
    <link href="https://www.codetool.top/article/leetcode155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>https://www.codetool.top/article/leetcode155-最小栈/</id>
    <published>2019-12-11T08:42:41.000Z</published>
    <updated>2019-12-12T07:43:10.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) – 将元素 x 推入栈中。</li><li>pop() – 删除栈顶的元素。</li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><blockquote><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>用list实现栈，再用一个stack保存着入栈期间出现过的所有最小数。（栈首元素表示在某个时刻list中最小的数）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加元素时，如果最小数栈是空的或者该元素比栈首元素要小，则入栈</span></span><br><span class="line">        <span class="keyword">if</span>(stack.empty()||x&lt;=stack.peek()) stack.push(x);</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//移除元素时，如果移除的元素是最小数栈的栈首元素，那么栈首元素也要出栈</span></span><br><span class="line">        <span class="keyword">if</span>(stack.peek().equals(list.get(list.size()-<span class="number">1</span>)))</span><br><span class="line">            stack.pop();</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小数栈的栈首元素</span></span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 将元素 x
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode279-完全平方数</title>
    <link href="https://www.codetool.top/article/leetcode279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode279-完全平方数/</id>
    <published>2019-12-11T08:10:25.000Z</published>
    <updated>2019-12-11T09:36:32.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> n = 12<br><strong>输出:</strong> 3<br><strong>解释:</strong> 12 = 4 + 4 + 4.  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> n = 13<br><strong>输出:</strong> 2<br><strong>解释:</strong> 13 = 4 + 9.  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>以12为例。</p><p>这道题确实对时间要求比较严格，如果不过滤掉重复计算的部分会无法通过。</p><p>从目标数出发自顶向下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/11/QsnGnO.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由已知的目标数出发，减去比它小的平方数，这样一层一层减下去，直到获得0的那一层的层数就是答案。</p><p>需要过滤掉数值重复的节点，比如11-4和8-1。</p><p>从平方数出发自底向上：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/11/Qsnh3q.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由比已知目标数小的所有平方数出发，每层做一个组合加法，但是有一些地方需要处理：</p><ol><li>遇到数值相等的节点，如1+4和4+1，跳过该节点。</li><li>在组合的时候遇到从一个数开始，加上它就会大于目标数，那么它之后的平方数都可以不做组合了，因为都比它大。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>自顶向下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> depth;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.depth = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mark[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>) <span class="keyword">return</span> n;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Node(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.value==<span class="number">0</span>) <span class="keyword">return</span> node.depth; </span><br><span class="line">            <span class="keyword">int</span> sqrt = (<span class="keyword">int</span>)Math.sqrt(node.value);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = sqrt; i &gt; <span class="number">0</span> ; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[node.value-i*i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Node(node.value-i*i,node.depth+<span class="number">1</span>));</span><br><span class="line">                    mark[node.value-i*i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> depth;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.depth = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> a = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a;i&gt;a/<span class="number">2</span>;i--)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> Node(i*i,<span class="number">1</span>));</span><br><span class="line">            mark[i*i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> value = node.value;</span><br><span class="line">            <span class="keyword">if</span>(value==n) <span class="keyword">return</span> node.depth;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(value+i*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(mark[value+i*i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Node(value+i*i,node.depth+<span class="number">1</span>));</span><br><span class="line">                mark[value+i*i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定正整数 &lt;em&gt;n&lt;/em&gt;，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 &lt;em&gt;n&lt;/em&gt;。你需要让
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>用hexo的live2d插件做了一个可以聊天的小宠物</title>
    <link href="https://www.codetool.top/article/%E7%94%A8hexo%E7%9A%84live2d%E6%8F%92%E4%BB%B6%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%81%8A%E5%A4%A9%E7%9A%84%E5%B0%8F%E5%AE%A0%E7%89%A9/"/>
    <id>https://www.codetool.top/article/用hexo的live2d插件做了一个可以聊天的小宠物/</id>
    <published>2019-12-10T10:49:52.000Z</published>
    <updated>2019-12-10T13:46:31.787Z</updated>
    
    <content type="html"><![CDATA[<p>今天觉得我的博客有点小小的简陋，就做了一点美化工作</p><p>主要使用hexo的live2d插件（感谢作者），搭配上机器人对话api，做了一个可以聊天的小宠物。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/10/QD1vCj.png" alt="效果图" title="">                </div>                <div class="image-caption">效果图</div>            </figure><p>本来是在<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">live2d的github主页</a>上看到了有dialog这个配置选项，一开始以为就是可以配置一个交互式的聊天窗口。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/10/QDwX38.png" alt="dialog配置" title="">                </div>                <div class="image-caption">dialog配置</div>            </figure><p>然后发现使用一言api只是过个几秒钟给你弹一句话看看，也没有其他的api选项可以配置，在百度上一搜好像也没有多少人写过关于这个dialog的用法。</p><p>然后我看了下它生成的源码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/10/QD0I2T.png" alt="组件结构" title="">                </div>                <div class="image-caption">组件结构</div>            </figure><p><code>live2d-widget</code>是整个组件的div，里面有一个<code>live2d-widget-dialog</code>就是卡通形象上面的那个对话框，<code>live2dcanvas</code>就是画卡通形象的画布。如果要让对话框显示文字，就是修改class名为<code>live2d-widget-dialog</code>的div的innerHtml。</p><p>既然没有提供相关的对话api，那就手动做一个吧。</p><h1 id="live2d安装"><a href="#live2d安装" class="headerlink" title="live2d安装"></a>live2d安装</h1><p>你既然看到了这篇文章，我就假设你知道live2d是什么 <del>(看板娘)</del> 。在hexo安装live2d插件的方式很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>然后选一个心仪的模型安装，模型的预览可以参考插件作者的博客：</p><p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a></p><p>模型的名称参考：</p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save 模型名称</span><br></pre></td></tr></table></figure><p>然后在hexo根目录下的<code>_config.yml</code>中配置live2d：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">model:</span> </span><br><span class="line">        <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment">#模型选择</span></span><br><span class="line"><span class="attr">display:</span> </span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span> <span class="comment">#模型位置</span></span><br><span class="line">        <span class="attr">width:</span> <span class="number">200</span>      <span class="comment">#模型宽度</span></span><br><span class="line">        <span class="attr">height:</span> <span class="number">200</span>     <span class="comment">#模型高度</span></span><br><span class="line">        <span class="attr">hOffset:</span> <span class="number">20</span>     <span class="comment">#水平偏移</span></span><br><span class="line">        <span class="attr">vOffset:</span> <span class="number">100</span>    <span class="comment">#垂直偏移</span></span><br><span class="line">    <span class="attr">mobile:</span> </span><br><span class="line">        <span class="attr">show:</span> <span class="literal">false</span>     <span class="comment">#是否在手机端显示</span></span><br><span class="line">    <span class="attr">dialog:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment">#启用对话框</span></span><br><span class="line">        <span class="attr">hitokoto:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>具体的配置可以参考：</p><p><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" rel="noopener">https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</a></p><h1 id="组件改造"><a href="#组件改造" class="headerlink" title="组件改造"></a>组件改造</h1><h2 id="在模型下方增加一个input输入框"><a href="#在模型下方增加一个input输入框" class="headerlink" title="在模型下方增加一个input输入框"></a>在模型下方增加一个input输入框</h2><p>因为我把模型放在了右边，并且水平偏移和垂直偏移都是已知的。<br>要在它的下方增加一个输入框，找到hexo中<code>/themes/你的主题/layout/layout.ejs</code>文件，在里面body标签中末尾添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chat_input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"question"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"陪我聊聊天吧"</span> <span class="attr">onkeypress</span>=<span class="string">"return onKeyPress(event)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在文件尾部配置它的样式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt; </span><br><span class="line"><span class="selector-id">#chat_input</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-id">#question</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: none;<span class="comment">/*取消输入框边框*/</span></span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> <span class="number">#aaaaaa</span> solid;<span class="comment">/*设置下边框*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: transparent;<span class="comment">/*背景透明*/</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*手机端不显示*/</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">480px</span>) &#123;</span><br><span class="line">    <span class="selector-id">#chat_input</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#live2d-widget</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>输入框就做好了。</p><h2 id="聊天逻辑实现"><a href="#聊天逻辑实现" class="headerlink" title="聊天逻辑实现"></a>聊天逻辑实现</h2><p>要做到智能聊天需要一个聊天机器人的api，有图灵机器人、小i机器人等可以选择。</p><p>我这里用的是茉莉机器人，就不推荐大家使用了，小小吐槽一下这个开发者好像不是很懂后端api，鉴权方式有点奇怪 <del>(人间迷惑行为大赏)</del>。</p><p>获取了api之后就可以做输入框的事件处理：（因为我的主题不包含jQuery我也懒得引，就用的原生js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在聊天框按下回车事件处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onKeyPress</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keyCode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(e.which)</span><br><span class="line">        keyCode = e.which;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.keyCode)</span><br><span class="line">        keyCode = e.keyCode;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//如果按下回车</span></span><br><span class="line">    <span class="keyword">if</span>(keyCode == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取输入框中的问题</span></span><br><span class="line">        <span class="keyword">var</span> question_box = <span class="built_in">document</span>.getElementById(<span class="string">'question'</span>)</span><br><span class="line">        <span class="keyword">var</span> question = question_box.value</span><br><span class="line">        <span class="comment">//清空输入框内容并禁用输入框</span></span><br><span class="line">        question_box.value = <span class="string">""</span></span><br><span class="line">        question_box.setAttribute(<span class="string">"disabled"</span>,<span class="string">"disabled"</span>)</span><br><span class="line">        <span class="comment">//不要问我为什么不隐藏这个:）</span></span><br><span class="line">        <span class="keyword">var</span> api_key = <span class="string">"78c33a07808c7b9e1905c89c88b3be14"</span></span><br><span class="line">        <span class="keyword">var</span> api_secret = <span class="string">"q707tevnk00f"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过XHR发送一个GET请求</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>,<span class="string">'http://i.itpk.cn/api.php?question='</span>+<span class="built_in">encodeURIComponent</span>(question)+<span class="string">"&amp;api_key="</span>+api_key+<span class="string">"&amp;api_secret="</span>+api_secret)</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//启用输入框</span></span><br><span class="line">            question_box.removeAttribute(<span class="string">'disabled'</span>);</span><br><span class="line">            <span class="comment">//获取对话框</span></span><br><span class="line">            <span class="keyword">var</span> live2d_dialog = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"live2d-widget-dialog"</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">//显示对话框并把获取到的内容显示在对话框上</span></span><br><span class="line">            live2d_dialog.style.opacity=<span class="number">1</span></span><br><span class="line">            live2d_dialog.innerHTML = <span class="keyword">this</span>.responseText</span><br><span class="line">            <span class="comment">//五秒后隐藏对话框</span></span><br><span class="line">            <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                live2d_dialog.style.opacity=<span class="number">0</span></span><br><span class="line">            &#125;, <span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>一般api都不允许js跨域，需要用自己的服务器代理一下或者做一下中间处理（把认证的东西放自己服务器上）</li><li>我这里没把认证key和secret放自己服务器的原因是。。。这个api看上去就很不安全啊，没必要多此一举。</li><li>一般api用的是POST请求并且需要解析返回的JSON数据，我这里没有大家懂的都懂: )</li></ol><hr><p>20:43补充：</p><p>谁知道我最后还是用了自己的服务器代理😀，因为我发现https网站发送不了http请求。</p><p>嘻嘻，说不定哪天我就换个api用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天觉得我的博客有点小小的简陋，就做了一点美化工作&lt;/p&gt;
&lt;p&gt;主要使用hexo的live2d插件（感谢作者），搭配上机器人对话api，做了一个可以聊天的小宠物。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="网站日志" scheme="https://www.codetool.top/tags/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
      <category term="hexo" scheme="https://www.codetool.top/tags/hexo/"/>
    
      <category term="JavaScript" scheme="https://www.codetool.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
