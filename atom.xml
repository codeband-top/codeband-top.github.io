<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-30T14:08:21.509Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记13</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B013/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记13/</id>
    <published>2020-01-30T08:08:33.000Z</published>
    <updated>2020-01-30T14:08:21.509Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第十三章 Java内存模型与线程</strong>的内容</p><h1 id="线程安全">1 线程安全</h1><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><h2 id="Java语言中的线程安全">1.1 Java语言中的线程安全</h2><p>我们可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h3 id="不可变">1.1.1 不可变</h3><p>不可变的对象一定是线程安全的，“不可变”带来的安全性是最直接、最纯粹的。</p><p>Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。</p><p>String就是一个典型的不可变对象。</p><h3 id="绝对线程安全">1.1.2 绝对线程安全</h3><p>不管运行时环境如何，调用者都不需要任何额外的同步措施，即使在方法调用端。</p><h3 id="相对线程安全">1.1.3 相对线程安全</h3><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安<br>全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><h3 id="线程兼容">1.1.4 线程兼容</h3><p>对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。Java类库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p><h3 id="线程对立">1.1.5 线程对立</h3><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是这个原因，suspend()和resume()方法都已经被声明废弃了。常见的线程对立的操作还有<code>System.setIn()</code>、<code>System.setOut()</code>和<code>System.runFinalizersOnExit()</code>等。</p><h2 id="线程安全的实现方法">1.2 线程安全的实现方法</h2><h3 id="互斥同步">1.2.1 互斥同步</h3><p>互斥同步是一种最常见也是最主要的并发正确性保障手段。<strong>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用</strong>。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p><p>在Java里面，最基本的互斥同步手段就是<code>synchronized</code>关键字，这是一种块结构的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取<strong>代码所在的对象实例</strong>还是取<strong>类型对应的Class对象</strong>来作为线程要持有的锁。</p><p>注意：</p><ul><li>被<code>synchronized</code>修饰的同步块对同一条线程来说是<strong>可重入</strong>的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被<code>synchronized</code>修饰的同步块在持有锁的线程执行完毕并释放锁之前，会<strong>无条件地阻塞后面其他线程的进入</strong>。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p>从执行成本的角度看，持有锁是一个重量级的操作。Java如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。所以说synchronized是Java的一个重量级操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，以避免频繁地切入核心态之中。</p><p>自JDK 5起，Java类库中新提供了<code>java.util.concurrent</code>包，其中的<code>java.util.concurrent.locks.Lock</code>接口便成了Java的另一种全新的互斥同步手段。基于Lock接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。</p><p>重入锁（<code>ReentrantLock</code>）是Lock接口最常见的一种实现，顾名思义，它与synchronized一样是可重入的。在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：</p><ul><li>等待可中断：是指当持有锁的线程长期不释放锁的时候，<strong>正在等待的线程可以选择放弃等待，改为处理其他事情。</strong> 可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁：是指多个线程<strong>在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</strong>；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<strong><code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>在默认情况下也是非公平的</strong>，但可以通过带布尔值的构造函数要求使用公平锁。不过<strong>一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降</strong>，会明显影响吞吐量。</li><li>锁绑定多个条件：是指<strong>一个<code>ReentrantLock</code>对象可以同时绑定多个Condition对象。</strong> 在<code>synchronized</code>中，锁对象的<code>wait()</code>跟它的<code>notify()</code>或者<code>notifyAll()</code>方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而<code>ReentrantLock</code>则无须这样做，多次调用<code>newCondition()</code>方法即可。</li></ul><p>JDK6以后synchronized和ReentrantLock的性能差距已经不大。</p><p>synchronized的优点：</p><ul><li>synchronized是在Java语法层面的同步，足够清晰，也足够简单。每个Java程序员都熟悉 synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐 synchronized。</li><li>Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。</li><li>尽管在JDK 5时代ReentrantLock曾经在性能上领先过synchronized，但这已经是十多年之前的胜利了。从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li></ul><h3 id="非阻塞同步">1.2.2 非阻塞同步</h3><p>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步（Blocking Synchronization）。</p><p>从解决问题的方式上看，<strong>互斥同步属于一种悲观的并发策略</strong>，其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。随着硬件指令集的发展，我们已经有了另外一个选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，<strong>产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</strong>这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为<strong>非阻塞同步</strong>，使用这种措施的代码也常被称为<strong>无锁编程</strong>。</p><p>为了实现乐观并发策略，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap，简称CAS）</li><li>加载链接/条件储存（Load-Linked/Store-Conditional，简称LL/SC）</li></ul><p>CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，<strong>当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。</strong> 但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</p><p>在JDK 5之后，<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供CAS操作。HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。不过由于Unsafe类在设计上就不是提供给用户程序调用的类（Unsafe::getUnsafe()的代码中限制了只有启动类加载器加载的Class才能访问它），因此<strong>在JDK 9之前只有Java类库可以使用CAS</strong>。而如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破Unsafe的访问限制，要么就只能通过Java类库API来间接使用它。直到JDK 9之后，Java类库才在<code>VarHandle</code>类里开放了面向用户程序使用的CAS操作。</p><p>例：（使用AtomicInteger实现原子操作）</p><iframe src="https://run.codetool.top/?id=25" frameborder="0" height="600" style="width:100%;border:1px solid #ccc;"></iframe><p>CAS存在一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，仍有可能是因为在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA问题”。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类<code>AtomicStampedReference</code>，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类处于相当鸡肋的位置，<strong>大部分情况下ABA问题不会影响程序并发的正确性</strong>，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。</p><h3 id="无同步方案">1.2.3 无同步方案</h3><p>有一些代码天生就是线程安全的：</p><ul><li>可重入代码：可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。</li><li>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</li></ul><p>我们可以通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个<code>ThreadLocalMap</code>对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，以本地线程变量为值的K-V值对。</p><h1 id="锁优化">2 锁优化</h1><h2 id="自旋锁与自适应自旋">2.1 自旋锁与自适应自旋</h2><p>现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以<strong>让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</strong>为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋等待的时间有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程，默认值是十次，用户也可以使用参数<code>-XX：PreBlockSpin</code>来自行更改。</p><h2 id="锁消除">2.2 锁消除</h2><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是<strong>对被检测到不可能存在共享数据竞争的锁进行消除。</strong>如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p><h2 id="锁粗化">2.3 锁粗化</h2><p>通常编写代码时推荐将同步块的作用范围限制得尽量小，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会<strong>把加锁同步的范围扩展（粗化）到整个操作序列的外部。</strong></p><h2 id="轻量级锁">2.4 轻量级锁</h2><p>轻量级锁是JDK 6时加入的新型锁机制，“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。它设计的初衷是在<strong>没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p><p>HotSpot虚拟机的对象头分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p><p><img src="https://api.codetool.top/img/15803913861561.png" alt="HotSpot虚拟机对象头Mark Word"></p><p>轻量级锁的工作过程:</p><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将<strong>在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝</strong>（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图:</p><p><img src="https://api.codetool.top/img/1580391784873.png" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p><p>然后，虚拟机将使用CAS操作尝试<strong>把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。</strong>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图所示:</p><p><img src="https://api.codetool.top/img/15803918727169.png" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p><p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。<strong>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁</strong>，锁标志的状态值变为“10”，此时Mark Word中存储的就是<strong>指向重量级锁（互斥量）的指针</strong>，后面等待锁的线程也必须进入阻塞状态。</p><p>轻量级锁的解锁过程同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此<strong>在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</strong></p><h2 id="偏向锁">2.5 偏向锁</h2><p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是<strong>消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。</strong>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。</p><p>偏向锁的意思是这个锁会<strong>偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</strong></p><p>假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p><p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图所示：</p><p><img src="https://api.codetool.top/img/15803928088712.png" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系"></p><p>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</p><p><strong>如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。</strong>在具体问题具体分析的前提下，有时候使用参数<code>-XX：-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第十三章 Java内存模型与线程&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;线程安全&quot;&gt;1 线程安全&lt;/h1&gt;&lt;p&gt;当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode456-132模式</title>
    <link href="https://www.codetool.top/article/leetcode456-132%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.codetool.top/article/leetcode456-132模式/</id>
    <published>2020-01-29T18:19:44.000Z</published>
    <updated>2020-01-29T18:44:21.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数序列：a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>，一个132模式的子序列 a<sub>i</sub>, a<sub>j</sub>, a<sub>k</sub> 被定义为：当 i &lt; j &lt; k 时，a<sub>i</sub> &lt; a<sub>k</sub> &lt; a<sub>j</sub>。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。 </p><p><strong>注意：</strong> n 的值小于15000。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> [1, 2, 3, 4]<br><strong>输出：</strong> False<br><strong>解释：</strong> 序列中不存在132模式的子序列。 </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> [3, 1, 4, 2]<br><strong>输出：</strong> True<br><strong>解释：</strong> 序列中有 1 个132模式的子序列： [1, 4, 2].</p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入：</strong> [-1, 3, 2, 0]<br><strong>输出：</strong> True<br><strong>解释：</strong> 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li><p>暴力，从尾向头遍历，如果当前元素是132中的最后一个元素，则前面和中间一定分别有一个小于当前元素的元素和一个大于当前元素的元素。</p></li><li><p>栈，参考 <a href="https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-2/</a></p></li></ol><h2 id="代码">2.2 代码</h2><ol><li>暴力</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">find132pattern</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> tail <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> hasPeek <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>tail<span class="token punctuation">)</span> hasPeek <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>hasPeek<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>tail<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>栈</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">find132pattern</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> min <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        min<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            min<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> min<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> min<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数序列：a&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;, …, a&lt;sub&gt;n&lt;/sub&gt;，一个132模式的子序列 a&lt;sub&gt;i&lt;/sub&gt;, a&lt;sub&gt;j&lt;/sub&gt;, a&lt;sub&gt;k&lt;/sub&gt; 被定义为
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记12</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B012/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记12/</id>
    <published>2020-01-29T08:25:14.000Z</published>
    <updated>2020-01-29T18:42:57.391Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第十二章 Java内存模型与线程</strong>的内容</p><h1 id="硬件的效率与一致性">1 硬件的效率与一致性</h1><p>基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、<br>Synapse、Firefly及Dragon Protocol等。</p><p>不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且与这里介绍的内存访问操作及硬件的缓存访问操作具有高度的可类比性。</p><h1 id="Java内存模型">2 Java内存模型</h1><h2 id="主内存与工作内存">2.1 主内存与工作内存</h2><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="https://api.codetool.top/img/15802933357430.png" alt="线程、主内存、工作内存三者的交互关系"></p><p>主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。</p><h2 id="内存间交互操作">2.2 内存间交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了以下8种操作来完成。每一种操作都是原子的、不可再分的：</p><ul><li><code>lock</code>（锁定）：作用于主内存的变量，它<strong>把一个变量标识为一条线程独占的状态。</strong></li><li><code>unlock</code>（解锁）：作用于主内存的变量，它<strong>把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</strong></li><li><code>read</code>（读取）：作用于主内存的变量，它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>，以便随后的load动作使用。</li><li><code>load</code>（载入）：作用于工作内存的变量，它<strong>把read操作从主内存中得到的变量值放入工作内存的变量副本中。</strong></li><li><code>use</code>（使用）：作用于工作内存的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><code>assign</code>（赋值）：作用于工作内存的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><code>store</code>（存储）：作用于工作内存的变量，它<strong>把工作内存中一个变量的值传送到主内存中</strong>，以便随后的write操作使用。</li><li><code>write</code>（写入）：作用于主内存的变量，它<strong>把store操作从工作内存中得到的变量的值放入主内存的变量中</strong>。</li></ul><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，相反就要顺序执行store和write操作。可以不连续执行，但必须相对地顺序在执行。</p><p>这些操作必须满足规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或 assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但<strong>lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</strong></li><li>如果<strong>对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</strong></li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li><strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</strong></li></ul><p>最近JSR-133文档中把Java内存模型的操作简化成read、write、lock和unlock四种，但实际设计没有变。</p><h2 id="对于volatile型变量的特殊规则">2.3 对于volatile型变量的特殊规则</h2><p>当一个变量被定义成volatile之后，它将具备两项特性：</p><p>第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</p><p>Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的，示例：</p><iframe src="https://run.codetool.top/?id=24" frameborder="0" height="600" style="width:100%;border:1px solid #ccc;"></iframe><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。</p><p>问题就出在自增运算“race++”之中，反编译这段代码后，发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成。从字节码层面上已经很容易分析出并发失败的原因了：当getstatic指令把 race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以 putstatic指令执行后就可能把较小的race值同步回主内存之中。</p><pre><code>public static void increase();    Code:        Stack=2, Locals=0, Args_size=0        0:   getstatic       #13; //Field race:I        3:   iconst_1        4:   iadd        5:   putstatic       #13; //Field race:I        8:   return    LineNumberTable:        line 14: 0                 line 15: 8</code></pre><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>第二项是禁止指令重排序优化。</p><h2 id="针对long和double型变量的特殊规则">2.4 针对long和double型变量的特殊规则</h2><p>对于64位的数据类型（long和double），允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“long和double的非原子性协定”。</p><p>但是目前主流平台下商用的64位Java虚拟机中并不会出现非原子性访问行为。并且JDK9开始实验性的虚拟机参数<code>-XX：+AlwaysAtomicAccesses</code>要求对所有数据类型进行原子性的访问。</p><h2 id="原子性、可见性与有序性">2.5 原子性、可见性与有序性</h2><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。</p><h3 id="原子性">2.5.1 原子性</h3><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定）</p><p>如果应用场景需要一个更大范围的原子性保证，通常通过synchronized来实现。</p><h3 id="可见性">2.5.2 可见性</h3><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p><p>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。</p><p>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</p><h3 id="有序性">2.5.3 有序性</h3><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p><h2 id="先行发生原则">2.6 先行发生原则</h2><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下操作在线程A中执行 </span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以下操作在线程B中执行 </span>j <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以下操作在线程C中执行 </span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre><p>假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，得出这个结论的依据有两个：一是根据先行发生原则，“i=1”的结果可以被观察到；二是线程C还没登场，线程A操作结束之后没有其他线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而C出现在线程A和B的操作之间，但是C与B没有先行发生关系，那j的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p><ul><li>程序次序规则：<strong>在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</strong>注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则：<strong>一个unlock操作先行发生于后面对同一个锁的lock操作。</strong>这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li><li>volatile变量规则：<strong>对一个volatile变量的写操作先行发生于后面对这个变量的读操作</strong>，这里的“后面”同样是指时间上的先后。</li><li>线程启动规则：Thread对象的<strong>start()方法先行发生于此线程的每一个动作。</strong></li><li>线程终止规则：<strong>线程中的所有操作都先行发生于对此线程的终止检测</strong>，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li><li>线程中断规则：对<strong>线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</strong>，可以通过Thread::interrupted()方法检测到是否有中断发生。</li><li>对象终结规则：一个对象的<strong>初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。</strong></li><li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><h1 id="Java与线程">3 Java与线程</h1><h2 id="线程的实现">3.1 线程的实现</h2><p>目前线程是Java里面进行处理器资源调度的最基本单位，主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过start()方法且还未结束的<code>java.lang.Thread</code>类的实例就代表着一个线程。</p><p>实现线程主要有三种方式：使用内核线程实现（1：1实现），使用用户线程实现（1：N实现），使用用户线程加轻量级进程混合实现（N：M实现）。</p><h3 id="内核线程实现">3.1.1 内核线程实现</h3><p>使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。</p><p><strong>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程</strong>（Light<br>Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1 的关系称为一对一的线程模型。</p><p><img src="https://api.codetool.top/img/15803087252150.png" alt="轻量级进程与内核线程之间1：1的关系"></p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先，<strong>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高</strong>，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p><h3 id="用户线程实现">3.1.2 用户线程实现</h3><p>广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，因此从这个定义上看，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。</p><p>而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型。</p><p><img src="https://api.codetool.top/img/15803088857722.png" alt="进程与用户线程之间1：N的关系"></p><p>用户线程的优势在于不需要系统内核支援，但也正由于不依赖于系统内核，应用程序很难独立实现线程的创建、销毁、切换和调度等操作或者实现起来较为复杂。</p><h3 id="混合实现">3.1.3 混合实现</h3><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N：M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N：M的关系。</p><p><img src="https://api.codetool.top/img/15803090692672.png" alt="用户线程与轻量级进程之间M：N的关系"></p><h3 id="Java线程的实现">3.1.4 Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。从JDK 1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。</p><p>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p><h2 id="Java线程调度">3.2 Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式线程调度和抢占式线程调度。</p><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。譬如在Java中，有Thread::yield()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度。</p><p>虽然说Java线程调度是系统自动完成的，但是我们仍然可以“建议”操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作是通过设置线程优先级来完成的。Java 语言一共设置了10个级别的线程优先级（<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>）。</p><p>不过，线程优先级并不是一项稳定的调节手段，线程调度最终还是由操作系统说了算。如果操作系统原生提供的线程优先级的数量比Java少，就不得不出现几个线程优先级对应到同一个操作系统优先级的情况，例如Windows中就只有七种优先级。</p><h2 id="状态转换">3.3 状态转换</h2><p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：</p><ul><li>新建（New）：创建后尚未启动的线程处于这种状态。</li><li>运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li><li>无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ul><li>没有设置Timeout参数的<code>Thread::join()</code>方法；</li><li><code>LockSupport::park()</code>方法。</li></ul></li><li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul><li><code>Thread::sleep()</code>方法；</li><li>设置了Timeout参数的<code>Object::wait()</code>方法；</li><li>设置了Timeout参数的<code>Thread::join()</code>方法；</li><li><code>LockSupport::parkNanos()</code>方法；</li><li><code>LockSupport::parkUntil()</code>方法。</li></ul></li><li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul><p><img src="https://api.codetool.top/img/15803163309693.png" alt="线程状态转换关系"></p><h1 id="Java与协程">4 Java与协程</h1><h2 id="内核线程的局限">4.1 内核线程的局限</h2><p>今天对Web应用的服务要求，不论是在请求数量上还是在复杂度上，与十多年前相比已不可同日而语，这一方面是源于业务量的增长，另一方面来自于为了应对业务复杂化而不断进行的服务细分。</p><p>Java目前的并发编程机制产生了一些矛盾，1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在<strong>每个请求本身的执行时间变得很短、数量变得很多</strong>的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</p><p>传统的Java Web服务器的线程池的容量通常在几十个到两百之间，当程序员把数以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。</p><h2 id="协程的复苏">4.2 协程的复苏</h2><p>协程采用协同调度，通过应用来模拟多线程，分为有栈协程、无栈协程。</p><p>各种语言中的await、async、yield这类关键字是无栈协程，更轻量，但功能也相对有限。</p><h2 id="Java的解决方案">4.3 Java的解决方案</h2><p>对于<strong>有栈协程</strong>，有一种特例实现名为<strong>纤程（Fiber）</strong>，这个词最早是来自微软公司，后来微软还推出过系统层面的纤程包来方便应用做现场保存、恢复和纤程调度。</p><p>OpenJDK在2018年创建了Loom项目，这是Java用来应对本节开篇所列场景的官方解决方案，根据目前公开的信息，如无意外，日后该项目为Java语言引入的、与现在线程模型平行的新并发编程机制中应该也会采用“纤程”这个名字。</p><p>Loom项目背后的意图是重新提供对用户线程的支持，但与过去的绿色线程不同，这些新功能不是为了取代当前基于操作系统的线程实现，而是会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用。新模型有意地保持了与目前线程模型相似的API设计，它们甚至可以拥有一个共同的基类，这样现有的代码就不需要为了使用纤程而进行过多改动，甚至不需要知道背后采用了哪个并发编程模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第十二章 Java内存模型与线程&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;硬件的效率与一致性&quot;&gt;1 硬件的效率与一致性&lt;/h1&gt;&lt;p&gt;基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode402-移掉K位数字</title>
    <link href="https://www.codetool.top/article/leetcode402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>https://www.codetool.top/article/leetcode402-移掉K位数字/</id>
    <published>2020-01-28T19:44:58.000Z</published>
    <updated>2020-01-28T19:58:35.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p><strong>注意：</strong> </p><ul><li><em>num</em> 的长度小于 10002 且 ≥ <em>k</em>。</li><li><em>num</em> 不会包含任何前导零。</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入: num = “1432219”, k = 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入: num = “10200”, k = 1<br>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。789  </p></blockquote><p><strong>示例 3 :</strong></p><blockquote><p>输入: num = “10”, k = 2<br>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>要在一个长度为length的字符数组中去掉k位，留下一个最小数字，则是要留下一个length-k位的数字，我们每一次都要保证在剩余位数充足的情况下选择最小的数字。</p><p>对于示例一，<code>&quot;1432219&quot;</code>要选出<code>7-3=4</code>位数字，我们可以保留最后三位，在前五位中选出一个最小数字1，然后在剩下的<code>&quot;432219&quot;</code>中选出3位数字，我们可以保留最后两位，在前四位中选出一个最小数字2，然后在剩下的<code>&quot;219&quot;</code>中选出2位数字，我们可以保留最后一位，在前两位中选出一个最小数字1，然后在剩下的<code>&quot;9&quot;</code>中选出1位数字，选取9。</p><p>得到的结果就是<code>&quot;1219&quot;</code></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">removeKdigits</span><span class="token punctuation">(</span>String num<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一次选取数字开始的位置</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> origink <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存结果</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//保留有限位数，选取最小数字</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    min <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            result<span class="token punctuation">[</span>k<span class="token operator">-</span>origink<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>            k<span class="token operator">++</span><span class="token punctuation">;</span>            start <span class="token operator">=</span> min<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            min <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>result<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//去除开头的0</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>result<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token string">"0"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                result <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>i<span class="token punctuation">,</span>result<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;num&lt;/em&gt; 的长度小于 10002 且 ≥ 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode385-迷你语法分析器</title>
    <link href="https://www.codetool.top/article/leetcode385-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode385-迷你语法分析器/</id>
    <published>2020-01-27T18:14:31.000Z</published>
    <updated>2020-01-27T18:37:12.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。</p><p>列表中的每个元素只可能是整数或整数嵌套列表</p><p><strong>提示：</strong> 你可以假定这些字符串都是格式良好的：</p><ul><li>字符串非空</li><li>字符串不包含空格</li><li>字符串只包含数字<code>0-9</code>, <code>[</code>, <code>-</code> ,<code>,</code>, <code>]</code></li></ul><p><strong>示例 1：</strong></p><blockquote><p>给定 s = “324”,</p><p>你应该返回一个 NestedInteger 对象，其中只包含整数值 324。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>给定 s = “[123,[456,[789]]]”,</p><p>返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：</p><p>1. 一个 integer 包含值 123<br>2. 一个包含两个元素的嵌套列表：<br>&nbsp;&nbsp;&nbsp;&nbsp;i.  一个 integer 包含值 456<br>&nbsp;&nbsp;&nbsp;&nbsp;ii. 一个包含一个元素的嵌套列表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. 一个 integer 包含值 789</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设定一个getNest()函数用于返回一个列表类型的NestedInteger。</p><p>相当于每个<code>[</code> <code>]</code>中都代表一次递归函数调用。</p><p>最重要的思想是通过类的全局字符数组和一个下标值让每次调用递归函数都知道要处理哪个位置。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//递归函数通过字符数组和cur下标确定要处理的位置</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> NestedInteger <span class="token function">deserialize</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//本身不是一个集合而是一个整数的情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'['</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用递归函数返回根集合</span>        <span class="token keyword">return</span> <span class="token function">getNest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> NestedInteger <span class="token function">getNest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        NestedInteger nest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//num用于缓存用逗号分割的整数类型的值</span>        <span class="token keyword">boolean</span> negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前记录的整数是不是负数</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">','</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">)</span> nest<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getNest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遇到[递归获取子集合</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nest<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> negative <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//是数字的情况</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>negative<span class="token punctuation">)</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>num <span class="token operator">-</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>num <span class="token operator">+</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果下一个字符是,或者]说明当前数字已经记录完了，需要加入集合中</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">','</span><span class="token operator">||</span>chars<span class="token punctuation">[</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                     nest<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。&lt;/p&gt;
&lt;p&gt;列表中的每个元素只可能是整数或整数嵌套列表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 你可以假定这些字符串都是格式良好的：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记11</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B011/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记11/</id>
    <published>2020-01-27T12:32:40.000Z</published>
    <updated>2020-01-29T08:24:41.480Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第十一章 后端编译与优化</strong>的内容</p><p>把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码可以视为整个编译过程的后端。</p><p>最近几年提前编译也开始兴起，我们在这章把它和即时编译共称为后端编译。</p><h1 id="即时编译器">1 即时编译器</h1><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。</p><h2 id="解释器与编译器">1.1 解释器与编译器</h2><p>目前主流的商用Java虚拟机内部都同时包含解释器与编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。</p><p><img src="https://api.codetool.top/img/15801398731996.png" alt></p><p>HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称<br>为“客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和C2编译器,第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。</p><p>解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”，用户也可以使用参数<code>-Xint</code>强制虚拟机运行于“解释模式”。另外，也可以使用参数<code>-Xcomp</code>强制虚拟机运行于“编译模式”，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p><p>由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot虚拟机在编译子系统中加入了<strong>分层编译</strong>的功能。</p><p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层。程序<strong>纯解释执行</strong>，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层。使用<strong>客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化</strong>，不开启性能监控功能。</li><li>第2层。仍然<strong>使用客户端编译器执行</strong>，仅<strong>开启方法及回边次数统计等有限的性能监控功能。</strong></li><li>第3层。仍然<strong>使用客户端编译器执行，开启全部性能监控</strong>，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层。<strong>使用服务端编译器将字节码编译为本地代码</strong>，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h2 id="编译对象与触发条件">1.2 编译对象与触发条件</h2><p>热点代码：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。</p><p>要知道某段代码是不是热点代码，称为“热点探测”，有两种方法：</p><ul><li>基于采样的热点探测：周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。</li><li>基于计数器的热点探测：为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”，更精确。</li></ul><p>HotSpot使用了第二种方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，一旦溢出，就会触发即时编译。</p><p>方法调用计数器默认阈值在客户端模式下是<code>1500次</code>，在服务端模式下是<code>10000次</code>，这个阈值可以通过虚拟机参数<code>-XX： CompileThreshold</code>来人为设定。</p><p>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是<strong>一段时间之内方法被调用的次数。</strong>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被<strong>减少一半</strong>，这个过程被称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的<strong>半衰周期</strong>，进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX：-UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用<code>-XX：CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><p>回边计数器统计一个方法中循环体代码执行的次数，阈值使用<code>-XX：OnStackReplacePercentage</code>间接设置：</p><ul><li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：<br>CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：<br>OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995。</li><li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：<br>CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700。</li></ul><p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p><h2 id="编译过程">1.3 编译过程</h2><p>在默认条件下，编译的过程中，虚拟机仍然将按照解释方式继续执行代码，编译动作则在后台的编译线程中进行。用户可以通过参数<code>-XX：-BackgroundCompilation</code>来禁止后台编译，后台编译被禁止后，编译的时候将会一直阻塞等待，直到编译过程完成再开始执行代码。</p><p>服务端编译器和客户端编译器的编译过程是有所差别的。对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p><ul><li>在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</li><li>在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</li><li>最后的阶段是在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。</li></ul><p><img src="https://api.codetool.top/img/15802123994639.png" alt="客户端编译器工作流程"></p><p>而服务端编译器则是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度。它会执行大部分经典的优化动作，如：无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除（不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）等。另外，还可能根据解释器或客户端编译器提供的性能监控信息，进行一些不稳定的预测性激进优化，如守护内联、分支频率预测等。</p><h1 id="提前编译器">2 提前编译器</h1><p>Android中的ART（Android Runtime）就是提前编译的。</p><h2 id="提前编译的优劣得失">2.1 提前编译的优劣得失</h2><p>字节膨胀：提前编译的本地二进制码的体积会明显大于字节码的体积。</p><p>动态扩展：提前编译通常要求程序是封闭的，不能在外部动态加载新的字节码。</p><p>提前编译有两种分支：</p><ul><li>做与传统C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作</li><li>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。</li></ul><p>第一条是传统的提前编译应用形式。编译期间需要消耗很多资源和时间用来优化，例如“过程间分析”，将它节省下来给运行能明显提高效率。</p><p>第二条则是给即时编译器做缓存加速，去改善Java程序的启动时间。这种提前编译被称为动态提前编译（Dynamic<br>AOT）或者索性就大大方方地直接叫即时编译缓存（JIT Caching）。</p><p>而<strong>即时编译器的优势</strong>有：</p><ul><li>性能分析制导优化：在解释器或者客户端编译器运行过程中，会不断收集性能监控信息，有助于在运行期动态优化。</li><li>激进预测性优化：提前编译做的优化较为保守，需要考虑程序实际运行的效果不能有差错，而即时编译可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行。</li><li>链接时优化：Java语言天生就是动态链接的，如果要连接的代码在运行前在不同的机器、编译器上进行编译，最后连接可能会出现边界隔阂。</li></ul><h1 id="编译器优化技术">3 编译器优化技术</h1><h2 id="优化技术概览">3.1 优化技术概览</h2><p>参考地址：<a href="https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex</a></p><p><strong>编译器策略</strong></p><ul><li>延迟编译</li><li>分层编译</li><li>栈上替换</li><li>延迟优化</li><li>程序依赖图表示</li><li>静态单赋值表示</li></ul><p><strong>基于性能监控的优化技术</strong></p><ul><li>乐观空值断言</li><li>乐观类型断言</li><li>乐观类型增强</li><li>乐观数组长度加强</li><li>裁剪未被选择的分支</li><li>乐观的多态内联</li><li>分支频率预测</li><li>调用频率预测</li></ul><p><strong>基于证据的优化技术</strong></p><ul><li>精确类型推断</li><li>内存值推断</li><li>内存值跟踪</li><li>常量折叠</li><li>重组</li><li>操作符退化</li><li>空值检查消除</li><li>类型检测退化</li><li>类型检测消除</li><li>代数化简</li><li>公共子表达式消除</li></ul><p><strong>数据流敏感重写</strong></p><ul><li>条件常量传播</li><li>基于流承载的类型缩减转换</li><li>无用代码消除</li></ul><p><strong>语言相关的优化技术</strong></p><ul><li>类型继承关系分析</li><li>去虚拟机化</li><li>符号常量传播</li><li>自动装箱消除</li><li>逃逸分析</li><li>锁消除</li><li>锁膨胀</li><li>消除反射</li></ul><p><strong>内存及代码位置变换</strong></p><ul><li>表达式提升</li><li>表达式下沉 </li><li>冗余存储消除</li><li>相邻存储合并</li><li>交汇点分离</li></ul><p><strong>循环变换</strong></p><ul><li>循环展开</li><li>循环剥离</li><li>安全点消除</li><li>迭代范围分离</li><li>范围检查消除</li><li>循环向量化</li></ul><p><strong>全局代码调整</strong></p><ul><li>内联</li><li>全局代码外提</li><li>基于热度的代码布局</li><li>Switch 调整</li></ul><p><strong>控制流图变换</strong> </p><ul><li>本地代码编排</li><li>本地代码封包</li><li>延迟槽填充</li><li>着色图寄存器分配</li><li>线性扫描寄存器分配</li><li>复写聚合</li><li>常量分裂</li><li>复写移除</li><li>地址模式匹配</li></ul><p>下面介绍四种优化技术：</p><ul><li>最重要的优化技术之一：方法内联。</li><li>最前沿的优化技术之一：逃逸分析。</li><li>语言无关的经典优化技术之一：公共子表达式消除。</li><li>语言相关的经典优化技术之一：数组边界检查消除。</li></ul><h2 id="方法内联">3.2 方法内联</h2><p>内联为除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。</p><p>内联可能会遇到虚方法无法确定的问题。为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为类型继承关系分析（CHA）的技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。这样，编译器在进行内联时，如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为<strong>守护内联</strong>。不过由于后面可能会加载其他类，这属于激进优化。如果在后面的加载过程加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</p><p>假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用<strong>内联缓存</strong>的方式来缩减方法调用的开销。</p><p>这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口<br>之前的缓存，它的工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下<strong>方法接收者的版本信息</strong>，并且每次进行方法调用时都比较接收者的版本。如果以后进来的<strong>每次调用的方法接收者版本都是一样的，那么这时它就是一种单态内联缓存。通过该缓存来调用</strong>，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。但如果真的<strong>出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存，其开销相当于真正查找虚方法表来进行方法分派。</strong></p><h2 id="逃逸分析">3.3 逃逸分析</h2><p>逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p><p>逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。<br>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：</p><ul><li>栈上分配：栈上分配变量可以避免对这个变量进行垃圾回收，从而提高效率，（同时，栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）栈上分配支持方法逃逸，但不能支持线程逃逸。</li><li>标量替换：不能分解的，例如int、long等数值类型及reference类型等称为标量。相对的，可以继续分解称为聚合量，例如Java中的对象。如果把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够<strong>证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。</strong>将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单，但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</li><li>同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定<strong>一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争</strong>，对这个变量实施的同步措施也就可以安全地消除掉。</li></ul><h2 id="公共子表达式消除">3.4 公共子表达式消除</h2><p>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。</p><h2 id="数组边界检查消除">3.5 数组边界检查消除</h2><p>有些代码在编译的时候就可以确定运行的时候数组下标一定不会越界，那么运行时就可以不做检查。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第十一章 后端编译与优化&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码可以视为整个编译过程的后端。&lt;/p&gt;
&lt;p&gt;最近几年提前编译也开始兴起，我们在这章把它和即时编译共称为后端编译
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode341-扁平化嵌套列表迭代器</title>
    <link href="https://www.codetool.top/article/leetcode341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode341-扁平化嵌套列表迭代器/</id>
    <published>2020-01-26T18:18:33.000Z</published>
    <updated>2020-01-26T18:36:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p><p>列表中的项或者为一个整数，或者是另一个列表。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> [[1,1],2,[1,1]]<br><strong>输出:</strong> [1,1,2,1,1]<br><strong>解释:</strong> 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> 14<br><strong>输出:</strong> False<br><strong>解释:</strong> 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>构造通过递归构造，获取元素就是通用迭代器的方法。    </p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIterator</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addViaList</span><span class="token punctuation">(</span>nestedList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViaList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>NestedInteger i<span class="token operator">:</span>nestedList<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">addViaList</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cur<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/p&gt;
&lt;p&gt;列表中的项或者为一个整数，或者是另一个列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode331-验证二叉树的前序序列化</title>
    <link href="https://www.codetool.top/article/leetcode331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://www.codetool.top/article/leetcode331-验证二叉树的前序序列化/</id>
    <published>2020-01-26T15:51:46.000Z</published>
    <updated>2020-01-26T16:14:19.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><pre><code>     _9_    /   \   3     2  / \   / \ 4   1  #  6/ \ / \   / \# # # #   # #</code></pre><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> “9,3,4,#,#,1,#,#,2,#,6,#,#”<br><strong>输出:</strong> true   </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> “1,#”<br><strong>输出:</strong> false  </p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> “9,#,#,1”<br><strong>输出:</strong> false</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>可能导致前序序列化验证失败的情况有：</p><ol><li>null做空节点</li><li>子节点不完全</li></ol><pre><code>  #       1 / \     / \1   2   3</code></pre><p>假设任一状态待填充的节点数为count，第一种情况会导致在某一个时刻count小于0，第二种情况会导致最后count大于0。而这两种情况是不会同时存在的。</p><p>每次遇到一个节点count的值减一，遇到一个非null的节点count的值加二，最后看count是否为0。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidSerialization</span><span class="token punctuation">(</span>String preorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> nodes <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>nodes<span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">-=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> count<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 &lt;code&gt;#&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     _9_
   
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode224-基本计算器</title>
    <link href="https://www.codetool.top/article/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode224-基本计算器/</id>
    <published>2020-01-25T19:07:56.000Z</published>
    <updated>2020-01-25T19:19:58.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式可以包含左括号 <code>(</code> ，右括号 <code>)</code>，加号 <code>+</code> ，减号 <code>-</code>，<strong>非负</strong>整数和空格<code></code> 。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> “1 + 1”<br><strong>输出:</strong> 2  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> “ 2-1 + 2 “<br><strong>输出:</strong> 3</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> “(1+(4+5+2)-3)+(6+8)”<br><strong>输出:</strong> 23</p></blockquote><p><strong>说明：</strong></p><ul><li>你可以假设所给定的表达式都是有效的。</li><li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>操作数栈的思想</p><h2 id="代码">2.2 代码</h2><p>原来以为递归会很取巧，结果遇到了很多细节问题。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> hasNum <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token string">'0'</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hasNum <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>negative<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span> num<span class="token operator">=</span><span class="token punctuation">(</span>num<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> num<span class="token operator">=</span><span class="token punctuation">(</span>num<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    hasNum <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>                    num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>hasNum <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> negative <span class="token operator">=</span> <span class="token operator">!</span>negative<span class="token punctuation">;</span>                    <span class="token keyword">else</span> negative <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    hasNum <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>                    num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lastLeft <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastLeft<span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token operator">+</span>lastLeft<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">calculate</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>lastLeft<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">calculate</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastLeft<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>栈的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> signs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        signs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                signs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                signs<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> signs<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">+</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式的值。&lt;/p&gt;
&lt;p&gt;字符串表达式可以包含左括号 &lt;code&gt;(&lt;/code&gt; ，右括号 &lt;code&gt;)&lt;/code&gt;，加号 &lt;code&gt;+&lt;/code&gt; ，减号 &lt;code&gt;-&lt;/c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记10</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B010/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记10/</id>
    <published>2020-01-25T13:15:55.000Z</published>
    <updated>2020-01-29T18:40:41.513Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第十章 前端编译与优化</strong>的内容</p><p>Java中的编译可能是指：</p><ul><li><strong>前端编译</strong>：把*.java文件转变成*.class文件的过程</li><li><strong>即时编译（JIT）</strong>：运行期把字节码转变成本地机器码的过程</li><li><strong>提前编译（AOT）</strong>：直接把程序编译成与目标机器指令集相关的二进制代码的过程</li></ul><p>这一章讲的是前端编译</p><h1 id="Javac编译器">1 Javac编译器</h1><p>javac是一个由java语言编写的程序</p><h2 id="Javac的源码与调试">1.1 Javac的源码与调试</h2><p>Java6以后，Javac的源码放在了<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code></p><p><strong>Javac的工作流程</strong></p><ol><li>准备过程：初始化插入式注解处理器。</li><li>解析与填充符号表过程，包括：<br>·词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。<br>·填充符号表。产生符号地址和符号信息。 </li><li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li><li>分析与字节码生成过程，包括：<ul><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态运行过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ol><p>执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号。</p><h1 id="Java语法糖的味道">2 Java语法糖的味道</h1><h2 id="泛型">2.1 泛型</h2><h3 id="Java与C-的泛型">2.1.1 Java与C#的泛型</h3><p>Java是 <strong>“类型擦除式泛型”</strong>，C#是 <strong>“具现化式泛型”</strong>。</p><p>Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型，并且在相应的地方插入了强制转型代码。</p><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于C#的具现化式泛型，而它的唯一优势是在于实现这种泛型的影响范围上。</p><p>Java选择类型擦除主要是因为遗留代码多，向前兼容。</p><h3 id="类型擦除">2.1.2 类型擦除</h3><p>实现：泛型类原地泛型化变成裸类型</p><p>Java是简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在元素访问、修改时自动插入一些强制类型转换和检查指令。</p><p><strong>类型擦除的缺陷：</strong></p><ol><li>不支持基本类型，例如<code>ArrayList&lt;int&gt;</code>，因为无法实现int和Object互转，只能自动装箱、拆箱使用Integer，导致执行效率低。</li><li>运行期无法取到泛型类型信息，导致不能出现下列操作：<ul><li><code>if (item instanceof E) {   // 不合法，无法对泛型进行实例判断</code></li><li><code>E newItem = new E();       // 不合法，无法使用泛型创建对象</code></li><li><code>E[] itemArray = new E[10]; // 不合法，无法使用泛型创建数组</code></li></ul></li><li>方法重载即使是不同泛型类型的参数也不能作为不一样的特征签名。但是返回值类型不同实际是可以正常运行的，虽然特征签名还是一致，但class文件支持不同描述符的方法共存，后续JVM有优化。</li></ol><h3 id="值类型和未来的泛型">2.1.3 值类型和未来的泛型</h3><p>在2014年，刚好是Java泛型出现的十年之后，Oracle建立了一个名为Valhalla的语言改进项目，希望改进Java语言留下的各种缺陷（解决泛型的缺陷就是项目主要目标其中之一）。</p><p>在Valhalla项目中规划了几种不同的新泛型实现方案，在这些新的泛型设计中，泛型类型有可能被具现化，也有可能继续维持类型擦除以保持兼容（取决于采用哪种实现方案），即使是继续采用类型擦除的方案，泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用，也可以指定编译器默认要擦除哪些类型。相对于使用不同方式实现泛型，<strong>目前比较明确的是未来的Java应该会提供“值类型”（Value Type）的语言层面的支持。</strong></p><p>值类型可以与引用类型一样，具有构造函数、方法或是属性字段，等等，而它与引用类型的区别在于它<strong>在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的。</strong>更为关键的是，值类型的实例很容易实现分配在方法的调用栈上的，这意味着<strong>值类型会随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</strong></p><p>在Valhalla项目中，Java的值类型方案被称为“内联类型”，计划通过一个新的关键字inline来定义。</p><h2 id="条件编译">2.2 条件编译</h2><p>使用条件为常量的if语句，可以在编译期间过滤掉一些代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>反编译的结果</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="可变参数">2.3 可变参数</h2><p><code>public void foo(String... args){}</code></p><p>=&gt; <code>public void foo(String[] args){}</code></p><h2 id="switch-字符串和switch-enum">2.4 switch-字符串和switch-enum</h2><h3 id="switch-字符串">2.4.1 switch-字符串</h3><p>配合字符串的哈希值使用。</p><pre class=" language-java"><code class="language-java">String i <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"hello"</span><span class="token operator">:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">"world"</span><span class="token operator">:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>反编译后</p><pre class=" language-java"><code class="language-java">String i <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token keyword">byte</span> var3 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">99162322</span><span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">113318802</span><span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">switch</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="switch-enum">2.4.2 switch-enum</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Sex<span class="token punctuation">{</span>    MALE<span class="token punctuation">,</span>FEMALE<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Sex sex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">case</span> MALE<span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> FEMALE<span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>反编译后</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* *定义一个合成类（仅jvm使用，对我们不可见） *用来映射枚举的ordina1与数组元素的关系 *枚举的ordinal表示枚举对象的序号，从0开始 *即MALE的ordinal()=0，FEMALE的ordinal()=1 */</span><span class="token keyword">static</span> <span class="token keyword">class</span> $MAP<span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//数组大小即为枚举元素个数，里面存储case用来对比的数字 </span>    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">static</span><span class="token punctuation">{</span>         map<span class="token punctuation">[</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>         map<span class="token punctuation">[</span>Sex<span class="token punctuation">.</span>FEMALE<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Sex sex<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> x <span class="token operator">=</span> $MAP<span class="token punctuation">.</span>map<span class="token punctuation">[</span>sex<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">switch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span>）<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span>）<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="枚举">2.5 枚举</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Sex<span class="token punctuation">{</span>    MALE<span class="token punctuation">,</span>FEMALE<span class="token punctuation">}</span></code></pre><p>实际上是编译成了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sex</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>Sex<span class="token operator">></span><span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex MALE<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex FEMALE<span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex<span class="token punctuation">[</span><span class="token punctuation">]</span> $VALUES<span class="token punctuation">;</span>    <span class="token keyword">static</span><span class="token punctuation">{</span>         MALE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"MALE"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         FEMALE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"FEMALE"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         $VALUES <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>MALE<span class="token punctuation">,</span>FEMALE<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Sex</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> ordinal<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>ordinal<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Sex<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> $VALUES<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Sex <span class="token function">valueOf</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> Enum<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>Sex<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="try-with-resources">2.6 try-with-resources</h2><p>JDK7开始新增了对需要关闭的资源处理的特殊语法<code>try-with-resources</code>:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>资源变量<span class="token operator">=</span>创建资源对象<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>其中资源对象需要实现<code>Autocloseable</code>接口，例如<code>InputStream、OutputStream、Connection、Statement、Resultset</code>等接口都实现了<code>Autocloseable</code>，使用<code>try-with-resources</code>可以不用写finally语句块，编译器会帮助生成关闭资源代码，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">try</span><span class="token punctuation">(</span>InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"d:\\1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span><span class="token punctuation">{</span>         e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> </code></pre><p>反编译后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"d:\\1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Throwable var2 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var12<span class="token punctuation">)</span> <span class="token punctuation">{</span>        var2 <span class="token operator">=</span> var12<span class="token punctuation">;</span>        <span class="token keyword">throw</span> var12<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var11<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    var2<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>var11<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var14<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var14<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第十章 前端编译与优化&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;Java中的编译可能是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端编译&lt;/strong&gt;：把*.java文件转变成*.class文件的过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时编译
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode103-二叉树的锯齿形层次遍历</title>
    <link href="https://www.codetool.top/article/leetcode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode103-二叉树的锯齿形层次遍历/</id>
    <published>2020-01-24T18:52:24.000Z</published>
    <updated>2020-01-24T19:04:58.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;/ \<br>&nbsp;&nbsp;9&nbsp;&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;7  </p></blockquote><p>返回锯齿形层次遍历如下：</p><blockquote><p>[<br>&nbsp;&nbsp;[3],<br>&nbsp;&nbsp;[20,9],<br>&nbsp;&nbsp;[15,7]<br>]  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>用两个栈来交替存储某一层和下一层的节点:</p><p>读取第一个栈的时候，从左向右的读取节点，将它们的子节点从左向右入第二个栈，能使读取第二个栈的时候是以从右向左的顺序出栈的。</p><p>读取第二个栈的时候，从右向左的读取节点，将它们的子节点从右向左入第一个栈，能使读取第一个栈的时候是以从左向右的顺序出栈的。</p><p>这样交替使用两个栈，可以实现两层之间的顺序反转。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当前层的节点按从左向右的顺序依次出栈，子节点按从左向右的顺序入second栈，实现顺序逆转</span>            cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> second<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> second<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下一层的节点按从右向左的顺序依次出栈，子节点按从右向左的顺序入first栈，实现顺序逆转</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> second<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/cod
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>愿广大国人都能平安度过这个春节</title>
    <link href="https://www.codetool.top/article/%E6%84%BF%E5%B9%BF%E5%A4%A7%E5%9B%BD%E4%BA%BA%E9%83%BD%E8%83%BD%E5%B9%B3%E5%AE%89%E5%BA%A6%E8%BF%87%E8%BF%99%E4%B8%AA%E6%98%A5%E8%8A%82/"/>
    <id>https://www.codetool.top/article/愿广大国人都能平安度过这个春节/</id>
    <published>2020-01-24T16:30:44.000Z</published>
    <updated>2020-01-24T16:51:20.114Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2020年1月25日，农历正月初一，是咱们国家的传统佳节——春节。我一直觉得春节是中国很重要的一个文化符号，我相信对于所有华人来说，春节的特殊性已经融于血液之中，是不可替代的节日。我在这里恭祝所有华人新年快乐，鼠年大吉。</p><p>同时我也希望，大家应时刻把自己的健康安全放在第一位，在2019-nCoV（武汉肺炎）肆虐之际，要时刻注意清洁卫生，出门戴好口罩，这段时间尽量避免和别人接触。</p><p>截至目前，大多数省级行政区都启动了突发公共卫生事件一级响应，这件事的重要程度不言而喻，我也有在持续关注疫情的动态。我相信只要大家齐心协力，我们一定能打好这场攻坚战，我们也不用太过恐慌，保护好自己就是最重要的。</p><p>目前已经可以看到很多市民的防范意识都有提高，我觉得我们现在做的一切都在步入正轨。</p><p>希望这个春节所有人都平平安安！武汉加油！中国加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是2020年1月25日，农历正月初一，是咱们国家的传统佳节——春节。我一直觉得春节是中国很重要的一个文化符号，我相信对于所有华人来说，春节的特殊性已经融于血液之中，是不可替代的节日。我在这里恭祝所有华人新年快乐，鼠年大吉。&lt;/p&gt;
&lt;p&gt;同时我也希望，大家应时刻把自己的
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode85-最大矩形</title>
    <link href="https://www.codetool.top/article/leetcode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode85-最大矩形/</id>
    <published>2020-01-24T05:19:04.000Z</published>
    <updated>2020-01-24T05:53:01.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong><br>[<br>&nbsp;&nbsp;[“1”,”0”,”1”,”0”,”0”],<br>&nbsp;&nbsp;[“1”,”0”,”1”,”1”,”1”],<br>&nbsp;&nbsp;[“1”,”1”,”1”,”1”,”1”],<br>&nbsp;&nbsp;[“1”,”0”,”0”,”1”,”0”]<br>]<br><strong>输出:</strong> 6  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题可以分解成若干<a href="../leetcode84-柱状图中最大的矩形/">leetcode84-柱状图中最大的矩形</a>的子问题，可以使用相同的方法。</p><p>我们从上往下动态规划二维数组，每增加一行就会出现不同的柱状区域。</p><p><img src="https://api.codetool.top/img/15798449822257.png" alt></p><p>从每一次得到的最大矩形面积中获取最大值，就是该题的答案</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> line<span class="token operator">:</span>matrix<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//每增加一行改变height数组</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span><span class="token punctuation">)</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max<span class="token operator">=</span>area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt;&lt;br
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode84-柱状图中最大的矩形</title>
    <link href="https://www.codetool.top/article/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode84-柱状图中最大的矩形/</id>
    <published>2020-01-23T19:01:50.000Z</published>
    <updated>2020-01-23T19:12:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://api.codetool.top/img/15798062014581.png" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://api.codetool.top/img/15798062338069.png" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [2,1,5,6,2,3]<br><strong>输出：</strong> 10</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode42-接雨水/">leetcode42-接雨水</a>较为相似。</p><p>对于每列来说，以当前列高为高的最大矩形区域的宽度区域为被左边最近较矮一列和右边最近较矮一列围起来的宽度。</p><p>如果两边有一边没有比当前列矮的一列，则左边算作-1，右边算作length。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.to
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记09</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B009/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记09/</id>
    <published>2020-01-23T13:14:13.000Z</published>
    <updated>2020-01-25T13:15:49.781Z</updated>
    
    <content type="html"><![CDATA[<p>续<a href="../深入理解java虚拟机第三版读书笔记08">深入理解java虚拟机第三版读书笔记08</a></p><h1 id="类加载器">1 类加载器</h1><p><strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>称为类加载器。类加载器可以用户自定义，是java语言流行的一项原因</p><h2 id="类与类加载器">1.1 类与类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>或者说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><h2 id="双亲委派模型">1.2 双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap<br>ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p><p>自JDK 1.2以来，Java一直保持着<strong>三层类加载器、双亲委派的类加载架构。</strong></p><p>对于JDK8及之前版本的Java，绝大多数程序都会使用到以下3个系统提供的类加载器来进行加载</p><ul><li>启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在 <code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</li><li>扩展类加载器（Extension Class Loader）：这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application Class Loader）：这个类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是<strong>程序中默认的类加载器</strong>。</li></ul><p><img src="https://api.codetool.top/img/15797991285820.png" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。（子加载器将部分动作委派给父加载器）</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有<strong>当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><p>好处是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类<code>java.lang.Object</code>都是交给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>实现双亲委派模型的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，检查请求的类是否已经被加载过了</span>    Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//代表找到了启动类加载器</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>            <span class="token comment" spellcheck="true">// 说明父类加载器无法完成加载请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时</span>            <span class="token comment" spellcheck="true">// 再调用本身的findClass方法来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//findClass实现加载过程</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="破坏双亲委派模型">1.3 破坏双亲委派模型</h2><p><strong>为什么要破坏双亲委派模型？</strong></p><ol><li><p>如果基础类型要调用回用户的代码。</p><p> 实例：</p><ul><li><p>启动类加载器加载的DriverManager在<code>loadInitialDriver()</code>加载<code>com.mysql.jdbc.Driver</code>应用程序类</p></li><li><p>JNDI服务对资源进行查找和集中管理，可以通过接口名获取所有实现类，需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。</p></li></ul></li><li><p>JDK9的模块化实现热部署。</p></li></ol><p><strong>解决方案：</strong></p><p>线程上下文类加载器（Thread Context ClassLoader）。<br>这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，<br>如果创建线程时还未设置，它将会从父线程中继承一个，<br>如果在应用程序的全局范围内都没有设置过的话，那<strong>这个类加载器默认就是应用程序类加载器。</strong></p><p>使用<code>Class.forName(String name, boolean initialize,ClassLoader loader)</code>方法使用指定的类加载器加载类。</p><h2 id="自定义类加载器">1.4 自定义类加载器</h2><ol><li>继承ClassLoader父类</li><li>要遵从双亲委派模型，重写findClass方法。</li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用该类加载器的loadClass方法</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        String path <span class="token operator">=</span> <span class="token string">"e:\\mypath\\"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ByteArrayOutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Files<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="补充">1.5 补充</h2><ul><li><code>Class.getClassLoader()</code>可以获取一个类的加载器，启动类加载器是null</li><li><code>-Xbootclasspath/a:&lt;追加路径&gt;</code>可以在<code>JAVA_HOME/lib</code>的基础上追加路径让启动类加载器加载。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;续&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记08&quot;&gt;深入理解java虚拟机第三版读书笔记08&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;类加载器&quot;&gt;1 类加载器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;通过一个类的全限定名来获取描述该类的二进制字节流&lt;/strong&gt;称为类加
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码实例探究</title>
    <link href="https://www.codetool.top/article/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.codetool.top/article/Java字节码实例探究/</id>
    <published>2020-01-23T10:22:05.000Z</published>
    <updated>2020-01-23T13:11:56.515Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a>中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。</p><p>java源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">40000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个类有方法有实例变量有静态变量，在JDK8环境下编译后的字节码开头部分如下图：</p><p><img src="https://api.codetool.top/img/15797791725139.png" alt="该文件开头部分"></p><p>我们来逐字节分析：</p><h1 id="魔数、次版本号、主版本号">1 魔数、次版本号、主版本号</h1><p>00~03：<code>CA FE BA BE</code>，魔数。</p><p>04~05：<code>00 00</code> Minor Version，次版本号<br>06~07：<code>00 34</code> 十进制52，Major Version，主版本号，两者对应JDK8</p><h1 id="常量池">2 常量池</h1><p>08~09：<code>00 2F</code> 十进制47，代表常量池内项的数量。</p><p>10开始为常量池中的各表：</p><p><strong>#1</strong><br>0A：<code>0A</code> 十进制10，代表<code>CONSTANT_Methodref_info</code>类型，<br>0B~0E：<code>00 0A 00 1E</code> #10，#30</p><p><strong>#2</strong><br>0F：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>10~13：<code>00 09 00 1F</code> #9，#31</p><p><strong>#3</strong><br>14：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>15~18：<code>00 20 00 21</code> #32，#33</p><p><strong>#4</strong><br>19：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>1A~1D：<code>00 09 00 22</code> #9，#34</p><p><strong>#5</strong><br>1E：<code>0A</code> 十进制9，代表<code>CONSTANT_Methodref_info</code>类型，<br>1F~22：<code>00 23 00 24</code> #35，#36</p><p><strong>#6</strong><br>1E：<code>03</code> 十进制3，代表<code>CONSTANT_Integer_info</code>类型，<br>15~18：<code>00 00 9C 40</code> 40000</p><p><strong>#7</strong><br>28：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>29~2C：<code>00 09 00 25</code> #9，#37</p><p><strong>#8</strong><br>2D：<code>08</code> 十进制8，代表<code>CONSTANT_String_info</code>类型，<br>2E~2F：<code>00 26</code> #38</p><p><strong>#9</strong><br>30：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>31~32：<code>00 27</code> #39</p><p><strong>#10</strong><br>33：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>34~35：<code>00 28</code> #40</p><p><strong>#11</strong><br>36：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>37~38：<code>00 01</code>代表长度为1，39：<code>69</code> 代表字符<code>&#39;i&#39;</code></p><p><strong>#12</strong><br>3A：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>3B~3C：<code>00 01</code>代表长度为1，3D：<code>49</code> 代表字符<code>&#39;I&#39;</code></p><p>剩余常量池的项我们用javap得到（其实累了）：</p><pre><code>#13 = Utf8               j#14 = Utf8               str#15 = Utf8               Ljava/lang/String;#16 = Utf8               &lt;init&gt;#17 = Utf8               ()V#18 = Utf8               Code#19 = Utf8               LineNumberTable#20 = Utf8               LocalVariableTable#21 = Utf8               this#22 = Utf8               LMain;#23 = Utf8               main#24 = Utf8               ([Ljava/lang/String;)V#25 = Utf8               args#26 = Utf8               [Ljava/lang/String;#27 = Utf8               &lt;clinit&gt;#28 = Utf8               SourceFile#29 = Utf8               Main.java#30 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V#31 = NameAndType        #11:#12        // i:I#32 = Class              #41            // java/lang/System#33 = NameAndType        #42:#43        // out:Ljava/io/PrintStream;#34 = NameAndType        #14:#15        // str:Ljava/lang/String;#35 = Class              #44            // java/io/PrintStream#36 = NameAndType        #45:#46        // println:(Ljava/lang/String;)V#37 = NameAndType        #13:#12        // j:I#38 = Utf8               Hello World!#39 = Utf8               Main#40 = Utf8               java/lang/Object#41 = Utf8               java/lang/System#42 = Utf8               out#43 = Utf8               Ljava/io/PrintStream;#44 = Utf8               java/io/PrintStream#45 = Utf8               println#46 = Utf8               (Ljava/lang/String;)V</code></pre><h1 id="访问标志、类索引、父类索引、接口索引集合">3 访问标志、类索引、父类索引、接口索引集合</h1><p>跳过常量池，到了<strong>访问标志：</strong></p><p>01C1~01C2：<code>00 21</code>，代表<code>ACC_SUPER</code>（0x0020）和<code>ACC_PUBLIC</code>（0x0001）。</p><p>接着是<strong>类索引：</strong></p><p>01C3~01C4：<code>00 09</code> 代表常量池中#9，#9又指向#39，可以得知是Main，即类名</p><p><strong>父类索引：</strong></p><p>01C5~01C6：<code>00 0A</code> 代表常量池中#10，#10又指向#40，可以得知是<code>java/lang/Object</code></p><p><strong>接口索引集合：</strong></p><p>01C7~01D8：<code>00 00</code> 代表接口索引集合中没有数据，长度是0</p><h1 id="字段表集合">4 字段表集合</h1><p>01C9~01CA: <code>00 03</code> 十进制3，代表字段表中有三项数据：</p><p>第一个字段：</p><p>01CB~01CC: <code>00 02</code> ，访问标志，代表<code>ACC_PRIVATE</code>（0x0002）<br>01CD~01CE：<code>00 0B</code> ，name_index，指向常量池#11，#11代表<code>&#39;i&#39;</code><br>01CF~01D0：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D1~01D2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第二个字段：</p><p>01D3~01D4: <code>00 0A</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PRIVATE</code>（0x0002）<br>01D5~01D6：<code>00 0D</code> ，name_index，指向常量池#13，#13代表<code>&#39;j&#39;</code><br>01D7~01D8：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D9~01DA：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第三个字段：</p><p>01DB~01DC: <code>00 09</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PUBLIC</code>（0x0001）<br>01DD~01DE：<code>00 0E</code> ，name_index，指向常量池#14，#14代表<code>&quot;str&quot;</code><br>01DF~01E0：<code>00 0F</code> , discriptor_index，指向常量池#15，#15代表<code>&quot;Ljava/lang/String;&quot;</code>（即String类型）<br>01E1~01E2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><h1 id="方法表集合">5 方法表集合</h1><p>01E3~01E4：<code>00 03</code> ，十进制3，代表方法表中有三项数据：</p><p><strong>第一个方法：</strong></p><p>01E5~01E6: <code>00 01</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）<br>01E7~01E8：<code>00 10</code> ，name_index，指向常量池#16，#16代表<code>&quot;&lt;init&gt;&quot;</code>（即对象构造器）<br>01E9~01EA：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参、无返回值）<br>01EB~01EC：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>01ED~01EE: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>01EF~01F2：<code>00 00 00 39</code>，代表Code内容长度为57个字节。</p><p>接下来57个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>01F3~022B</p><pre><code>Code:stack=2, locals=1, args_size=1    0: aload_0    1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V    4: aload_0    5: bipush        10    7: putfield      #2                  // Field i:I    10: returnLineNumberTable:    line 7: 0    line 8: 4LocalVariableTable:    Start  Length   Slot    Name    Signature    0      11       0       this    LMain;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>aload_0      </p></blockquote><p>将局部变量表slot 0加载到操作数栈，那么局部变量表slot 0原来存放的是什么呢？非静态方法局部变量表0位置一开始都是存放的this，即调用方法的当前对象。这句话就是把this入操作数栈。</p><blockquote><p>invokespecial #1</p></blockquote><p>this调用#1代表的方法，我们查常量表#1，#1又指向#10和#30，#10指向#40，是<code>java/lang/Object</code>，#30是<code>&quot;&lt;init&gt;&quot;:()V</code>，即调用父类Object的构造方法。</p><blockquote><p>aload_0</p></blockquote><p>再次加载this</p><blockquote><p>bipush 10</p></blockquote><p>将常量10压入操作数栈。</p><blockquote><p>putfield #2</p></blockquote><p>putfield是设置对象的字段值，通过查常量表，#2代表<code>Main</code>中的<code>i:I</code>，这句话就把栈里的两个操作数：<code>10</code>设置给<code>this.i</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第二个方法：</strong></p><p>022C~022D: <code>00 09</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）和<code>ACC_STATIC</code>（0x0008）<br>022E~022F：<code>00 17</code> ，name_index，指向常量池#23，#23代表<code>&quot;main&quot;</code><br>0230~0231：<code>00 18</code> , discriptor_index，指向常量池#24，#24代表<code>&quot;([Ljava/lang/String;)V&quot;</code>（即参数为String数组、无返回值）<br>0232~0233：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>0234~0235: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>0236~0239：<code>00 00 00 38</code>，代表Code内容长度为56个字节。</p><p>接下来56个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>023A~0271</p><pre><code>Code:stack=2, locals=1, args_size=1    0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;    3: getstatic     #4                  // Field str:Ljava/lang/String;    6: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V    9: returnLineNumberTable:    line 12: 0    line 13: 9LocalVariableTable:    Start  Length  Slot  Name   Signature        0      10     0  args   [Ljava/lang/String;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>getstatic #3      </p></blockquote><p>获取一个类的静态字段，通过查常量表可知#3是<code>java/lang/System</code>的<code>out:Ljava/io/PrintStream;</code>即获取<code>System.out</code></p><blockquote><p>getstatic #4</p></blockquote><p>获取一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>即获取str字段。</p><blockquote><p>invokevirtual #5</p></blockquote><p>调用#5方法，通过查常量表可知#5是<code>java/io/PrintStream</code>的<code>println:(Ljava/lang/String;)V</code>，即在操作栈的基础上调用<code>System.out.println(str)</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第三个方法：</strong></p><p>0272~0273: <code>00 08</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）<br>0274~0275：<code>00 1B</code> ，name_index，指向常量池#27，#27代表<code>&quot;&lt;clinit&gt;&quot;</code>（即类构造器）<br>0276~0277：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参无返回值）<br>0278~0279：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>027A~027B: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>027C~027F：<code>00 00 00 27</code>，代表Code内容长度为39个字节。</p><p>接下来39个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>0280~02A6</p><pre><code>Code:stack=1, locals=0, args_size=0    0: ldc           #6                  // int 40000    2: putstatic     #7                  // Field j:I    5: ldc           #8                  // String Hello World!    7: putstatic     #4                  // Field str:Ljava/lang/String;    10: returnLineNumberTable:    line 9: 0    line 10: 5</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>ldc #6     </p></blockquote><p>把一个常量#6加载到操作数栈，通过查常量表可知#6是40000。</p><blockquote><p>putstatic #7</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#7是<code>Main</code>的<code>j:I</code>，即设置j的值为40000。（注意这里与第一个方法不同的是，设置小于等于short最大值的值的时候常数放在字节码中，而大于short最大值的常量放在常量表中）</p><blockquote><p>ldc #8</p></blockquote><p>把一个常量#8加载到操作数栈，通过查常量表可知#8是<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>putstatic #4</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>，即将str的值设置为<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>return</p></blockquote><p>返回</p><h1 id="属性表">6 属性表</h1><p>02A7~02A8：<code>00 01</code> attributes_count，代表属性表中有一项数据<br>02A9~02AA：<code>00 1C</code> attribute_name_index，指向常量池#28，#28代表<code>&quot;SourceFile&quot;</code>（记录源文件名称）<br>02AB~02AE: <code>00 00 00 02</code> 代表属性内容长度为2个字节。<br>02AF~02B0: <code>00 1D</code> 代表属性的值，指向常量池#29，#29代表<code>&quot;Main.java&quot;</code>  </p><p>到此，该class文件的字节码全部分析完</p><p><img src="https://api.codetool.top/img/15797822431714.png" alt="该文件结尾部分"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记06&quot;&gt;深入理解java虚拟机第三版读书笔记06&lt;/a&gt;中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。&lt;/p&gt;
&lt;p&gt;java源码：&lt;/p&gt;
&lt;pre class=&quot; language
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="Class文件" scheme="https://www.codetool.top/tags/Class%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode71-简化路径</title>
    <link href="https://www.codetool.top/article/leetcode71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.codetool.top/article/leetcode71-简化路径/</id>
    <published>2020-01-23T06:40:01.000Z</published>
    <updated>2020-01-23T07:10:01.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> “/home/“<br><strong>输出：</strong> “/home”<br><strong>解释：</strong> 注意，最后一个目录名后面没有斜杠。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> “/../“<br><strong>输出：</strong> “/“<br><strong>解释：</strong> 从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> “/home//foo/“<br><strong>输出：</strong> “/home/foo”<br><strong>解释：</strong> 在规范路径中，多个连续斜杠需要用一个斜杠替换。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> “/a/./b/../../c/“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong> “/a/../../b/../c//.//“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 6：</strong></p><blockquote><p><strong>输入：</strong> “/a//b////c/d//././/..”<br><strong>输出：</strong> “/a/b/c”  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用栈的思想来解决该问题，将给定的字符串使用<code>&quot;/&quot;</code>分割，会得到由空字符串、<code>&quot;.&quot;</code>、<code>&quot;..&quot;</code>、目录名组成的字符串数组，然后根据它们的特点对元素进行入栈出栈等操作。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">simplifyPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//因为最后要遍历栈，这里用ArrayList来模拟栈</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>dirs<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//空字符串和"."都表示当前目录</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">||</span> i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//".."表示上一级目录，出栈一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>                     stack<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//其他目录名入栈</span>            <span class="token keyword">else</span> stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过"/"连接起来</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>stack<span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;以 Unix 风格给出一个文件的&lt;strong&gt;绝对路径&lt;/strong&gt;，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（&lt;code&gt;.&lt;/code&gt;）表示当前目录本身；此外
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42-接雨水</title>
    <link href="https://www.codetool.top/article/leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://www.codetool.top/article/leetcode42-接雨水/</id>
    <published>2020-01-22T17:09:42.000Z</published>
    <updated>2020-01-22T17:39:56.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://api.codetool.top/img/15797131314307.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong> 6</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一列能存下的雨水单位等于<code>左右最高两列当中的较矮一列与当前高度的高度差</code>。</p><p><img src="https://api.codetool.top/img/15797135878580.png" alt></p><p>如图，第五列的积雨水量，等于左边最高一列（第四列left）和右边最高一列（第八列right）的较矮一列（left）与当前列高度的高度差（2-1=1）</p><p>如果两边有一边没有比当前列高的列，则当前列不会积水。</p><h2 id="代码">2.2 代码</h2><p>我一开始是这样写的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新左边所有列的right</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新右边所有列的left</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null <span class="token operator">||</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>时间复杂度达到了N<sup>2</sup>级别，那么如何优化呢？</p><ol><li>不必使用null来表示没有比当前列高的列，即使两列相等，高度差也是0，相当于不积水。</li><li>利用动态规划的思想，如果前一列的left比当前列高，则当前列的left也等于前一列的left。对于right也是一样的。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从左向右更新left</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从右向左更新right</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15797131314307.png&quot; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode95-不同的二叉搜索树II</title>
    <link href="https://www.codetool.top/article/leetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://www.codetool.top/article/leetcode95-不同的二叉搜索树II/</id>
    <published>2020-01-22T15:12:01.000Z</published>
    <updated>2020-01-22T15:20:18.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong><br>[<br>&nbsp;&nbsp;[1,null,3,2],<br>&nbsp;&nbsp;[3,2,null,1],<br>&nbsp;&nbsp;[3,1,null,null,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[1,null,2,null,3]<br>]<br><strong>解释:</strong><br>以上的输出对应以下 5 种不同结构的二叉搜索树：<br>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题的思想和<a href="../leetcode96-不同的二叉搜索树">leetcode96-不同的二叉搜索树</a>类似，通过各种左右组合情况得到为一个list返回。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">></span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含null的list使得for嵌套能正常工作</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含本数字的list</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自由组合左子树和右子树的情况</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode left<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode right<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96-不同的二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode96-不同的二叉搜索树/</id>
    <published>2020-01-22T14:15:52.000Z</published>
    <updated>2020-01-22T15:16:07.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:  </p><p>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于每一个n对应的数量应该是相同的，我们从1~n中任选一个做根节点（假设是第i个），那么左右两边各有<code>F(i-1)</code>和<code>F(n-i)</code>中情况，将它们相乘就是此时第i个元素做根节点的情况。如此递归计算总数量。</p><h2 id="代码">2.2 代码</h2><p>我一开始的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是发现这样写消耗非常多时间，leetcode执行用时<code>1700 ms</code>。</p><p>优化的思路主要是：</p><ol><li>end和start并不关键，只要start-end（即范围内的数字数量,用n表示）相同，对应的值就相同。</li><li>假如优化上条，很多<code>F(n)</code>单元会被重复计算，可以使用数组做缓存。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
