<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-04-23T06:05:18.281Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm安装node-sass速度慢，卡死的解决方案</title>
    <link href="https://www.codetool.top/article/npm%E5%AE%89%E8%A3%85node-sass%E9%80%9F%E5%BA%A6%E6%85%A2%EF%BC%8C%E5%8D%A1%E6%AD%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://www.codetool.top/article/npm安装node-sass速度慢，卡死的解决方案/</id>
    <published>2020-04-23T05:54:09.000Z</published>
    <updated>2020-04-23T06:05:18.281Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在用npm install安装一个前端项目依赖的时候浪费了我好长时间，即使注册了淘宝镜像，但中间还是会去<code>node.org</code>和<code>github.com</code>上面下载一些东西，中间经常卡死，导致我不停的中止、删node_modules、重新安装。</p><p>日志就是gyp什么什么的错误。</p><p>后来注意到是它在安装node-sass，并且一开始依赖的是python2（我电脑上装的python3），所以会报错python版本问题，语法识别错误什么的，可以用管理员权限打开powershell，使用下面命令安装<code>windows-build-tools</code></p><pre><code>npm install -g windows-build-tools</code></pre><p>或者自己安装python2并配置环境变量</p><p>然后中途卡死的问题主要还是去外网下载的，配置npm的镜像没有用，需要指定一个环境变量：</p><pre><code>npm install --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre><p>做到这一步如果还是失败可能是nodejs和node-gyp的版本不搭，我昨天就是因为一开始用了<code>nodejs14.0.0</code>，版本太高了，后来中间安装的时候又卡死。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天在用npm install安装一个前端项目依赖的时候浪费了我好长时间，即使注册了淘宝镜像，但中间还是会去&lt;code&gt;node.org&lt;/code&gt;和&lt;code&gt;github.com&lt;/code&gt;上面下载一些东西，中间经常卡死，导致我不停的中止、删node_modules
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典08.11-硬币</title>
    <link href="https://www.codetool.top/article/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B808-11-%E7%A1%AC%E5%B8%81/"/>
    <id>https://www.codetool.top/article/程序员面试金典08-11-硬币/</id>
    <published>2020-04-23T05:36:28.000Z</published>
    <updated>2020-04-23T05:42:59.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> n = 5<br><strong>输出:</strong> 2<br><strong>解释:</strong> 有两种方式可以凑成总金额:<br>5=5<br>5=1+1+1+1+1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 4<br><strong>解释:</strong> 有四种方式可以凑成总金额:<br>10=10<br>10=5+5<br>10=5+1+1+1+1+1<br>10=1+1+1+1+1+1+1+1+1+1   </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，不过需要注意排列组合去重</p><h2 id="代码">2.2 代码</h2><p>常见<strong>错误</strong>是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然而却忽略了重复的情况，例如6可以由<code>1+5</code>组合来，也可以由<code>5+1</code>组合来。</p><p>正确的答案其实只是将内外循环换了个顺序，<strong>保证这些数字是按递增的方式组合的</strong>，就能做到去重。：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199-二叉树的右视图</title>
    <link href="https://www.codetool.top/article/leetcode199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>https://www.codetool.top/article/leetcode199-二叉树的右视图/</id>
    <published>2020-04-22T04:20:57.000Z</published>
    <updated>2020-04-22T05:01:54.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例：</strong></p><pre><strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]<strong>输出:</strong>&nbsp;[1, 3, 4]<strong>解释:</strong>   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</pre><style>pre,pre>*{    color:#e8eaf6;}</style><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>dfs，注意查找顺序即可，用list存储答案下标代表层数，后找到的不会覆盖先找到的</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt;&amp;nbsp;[1,2,3,
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习03-同步、通信与死锁</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A003-%E5%90%8C%E6%AD%A5%E3%80%81%E9%80%9A%E4%BF%A1%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>https://www.codetool.top/article/操作系统复习03-同步、通信与死锁/</id>
    <published>2020-04-21T17:02:02.000Z</published>
    <updated>2020-04-22T07:41:59.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发进程">1 并发进程</h1><p><img src="https://api.codetool.top/img/15874794302366.png" alt></p><h2 id="顺序程序设计">1.1 顺序程序设计</h2><p>顺序程序设计是把一个程序设计成一个顺序执行的程序模块，顺序的含义不但指一个程序模块内部，也指两个程序模块之间。</p><p>顺序程序设计的特点：</p><ul><li><strong>程序执行的顺序性</strong></li><li><strong>程序环境的封闭性</strong>：运行程序独占全部资源，除初始状态外，其所处的环境由程序本身决定，只有程序本身的动作才能改变其环境</li><li><strong>执行结果的确定性</strong>：程序执行过程中允许被中断，但这种中断对程序的最终结果无影响，也即程序的执行结果与它的执行速率无关</li><li><strong>计算过程的可再现性</strong>：在同一个数据集合上重复执行一个程序会得到相同结果，因而错误也可以重现，便于分析</li></ul><h2 id="并发程序设计">1.2 并发程序设计</h2><h3 id="程序并发机制">1.2.1 程序并发机制</h3><p><strong>进程执行的并发性：</strong> 一组进程的执行在时间上是重叠的。（和并行区分开）</p><p>从宏观上看，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态。</p><p>从微观上看，任一时刻仅有一个进程在处理器上运行。</p><p>并发的实质是一个处理器在几个进程之间的多路复用，并发是<strong>对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</strong></p><h3 id="并发进程的特性">1.2.2 并发进程的特性</h3><p>并发进程之间的关系分为两类：无关的和交互的</p><p><strong>无关的并发进程：</strong> 一组并发进程分别<strong>在不同的变量集合上操作</strong>，一个进程的执行与其他并发进程的进展无关，即一个并发，进程不会改变另一个并发进程的变量值。</p><p><strong>交互的并发进程：</strong> 一组并发进程<strong>共享某些变量</strong>，一个进程的执行可能影响其他并发进程的执行结果。<strong>交互的并发进程之间具有制约关系</strong>，这种交互必须是有控制的,否则会出现不正确的结果。</p><p>对于一组交互的并发进程，若执行的相对速度无法相互控制，则各种与时间有关的错误就可能出现。与时间有关的错误有两种表现形式:</p><ul><li>结果不唯一</li><li>永远等待</li></ul><p>并发多道程序的优点：</p><ul><li>对于单处理器系统，可让处理器和各I/O设备同时工作,发挥硬部件的并行能力。</li><li><strong>对于多处理器系统，可让各进程在不同处理器上物理地并行，加快计算速度。</strong></li><li>简化程序设计任务。 </li></ul><p>并发程序设计的特征：</p><ol><li>并行性：进程的执行在时间上可以重叠，<strong>在单处理器系统中可以并发执行，在多处理器环境中可以并行执行</strong></li><li>共享性：并发进程<strong>通过引用共享变量交换信号</strong>，从而，程序运行的环境不再是封闭的</li><li>制约性：进程并发执行或协同<strong>完成同一任务时，会产生相互制约关系</strong>，必须对它们并发执行的次序加以协调</li><li>交互性：由于并发进程共享某些变量，所以，一个进程的执行可能影响其他进程的执行结果，<strong>程序运行结果可能不确定，计算过程具有不可再现性。</strong>因此，这种交互必须是有控制的，否则会出现不正确的结果</li></ol><h3 id="进程的交互">1.2.3 进程的交互</h3><p>交互进程有两种关系：</p><ul><li><strong>竞争关系</strong>：系统中的多个进程之间<strong>彼此无关，相互并不知道其它进程的存在</strong>，相互之间并不交换信息。但是<strong>由于这些进程共用了一套计算机系统资源,因而必然产生竞争资源的问题</strong>，一个进程的执行可能影响到同其竞争资源的其它进程。操作系统必须协调好诸进程对资源的争用。一旦一个进程要使用已分配给另一个进程的资源，则该进程必须等待。资源竞争产生两个问题:<ul><li>一个是<strong>死锁(Deadlock)问题</strong>，就是一组进程如果都获得了部分资源，还想要得到其他进程所占用的资源，最终所有进程都将陷入死锁</li><li>一个是<strong>饥饿(Starvation)问题</strong>，是指一个进程由于其它进程总是优先于它而被无限期拖延</li><li>既要解决饥饿问题，又要解决死锁问题。解决饥饿问题的最简单策略是FCFS资源分配策略</li><li>竞争关系的进程使用同一资源时，同一时刻最多只允许一个进程使用，其他进程必须等待，我们称这种现象为<strong>进程互斥</strong>。</li></ul></li><li><strong>协作关系</strong>：某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。<strong>当协作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后才被唤醒并继续执行</strong>。这种<strong>协作进程之间相互等待对方消息或信号的协调关系称为进程同步</strong><ul><li>进程间的协作可以是双方不知道对方名字的间接协作（如多个进程通过访问一个公共缓冲区进行松散式协作），也可以是双方知道对方名字的直接协作，进程间通过通信机制紧密协作。</li></ul></li></ul><h1 id="临界区管理">2 临界区管理</h1><p><img src="https://api.codetool.top/img/15874814349435.png" alt></p><h2 id="互斥与临界区">2.1 互斥与临界区</h2><p>并发进程中<strong>与共享变量有关的程序段叫“临界区”</strong>， 共享变量代表的资源叫“临界资源”。 </p><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预知。<strong>如果能保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误</strong></p><h2 id="临界区调度原则">2.2 临界区调度原则</h2><ul><li><strong>一次至多一个进程能够进入临界区内执行</strong></li><li>如果<strong>已有进程在临界区，其他试图进入的进程应等待</strong></li><li>进入临界区内的进程<strong>应在有限时间内退出</strong>，以便让等待进程中的一个进入</li></ul><p>临界区调度原则可总结为：</p><p>互斥使用、有空让进，<br>忙则等待、有限等待，<br>择一而入、算法可行。</p><p>算法可行是指<strong>不能因为所选的调度策略造成进程饥饿甚至死锁</strong>。</p><h2 id="软件管理临界区">2.3 软件管理临界区</h2><p>软件方法是为在具有一个处理器或共享主存的多处理器上执行的并发进程实现的，这种方法<strong>假定对主存中同一个单元的同时访问必定由存储器进行仲裁，使其串行化。</strong></p><p>临界区管理的尝试：（下面是一段伪代码，非C语言）</p><pre class=" language-c"><code class="language-c">bool inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P1不在其临界区内*/</span>bool inside2<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P2不在其临界区内*/</span>cobegin             <span class="token comment" spellcheck="true">/*cobegin和coend表示括号中的进程是一组并发进程*/</span>process <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>inside2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*等待*/</span>      inside1<span class="token operator">=</span>true<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">/*临界区*/</span>                          inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>process <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>inside1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*等待*/</span>    inside2<span class="token operator">=</span>true<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>    inside2<span class="token operator">=</span>false<span class="token punctuation">;</span><span class="token punctuation">}</span>coend </code></pre><p>这种方法看似没有问题，实则是错误的，</p><p><img src="https://api.codetool.top/img/15874826788391.png" alt></p><p>如上图所示，由于P1执行的时候将inside1设为true存在一定的时间延迟（和上一个操作不是原子的），在这段延迟的时间内，P2发现inside1仍为false，于是也进入临界区执行。出现了两个进程同时进入临界区的情况。</p><p>此外还有可能P1在临界区内失败（异常），导致无法将inside1置为false，使得其他进程再也无法进入临界区。</p><p>除此之外还出现了许多尝试，但仍存在一些无法解决的问题。</p><p>后来出现了两个真正实现了临界区管理的软件方法：Dekker算法和Peterson算法。由于软件实现临界区管理也不是主流，这里不重点研究了。</p><p>Dekker算法的实现：（下面两段代码来自 <a href="https://blog.csdn.net/JustJavaC2016/article/details/78660768）" target="_blank" rel="noopener">https://blog.csdn.net/JustJavaC2016/article/details/78660768）</a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span><span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> turn<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"P%d is visting\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用关键区。  </span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//检查P1是不是也想用？  </span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果P1想用，则查看P1是否具有访问权限？  </span>            <span class="token punctuation">{</span>                  flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果有，则P0放弃。  </span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>                flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用。  </span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>        turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P1。  </span>        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0结束使用。  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1想使用关键区。  </span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//检查P0是不是也想用？  </span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果P0想用，则查看P0是否具有访问权限？  </span>            <span class="token punctuation">{</span>                  flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果有，则P1放弃。  </span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>                flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// P1想使用。  </span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>              <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>        turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P0。  </span>        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1结束使用。  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> err<span class="token punctuation">;</span>      err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>Peterson算法的实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span><span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> turn<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">procedure0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//退出while循环的条件就是，要么另一个线程  </span>        <span class="token comment" spellcheck="true">//不想要使用关键区，要么此线程拥有访问权限。  </span>        <span class="token punctuation">{</span>                  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure0 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//critical section  </span>        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">procedure1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>              flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span>                      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure1 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//critical section  </span>            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> err<span class="token punctuation">;</span>      turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><h2 id="硬件管理临界区">2.4 硬件管理临界区</h2><p>使用软件方法实现进程互斥使用临界资源是很困难的，他们通常能实现两个进程之间的互斥，很难控制多个进程的互斥。</p><h3 id="关中断">2.4.1 关中断</h3><p>关中断是实现互斥的最简单方法之一。</p><p>进程在测试标志之前，首先关中断，直到测试完并设置标志之后才开中断。进程在临界区执行期间，<strong>计算机系统不响应中断。因此不会转向调度，也就不会引起进程或线程切换，正在执行标志测试和设置的进程或线程不会被打断，从而保证了互斥。</strong></p><p>关中断方法的缺点:</p><ul><li>关中断时间过长会影响系统效率，限制处理器交叉执行程序的能力</li><li>关中断方法也不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其他处理器上执行相同临界区代码</li></ul><h3 id="测试并设置指令">2.4.2 测试并设置指令</h3><p>其实就是<code>TestAndSet</code>，Java CAS的原理，操作系统层面提供的原子操作指令。</p><p>因为该指令是原子的，就可以使用该指令管理一个互斥量，从而实现临界区管理。</p><p>TS指令实现临界区管理的算法如下：（自旋锁）</p><pre class=" language-c"><code class="language-c">bool s<span class="token operator">=</span>true<span class="token punctuation">;</span>cobeginprocess <span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i=1,2,...,n</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TS</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*上锁*/</span>    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>    s<span class="token operator">=</span>true<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/*开锁*/</span><span class="token punctuation">}</span>coend</code></pre><h3 id="对换指令">2.4.3 对换指令</h3><p>对换指令（swap）交换两个字的内容，在Intel 80x86中，对换指令称为<code>XCHG</code>指令</p><p>swap指令也可以看作是同时设置两个值的原子指令实现，所以也可以用于临界区管理，思想类似。</p><p><strong>软件方法和硬件方法都存在忙等问题（当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环测试一个变量直到某个值出现为止），浪费了处理器的时间，不会成为一种通用的方法。</strong></p><h1 id="信号量与PV操作">3 信号量与PV操作</h1><p><img src="https://api.codetool.top/img/15874850424979.png" alt></p><h2 id="信号量机制">3.1 信号量机制</h2><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以<strong>用一个信号量来表示系统中某种资源的数量</strong>，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>一对原语：<code>wait(S)</code>原语和<code>signal(S)</code>原语，常简称为P、V操作。</p><p><code>wait(S)</code>相当于占用一个S资源，<code>signal(S)</code>相当于释放一个S资源。</p><h3 id="整型信号量">3.1.1 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。下面是P、V原语的实现思想：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//初始化整型信号量S，表示当前系统中可用的打印机数</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果资源数不够，就一直循环等待</span>    S <span class="token operator">=</span> S<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果资源数够，则占用一个资源</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S <span class="token operator">=</span> S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>进程Pn：</p><pre class=" language-c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用打印机资源...</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="记录型信号量">3.1.2 记录型信号量</h3><p>（思维导图中的二值信号量和一般信号量都是属于这里的记录型信号量）</p><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*记录型信号量的定义*/</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//剩余资源数</span>    <span class="token keyword">struct</span> process <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待队列</span><span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果剩余资源数不够</span>        <span class="token comment" spellcheck="true">//使用block原语使进程从运行态进入阻塞</span>        <span class="token comment" spellcheck="true">//并把进程挂到信号量S的等待队列(即阻塞队列)中</span>        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//释放资源后，若还有别的进程在等待这种资源</span>        <span class="token comment" spellcheck="true">//则使用wakeup原语唤醒等待队列中的个进程</span>        <span class="token comment" spellcheck="true">//该进程从阻塞态变为就绪态</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里信号量的语义就是资源的个数，并且实现了让权等待，不会形成忙等。</p><h2 id="信号量机制实现进程互斥">3.2 信号量机制实现进程互斥</h2><p>我们可以把临界区看作一种特殊的资源，为临界区抽象出一个互斥信号量<code>mutex</code>，<strong>它是二值的，初值为1</strong>，代表同一个时间只能有一个进程进入临界区。</p><ul><li>在进入临界区之前执行<code>P(mutex)</code></li><li>在退出临界区之后执行<code>V(mutex)</code></li></ul><h2 id="信号量机制实现进程同步">3.3 信号量机制实现进程同步</h2><p>进程同步问题要求多个进程按一定次序先后执行一段代码。这个前驱关系可能是较复杂的，如下图所示，可以<strong>为每一对前驱关系各设置一个同步信号量</strong>，初值为0，<strong>要执行某操作前需要对前驱操作对应的信号量进行P操作，当完成了前驱操作时对对应的信号量执行V操作。</strong></p><p><img src="https://api.codetool.top/img/15874890505885.png" alt></p><pre><code>semaphore a = 0,b = 0,c = 0,d = 0,e = 0,f = 0,g = 0;P1(){    ...    S1;    V(a);    V(b);    ...}P2(){    ...    P(a);    S2;    V(c);    V(d);    ...}P3(){    ...    P(b);    S3;    V(g);    ...}P4(){    ...    P(c);    S4;    V(e);    ...}P5(){    ...    P(d);    S5;    V(f);    ...}P6(){    ...    P(e);    P(f);    P(g);    S6;    ...}</code></pre><h1 id="管程">4 管程</h1><p><img src="https://api.codetool.top/img/15875338871013.png" alt></p><h2 id="管程和条件变量">4.1 管程和条件变量</h2><h3 id="为什么要引入管程">4.1.1 为什么要引入管程</h3><p>信号量机制存在的问题：编写程序困难、易出错。</p><p>管程：</p><ul><li>把分散在各进程中的临界区集中起来进行管理 </li><li>防止进程有意或无意的违法同步操作</li><li>便于用高级语言来书写程序，也便于程序正确性验证</li></ul><h3 id="管程的定义">4.1.2 管程的定义</h3><p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。 </p><p>管程的基本特征:</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问</li><li><strong>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</strong></li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li></ol><p>管程的属性:</p><ul><li>共享性</li><li>安全性</li><li>互斥性</li></ul><h3 id="管程的结构">4.1.3 管程的结构</h3><p>管程是一种特殊的软件模块，有这些部分组成:</p><ol><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><p>例如：(使用类C语言语法模拟管程结构)</p><pre class=" language-cpp"><code class="language-cpp">type ProducerConsumer <span class="token operator">=</span> monitor<span class="token punctuation">{</span>    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//条件变量用来实现同步排队</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//缓冲区中的产品数</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//把产品item放入缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span>N<span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从缓冲区中取出一个产品</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>N<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//生产者进程</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        item <span class="token operator">=</span> 生产一个产品<span class="token punctuation">;</span>        ProducerConsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//消费者进程</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        消费产品item       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="管程的条件变量">4.1.4 管程的条件变量</h3><p>条件变量是出现在管程内的一种数据结构，且<strong>只有在管程中才能被访问</strong>，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它。</p><ul><li><code>wait()</code>：挂起调用进程并释放管程，直到另一个进程在该条件变量上执行<code>signal()</code>。</li><li><code>signal( )</code>：如果存在其他进程由于对条件变量执行<code>wait()</code>而被挂起，便释放之；如果没有进程在等待，那么，信号不被保存。</li></ul><p>这不就是Java <code>sychronized</code>的<code>monitorenter</code>和<code>monitorexit</code>吗！！！</p><h1 id="死锁">5 死锁</h1><p><img src="https://api.codetool.top/img/15875359806127.png" alt></p><h2 id="死锁的产生">5.1 死锁的产生</h2><p>操作系统中的死锁指：如果<strong>在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件</strong>，则称一组进程或系统此时发生死锁。</p><p>死锁产生的例子：</p><p>设系统有打印机、读卡机各一台，被进程Ｐ和Ｑ共享。两个进程并发执行，按下列次序请求和释放资源：</p><table><thead><tr><th align="center">进程Ｐ</th><th align="center">进程Ｑ</th></tr></thead><tbody><tr><td align="center">请求读卡机</td><td align="center">请求打印机</td></tr><tr><td align="center"><strong>请求打印机</strong></td><td align="center"><strong>请求读卡机</strong></td></tr><tr><td align="center">释放读卡机</td><td align="center">释放读卡机</td></tr><tr><td align="center">释放打印机</td><td align="center">释放打印机</td></tr></tbody></table><p>在PV操作中对应</p><table><thead><tr><th align="center">进程Q1</th><th align="center">进程Q2</th></tr></thead><tbody><tr><td align="center">P(S1)</td><td align="center">P(S2)</td></tr><tr><td align="center"><strong>P(S2)</strong></td><td align="center"><strong>P(S1)</strong></td></tr><tr><td align="center">使用r1和r2</td><td align="center">使用r1和r2</td></tr><tr><td align="center">V(S1)</td><td align="center">V(S2);</td></tr><tr><td align="center">V(S2)</td><td align="center">V(S1);</td></tr></tbody></table><p>在第一步中，双方都拿到了请求的资源，但是第二步中请求的资源都被对方所持有，于是都在等待对方释放资源，从而陷入死锁。</p><p>若系统中有m个资源被n个进程共享，每个进程都要求Ｋ个资源，而m &lt; n·K时，即<strong>资源数小于进程所要求的总数时，如果分配不得当就可能引起死锁。</strong></p><p>在著名的哲学家就餐问题中，若五个哲学家同时拿起右手边的餐具，此时左手边的的餐具就被另外一个哲学家占用，所有哲学家都陷入了无止境的等待资源释放状态，即死锁。</p><h2 id="死锁产生的必要条件">5.2 死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</strong>（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li><li><strong>不剥夺条件：</strong> 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件：</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件：</strong> 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>归根结底，循环等待条件是前三种条件导致的结果。</p><h2 id="解决方法">5.3 解决方法</h2><h3 id="死锁防止">5.3.1 死锁防止</h3><p>死锁防止就是要破坏死锁产生的必要条件。</p><p><strong>破坏互斥条件：</strong> 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备</strong>。例如使用SPOOLing技术将打印机改造为共享设备。</p><p><strong>破坏不剥夺条件：</strong></p><ul><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul><p>该策略的缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><p><strong>破坏请求和保持条件：</strong><br>可以采用静态分配方法，即进程<strong>在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。</strong> 一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都–直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><p><strong>破坏循环等待条件：</strong> 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p><p>该策略的缺点:</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="死锁避免">5.3.2 死锁避免</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>死锁避免就是避免系统进入不安全状态。</p><p>银行家算法的数据结构：</p><p>一个系统有n个进程和m种不同类型的资源,定义包含以下向量和矩阵的数据结构：</p><ul><li>系统每类资源总数：该m个元素的向量为<strong>系统中每类资源数量</strong><code>Resource=(R1,R2,…,Rm)</code></li><li>每类资源未分配数量：该m个元素的向量为<strong>系统中每类资源尚可供分配数量</strong><code>Avilable=(V1,V2,…,Vm)</code></li><li>最大需求矩阵：<strong>每个进程对每类资源的最大需求量</strong>，<code>Claim[I,j]</code>表示进程Pi需Rj类资源最大数</li><li>分配矩阵：表示<strong>进程当前已分得的资源数</strong>，<code>Allocation[i,j]</code>表示进程Pi已分到Rj类资源个数</li><li>尚需矩阵：表示<strong>进程当前尚需资源数</strong>，<code>Need[i,j]</code>表示进程Pi尚需Rj类资源个数</li></ul><p>银行家算法中下列关系式确保成立：</p><ul><li><code>Ri=Vi+∑Allocation[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>所有资源要么已被分配、要么尚可分配</strong></li><li><code>Claim[k,i]≤Rj</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请资源数不能超过系统拥有的资源总数</strong></li><li><code>Allocation[k,i] ≤ Claim[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请任何类资源数不能超过声明的最大资源需求数</strong></li></ul><p>系统中若要启动一个新进程工作,其对资源Ri的需求仅当满足下列不等式：</p><p><code>Ri ≥ C[(n+1),i]+ ∑C[k,i]</code>  对i=1,..,m,k=1,..,n; </p><p>即应满足<strong>当前系统中所有进程对资源Ri的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</strong></p><p>系统安全性定义：在时刻T0系统是安全的,仅当存在一个进程序列P1,..,Pn,对进程Pk满足公式：</p><p><code>Need[k,i] ≤Available [i]+ ∑Allocation[j,i]</code> 对于k=1,…,n;i=1,…,m; </p><p>即对任何一个进程都能满足其所需要的资源。</p><p>银行家算法的基本思想：</p><ul><li>系统中的所有进程进入进程集合,</li><li>在安全状态下系统收到进程的资源请求后,先把资源<strong>试探性分配</strong>给它。</li><li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到<strong>剩余资源能满足最大需求量的进程</strong>,从而,保证<strong>这个进程运行完毕并归还全部资源</strong>。</li><li>把这个进程从集合中去掉, 系统的剩余资源更多了,<strong>反复执行上述步骤</strong>。</li><li>最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。 </li></ul><h3 id="死锁的检测和解除">5.3.3 死锁的检测和解除</h3><p>该部分参考自：<a href="http://www.360doc.com/content/16/0421/16/478627_552610896.shtml" target="_blank" rel="noopener">死锁的检测和解除</a></p><p>解决死锁问题的一条途径是死锁检测和解除，这种方法<strong>对资源的分配不加任何限制，也不采取死锁避免措施</strong>，但系统定时地运行一个“死锁检测”程序，判断系统内是否已出现死锁，<strong>如果检测到系统已发性了死锁，再采取措施解除它</strong>。</p><p>进程-资源分配图：</p><p>如图所示，用<strong>圆圈代表一个进程</strong>，用<strong>框代表一类资源</strong>。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。<strong>从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</strong></p><p><img src="https://api.codetool.top/img/15875408526262.jpg" alt="初始资源分配图"></p><ol><li>如果进程-资源分配图中无环路，则此时系统没有发生死锁。</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程。</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。可以使用将资源分配图简化的方法来检测系统是否处于死锁状态：</li></ol><p>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且<strong>该有向边对应资源的申请数量小于等于系统中已有空闲资源数量</strong>。如上图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。<strong>消去它所有的请求边和分配边</strong>，使之称为孤立的结点。在上图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p><p><strong>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程</strong>，原来的阻塞进程可能变为非阻塞进程。在上图中，P2 就满足这样的条件。根据上面的方法进行一系列简化后，<strong>若能消去途中所有的边，则称该图是可完全简化的</strong>。</p><p><img src="https://api.codetool.top/img/15875411733947.jpg" alt="资源分配图的化简"></p><p>一旦检测出死锁，就应立即釆取相应的措施。死锁解除算法有：</p><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发进程&quot;&gt;1 并发进程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15874794302366.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;顺序程序设计&quot;&gt;1.1 顺序程序设计&lt;/h2&gt;&lt;p&gt;顺序程序设计是把一个
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode239-滑动窗口最大值</title>
    <link href="https://www.codetool.top/article/leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode239-滑动窗口最大值/</id>
    <published>2020-04-21T06:42:49.000Z</published>
    <updated>2020-04-21T14:17:27.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>进阶：</strong></p><p>你能在线性时间复杂度内解决此题吗？</p><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, 和 <em>k</em> = 3<strong>输出: </strong><code>[3,3,5,5,6,7] <strong>解释: </strong></code>  滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       <strong>3</strong> 1 [3  -1  -3] 5  3  6  7       <strong>3</strong> 1  3 [-1  -3  5] 3  6  7       <strong>5</strong> 1  3  -1 [-3  5  3] 6  7       <strong>5</strong> 1  3  -1  -3 [5  3  6] 7       <strong>6</strong> 1  3  -1  -3  5 [3  6  7]      <strong>7</strong></pre><style>pre > *,pre,code > *{    color: #e8eaf6}</style><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用一个双端队列维护一个单调递减队列（但实际上存放的是数组的下标），每滑动一次窗口，如果进来的元素比队尾下标对应的元素小，则进入队尾，否则将队列尾比该元素小的元素都弹出（类似单调栈的思想），再进入队尾，那么任意时刻队首元素即为当前最大元素的下标，而如果滑动窗口后队首元素的下标等于<code>当前下标-k</code>，说明队首元素过期，应该从队列首部弹出。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> qmax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>qmax<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>qmax<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                qmax<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            qmax<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>qmax<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>i<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                qmax<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>qmax<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面这种方法的思想是记录当前窗口内最大元素的下标，如果滑出去了重新选举最大值，如果没滑出去将进来的元素与当前最大元素比较。它和暴力又不太一样，因为其实重新选举的次数较少，实际leetcode中这种方法反而更快，可能是因为数据量的原因：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//求出前k个元素的最大值索引</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">)</span>maxIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//li是滑动窗口的最左端</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> li <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> li <span class="token operator">&lt;</span> maxes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> li<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//ri是滑动窗口的最右端的索引</span>            <span class="token keyword">int</span> ri <span class="token operator">=</span> li <span class="token operator">+</span> k<span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>maxIdx <span class="token operator">&lt;</span> li<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//最大值的索引不在滑动窗口范围内</span>                maxIdx <span class="token operator">=</span> li<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//求出[li, ri]范围内最大值的索引</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> li <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ri<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">)</span>maxIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>ri<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//最大值的索引在滑动窗口的范围内，并且大于最大值</span>                maxIdx <span class="token operator">=</span> ri<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxes<span class="token punctuation">[</span>li<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxes<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1248-统计「优美子数组」</title>
    <link href="https://www.codetool.top/article/leetcode1248-%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D/"/>
    <id>https://www.codetool.top/article/leetcode1248-统计「优美子数组」/</id>
    <published>2020-04-21T05:58:06.000Z</published>
    <updated>2020-04-21T06:22:30.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p><p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中「优美子数组」的数目。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> nums = [1,1,2,1,1], k = 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> nums = [2,4,6], k = 1<br><strong>输出：</strong> 0<br><strong>解释：</strong> 数列中不包含任何奇数，所以不存在优美子数组。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> nums = [2,2,2,1,2,2,1,2,2,2], k = 2<br><strong>输出：</strong> 16</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于一个满足条件的最小子数组，它的左界和右界都应恰好是1，并且包含k个奇数。那么从这个最小子数组延展开，只要是偶数就可以容纳进来，可以组成的子数组个数为 <code>左边连续偶数的个数+1 乘以 右边连续偶数的个数+1</code> 。</p><h2 id="代码">2.2 代码</h2><p>统计偶数间隔，这里我们统计每两个奇数之间（也可能是第一个奇数前面或最后一个奇数后面）偶数有多少个，并将它+1存放到list中，这样连续k个奇数能组成的子数组个数为数组中相隔k的两个元素的乘积：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> preEven<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                preEven<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>preEven<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                preEven<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>preEven<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">+=</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果某个 &lt;strong&gt;连续&lt;/strong&gt; 子数组中恰好有 &lt;code&gt;k&lt;/code&gt; 个奇数数字，我们就认为这
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用一个栈实现另一个栈的排序</title>
    <link href="https://www.codetool.top/article/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.codetool.top/article/用一个栈实现另一个栈的排序/</id>
    <published>2020-04-20T07:43:51.000Z</published>
    <updated>2020-04-20T07:53:28.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>申请一个辅助栈，应让该辅助栈成为一个单调栈，可以这样做：</p><p>原栈每次弹出一个元素，如果比辅助栈顶元素小（或辅助栈内为空）就直接压入辅助栈，如果比辅助栈顶元素大，则先保留该元素，将辅助栈内的比该元素小的元素压回原栈，再将该元素压入辅助栈，如此往复，直到辅助栈成为一个栈顶到栈底递增的栈，再将辅助栈内的元素压回原栈。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortStackByStack</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>help<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>help<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>help<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            help<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>help<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>help<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？&lt;/p&gt;
&lt;h1 id=&quot;解法&quot;&gt;2 解法&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode648-单词替换</title>
    <link href="https://www.codetool.top/article/leetcode648-%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"/>
    <id>https://www.codetool.top/article/leetcode648-单词替换/</id>
    <published>2020-04-20T07:03:52.000Z</published>
    <updated>2020-04-22T09:27:27.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>在英语中，我们有一个叫做 <code>词根</code>(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 <code>继承词</code>(successor)。例如，词根<code>an</code>，跟随着单词 <code>other</code>(其他)，可以形成新的单词 <code>another</code>(另一个)。</p><p>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有<code>继承词</code>用<code>词根</code>替换掉。如果<code>继承词</code>有许多可以形成它的<code>词根</code>，则用最短的词根替换它。</p><p>你需要输出替换之后的句子。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> dict(词典) = [“cat”, “bat”, “rat”]<br>sentence(句子) = “the cattle was rattled by the battery”<br><strong>输出:</strong> “the cat was rat by the bat”</p></blockquote><p><strong>注:</strong></p><ol><li>输入只包含小写字母。</li><li>1 &lt;= 字典单词数 &lt;=1000</li><li>1 &lt;=  句中词语数 &lt;= 1000</li><li>1 &lt;= 词根长度 &lt;= 100</li><li>1 &lt;= 句中词语长度 &lt;= 1000</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这里的词根其实就是字符串的前缀，一开始我以为出现在哪都可以。前缀可以使用字典树搜索。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">{</span>        TrieNode<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String word<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">replaceWords</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> dict<span class="token punctuation">,</span> String sentence<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TrieNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String word<span class="token operator">:</span>dict<span class="token punctuation">)</span> <span class="token function">insertToTrie</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> sentence<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String prefix <span class="token operator">=</span> <span class="token function">hasPrefix</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>prefix<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prefix<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>words<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*将前缀插入字典树*/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertToTrie</span><span class="token punctuation">(</span>TrieNode root<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        TrieNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token punctuation">.</span>word <span class="token operator">=</span> word<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*从字典树中获取前缀*/</span>    <span class="token keyword">public</span> String <span class="token function">hasPrefix</span><span class="token punctuation">(</span>TrieNode root<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        TrieNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>word<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> cur<span class="token punctuation">.</span>word<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;在英语中，我们有一个叫做 &lt;code&gt;词根&lt;/code&gt;(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 &lt;code&gt;继承词&lt;/code&gt;(successor)。例如，词根&lt;code&gt;an&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用递归函数逆序一个栈</title>
    <link href="https://www.codetool.top/article/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/"/>
    <id>https://www.codetool.top/article/使用递归函数逆序一个栈/</id>
    <published>2020-04-19T06:43:06.000Z</published>
    <updated>2020-04-22T09:27:27.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源：牛客网）">1 原题（来源：牛客网）</h1><p>一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函数来实现，而不能用另外的数据结构。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设计一个函数<code>getAndRemoveLastElement</code>用于获取并移除栈底元素，当栈空的时候进行回溯，并将获取的元素压入栈，就能达到逆序的效果。</p><p>这样做的时间复杂度肯定是没一个辅助队列来的快的，好处是没有使用额外的空间（除了递归栈空间）</p><p>时间复杂度计算：设栈的大小为n，每一次获取栈底元素的时间复杂度是<code>O(n)</code>，栈的大小要从n-&gt;0，就是<code>O(n)+O(n-1)+O(n-2)+...+O(1)</code>=<code>O(n^2)</code> </p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//每次获取栈底元素，最后一次获取的即是栈顶元素</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getAndRemoveLastElement</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//回溯的时候将获取的元素压入</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAndRemoveLastElement</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取并移除栈顶元素</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取栈底元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token function">getAndRemoveLastElement</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//回溯的时候将获取的元素压入</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源：牛客网）&quot;&gt;1 原题（来源：牛客网）&lt;/h1&gt;&lt;p&gt;一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode75-颜色分类</title>
    <link href="https://www.codetool.top/article/leetcode75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>https://www.codetool.top/article/leetcode75-颜色分类/</id>
    <published>2020-04-19T06:09:49.000Z</published>
    <updated>2020-04-19T06:21:07.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [2,0,2,1,1,0]<br><strong>输出:</strong> [0,0,1,1,2,2] </p></blockquote><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>计数排序算是这类问题的通解吧。。不过对于仅有两种或三种元素，可以使用交换方法来解。</p><h2 id="代码">2.2 代码</h2><p>计数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>count2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> count0<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> count1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> count2<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>count0<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>count0<span class="token operator">+</span>count1<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>三指针交换：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> p0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p2 <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>p0<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>cur<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>p2<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣杯春季个人赛-剧情触发时间</title>
    <link href="https://www.codetool.top/article/leetcode%E4%B8%AA%E4%BA%BA%E8%B5%9B-%E5%89%A7%E6%83%85%E8%A7%A6%E5%8F%91%E6%97%B6%E9%97%B4/"/>
    <id>https://www.codetool.top/article/leetcode个人赛-剧情触发时间/</id>
    <published>2020-04-18T09:50:32.000Z</published>
    <updated>2020-04-22T09:27:27.142Z</updated>
    
    <content type="html"><![CDATA[<p>这次的个人赛真是让我认清了自己的实力。。两道困难题都没做出😭，虽然大家的通过率也不咋地。。</p><p><img src="https://api.codetool.top/img/15872016427419.png" alt></p><p>最后排名</p><p><img src="https://api.codetool.top/img/15872173146160.jpg" alt></p><p>我记录一道做出来的题吧，这道题是一道中等题，通过率如下，虽然题目不难，但由于时间限制的问题，不使用技巧很容易超出时间限制</p><p><img src="https://api.codetool.top/img/15872016956913.png" alt></p><h1 id="原题">1 原题</h1><p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（<code>C</code>），资源储备（<code>R</code>）以及人口数量（<code>H</code>）。在游戏开始时（第 0 天），三种属性的值均为 0。</p><p>随着游戏进程的进行，每一天玩家的三种属性都会对应<strong>增加</strong>，我们用一个二维数组 <code>increase</code> 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 <code>[[1,2,1],[3,4,2]]</code> 表示第一天三种属性分别增加 <code>1,2,1</code> 而第二天分别增加 <code>3,4,2</code>。</p><p>所有剧情的触发条件也用一个二维数组 <code>requirements</code> 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code> 且 <code>H &gt;= h[i]</code> ，则剧情会被触发。</p><p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入： <code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code> <code>requirements = [[2,11,3],[15,10,&gt;7],[9,17,12],[8,1,14]]</code></p><p>输出: <code>[2,-1,3,-1]</code></p><p>解释：</p><p>初始时，C = 0，R = 0，H = 0</p><p>第 1 天，C = 2，R = 8，H = 4</p><p>第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0</p><p>第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2</p><p>剧情 1 和 3 无法触发。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入： <code>increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]]</code> <code>requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]</code></p><p>输出: <code>[-1,4,3,3,3]</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入： <code>increase = [[1,1,1]] requirements = [[0,0,0]]</code></p><p>输出: <code>[0]</code></p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= increase.length &lt;= 10000</code></li><li><code>1 &lt;= requirements.length &lt;= 100000</code></li><li><code>0 &lt;= increase[i] &lt;= 10</code></li><li><code>0 &lt;= requirements[i] &lt;= 100000</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>见代码部分</p><h2 id="代码">2.2 代码</h2><p>我一开始想的是用requirement里面的三元组每隔一天减去increase里面对应的三元组，然后记录答案，但是这种方法无论怎么剪枝优化都会超时，这样做的时间复杂度是<code>O(mn)</code>(m,n为两个数组的大小，我还省去了后面数组赋值的时间复杂度)：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getTriggerTime</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> increase<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> requirements<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>day<span class="token operator">&lt;=</span>increase<span class="token punctuation">.</span>length<span class="token punctuation">;</span>day<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">boolean</span> hasRemain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>day <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                hasRemain <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-=</span> increase<span class="token punctuation">[</span>day<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> increase<span class="token punctuation">[</span>day<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-=</span> increase<span class="token punctuation">[</span>day<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> day<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>day<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>hasRemain<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> realAns <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                realAns<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                realAns<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> realAns<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>后来想到可以计算每一天的属性值，然后二分查找，这样做的时间复杂度就是<code>O(m+nlogm)</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getTriggerTime</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> increase<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> requirements<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将increase中的三元组的含义变为每一天的属性值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>increase<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            increase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> increase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            increase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> increase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            increase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+=</span> increase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> increase<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果最后一天仍不满足，设为-1</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>increase<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//二分查找</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>increase<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        left <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次的个人赛真是让我认清了自己的实力。。两道困难题都没做出😭，虽然大家的通过率也不咋地。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15872016427419.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最后排名&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器地址栏输入URL，按下回车之后发生了什么？</title>
    <link href="https://www.codetool.top/article/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://www.codetool.top/article/在浏览器地址栏输入URL，按下回车之后发生了什么？/</id>
    <published>2020-04-17T18:05:08.000Z</published>
    <updated>2020-04-17T18:48:52.213Z</updated>
    
    <content type="html"><![CDATA[<p>一道经典的面试题~ 这篇文章不会用来讲知识点，如果按一个问题去讲里面的知识点完全形成不了体系，这篇文章只是做一个知识点的串联、回顾，帮助缕清知识点之间的关系，形成知识脉络。</p><p>下面的回答仅针对HTTP/HTTPS协议：（毕竟浏览器还可以ftp、websocket什么的，如果各种协议都谈真没完了）</p><ol><li><p>浏览器检查缓存，<strong>缓存未过期一般会使用强缓存，缓存过期一般会使用协商缓存</strong>，如果协商缓存未命中或没有缓存，继续下一步。</p><ul><li>具体请参考<a href="../HTTP浏览器缓存策略和服务器的缓存控制">HTTP浏览器缓存策略和服务器的缓存控制</a></li></ul></li><li><p>对域名进行DNS解析，<strong>如果客户机有DNS缓存，直接获得对应的IP</strong>，否则向DNS服务器发出请求解析域名，<strong>如果网站配置了CDN，会返回一个cname，指向CDN的全局负载均衡器</strong>，由智能算法为用户分配为其服务的服务器ip。如果没有配置CDN，根据网站的DNS配置返回一个IP。</p><ul><li>DNS相关请参考<a href="../计网复习06-应用层之域名系统DNS/">计网复习06-应用层之域名系统DNS</a>，CDN相关的东西我目前倒是没有写博客讲过，这里可以提一下，其实CDN的核心技术就是全局负载均衡和缓存管理，通常用于静态资源的分发（缓存代理），客户从<strong>边缘节点</strong>上取数据。和CDN性能相关的名词有<strong>命中率</strong>和<strong>回源率</strong>。最近还流行一种<strong>边缘计算</strong>的技术，把计算动态资源的代码和数据也放在cdn的节点上，就可以实现在cdn里获取动态资源而不用回源站。</li></ul></li><li><p>客户机使用IP与服务器建立TCP连接，通过TCP三次握手，建立连接之后如果是HTTPS协议还需要TLS握手，交换密码套件，通过椭圆曲线算法实现密钥交换。</p><ul><li>TCP建立连接三次握手相关内容见<a href="../计网复习05-传输层">计网复习05-传输层</a></li><li>TLS握手的详细过程我也没有写过博客，因为比较理论，我也没有那么权威，自己写不敢保证正确，复制粘贴也没有意思，不过HTTPS原理可以参考<a href="../HTTPS的原理——混合加密、数字签名、CA">HTTPS的原理——混合加密、数字签名、CA</a>。我这里简单提一下TLS的握手：<strong>TLS握手主要目的就是获取CA证书验证服务端身份和密钥交换，即获取后面用于对称加密的密钥。（也成为会话密钥）</strong>客户端和服务器会先协商使用同一个<strong>密码套件</strong>。密码套件的命名是<code>密钥交换算法-签名算法-对称加密算法-分组模式-摘要算法</code>，如<code>ECDHE-RSA-AES256-GCM-SHA384</code>。TLS1.2还有用RSA进行密钥交换，但由于<strong>前向安全</strong>的问题（RSA使用的公私钥是固定的，如果黑客坚持不懈的收集所有监听到的HTTPS报文，一旦有一天私钥泄露，所有之前收集的报文都能被破解），<strong>TLS1.3就完全废弃了使用RSA密钥交换，并推荐使用ECDHE密钥交换</strong>（即ECC+DH，基于椭圆曲线的离散对数问题，每次握手时都会生成一对临时的公钥和私钥，保证了前向安全）。</li><li>传输层再往下的协议我觉得就没必要讲了吧？网络层找IP，数据链路层找MAC，物理层传输。</li></ul></li><li><p>握手完成之后可以发送HTTP/HTTPS报文（对于一个复用的TCP连接我们会遇到队头阻塞等待，不过这里既然是在地址栏输入URL然后回车，肯定是第一次请求，没有这个问题），服务器收到后进行处理。（处理过程不定，如果是动态资源可能会调用后端程序），处理完成之后组成HTTP响应报文发送给客户端。</p><ul><li>网上有的博客说这里会服务器就会断开连接了？？未免知识点太久远了一点了吧，HTTPS1.1就默认长连接了。关于HTTP的版本相关可以参考<a href="../HTTP版本发展与Google的暗中助力">HTTP版本发展与Google的暗中助力</a></li></ul></li><li><p>浏览器下载对应的响应数据，并对HTML（如果是）进行渲染。渲染相关的知识我也不是很清楚，应该是前端比较需要掌握的部分。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道经典的面试题~ 这篇文章不会用来讲知识点，如果按一个问题去讲里面的知识点完全形成不了体系，这篇文章只是做一个知识点的串联、回顾，帮助缕清知识点之间的关系，形成知识脉络。&lt;/p&gt;
&lt;p&gt;下面的回答仅针对HTTP/HTTPS协议：（毕竟浏览器还可以ftp、websocket
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer17-打印从1到最大的n位数</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>https://www.codetool.top/article/剑指offer17-打印从1到最大的n位数/</id>
    <published>2020-04-17T06:49:50.000Z</published>
    <updated>2020-04-17T06:51:21.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> n = 1<br><strong>输出：</strong> [1,2,3,4,5,6,7,8,9]  </p></blockquote><p>说明：</p><ul><li>用返回一个整数列表来代替打印</li><li>n 为正整数</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>幂函数</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">printNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/stron
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS的原理——混合加密、数字签名、CA</title>
    <link href="https://www.codetool.top/article/HTTPS%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81CA/"/>
    <id>https://www.codetool.top/article/HTTPS的原理——混合加密、数字签名、CA/</id>
    <published>2020-04-16T17:51:52.000Z</published>
    <updated>2020-04-17T17:04:25.742Z</updated>
    
    <content type="html"><![CDATA[<p>前置知识：<a href="../谈谈对称加密、非对称加密、消息摘要以及数字签名">谈谈对称加密、非对称加密、消息摘要以及数字签名</a></p><p>本文参考资源：</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453141883&idx=2&sn=3b93d3bed05ec0094a0cae77bf1cc82c&chksm=8cf2dbf8bb8552ee286c4799b30d3847a641760142e50234b12bd042f9d238b3291c161b5996&mpshare=1&scene=23&srcid=&sharer_sharetime=1587058055254&sharer_shareid=c085eab43b9a65b398a19df04709e455#rd" target="_blank" rel="noopener">全网最透彻HTTPS（面试常问）</a></p><p><a href="https://blog.csdn.net/u014294681/article/details/86599741" target="_blank" rel="noopener">网络篇 - https协议中的数据是否需要二次加密_网络_u014294681的博客-CSDN博客</a></p><h1 id="HTTPS概述">1 HTTPS概述</h1><h2 id="HTTPS介绍">1.1 HTTPS介绍</h2><p>HTTPS是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。</p><p>HTTPS 把 HTTP 下层的传输协议由 <code>TCP/IP</code> 换成了 <code>SSL/TLS</code>，由<code>HTTP over TCP/IP</code>变成了<code>HTTP over SSL/TLS</code>，让 HTTP 运行在了安全的 <code>SSL/TLS</code> 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。</p><p><img src="https://api.codetool.top/img/15870519053306.png" alt></p><h2 id="什么是SSL-TLS">1.2 什么是SSL/TLS</h2><p>SSL 即安全套接层（Secure Sockets Layer），<strong>在 OSI 模型中处于第 5 层（会话层）</strong>，由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p><p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF <strong>在 1999 年把它改名为 TLS</strong>（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 <code>TLS1.0</code> 实际上就是 <code>SSLv3.1</code>。</p><p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和 2018 年的 1.3。</p><p>说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p><h1 id="TLS的关键技术">2 TLS的关键技术</h1><p>对于网络传输，要保证安全，必须保证：</p><ul><li>机密性：对数据进行加密，通过密文实现</li><li>完整性：指数据在传输过程中没有被窜改，服务器发的是什么，客户端接收的就是什么样的</li><li>身份认证：确认对方的真实身份，否则容易被中间人攻击</li><li>不可否认：也叫不可抵赖，意思是不能否认已经发生过的行为，如果缺了不可否认，那通信的事务真实性就得不到保证。</li></ul><p><img src="https://api.codetool.top/img/15870551057859.png" alt="实现安全要求的原理"></p><p>可以看到，TLS为保证安全，同时使用了对称加密、非对称加密和消息摘要。不了解的可以点击前置知识链接去看一下。</p><h2 id="传输加密">2.1 传输加密</h2><p>TLS保证传输加密是使用了混合加密，它同时使用了对称加密和非对称加密。</p><p>为什么要混合加密呢？我们在<a href="../谈谈对称加密、非对称加密、消息摘要以及数字签名">谈谈对称加密、非对称加密、消息摘要以及数字签名</a>中提到，非对称加密虽然安全，但加密解密速度较慢，效率较低，而对称加密又需要解决密钥的传输安全性问题，我们称之为 <strong>“密钥交换”</strong> 问题。于是，我们可以结合这二者，<strong>使用非对称加密解决对称加密的“密钥交换”问题</strong>。</p><p>客户端用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</p><p>服务端拿到密文之后再用私钥解密，拿到“会话密钥”，<strong>作为后续对称加密使用的密钥</strong>。</p><h2 id="消息摘要">2.2 消息摘要</h2><p>TLS保证消息的完整性则是使用了消息摘要，只要双方在消息后附上它的摘要，就能够保证数据的完整性。当然摘要也得使用混合加密，否则会被黑客修改。</p><p>目前 TLS 推荐使用摘要算法的是SHA-2系列（包含SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要）。</p><h2 id="数字签名-amp-CA">2.3 数字签名&amp;CA</h2><p>数字签名实现了身份认证和不可否认，数字签名又使用了非对称加密和消息摘要技术。我们在<a href="../谈谈对称加密、非对称加密、消息摘要以及数字签名">谈谈对称加密、非对称加密、消息摘要以及数字签名</a>中介绍过。数字签名就是将消息摘要后的数据再使用私钥加密。</p><p><img src="https://api.codetool.top/img/15870581177513.png" alt></p><p>然而考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。</p><p>当服务端向客户端返回公钥A1的时候，中间人将其替换成自己的公钥B1传送给浏览器。</p><p>而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被中间人截获，中间人利用自己的私钥B2解密，得到密钥K，再使用服务端的公钥A1加密传送给服务端，完成了通信链路，而服务端和客户端毫无感知。</p><p><img src="https://api.codetool.top/img/15870559453668.jpg" alt></p><p>这个时候就需要CA证书了，<strong>CA证书证明该公钥确实是来自服务端</strong>。服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份数字证书，数字证书里包含有证书持有者、证书有效期、服务端的公钥、CA使用的消息摘要算法等信息，称为明文数据，CA还会将证书的明文数据进行消息摘要，并使用私钥生成数字签名，附在证书内。服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。（<strong>证书的构成：证书的明文信息+由证书的明文信息和CA的私钥生成的数字签名</strong>）</p><p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。<strong>小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。</strong>你必须相信，否则整个证书信任链就走不下去了。</p><p>有了这个证书体系，<strong>操作系统和浏览器都内置了各大 CA 的根证书（包含CA的公钥）</strong>，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而确定里面的公钥也是可信的。</p><p>CA机构颁发证书的过程：</p><ol><li>CA机构拥有自己的一对公钥和私钥</li><li>CA机构在颁发证书时对证书明文信息进行哈希</li><li>将哈希值用私钥进行加签，得到数字签名</li></ol><p><strong>服务端将证书明文数据和数字签名组成证书，传递给客户端。</strong> 而客户端需要验证证书中的公钥没有被篡改：</p><ol><li>客户端得到证书，分解成明文部分Text和数字签名Sig1</li><li>用CA机构的公钥进行解密，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）</li><li>用证书里声明的哈希算法对明文Text部分进行哈希得到H</li><li>当自己计算得到的哈希值H与Sig2相等，表示证书可信，没有被篡改</li></ol><p>然后客户端就可以信任明文数据中的服务端公钥了。</p><h1 id="HTTP通信过程一览">3 HTTP通信过程一览</h1><p><img src="https://api.codetool.top/img/15870544945377.png" alt="HTTPS原理一览图"></p><ol><li>用户在浏览器发起HTTPS请求（如 <a href="https://www.mogu.com/），默认使用服务端的443端口进行连接" target="_blank" rel="noopener">https://www.mogu.com/），默认使用服务端的443端口进行连接</a></li><li>HTTPS需要使用一套CA数字证书，<strong>证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开</strong></li><li>服务端收到请求，<strong>返回配置好的包含公钥Pub的证书给客户端</strong></li><li>客户端收到证书，<strong>校验合法性</strong>，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续</li><li>客户端<strong>生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端</strong></li><li>服务端收到随机Key的密文，<strong>使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key</strong></li><li>服务端<strong>使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密</strong>，将密文返回客户端；</li><li>客户端<strong>使用随机Key对称解密密文</strong>，得到HTTP数据明文</li><li>后续HTTPS请求使用之前交换好的随机Key进行对称加解密</li></ol><p>其中用了两次非对称加密，这两次非对称加密是容易把人搞懵的：</p><ul><li>第一次是客户端获取证书后，<strong>使用CA的公钥解密证书中的数字签名</strong>，然后判断证书中的服务端公钥是否可信</li><li>第二次是客户端<strong>使用服务端公钥对使用随机数生成的对称加密密钥进行加密</strong>，然后发给服务端。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前置知识：&lt;a href=&quot;../谈谈对称加密、非对称加密、消息摘要以及数字签名&quot;&gt;谈谈对称加密、非对称加密、消息摘要以及数字签名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAw
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习02-处理器管理（进程管理）</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A002-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%89/"/>
    <id>https://www.codetool.top/article/操作系统复习02-处理器管理（进程管理）/</id>
    <published>2020-04-16T09:54:01.000Z</published>
    <updated>2020-04-21T16:52:51.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理器概念">1 处理器概念</h1><p><img src="https://api.codetool.top/img/15870310461239.png" alt></p><p>特权指令和非特权指令、管态和目态已在上一篇提及。</p><p>Intel的X86处理器具有四个特权级别，分别是RING0、RING1、RING2、RING3，RING0层拥有最高权限，依此向下RING3层即拥有最低的权限。</p><p>用户态切换为核心态是通过中断实现的。并且中断是唯一途径，用户手动触发中断的指令称为陷阱指令，也称为访管指令。</p><p>核心态切换为用户态是通过执行一个特权指令，将程序状态字(PSW)的标志位设置为用户态。</p><h2 id="用户栈和核心栈">1.1 用户栈和核心栈</h2><p>用户栈：是用户进程空间中开辟的内存区域，用于保存应用程序的子程序(函数)间相互调用的参数、返回值、返回点以及子程序的局部变量。</p><p>核心栈：每个进程被创建时捆绑一个核心栈，是内存中属于OS空间的区域，用途包括：用于保存中断现场；或保存OS程序间相互调用的参数、返回值、返回点以及程序局部变量。</p><h2 id="程序状态字PSW">1.2 程序状态字PSW</h2><p>计算机如何知道当前处于管态还是目态？通常OS都引入程序状态字PSW（Program Status Word）来区别不同的处理器工作状态。</p><p>PSW用来<strong>控制指令执行顺序并保留和指示与程序有关的系统状态</strong>，主要作用是实现程序状态的保护和恢复。<strong>每个程序都有一个与其执行相关的PSW，每个处理器都设置一个PSW寄存器。</strong>程序占有处理器执行，它的PSW将占有PSW寄存器。 </p><p>PSW寄存器包括以下内容：</p><ul><li>程序基本状态：<ol><li>程序计数器；</li><li>条件码；</li><li>处理器状态位。</li></ol></li><li>中断码：保存程序执行时当前发生的中断事件。</li><li>中断屏蔽位：指明程序执行中发生中断事件时，是否响应出现的中断事件。</li></ul><p>Intel x86中，PSW由标志寄存器EFLAGS和指令指针寄存器EIP组成，均为32位。</p><p>EFLAGS的低16位称FLAGS，标志可划分为三组：状态标志、控制标志、系统标志。</p><h1 id="中断技术">2 中断技术</h1><p><img src="https://api.codetool.top/img/15870310716982.png" alt></p><p>中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程。</p><h2 id="中断源分类">2.1 中断源分类</h2><ul><li>内中断：信号的来源是CPU内部，与当前执行的指令有关<ul><li>I/O中断</li><li>访管中断：调用访管指令，是程序自愿的</li><li>硬件故障</li><li>程序性中断（和编程时的问题有关）</li></ul></li><li>外中断：信号的来源是CPU外部，与当前执行的指令无关<ul><li>外部设备请求</li><li>时钟中断</li></ul></li></ul><p>外中断又分可屏蔽中断和不可屏蔽中断，内中断完全不可屏蔽。</p><p>时钟是操作系统进行调度工作的重要工具，如让分时进程作时间片轮转、让实时进程定时发出或接收控制信号、系统定时唤醒或阻塞一个进程、对用户进程进行记账。</p><h2 id="中断优先级">2.2 中断优先级</h2><p>每个不同中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会屏蔽部分或全部低级中断。级别高的有优先获得响应的权力，中断装置预定的这个响应顺序称为中断优先级。 </p><h2 id="多重中断事件的处理">2.3 多重中断事件的处理</h2><p><strong>中断正在进行处理期间，CPU又响应新的中断事件</strong>，于是暂时停止正在运行的中断处理程序，转去执行新的中断处理程序，就叫多重中断（又称中断嵌套）。处理方法：</p><ol><li>串行处理，</li><li>嵌套处理，</li><li>即时处理。</li></ol><h1 id="进程及其实现">3 进程及其实现</h1><p><img src="https://api.codetool.top/img/15870310852352.png" alt></p><h2 id="进程概念">3.1 进程概念</h2><ul><li>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是<strong>操作系统进行资源分配和保护的基本单位。</strong></li><li>进程是一个<strong>既能用来共享资源，又能描述程序并发执行过程的系统基本单位。</strong></li><li>进程是一种支持程序执行的系统机制。</li></ul><p>进程的属性：</p><ul><li>动态性</li><li>共享性</li><li>独立性：独立性会体现在虚存、程序计数器、内部状态上</li><li>制约性</li><li>并发性</li></ul><h2 id="进程状态和转换">3.2 进程状态和转换</h2><p>本节参考和图片来源：<a href="https://www.cnblogs.com/lrhya/p/10636011.html" target="_blank" rel="noopener">进程的状态转换 - LRH呀 - 博客园</a></p><h3 id="三态模型">3.2.1 三态模型</h3><p>三态模型，也是最基本的几个状态：</p><p><img src="https://api.codetool.top/img/15870345103687.png" alt></p><ul><li><strong>就绪态</strong>意味着运行条件满足，等待系统分配处理器以便运行</li><li><strong>运行态</strong>是已分配处理器，正在运行的状态</li><li><strong>等待态</strong>（也称为阻塞态）是不具备运行条件，等待某个事件完成，如IO输入。</li></ul><h3 id="五态模型">3.2.2 五态模型</h3><p><img src="https://api.codetool.top/img/15870348059720.png" alt></p><p>五态模型在三态模型的基础上加了新建态和终止态。</p><ul><li>新建态：对应于进程被创建时的状态，尚未进入就绪队列。<blockquote><p>创建一个进程需要通过两个步骤：  </p></blockquote></li></ul><p>1.为新进程分配所需要资源和建立必要的管理信息。<br>2.设置该进程为就绪态，并等待被调度执行。  </p><ul><li>终止态：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。<blockquote><p>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。<br>终止一个进程需要两个步骤：    </p></blockquote></li></ul><p>1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。<br>2.然后回收占用的资源并被系统删除。</p><h3 id="七态模型">3.2.3 七态模型</h3><p>三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，<strong>当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。</strong> 起到平滑系统操作负荷的目的。</p><p>七态模型在五态模型的基础上增加了挂起就绪态（ready suspend）和挂起等待态（blocked suspend）。</p><ul><li>挂起就绪态：进程具备运行条件，但目前<strong>在外存中</strong>，只有它被对换到内存才能被调度执行。</li><li>挂起等待态：表明进程正在等待某一个事件发生且<strong>在外存中</strong>。</li></ul><p><img src="https://api.codetool.top/img/15870350867344.png" alt></p><h2 id="进程的描述和组成">3.3 进程的描述和组成</h2><h3 id="进程映像">3.3.1 进程映像</h3><p>进程实体(进程映像)的组成：</p><ul><li>进程控制块（<strong>PCB</strong>）</li><li>进程<strong>程序块</strong></li><li>进程核心栈</li><li>进程<strong>数据块</strong></li></ul><p>进程控制块PCB，是OS<strong>用于记录和刻划进程状态及有关信息的数据结构</strong>。也是OS掌握进程的唯一资料结构，它包括<strong>进程执行时的情况，以及进程让出处理器后所处的状态、断点等信息。</strong> PCB是进程存在的唯一标志。</p><p>进程控制块包含三类信息：</p><ul><li>标识信息，包括进程号（pid），进程组，用户标识符（uid）</li><li>现场信息，包含中断时处理器的信息</li><li>控制信息<ul><li>进程调度的相关信息，如进程优先级</li><li>进程组成信息</li><li>进程间的族系信息</li><li>进程间通信信息</li></ul></li></ul><h3 id="进程队列及其管理">3.3.2 进程队列及其管理</h3><p>处于同一状态的所有PCB链接在一起的数据结构称为进程队列。 可按先来先到的原则排成队列，也可按优先数或其它原则排队。</p><p>组织方式：</p><ul><li>线性方式</li><li>链接方式：操作系统持有指向各个队列的指针</li><li>索引方式：根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针</li></ul><h3 id="进程上下文切换">3.3.3 进程上下文切换</h3><p>进程切换是让处于运行态的进程中断运行，让出处理器，这时要做一次进程上下文切换、即保存老进程的上下文而装入被保护了的新进程的上下文，以便新进程运行。</p><p>中断运行的三种情况：</p><ul><li>被阻塞的高优先级进程变为就绪态</li><li>运行进程的时间片耗尽</li><li>运行进程执行阻塞型I/O指令（变为准备态）</li></ul><p>当然，这些情况触发也不一定就会立即进行进程调度和切换，例外情况：</p><ul><li>内核正在处理中断的过程中</li><li>进程运行在内核临界区中</li><li>内核处在需要屏蔽中断的原子操作过程中</li></ul><p>进程上下文切换的步骤：</p><ol><li>保存被中断进程的处理器现场信息</li><li>修改被中断进程的PCB有关信息，如进程状态等</li><li>把被中断进程的PSB加入有关队列</li><li>选择下一个占有处理器运行的进程</li><li>修改被选中进程的PSB的有关信息</li><li>根据被选中进程设置操作系统用到的地址转换和存储保护信息</li><li>根据被选中进程恢复处理器现场</li></ol><p>当中断/系统调用发生时，暂时中断正在执行的用户进程，把进程从用户状态转换到内核状态，去执行操作系统服务程序以获得服务，这就是一次处理器状态转换。</p><p>处理器状态转换的步骤：</p><ol><li>保存被中断进程的处理器现场信息；</li><li>处理器从用户态转换到核心态，以便执行服务程序或中断处理程序；</li><li>如果处理中断，可根据规定的中断级设置中断屏蔽位；</li><li>根据系统调用号或中断号，从系统调用表或中断入口表找到服务程序或中断处理程序地址。</li></ol><h2 id="进程管理原语">3.4 进程管理原语</h2><p>这个不属于进程上下文切换中的内容，思维导图里面是我弄错了。</p><p>进程管理原语用于进程控制，有：</p><ul><li>进程创建</li><li>进程撤销</li><li>进程阻塞</li><li>进程唤醒</li><li>进程挂起</li><li>进程激活</li></ul><p>进程创建的详细步骤：</p><ol><li>在进程列表中增加一项，从PCB池中申请一个空闲PCB，为新进程分配惟一的进程标识符</li><li>为新进程的进程映像分配地址空间，以便容纳进程实体。进程管理程序确定加载到进程地址空间中的程序</li><li>为新进程分配除主存空间外的其他各种所需资源；</li><li>初始化PCB，如进程标识符、处理器初始状态、进程优先级等；</li><li>把新进程状态置为就绪态，并移入就绪进程队列；</li><li>通知操作系统的某些模块，如记账程序、性能监控程序。</li></ol><p>linux创建进程/线程可以使用：</p><ul><li><code>fork()</code>：父子进程是独立的进程 </li><li><code>clone()</code>：父子进程允许共享资源</li><li><code>vfork()</code>：子进程租用父进程地址空间 </li></ul><p>进程撤销的详细步骤：</p><ol><li>根据撤销进程标识号，从相应队列中找到并移出它</li><li>将该进程拥有的资源归还给父进程或操作系统</li><li>若该进程拥有子进程，先撤销它的所有子进程，以防它们脱离控制</li><li>回收PCB，并归还到PCB池</li></ol><p>进程阻塞步骤：</p><ol><li>停止进程执行，保存现场信息到PCB</li><li>修改进程PCB有关内容，如进程状态由运行态改为等待态等，并把修改状态后的进程移入相应事件的等待队列中</li><li>转入进程调度程序去调度其他进程运行</li></ol><p>进程唤醒步骤：</p><ol><li>从相应的等待队列中移出进程</li><li>修改进程PCB的有关信息，如进程状态改为就绪态，并移入就绪队列</li><li>若被唤醒进程比当前运行进程优先级高，重新设置调度标志</li></ol><h1 id="线程及其实现">4 线程及其实现</h1><p><img src="https://api.codetool.top/img/15870311193616.png" alt></p><h2 id="线程概念">4.1 线程概念</h2><p>OS中引入进程的目的是为了使多个程序并发执行，以改善资源使用率和提高系统效率，OS中再引入线程，则是<strong>为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好。</strong></p><p>线程是OS进程中能够独立执行的实体（控制流），<strong>是处理器调度和分派的基本单位。线程是进程的组成部分</strong>，每个进程内允许包含多个并发执行的实体（控制流），这就是多线程。</p><h2 id="线程优点">4.2 线程优点</h2><ul><li>快速线程切换</li><li>通信易于实现</li><li>减少管理开销</li><li>并发程度提高</li></ul><p>进程作为系统资源分配和保护的独立单位，不需要频繁地切换，而线程共享进程中的数据，利于通信。</p><h2 id="多线程环境">4.3 多线程环境</h2><h3 id="线程组成">4.3.1 线程组成</h3><ol><li>线程控制块：线程<strong>唯一标识符及线程状态信息</strong>(运行态、就绪态、阻塞态和终止态)</li><li>线程是一条执行路径，<strong>有独立的程序计数器</strong>；未运行时保护线程上下文</li><li>线程有<strong>执行栈和存放局部变量的私用存储空间</strong></li><li><strong>可访问所属进程的内存和资源</strong>，并与该进程中的其他线程共享这些资源</li></ol><p>线程又称轻量进程，线程运行在进程的上下文中,并使用进程的资源和环境。系统调度的基本单位是线程而不是进程,每当创建一个进程时，至少要同时为该进程创建一个线程。</p><h3 id="线程状态">4.3.2 线程状态</h3><p>线程状态有：运行、就绪、等待和终止，状态转换也类似于进程。</p><p>挂起状态对线程是没有意义，如果进程挂起后被对换出主存，则它的所有线程因共享进程的地址空间，也必须全部对换出去。</p><h3 id="线程组织">4.3.3 线程组织</h3><p>进程中线程多种组织方式：</p><ul><li>调度员／工作者模式：一个线程担任调度员，用于分配任务并唤醒工作者，其他线程为工作者。</li><li>组模式：各个线程都可以取得并处理工作请求，对特定任务建立相应线程队列（执行不同任务）</li><li>流水线模式：线程排成某个次序，前一个线程产生的数据交给下一个线程处理 </li></ul><h2 id="线程的实现">4.4 线程的实现</h2><p>本节参考：<a href="https://blog.csdn.net/cxy19931018/article/details/81435811" target="_blank" rel="noopener">操作系统学习记录之五：多线程实现的混合策略_小小柴的博客-CSDN博客</a></p><p>从实现角度看，线程分成:</p><ul><li>用户级线程ULT(如Java ,Informix)。</li><li>内核级线程KLT(如OS/2)。</li><li>混合式线程(如Solaris)。</li></ul><p>内核级线程是内核支持的线程，线程管理工作由内核完成。优点是线程切换速度快、执行效率高。缺点是用户态运行、内核态管理导致系统开销大。</p><p>用户级线程是<strong>由应用程序所支持的线程实现</strong>, 内核意识不到用户级线程的实现。线程管理由应用程序完成。优点：</p><ul><li>节省系统模式转换开销和内核的宝贵资源</li><li>允许进程按照应用的特定需要选择调度算法</li><li>能够运行在任何操作系统上</li><li>内核无须做任何改变</li></ul><p>缺点：</p><ul><li>线程的阻塞将引起整个进程的阻塞</li><li>不可能得益于多线程的并发执行</li></ul><p>混合式线程：线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。<strong>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上。</strong>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点。</p><p><img src="https://api.codetool.top/img/15870405337015.png" alt></p><h1 id="处理器调度">5 处理器调度</h1><p><img src="https://api.codetool.top/img/15870311366136.png" alt></p><h2 id="调度层次">5.1 调度层次</h2><p>作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度：</p><p>高级调度，又称作业调度、长程调度。任务是<strong>选择作业进入内存</strong>，控制多道程序的道数。</p><p>中级调度，又称平衡调度、中程调度。任务是<strong>完成外存和内存中的进程对换工作、转换就绪态和等待态</strong>,提高内存利用率和系统吞吐率。</p><p>低级调度，又称进程调度/线程调度、短程调度。任务是<strong>决定就绪队列中的某个进程/线程获得处理器</strong>。</p><h2 id="选择调度算法原则">5.2 选择调度算法原则</h2><p>原则就是性能指标，包含：</p><ul><li>资源利用率：CPU利用率=CPU有效工作时间/CPU总的运行时间。CPU总的运行时间=CPU有效工作时间+CPU空闲等待时间。</li><li>吞吐率：单位时间内CPU处理作业的个数。</li><li>公平性：确保每个进程都能获得合理的资源份额，不会出现饥饿现象。</li><li>响应时间：交互式进程从提交一个请求(命令)到接收到响应之间的时间间隔称响应时间。</li><li>周转时间：从提交作业开始到作业完成的时间。</li></ul><h2 id="作业的管理与调度">5.3 作业的管理与调度</h2><h3 id="作业和进程的关系">5.3.1 作业和进程的关系</h3><p>作业是任务实体，进程是完成任务的执行实体;没有作业任务，进程无事可干，没有进程，作业任务没法完成。</p><p><strong>作业概念更多地用在批处理操作系统，而进程则可以用在各种多道程序设计系统。</strong></p><h3 id="作业控制块">5.3.2 作业控制块</h3><p>多道批处理操作系统具有独立的作业管理模块，必须像进程管理一样为每一个作业建立作业控制块（JCB）。</p><p>JCB通常是在批作业进入系统时，由Spooling系统建立的，它是作业存在于系统的标志，作业撤离时，JCB也被撤销。</p><p>JCB的主要内容包括：</p><ol><li>作业情况</li><li>资源需求</li><li>资源使用情况</li></ol><h3 id="批处理作业的调度">5.3.3 批处理作业的调度</h3><ol><li>选择作业：按照调度算法选择</li><li>分配资源</li><li>创建进程：被调度时，系统为作业创建进程，并生成PCB及各种进程实体</li><li>作业控制：按说明书运行</li><li>后续处理：调度程序做好作业撤离和善后工作</li></ol><h3 id="低级调度功能和类型">5.3.4 低级调度功能和类型</h3><p><strong>调度程序两项任务：</strong> 调度和分派。<strong>调度决定就绪态线程竞争使用处理器的次序，分派决定如何时分复用CPU，处理上下文切换。</strong></p><p>低级调度的基本类型：第一类称剥夺式，有两种处理器剥夺原则，其一是高优先级进程/线程可剥夺低优先级进程/线程，另一种是当运行进程/线程时间片用完后被剥夺。第二类称非剥夺式，进程/线程开始运行后不再让出处理器</p><p>作业调度和低级调度算法：</p><ul><li>先来先服务算法FCFS</li></ul><p>先来先服务是<strong>按照作业进入系统后备队列的先后次序来挑选作业</strong>，先进入系统的作业优先被挑选进入内存。 它是非剥夺式算法，<strong>不利于短作业（短作业的平均周转时间会较长，因为需要等待前面的作业完成）</strong></p><ul><li>最短作业优先算法SJF</li></ul><p>SJF算法<strong>以进入系统的作业所要求的CPU时间为标准，总选取估计计算时间最短的作业投入运行。</strong>（但是由于这个时间只是估算的，并不能保证实际上一定是最短作业）。它也是非剥夺式算法，缺点是长作业可能出现饥饿现象（一直得不到调度），缺少剥夺机制，对分时实时处理不理想。</p><ul><li>最高响应比优先算法HRRF</li></ul><p>FCFS只考虑等待时间而忽视了作业的计算时间，SJF只考虑用户估计的作业计算时间而忽视了作业等待时间，因而比较片面。HRRF是介于FCFS与SJF之间的折中算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。 </p><p><code>响应比 = 周转时间/处理时间 = 1+已等待时间/估计运行时间</code></p><p>因而这种算法会<strong>根据作业已等待的时间和估计运行时间动态调整调度的优先级</strong>，短作业容易得到较高响应比，长作业等待时间足够长后，也将获得足够高的响应比，饥饿现象不会发生。</p><ul><li>优先级调度算法</li></ul><p>永远先选取优先级高的，这个优先级可能是用户指定的，也可能是系统根据作业的重要性等信息调整的。</p><ul><li>最短剩余时间优先算法SRTF</li></ul><p>这是一种剥夺式算法，当一个新作业进入就绪状态，<strong>如果新作业需要的CPU时间比当前正在执行的作业剩余下来还需的CPU时间短，SRTF强行赶走当前正在执行作业。</strong></p><ul><li>轮转调度算法RR</li></ul><p>轮流使用时间片，剥夺式调度。<strong>合适选取时间片的长度很重要，如果时间片太长了就会变成FCFS，如果太短了就会使系统调度开销很大。</strong></p><ul><li>多级反馈队列调度算法MLFQ</li></ul><p>又称反馈循环队列或多队列策略。主要思想是将就绪进程分为两级或多级，系统相应建立两个或多个就绪进程队列，<strong>较高优先级的队列一般分配给较短的时间片。</strong></p><p>处理器调度<strong>先从高级就绪进程队列中选取可占有处理器的进程，只有在选不到时，才从较低级的就绪进程队列中选取。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;处理器概念&quot;&gt;1 处理器概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15870310461239.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;特权指令和非特权指令、管态和目态已在上一篇提及。&lt;/p&gt;
&lt;p&gt;Intel的X
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode56-合并区间</title>
    <link href="https://www.codetool.top/article/leetcode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://www.codetool.top/article/leetcode56-合并区间/</id>
    <published>2020-04-16T06:29:48.000Z</published>
    <updated>2020-04-16T06:34:17.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]<br><strong>输出:</strong> [[1,6],[8,10],[15,18]]<br><strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [[1,4],[4,5]]<br><strong>输出:</strong> [[1,5]]<br><strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode435-无重叠区间">leetcode435-无重叠区间</a>方法有一点类似，先排序，再处理区间。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> intervals<span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>array1<span class="token punctuation">,</span>array2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">return</span> array1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>array2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果两个区间没有重叠部分，都保留</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>intervals<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lastIndex <span class="token operator">=</span> cur<span class="token punctuation">;</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果两个区间重叠，合并两个区间</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>intervals<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [[1,3],[2,6],[8,10],[15
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode191-位1的个数</title>
    <link href="https://www.codetool.top/article/leetcode191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode191-位1的个数/</id>
    <published>2020-04-15T06:23:54.000Z</published>
    <updated>2020-04-15T06:59:12.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 3<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000010000000<br><strong>输出：</strong> 1<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 31<br><strong>解释：</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p></blockquote><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>进阶:</strong><br>如果多次调用这个函数，你将如何优化你的算法？</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>可以用位运算</p><h2 id="代码">2.2 代码</h2><p>冷酷无情的API选手做法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> num <span class="token operator">:</span>chars<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span>  sum <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>按位与算法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP浏览器缓存策略和相关首部字段</title>
    <link href="https://www.codetool.top/article/HTTP%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.codetool.top/article/HTTP浏览器缓存策略和服务器的缓存控制/</id>
    <published>2020-04-14T16:11:19.000Z</published>
    <updated>2020-04-14T17:58:07.305Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="noopener">HTTP强缓存和协商缓存 - JavaScript学习笔记 - SegmentFault 思否</a></p><p><a href="https://blog.csdn.net/jiangshangchunjiezi/article/details/88581824" target="_blank" rel="noopener">（七）条件请求If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since_Python_FixedStar 的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zl399615007/article/details/84534884" target="_blank" rel="noopener">强制缓存（200）和协商缓存（304）整理_网络_zlong的博客-CSDN博客</a></p><p>在一次HTTP通信中，最接近用户的缓存应该就是浏览器的缓存了，而浏览器到底什么时候走缓存，什么时候请求服务器呢？和服务器有关吗？这篇文章里，就来谈一谈浏览器的缓存策略。</p><h1 id="浏览器缓存概述">1 浏览器缓存概述</h1><p>浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。</p><p>浏览器缓存有以下优点：</p><ol><li>减少冗余数据传输</li><li>减少服务器负担</li><li>加载客户端加载网页的速度</li></ol><h1 id="浏览器请求资源流程图">2 浏览器请求资源流程图</h1><p><img src="https://api.codetool.top/img/15868806136371.png" alt></p><p>这张图里涉及到两个概念：<code>强缓存</code>和<code>协商缓存</code>，浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：<strong>强缓存命中的话不会发请求到服务器（比如 chrome 中的 200 from memory cache）</strong>，协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，<strong>如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。</strong></p><h1 id="强缓存">3 强缓存</h1><p>什么时候会使用强缓存？<strong>打开页面请求资源（或前进、后退、重定向）</strong>的时候会先获取该资源缓存的header信息，然后根据header中的<code>Cache-Control</code>和<code>Expires</code>来判断是否过期，<strong>如果发现本地缓存还没过期，则使用强缓存。</strong></p><p>强缓存利用http头中的<code>Expires</code>和<code>Cache-Control</code>两个字段来控制，用来表示<strong>资源缓存时间</strong>。但<strong>只要刷新就不会使用强缓存</strong>，普通刷新（F5或点击刷新按钮）会忽略它，但是不会清除它，并且请求会带上<code>Cache-Control: max-age=0</code>。强制刷新（Ctrl+F5）则会清除缓存。<strong>并且请求会带上<code>Cache-Control:no-cache</code></strong>，代表该请求不会使用缓存，且不会记录缓存。</p><p>控制强缓存的字段（选其一使用即可）：</p><h2 id="Expires">3.1 Expires</h2><p>Expires是HTTP/1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串，代表资源的失效时间，只要发送的请求在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以<strong>当服务器与客户端时间偏差较大时，就会导致缓存混乱</strong>。如果同时出现Cache-Control:max-age和Expires，那么<strong>max-age的优先级更高</strong>。</p><h2 id="Cache-Control">3.2 Cache-Control</h2><p>Cache-Control 是一个通用首部字段（请求头和响应头都可以用），也是 HTTP/1.1 控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p><ul><li><code>max-age</code>（单位为 s）：设置<strong>缓存的存在时间，相对于发送请求的时间（即响应头中的Date字段）</strong>。只有响应报文首部设置<code>Cache-Control</code>为<strong>非0的max-age</strong>或者设置了大于请求日期的 Expires才有可能命中强缓存。</li><li><code>no-cache</code> 表示<strong>请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存）</strong>，无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。浏览器强制刷新就会带上<code>Cache-Control:no-cache</code>。</li><li><code>no-store</code>：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面，<strong>一定不会出现强缓存和协商缓存</strong>。</li><li><code>must-revalidate</code>：如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。这个值通常配合<code>max-age</code>使用。</li><li><code>public</code>：表明响应可以被浏览器、CDN 等等缓存。</li><li><code>private</code>：响应只作为私有的缓存，不能被 CDN 等缓存。如果要求 HTTP 认证，响应会自动设置为 private。</li></ul><h1 id="协商缓存">4 协商缓存</h1><p>协商缓存就是<strong>由服务器来确定缓存的资源是否可用</strong>，所以客户端与服务器要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p><p>当缓存的<code>max-age</code>过期或浏览器普通刷新，就会启用协商缓存。浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器，服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同，若相同，就将<code>If-None-Match</code>的值设为<code>false</code>，返回状态<code>304</code>，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将<code>If-None-Match</code>的值设为<code>true</code>，返回状态为200，客户端重新解析服务器端返回的数据；<strong>客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的最后修改时间戳（<code>Last-Modified</code>）发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的</strong>，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</p><p>控制协商缓存的字段（选其一使用即可）：</p><h2 id="Last-Modified-If-Modified-Since">4.1 Last-Modified/If-Modified-Since</h2><p><strong><code>If-Modified-Since</code> 是一个请求首部字段</strong>，并且只能用在 GET 或者 HEAD 请求中。<strong><code>Last-Modified</code> 是一个响应首部字段</strong>，包含服务器认定的资源作出修改的日期及时间。<strong>当带着 If-Modified-Since 头访问服务器请求资源时，服务器会检查 Last-Modified，如果 Last-Modified 的时间早于或等于If-Modified-Since 则会返回一个不带主体的 304 响应，</strong>否则将重新返回资源。</p><h2 id="ETag-If-None-Match">4.2 ETag/If-None-Match</h2><p><code>ETag</code> 是一个响应首部字段，它是<strong>根据实体内容生成的一段 hash 字符串，标识资源的状态</strong>，由服务端产生。<code>If-None-Match</code> 是一个条件式的请求首部。<strong>如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的 ETag，则当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的 200 响应，否则服务器会返回不带实体的 304 响应。</strong> <strong>ETag 优先级比 Last-Modified 高</strong>，同时存在时会以 ETag 为准。</p><p><img src="https://api.codetool.top/img/15868853077728.png" alt></p><p>ETag 还有“强”“弱”之分：<strong>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个<code>“W/”</code>标记，只要求资源在语义上没有变化</strong>，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p><p>下面是一次etag命中（你可以打开开发者工具，尝试刷新我的博客，观察结果）：</p><p><img src="https://api.codetool.top/img/15868860702089.png" alt="请求头"></p><p><img src="https://api.codetool.top/img/15868861139012.png" alt="响应头"></p><p>因为 ETag 的特性，所以相较于 Last-Modified 有一些优势：</p><ol><li>某些情况下服务器无法获取资源的最后修改时间</li><li><strong>资源的最后修改时间变了但是内容没变，使用 <code>ETag</code>可以正确缓存</strong></li><li>如果资源修改非常频繁，在秒以下的时间进行修改，<code>Last-Modified</code> 只能精确到秒</li></ol><p>协商缓存属于HTTP<strong>条件请求</strong>的一部分，条件请求还有<code>If-Unmodified-Since</code>，<code>If-Match</code>，<code>If-Range</code>等字段（用于断点续传，和412状态码有关）</p><h1 id="详细总结流程图">5 详细总结流程图</h1><p><img src="https://api.codetool.top/img/15868850187041.png" alt></p><p>注意：Pragma已被废弃。</p><p>下表是用户操作对强缓存/协商缓存的影响：</p><table><thead><tr><th>用户操作</th><th>Expires/Cache-Control</th><th>Last-Modified/Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td>有效</td><td>有效</td></tr><tr><td>页面链接跳转</td><td>有效</td><td>有效</td></tr><tr><td>新开窗口</td><td>有效</td><td>有效</td></tr><tr><td>前进后退</td><td>有效</td><td>有效</td></tr><tr><td>F5刷新</td><td>无效</td><td>有效</td></tr><tr><td>Ctrl+F5强制刷新</td><td>无效</td><td>无效</td></tr></tbody></table><p>需要注意的是，我在chrome中实验发现，当服务器没有响应Cache-Control、Expire相关字段的时候，一定时间内再次访问网站依然会走<code>200(from disk cache)</code>强缓存，可能是和浏览器本身的策略有关，或是<code>Cache-Control</code>有默认值？我在网络上没有查询到资料明确指出<code>Cache-Control</code>是否有默认值，或者<code>max-age</code>的默认值为多少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008956069&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP强缓存和协商缓存 - JavaScript学习笔记 - Segme
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计网复习07-应用层之HTTP报文格式</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A007-%E5%BA%94%E7%94%A8%E5%B1%82%E4%B9%8BHTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/"/>
    <id>https://www.codetool.top/article/计网复习07-应用层之HTTP报文格式/</id>
    <published>2020-04-14T14:18:50.000Z</published>
    <updated>2020-04-14T15:49:30.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP报文概述">1 HTTP报文概述</h1><p>HTTP概述在<a href="../HTTP版本发展与Google的暗中助力/">HTTP版本发展与Google的暗中助力</a> 中已经说得差不多了，这篇文章来专门讲一下HTTP的报文格式</p><p><img src="https://api.codetool.top/img/15868743125701.png" alt></p><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）：描述请求或响应的基本信息；</li><li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li><li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li></ul><p>这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。</p><p>HTTP报文是面向文本的，因此header都是一些ASCII码串，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。（所以中文通常要经过urlencode）</p><p>HTTP 协议规定报文必须有 header，但可以没有 body，<strong>而且在 header 之后必须要有一个“空行”</strong>，也就是“CRLF”，十六进制的<code>“0D0A”</code>。</p><h1 id="请求行-amp-状态行">2 请求行&amp;状态行</h1><h2 id="请求行">2.1 请求行</h2><p><img src="https://api.codetool.top/img/15868744881740.png" alt></p><p>请求行是请求报文中的第一行，请求行由三部分构成：</p><ol><li>请求方法：是一个动词，如 GET/POST，表示对资源的操作。事实上，请求方法的语义并没有被严格遵守，直到RESTful API的广泛应用，才使得请求方法的语义变得重要了起来。</li></ol><table><thead><tr><th>方法（操作）</th><th>意义</th></tr></thead><tbody><tr><td>OPTION</td><td>请求一些选项的信息</td></tr><tr><td>GET</td><td>请求读取由 URL所标志的信息</td></tr><tr><td>HEAD</td><td>请求读取由 URL所标志的信息的首部</td></tr><tr><td>POST</td><td>给服务器添加信息（例如，注释）</td></tr><tr><td>PUT</td><td>在指明的 URL下存储一个文档</td></tr><tr><td>DELETE</td><td>删除指明的 URL所标志的资源</td></tr><tr><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><p>关于请求方法，我们通常谈到幂等性，相关内容可以参考<a href="../Http请求的幂等性/">Http请求的幂等性</a></p><ol start="2"><li>请求目标：通常是一个 URI，标记了请求方法要操作的资源。</li><li>版本号：表示报文使用的 HTTP 协议版本。</li></ol><p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p><h2 id="状态行">2.2 状态行</h2><p>状态行是响应报文中的第一行，与请求行的结构类似。</p><p><img src="https://api.codetool.top/img/15868750209984.png" alt></p><p>状态行包括三项内容:</p><ol><li>版本号：表示报文使用的 HTTP 协议版本。</li><li>状态码：一个三位数，用代码的形式表示处理的结果。我在<a href="../SpringBoot开发RESTful%20API">SpringBoot开发RESTful API</a>中列举了常用的HTTP状态码。</li><li>短语：解释状态码的简单短语，帮助人理解原因。对于常见的状态码200，后面跟的短语可能就是<code>OK</code>。</li></ol><h1 id="头部字段（首部行）">3 头部字段（首部行）</h1><p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头。请求报文和响应报文中的头部字段的格式都是一样的，只是字段可能有所区别。</p><p>头部字段是 key-value 的形式，key 和 value 之间用<code>“: ”</code>分隔，最后用 CRLF 换行表示字段结束。比如在<code>“Host: 127.0.0.1”</code>这一行里 key 就是<code>“Host”</code>，value 就是<code>“127.0.0.1”</code>。</p><p>使用头字段需要注意下面几点：</p><ul><li>字段名<strong>不区分大小写</strong>，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li><li>字段名里<strong>不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”</strong>。例如，<code>“test-name”</code>是合法的字段名，而<code>“test name”``“test_name”</code>是不正确的字段名；</li><li>字段名后面必须紧接着“:”，不能有空格，<strong>而“:”后的字段值前可以有多个空格</strong>；</li><li>字段的顺序是没有意义的，可以任意排列不影响语义；</li><li>字段<strong>原则上不能重复</strong>，除非这个字段本身的语义允许，例如 Set-Cookie。</li></ul><h2 id="Content-Type-amp-Content-Encoding">3.1 Content-Type&amp;Content-Encoding</h2><p><code>Content-Type</code>：标识body的内容类型，取值通过<code>“MIME type”</code>标准确定，MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</p><p>这里简单列举一下在 HTTP 里经常遇到的几个类别：</p><ul><li><code>text</code>：即文本格式的可读数据，我们最熟悉的应该就是 <code>text/html</code> 了，表示超文本文档，此外还有纯文本 <code>text/plain</code>、样式表 <code>text/css</code> 等。</li><li><code>image</code>：即图像文件，有 <code>image/gif</code>、<code>image/jpeg</code>、<code>image/png</code> 等。</li><li><code>audio/video</code>：音频和视频数据，例如 <code>audio/mpeg</code>、<code>video/mp4</code> 等。</li><li><code>application</code>：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 <code>application/json</code>，<code>application/javascript</code>、<code>application/pdf</code> 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 <code>application/octet-stream</code>，即不透明的二进制数据。</li></ul><p>需要注意的是以<code>x-</code>开头的类型是我们自定义的类型。使用<code>*</code>代表任意类型。</p><p><code>Content-Encoding</code>：告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。如果响应报文里没有 <code>Content-Encoding</code> 字段，就表示响应数据没有被压缩。常见的<code>Content-Encoding</code>：</p><ul><li><code>gzip</code>：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li><li><code>deflate</code>：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li><li><code>br</code>：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li></ul><h2 id="Accept-amp-Accept-Encoding">3.2 Accept&amp;Accept-Encoding</h2><p>如果服务器一厢情愿发送特定的数据类型而客户端解析不了也不行，所以请求首部字段中通常会有<code>Accept</code>字段，代表客户端可理解的 MIME type，用<code>,</code>做分隔符列出多个类型。对应的，也存在<code>Accept-Encoding</code>字段，代表客户端支持的压缩格式。服务器通常要通过这两个字段决定响应的数据类型。</p><h2 id="其他Accept-和Content-字段">3.3 其他Accept-和Content-字段</h2><p><code>Accept-Language</code>代表客户端可理解的自然语言，<code>Content-Language</code>告诉客户端实体数据使用的实际语言类型。</p><p><code>Accept-Charset</code>代表客户端可解析的字符集，<strong>响应报文并不会有<code>Content-Charset</code>，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示。</strong></p><p>不过现在的浏览器都支持多种字符集，通常不会发送 <code>Accept-Charset</code>，而服务器也不会发送 <code>Content-Language</code>，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 <code>Accept-Language</code> 字段，响应头里只会有 <code>Content-Type</code> 字段。</p><h2 id="内容协商的质量值">3.4 内容协商的质量值</h2><p>我们称以上<code>Accept-*</code>和<code>Content-*</code>字段为客户端和服务端对传输的内容进行<strong>内容协商</strong>，在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，<strong>还可以用一种特殊的“q”参数表示权重来设定优先级</strong>，这里的“q”是“quality factor”的意思。</p><p>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个<code>;</code>，然后是<code>q=value</code>。</p><p>例如：</p><pre><code>Accept: text/html,application/xml;q=0.9,*/*;q=0.8</code></pre><p>它表示浏览器最希望使用的是 HTML 文件，权重是 <code>1</code>，其次是 XML 文件，权重是 <code>0.9</code>，最后是任意数据类型，权重是 <code>0.8</code>。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p><h2 id="内容协商的结果">3.5 内容协商的结果</h2><p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个<code>Vary</code>字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p><pre><code>Vary: Accept-Encoding,User-Agent,Accept</code></pre><p>这个 <code>Vary</code> 字段表示服务器依据了 <code>Accept-Encoding</code>、<code>User-Agent</code> 和 <code>Accept</code> 这三个头字段，然后决定了发回的响应报文。</p><h2 id="其他常见的头部字段">3.6 其他常见的头部字段</h2><p><code>Host</code>字段，它属于<strong>请求字段</strong>，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里<strong>要求必须出现的字段</strong>，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。<strong>Host 字段告诉服务器这个请求应该由哪个主机来处理</strong>，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p><p><code>User-Agent</code>是<strong>请求字段</strong>，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是<code>“Mozilla”``“Chrome”``“Safari”</code>，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。</p><p><code>Date</code>字段是一个通用字段，但<strong>通常出现在响应头里，表示 HTTP 报文创建的时间</strong>，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p><p><code>Server</code>字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如<code>nginx/1.**</code>。<strong>Server 字段也不是必须要出现的</strong>，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，<strong>有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</strong></p><p><code>Content-Length</code>，它表示报文里 body 的长度，也就是<strong>请求头或响应头空行后面数据的长度</strong>。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。<strong>如果没有这个字段，那么 body 就是不定长的，需要使用 <code>chunked</code> 方式分段传输。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP报文概述&quot;&gt;1 HTTP报文概述&lt;/h1&gt;&lt;p&gt;HTTP概述在&lt;a href=&quot;../HTTP版本发展与Google的暗中助力/&quot;&gt;HTTP版本发展与Google的暗中助力&lt;/a&gt; 中已经说得差不多了，这篇文章来专门讲一下HTTP的报文格式&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计网复习06-应用层之域名系统DNS</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A006-%E5%BA%94%E7%94%A8%E5%B1%82%E4%B9%8B%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <id>https://www.codetool.top/article/计网复习06-应用层之域名系统DNS/</id>
    <published>2020-04-14T04:11:10.000Z</published>
    <updated>2020-04-14T05:24:05.417Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://blog.csdn.net/grace_yi/article/details/89419106" target="_blank" rel="noopener">全局负载均衡（GSLB）的实现方案_运维_奔向云计算的笨鸟的专栏-CSDN博客</a></p><p><a href="https://blog.csdn.net/cywosp/article/details/38017027" target="_blank" rel="noopener">每天进步一点点——负载均衡之DNS域名解析_运维_Cynric 的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/zhuxiangru/p/9536092.html" target="_blank" rel="noopener">几种域名解析类型和使用方式 - 菜鸟的一天 - 博客园</a></p><p>现在网站的数目非常多，如果全部用 IP 地址进行访问，恐怕很难记住。许多应用层软件经常直接使用<strong>域名系统</strong>(DNS, Domain Name System)，但计算机的用户只是间接而不是直接使用域名系统。 </p><h1 id="域名系统DNS">1 域名系统DNS</h1><p>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。<br>互联网采用了<strong>层次树状结构</strong>的命名方法，域名的结构由标号序列组成，各标号之间用点隔开：</p><pre><code>….三级域名.二级域名.顶级域名</code></pre><p>对于我的博客 <a href="http://www.codetool.top">http://www.codetool.top</a> ，top就是顶级域名，codetool是二级域名。</p><p>最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。</p><p>域名只是个逻辑概念，并不代表计算机所在的物理地点。</p><h2 id="常见顶级域名">1.1 常见顶级域名</h2><ol><li>国家顶级域名 nTLD<ul><li><code>.cn</code> 表示中国，</li><li><code>.us</code> 表示美国，</li><li><code>.uk</code> 表示英国，等等。</li></ul></li><li>通用顶级域名 gTLD<br> 最早的顶级域名是：<ul><li><code>.com</code>    （公司和企业）</li><li><code>.net</code>    （网络服务机构</li><li><code>.org</code>    （非赢利性组织）</li><li><code>.edu</code>    （美国专用的教育机构）</li><li><code>.gov</code>    （美国专用的政府部门）</li><li><code>.mil</code>    （美国专用的军事部门）</li><li><code>.int</code>    （国际组织）</li></ul></li><li>基础结构域名 (infrastructure domain)：这种顶级域名只有一个，即 <code>arpa</code>，用于反向域名解析，因此又称为反向域名。 </li></ol><p>随着互联网的发展，出现了很多新增的顶级域名，这里不谈。</p><h2 id="注意事项">1.2 注意事项</h2><ol><li>域名已经支持中文，不过不被广泛使用</li><li>域名的总长度限制在253个字符以内，而<strong>每一级域名长度不能超过63个字符</strong>。</li><li>域名是大小写无关的，但通常都使用小写的形式。</li><li>过长的域名或者过多的层次关系也会导致与IP 地址同样难于记忆的问题，所以常见的域名大多是两级或三级，四级以上的很少见。</li></ol><h1 id="DNS服务器">2 DNS服务器</h1><p><strong>域名到 IP 地址的解析是由若干个域名服务器程序完成的</strong>。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。  </p><p>一个服务器所负责管辖的（或有权限的）范围叫做区 (zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。  </p><p><img src="https://api.codetool.top/img/15868392791161.png" alt></p><p>域名服务器有以下四种类型：</p><ul><li>根域名服务器：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域名服务器：返回权威 DNS 服务器的 IP 地址</li><li>权限（权威）域名服务器：返回相应主机的 IP 地址</li><li>本地域名服务器 </li></ul><p><img src="https://api.codetool.top/img/15868398223943.png" alt></p><h2 id="根域名服务器">2.1 根域名服务器</h2><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。<strong>所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</strong></p><p>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</p><p>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a一直到m（前 13 个字母），它们又有数百台的镜像，保证一定能够被访问到。</p><p>根域名服务器共有 13 套装置，不是 13 个机器。这些根域名服务器相应的域名分别是：</p><pre><code>a.rootservers.netb.rootservers.net… m.rootservers.net</code></pre><p>到2016年2月，全世界已经在 588 个地点安装了根域名服务器，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器。 </p><h2 id="顶级域名服务器">2.2 顶级域名服务器</h2><p>顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。</p><p>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 </p><h2 id="权限域名服务器">2.3 权限域名服务器</h2><p>负责一个区的域名服务器。</p><p>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 </p><h2 id="本地域名服务器">2.4 本地域名服务器</h2><p>本地域名服务器对域名系统非常重要。</p><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。 </p><h1 id="域名的解析过程">3 域名的解析过程</h1><p><strong>主机向本地域名服务器的查询一般都是采用递归查询。</strong>如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p><p><img src="https://api.codetool.top/img/15868400281344.png" alt></p><p><strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询。</strong>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><p><img src="https://api.codetool.top/img/1586840043224.png" alt></p><h1 id="域名的高速缓存">4 域名的高速缓存</h1><p>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。 </p><p><strong>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项</strong>（例如，每个项目只存放两天）。</p><p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。 </p><p>另外，<strong>操作系统里也会对 DNS 解析结果做缓存</strong>，如果你之前访问过“<a href="http://www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到" target="_blank" rel="noopener">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p><h1 id="hosts文件">5 hosts文件</h1><p>操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是<code>“/etc/hosts”</code>，在 Windows 里是<code>“C:\WINDOWS\system32\drivers\etc\hosts”</code>，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p><h1 id="几种域名解析类型">6 几种域名解析类型</h1><h2 id="A记录">6.1 A记录</h2><p>最简单最常用，添加记录时候填写IP地址即可。A记录(Address)是用来<strong>指定主机名（或域名）对应的IP地址记录。</strong>通过A记录您可以将该域名指向到自己的网站服务器IP地址，同时也可以设置您域名的二级域名。 </p><h2 id="MX记录">6.2 MX记录</h2><p>是<code>Mail Exchanger</code>的缩写，意思是邮件交换记录。它<strong>指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。</strong>例如，当Internet上的某用户要发一封信给 <a href="mailto:user@vipiis.com" target="_blank" rel="noopener">user@vipiis.com</a>时，该用户的邮件系统通过DNS查找vipiis.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。 </p><h2 id="CNAME记录">6.3 CNAME记录</h2><p>也被称为别名记录，<strong>是双线智能解析和使用CDN加速必须用到的解析方法</strong>。CNAME解析通常是一个三级域名地址，您可以在主机管理后台”绑定域名”位置看到cname解析地址的信息提示，不同服务器会使用不同的cname解析地址。<strong>通过cname解析，可以让域名捆绑到多个服务器IP地址</strong>，需要注意的是cname解析地址后面有个英文“.”符号。 </p><p>通常来说，别名解析可以提供更大的灵活性，便于统一管理。举个例子来说，当主机因各种因素的影响需要更换IP时，如果域名做了CNAME记录，就可以同时更新别名的解析指向，不用需要进行新的解析操作，也就是说可以做到无缝更换IP，这对实际中IP的维护是很实用的。而且对于双线主机来说，电信和联通有不同的接口对应不同的IP,由于A记录只能指向一个IP,这时采用别名解析就可以很好的解决这个问题。当然了CNAME记录也存在一定的不足，很多人认为不同的IP会对网站优化产生一定的影响，当搜索引擎爬虫每次爬行的时候，IP变化容易让爬虫产生网站不稳定的误解。不过见仁见智，到底好不好还需要自己去判断。</p><h2 id="NS记录">6.4 NS记录</h2><p>是域名DNS服务器记录，全称Name Server记录，<strong>用来指定该域名由哪个DNS服务器来对您的域名进行解析。</strong>您注册域名时，总有默认的DNS服务器，每个注册的域名都是由一组DNS域名服务器来解析的。</p><h2 id="TXT记录">6.5 TXT记录</h2><p>一种文本记录，仅用于对主机名或者域名的记录信息，对解析无实质影响。</p><h2 id="TTL值">6.6 TTL值</h2><p>全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。默认即可。 </p><h1 id="基于DNS的负载均衡">7 基于DNS的负载均衡</h1><p>这里先谈谈什么是内部负载均衡（SLB）和全局负载均衡（GSLB）？</p><p>SLB(Server load balancing)是<strong>对集群内物理主机的负载均衡</strong>，而GSLB是<strong>对物理集群的负载均衡。</strong>这里的负载均衡可能不只是简单的流量均匀分配,而是会根据策略的不同实现不同场景的应用交付。</p><p>GSLB是依赖于用户和实际部署环境的互联网资源分发技术，不同的目的对应着一系列不同的技术实现。</p><h2 id="内部负载均衡">7.1 内部负载均衡</h2><p>使用DNS实现内部负载均衡较简单，直接<strong>将域名解析到多个IP地址</strong>，下面是利用DNS工作原理处理负载均衡的工作原理图：</p><p><img src="https://api.codetool.top/img/15868409833833.png" alt></p><p>由上图可以看出，在DNS服务器中应该配置了多个A记录，如：</p><pre><code>www.apusapp.com IN A 114.100.20.201;www.apusapp.com IN A 114.100.20.202;www.apusapp.com IN A 114.100.20.203;</code></pre><h2 id="全局负载均衡">7.2 全局负载均衡</h2><p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。</p><p>另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心（就近访问），这样，客户体验就会非常好，访问速度就会超快。</p><p>使用DNS实现全局负载均衡是在DNS服务器关联GSLB设备，它通过自定义的策略根据客户IP地理位置、运营商、可用集群等信息为客户分配合适的主机。</p><p><img src="https://api.codetool.top/img/15868416855058.png" alt></p><h1 id="DNS劫持">8 DNS劫持</h1><p>域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，<strong>把目标网站域名解析到错误的IP地址</strong>从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。</p><p>如何解决？使用可靠的DNS服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/grace_yi/article/details/89419106&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全局负载均衡（GSLB）的实现方案_运维_奔向云计
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
