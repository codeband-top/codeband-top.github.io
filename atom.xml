<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-05-29T04:18:08.388Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode198-打家劫舍</title>
    <link href="https://www.codetool.top/article/leetcode198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://www.codetool.top/article/leetcode198-打家劫舍/</id>
    <published>2020-05-29T04:01:14.000Z</published>
    <updated>2020-05-29T04:18:08.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [2,7,9,3,1]<br><strong>输出:</strong> 12<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，到第n间偷取的最高金额是<code>n-2间偷取的最高金额+该间金额</code>和<code>n-1间偷取的最高金额</code>的最大值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> second <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> second<span class="token punctuation">;</span>            second <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>first <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>            first <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏04</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F04/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏04/</id>
    <published>2020-05-28T06:48:37.000Z</published>
    <updated>2020-05-29T12:16:13.515Z</updated>
    
    <content type="html"><![CDATA[<p>继续我的复习刷题</p><h1 id="接口方法可以使用abstract修饰">1 接口方法可以使用abstract修饰</h1><p>问题：</p><p>java接口的方法修饰符可以为？(忽略内部接口)</p><p>A. private<br>B. protected<br>C. final<br>D. abstract  </p><p>正确答案: D   你的答案: D (正确)</p><p>虽然说接口中的方法都是抽象的，平时不写abstract，但是是可以使用abstract修饰的，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TestInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码没有任何问题，但Idea会好心提示：<code>Modifier &#39;abstract&#39; is redundant for interface methods</code>（即这个修饰符是多余的）</p><h1 id="lt-init-gt-方法是怎么组成的">2 &lt;init&gt;方法是怎么组成的</h1><p>问题：</p><p>在创建派生类对象，构造函数的执行顺序（）</p><p>A. 基类构造函数，派生类对象成员构造函数，派生类本身的构造函数<br>B. 派生类本身的构造函数，基类构造函数，对象成员构造函数<br>C. 基类构造函数，派生类本身的构造函数，派生类对象成员构造函数<br>D. 对象成员构造函数，基类构造函数，派生类本身的构造函数  </p><p>正确答案: A   你的答案: C (错误)</p><p>这道题我不太理解所谓的<code>对象成员构造函数</code>是什么，后面想了一下应该是指如果成员字段是一个对象的话，调用的构造函数吧。</p><p>那么这其实就涉及<code>&lt;init&gt;</code>这个方法的知识点了。</p><p><code>&lt;cinit&gt;</code>这个方法的组成特别好记：就是静态字段赋值和静态代码块从上到下连接构成的。</p><p>然而<code>&lt;init&gt;</code>这个方法呢？</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 成员字段的类别</span><span class="token keyword">class</span> <span class="token class-name">ChildrenClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ChildrenClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成员字段的赋值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BaseClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">BaseClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类的非静态域"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConstructor2</span> <span class="token keyword">extends</span> <span class="token class-name">BaseClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">TestConstructor2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自身的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自身的非静态域"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ChildrenClass childrenClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChildrenClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TestConstructor2 constructor2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestConstructor2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先看一下这段代码，输出是什么？</p><pre><code>父类的非静态域父类的构造函数自身的非静态域成员字段的赋值自身的构造函数</code></pre><p>再看一下字节码：</p><pre><code>---------调用父类的init方法------------- 0 aload_0 1 invokespecial #1 &lt;com/rhett/javafoundation/BaseClass.&lt;init&gt;&gt;---------非静态域方法------------------ 4 getstatic #2 &lt;java/lang/System.out&gt; 7 ldc #3 &lt;自身的非静态域&gt; 9 invokevirtual #4 &lt;java/io/PrintStream.println&gt;---------成员字段的赋值-----------------12 aload_013 new #5 &lt;com/rhett/javafoundation/ChildrenClass&gt;16 dup17 invokespecial #6 &lt;com/rhett/javafoundation/ChildrenClass.&lt;init&gt;&gt;20 putfield #7 &lt;com/rhett/javafoundation/TestConstructor2.childrenClass&gt;---------自身的构造函数-----------------23 getstatic #2 &lt;java/lang/System.out&gt;26 ldc #8 &lt;自身的构造函数&gt;28 invokevirtual #4 &lt;java/io/PrintStream.println&gt;31 return</code></pre><p>可以看到，顺序是这样的：</p><ol><li>调用父类的<init>方法</init></li><li>非静态域方法+成员字段的赋值（经实测，这两个的顺序就是代码中书写的顺序从上到下构成的）</li><li>自身的构造函数</li></ol><h1 id="字符串相加会触发从字符串常量池中取值吗">3 字符串相加会触发从字符串常量池中取值吗</h1><p>题目：</p><p>有以下代码片段：</p><pre class=" language-java"><code class="language-java">String str1<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>String str2<span class="token operator">=</span><span class="token string">"he"</span><span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"llo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>请问输出的结果是：</p><p>A. true<br>B. 都不对<br>C. null<br>D. false  </p><p>正确答案: D   你的答案: A (错误)</p><p>字符串字面量的机制，我已经在<a href="../String-s-new-String-123-创建了几个String对象？">String s = new String(“123”);创建了几个String对象？</a>中谈过了，然而这道题目我还是选错了，主要是没有认真思考，像这样的字符串加法，是不存在编译时优化的，<strong>内部机制还是通过使用StringBuilder去实现的字符串拼接，最终结果和字符串常量池中的对象肯定是不同的。</strong></p><p>那什么情况下会出现编译时优化呢？就是修改为下面这段代码：</p><pre class=" language-java"><code class="language-java">String str1<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>String str2<span class="token operator">=</span><span class="token string">"he"</span><span class="token operator">+</span><span class="token string">"llo"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>就会输出为true了。</p><h1 id="Java的自动转型规则">4 Java的自动转型规则</h1><p>题目：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span> b1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b2<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b3<span class="token punctuation">,</span>b6<span class="token punctuation">,</span>b8<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">byte</span> b4<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>b5<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>b7<span class="token punctuation">;</span>b3<span class="token operator">=</span><span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*语句1*/</span>b6<span class="token operator">=</span>b4<span class="token operator">+</span>b5<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*语句2*/</span>b8<span class="token operator">=</span><span class="token punctuation">(</span>b1<span class="token operator">+</span>b4<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*语句3*/</span>b7<span class="token operator">=</span><span class="token punctuation">(</span>b2<span class="token operator">+</span>b5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*语句4*/</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b3<span class="token operator">+</span>b6<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下列代码片段中，存在编译错误的语句是()</p><p>A. 语句2<br>B. 语句1<br>C. 语句3<br>D. 语句4</p><p>正确答案: B C D   你的答案: D (错误)</p><p>这道题涉及一个知识点，我之前确实不知道：（来自牛客网用户：Pandora）</p><p>Java表达式转型规则由低到高转换：</p><ol><li><strong>所有的byte,short,char型的值将被提升为int型</strong>；</li><li>如果有一个操作数是long型，计算结果是long型；</li><li>如果有一个操作数是float型，计算结果是float型；</li><li>如果有一个操作数是double型，计算结果是double型；</li><li><strong>被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化</strong>。</li></ol><p>第一点这个规则大概是因为没有对应的字节码操作指令，但我确实不知道会自动转为int。</p><p>因此：</p><ul><li>语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；</li><li>语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；</li><li>语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);</li><li>语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续我的复习刷题&lt;/p&gt;
&lt;h1 id=&quot;接口方法可以使用abstract修饰&quot;&gt;1 接口方法可以使用abstract修饰&lt;/h1&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;java接口的方法修饰符可以为？(忽略内部接口)&lt;/p&gt;
&lt;p&gt;A. private&lt;br&gt;B. protecte
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode443-压缩字符串</title>
    <link href="https://www.codetool.top/article/leetcode443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode443-压缩字符串/</id>
    <published>2020-05-28T02:56:31.000Z</published>
    <updated>2020-05-28T03:08:54.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一组字符，使用原地算法将其压缩。</p><p>压缩后的长度必须始终小于或等于原数组长度。</p><p>数组的每个元素应该是长度为1 的<strong>字符</strong>（不是 int 整数类型）。</p><p>在完成原地<strong>修改输入数组</strong>后，返回数组的新长度。</p><p><strong>进阶：</strong><br>你能否仅使用O(1) 空间解决问题？</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>["a","a","b","b","c","c","c"]<strong>输出：</strong>返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]<strong>说明：</strong>"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>["a"]<strong>输出：</strong>返回1，输入数组的前1个字符应该是：["a"]<strong>说明：</strong>没有任何字符串被替代。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>["a","b","b","b","b","b","b","b","b","b","b","b","b"]<strong>输出：</strong>返回4，输入数组的前4个字符应该是：["a","b","1","2"]。<strong>说明：</strong>由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。注意每个数字在数组中都有它自己的位置。</pre><p><strong>注意：</strong></p><ol><li>所有字符都有一个ASCII值在<code>[35, 126]</code>区间内。</li><li><code>1 &lt;= len(chars) &lt;= 1000</code>。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>看到这种原地修改字符串，且修改后的字符串比原来要短的题目，基本就是双指针</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compress</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            p2<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">==</span> chars<span class="token punctuation">.</span>length <span class="token operator">||</span> chars<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">!=</span>chars<span class="token punctuation">[</span>p2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                chars<span class="token punctuation">[</span><span class="token operator">++</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>p2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                String num <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        chars<span class="token punctuation">[</span><span class="token operator">++</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一组字符，使用原地算法将其压缩。&lt;/p&gt;
&lt;p&gt;压缩后的长度必须始终小于或等于原数组长度。&lt;/p&gt;
&lt;p&gt;数组的每个元素应该是长度为1 的&lt;strong&gt;字符&lt;/strong&gt;（不是 int 整数类型）。&lt;/p&gt;
&lt;p&gt;在完成原
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏03（附赠哈夫曼树&amp;哈夫曼编码）</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F03/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏03/</id>
    <published>2020-05-27T13:43:13.000Z</published>
    <updated>2020-05-27T14:30:34.086Z</updated>
    
    <content type="html"><![CDATA[<p>继续我的复习刷题</p><h1 id="构造器显式调用父类构造方法的规则">1 构造器显式调用父类构造方法的规则</h1><p>题目：</p><p>以下程序的输出结果为</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Derived</span> <span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>A. BD<br>B. DB<br>C. C<br>D. 编译错误   </p><p>正确答案: D   你的答案: A (错误)</p><p>这道题其实没什么特别的，就是之前对这个规则不熟悉：</p><p>在子类的构造方法中，必须调用父类的构造方法，如果没有显示地调用，编译器会在第一行添加一个父类的无参构造方法，但是如果父类重载了构造方法导致没有无参的构造方法，子类就必须在构造方法中显示地调用父类的构造方法，否则就会报错。</p><h1 id="IO流分为节点流和处理流">2 IO流分为节点流和处理流</h1><p>题目：</p><p>下列流当中，属于处理流的是：（）     </p><p>A. FileInputStream<br>B. InputStream<br>C. DataInputStream<br>D. BufferedInputStream</p><p>正确答案: C D   你的答案: A C (错误)</p><p>这道题选错是不知道节点流和处理流是什么。原来IO流可以这样分类：（来自牛客网用户：无情的AC机器）</p><p><strong>按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。</strong></p><ul><li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li><li>处理流：<strong>是对一个已存在的流的连接和封装</strong>，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul><p>JAVA常用的节点流：</p><ul><li>文 件 <code>FileInputStream</code>、<code>FileOutputStrean</code>、<code>FileReader</code>、<code>FileWriter</code>。文件进行处理的节点流。</li><li>字符串 <code>StringReader</code>、<code>StringWriter</code>。对字符串进行处理的节点流。</li><li>数 组：<code>ByteArrayInputStream</code>、<code>ByteArrayOutputStreamCharArrayReader</code>、<code>CharArrayWriter</code>。对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li><li>管 道：<code>PipedInputStream</code>、<code>PipedOutputStream</code>、<code>PipedReaderPipedWriter</code>。对管道进行处理的节点流。</li></ul><p>常用处理流（关闭处理流使用关闭里面的节点流）</p><ul><li>缓冲流：<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code>。增加缓冲功能，避免频繁读写硬盘。</li><li>转换流：<code>InputStreamReader</code>、<code>OutputStreamReader</code>。实现字节流和字符流之间的转换。</li><li>数据流：<code>DataInputStream</code>、<code>DataOutputStream</code>等。提供<strong>将基础数据类型写入到文件中，或者读取出来</strong>.</li></ul><h1 id="如何通过反射获取和设置对象私有字段的值">3 如何通过反射获取和设置对象私有字段的值</h1><p>这个倒不是刷题刷出来的，就是整理知识点的时候对这个API有点不太熟练，这里复习一下：</p><p><img src="https://api.codetool.top/img/15905882124003.png" alt></p><p>我相信这个思维导图已经概括得很详细了（这只是我复习中整理的一小部分，等我把整个java体系复习完了把整个思维导图分享出来）</p><p>下面上代码说明：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Security</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestReflect</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Security security <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Security</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取字段</span>        Field num <span class="token operator">=</span> security<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置访问权限</span>        num<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修改值</span>        num<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>security<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method getNum <span class="token operator">=</span> security<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"getNum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        getNum<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object invoke <span class="token operator">=</span> getNum<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>security<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>invoke<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码中还有一个知识点：<code>getNum</code>方法返回的是基本类型int，但<strong>invoke只能返回一个Object对象，它会自动把int类型装箱，即变成Integer类型返回</strong>，因此是可以输出的。</p><h1 id="哈夫曼树-amp-哈夫曼编码">4 哈夫曼树&amp;哈夫曼编码</h1><p>哈哈越扯越偏了，这里顺便放一个数据结构的知识点上来，这个不太想单独写一篇博客。</p><p>哈夫曼树，就是使<strong>带权外部路径长度最小</strong>（课本上这样说的）的一种二叉树。</p><p>至于如何计算这个带权外部路径：</p><ol><li>所有外部节点（叶子节点）带有一个权值</li><li><strong>每个外部节点乘以其到根节点的路径长之和</strong>，就是该树的带权外部路径长度。</li></ol><p>如何构造一个哈夫曼树：</p><ol><li>将所有外部节点按权值大小从小到大排序，组成一个有序链表</li><li>取出前两个节点，将它们的值相加，得到一个新的权值，用它构造一个新的节点，同时是这两个节点的父节点，然后把这个新的节点按值的大小插入链表中</li><li>重复第二步，直到组成一棵树</li></ol><p>我不太想画图，累了0v0（复习哪有时间认真写博客）</p><p>注意哈夫曼树是一种满二叉树（满二叉树这个定义有争议，我这里的定义就是除了叶子节点所有的节点的度都为2），即不包含度为1的节点。</p><p>然后哈夫曼树有一个应用就是哈夫曼编码，左边的出度取0，右边的出度取1。从根节点到叶子节点路径上的0、1值组成的就是哈夫曼编码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续我的复习刷题&lt;/p&gt;
&lt;h1 id=&quot;构造器显式调用父类构造方法的规则&quot;&gt;1 构造器显式调用父类构造方法的规则&lt;/h1&gt;&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;以下程序的输出结果为&lt;/p&gt;
&lt;pre class=&quot; language-java&quot;&gt;&lt;code class=&quot;langu
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode974-和可被K整除的子数组</title>
    <link href="https://www.codetool.top/article/leetcode974-%E5%92%8C%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode974-和可被K整除的子数组/</id>
    <published>2020-05-27T03:53:22.000Z</published>
    <updated>2020-05-27T03:55:15.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p><p><strong>示例:</strong>  </p><blockquote><p><strong>输入：</strong> A = [4,5,0,-2,-3,1], K = 5<br><strong>输出：</strong> 7<br><strong>解释：</strong><br>有 7 个子数组满足其元素之和可被 K = 5 整除：<br>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>2 &lt;= K &lt;= 10000</code></li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>看到连续的子数组的和就要想到前缀和</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraysDivByK</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> remainder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">;</span>        remainder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> remain <span class="token operator">=</span> sum<span class="token operator">%</span>K<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>remain<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> remain <span class="token operator">+=</span> K<span class="token punctuation">;</span>            count <span class="token operator">+=</span> remainder<span class="token punctuation">[</span>remain<span class="token punctuation">]</span><span class="token punctuation">;</span>            remainder<span class="token punctuation">[</span>remain<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;A&lt;/code&gt;，返回其中元素之和可被 &lt;code&gt;K&lt;/code&gt; 整除的（连续、非空）子数组的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM常用参数整理</title>
    <link href="https://www.codetool.top/article/JVM%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <id>https://www.codetool.top/article/JVM常用参数整理/</id>
    <published>2020-05-26T14:12:43.000Z</published>
    <updated>2020-05-26T14:43:20.589Z</updated>
    
    <content type="html"><![CDATA[<p>这里不保证完全准确，可以到官方文档上面去验证：</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><h1 id="GC常用参数">1 GC常用参数</h1><ul><li><code>-Xmn</code>：最大年轻代大小</li><li><code>-Xms</code>：最小堆空间</li><li><code>-Xmx</code>：最大堆空间</li><li><code>-Xss</code>：最大栈空间</li><li><code>-XX:+UseTLAB</code>：使用TLAB，默认打开</li><li><code>-XX:+PrintTLAB</code>：打印TLAB的使用情况</li><li><code>-XX:+TLABSize</code>：设置TLAB大小</li><li><code>-XX:+DisableExplictGC</code>：禁用显式的垃圾回收，即<code>System.gc()</code></li><li><code>-XX:+PrintGC</code>：打印GC信息</li><li><code>-XX:+PrintGCDetails</code>：GC详细信息</li><li><code>-XX:+PrintHeapAtGC</code>：GC打印堆栈情况</li><li><code>-XX:+PrintGCTimeStamps</code>：发生GC系统的时间</li><li><code>-XX:+PrintGCApplicationConcurrentTime</code>：打印自上次GC暂停以来经过的时间</li><li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印GC的暂停时长</li><li><code>-XX:+PrintReferenceGC</code>：记录回收了多少种不同引用类型的引用</li><li><code>-verbose:class</code>：类加载详细过程</li><li><code>-XX:+PrintVMOptions</code>：打印JVM的参数</li><li><code>-XX:+PrintFlagsFinal</code>/<code>-XX:+PrintFlagsInitial</code>：打印最终的/初始化默认的参数</li><li><code>-Xloggc:opt/log/gc.log</code></li><li><code>-XX:MaxTenuringThreshold</code>：新生代晋升年龄,最大值15</li><li>锁自旋次数 <code>-XX:PreBlockSpin</code> 热点代码检测参数 <code>-XX:CompileThreshold</code> 逃逸分析 标量替换…这些不建议设置</li></ul><h1 id="Parallel常用参数">2 Parallel常用参数</h1><ul><li><code>-XX:SurvivorRatio</code>：新生代Eden:Survivor1:Survivor2的比例，默认<code>8:1:1</code></li><li><code>-XX:PreTenureSizeThreshold</code>：多大对象直接放入老年代</li><li><code>-XX:MaxTenuringThreshold</code>：新生代晋升年龄,最大值15</li><li><code>-XX:+ParallelGCThreads</code>：并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：自适应Eden:Survivor1:Survivor2大小比例</li></ul><h1 id="CMS常用参数">3 CMS常用参数</h1><ul><li><code>-XX:+UseConcMarkSweepGC</code>：启用CMS</li><li><code>-XX:ParallelCMSThreads</code>：CMS线程数量</li><li><code>-XX:CMSInitiatingOccupancyFraction</code>：使用多少比例的老年代后开始CMS收集，默认是92%</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：在FGC时进行压缩，会导致回收耗时变长</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>：多少次FGC之后进行压缩</li><li><code>-XX:+CMSClassUnloadingEnabled</code>：永久代相关，1.8之前的</li><li><code>-XX:CMSInitiatingPermOccupancyFraction</code>：永久代相关，1.8之前的</li><li><code>-XX:GCTimeRatio</code>：建议GC时间占用程序运行时间的百分比</li><li><code>-XX:MaxGCPauseMillis</code>：期望的垃圾回收停顿时间</li></ul><h1 id="G1常用参数">4 G1常用参数</h1><ul><li><code>-XX:+UseG1GC</code>：启用G1</li><li><code>-XX:MaxGCPauseMillis</code>：建议GC停顿的最大事件，G1会尝试调整Young区的块数来达到这个值</li><li><code>-XX:GCPauseIntervalMillis</code>：GC的间隔时间</li><li><code>-XX:+G1HeapRegionSize</code>：设置Region分区大小，随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长，ZGC做了改进（动态区块大小）</li><li><code>-XX:G1NewSizePercent</code>：新生代最小比例，默认为5%</li><li><code>-XX:G1MaxNewSizePercent</code>：新生代最大比例，默认为60%</li><li><code>-XX:GCTimeRatio</code>：建议GC时间占用程序运行时间的百分比</li><li><code>-XX:ConcGCThreads</code>：用于清理的并发线程数量</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>：启动G1的堆空间占用比例</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里不保证完全准确，可以到官方文档上面去验证：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode80-删除排序数组中的重复项II</title>
    <link href="https://www.codetool.top/article/leetcode80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/"/>
    <id>https://www.codetool.top/article/leetcode80-删除排序数组中的重复项II/</id>
    <published>2020-05-26T06:01:39.000Z</published>
    <updated>2020-05-26T06:06:48.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地<strong>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre>给定 <em>nums</em> = <strong>[1,1,1,2,2,3]</strong>,函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong> <strong>3 </strong>。你不需要考虑数组中超出新长度后面的元素。</pre><p><strong>示例 2:</strong></p><pre>给定 <em>nums</em> = <strong>[0,0,1,1,1,1,2,3,3]</strong>,函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前五个元素被修改为&nbsp;<strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, <strong>3 。</strong>你不需要考虑数组中超出新长度后面的元素。</pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“<strong>引用</strong>”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。for (int i = 0; i &lt; len; i++) {&nbsp; &nbsp; print(nums[i]);}</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>和<a href="../leetcode26-删除排序数组中的重复项">leetcode26-删除排序数组中的重复项</a>类似，这里也使用双指针，但是添加一个变量用于计数。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果遇到了新的字符，计数清零</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果计数小于二，将后面那个指针指向的值赋给前面那个指针指向的值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地&lt;strong&gt;修改输入数组&lt;/strong&gt;并在使用 O(1) 额外空间的条件
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏02</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F02/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏02/</id>
    <published>2020-05-25T13:38:14.000Z</published>
    <updated>2020-05-25T14:46:48.874Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈我其实没有想到这个系列真会有续集，上次写完01以后以为不会再写下去了，没想到最近牛客网刷题有些题目还是挺纠结的，这里补一补</p><h1 id="构造器能带哪些修饰符">1 构造器能带哪些修饰符</h1><p>题目：</p><p>Which of the following can be applied to constructors:</p><p>A. final<br>B. static<br>C. synchronized<br>D. native<br>E. None of these.  </p><p>正确答案: E   你的答案: C (错误)</p><p>我选的时候觉得A C有可能，然后因为是单选选了C。</p><p>经测试，类构造器不能带以上任何一个修饰符，如果要声明为最终类，直接在类上修饰为final的就行了。</p><p>而synchronized，我一开始以为因为方法上的<code>synchronized</code>默认锁住的是this对象，而还没构造的对象可能不能锁，但后来发现并不是这个原因，起码下面这段代码是能运行的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConstructor</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TestConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            name <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TestConstructor testConstructor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testConstructor<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>并且通过调试发现在进入<code>synchronized</code>代码块之前对象已经创建出来，只是还没有对name赋值。所以可能就是硬不可以吧。</p><h1 id="关于整数和字符串相加的问题">2 关于整数和字符串相加的问题</h1><p>题目：</p><p>如果int x=20, y=5，则语句System.out.println(x+y +””+(x+y)+y);  的输出结果是（）</p><p>A. 2530<br>B. 55<br>C. 2052055<br>D. 25255  </p><p>正确答案: D   你的答案: D (正确)</p><p>这道题虽然选对了，但是是根据排除法做出来的，因为空字符串后面那部分<code>(x+y)+y</code>必是<code>255</code>，但是空字符串前面的那个<code>x+y</code>我不确定是<code>25</code>还是<code>205</code>。</p><p>经测试，运行结果是25255，那就说明在遇到字符串之前还是做正常的整数加法，而遇到字符串之后都是做字符串拼接。如果思考一下原因，也很好解释，大概就是因为加法是单步执行的（JVM字节码执行的时候一条指令最多操作两个操作数栈中的操作数），那么遇到字符串之前，都不知道后面会有字符串，也就会做正常的整数加法了。</p><h1 id="重载静态多分派">3 重载静态多分派</h1><p>题目：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> collections <span class="token operator">=</span>                <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Super subToSuper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection <span class="token operator">:</span> collections<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subToSuper<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:collection"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:list"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getType</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:arrayList"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:set"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getType</span><span class="token punctuation">(</span>HashSet<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:hashSet"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 我猜这一行应该是想返回"Sub:collection"</span>            <span class="token keyword">return</span> <span class="token string">"Sub"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>A.<br>Sub:collection<br>Sub:collection<br>Sub:collection  </p><p>B.<br>Sub:hashSet<br>Sub:arrayList<br>Sub:collection  </p><p>C.<br>Super:collection<br>Super:collection<br>Super:collection   </p><p>D.<br>Super:hashSet<br>Super:arrayList<br>Super:collection </p><p>正确答案: C   你的答案: A (错误)</p><p>这道题目做错了真的不怪我啊，牛客网上的排版太乱了，代码又长，很难读完的。</p><p>这道题目其实涉及多个知识点：</p><p>首先它是通过了一个实例对象去调用静态方法，注意两个类中的方法都是静态的，而静态方法是不会被覆写的。</p><p>然后下面这部分代码，要确定到底调用的是哪个类中的getType方法：</p><pre class=" language-java"><code class="language-java">Super subToSuper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection <span class="token operator">:</span> collections<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subToSuper<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一行就属于静态分派，new了一个<code>Sub</code>对象，但将其声明为<code>Super</code>类型的引用，这就属于编译期间确定好的类型，也称为“静态分派”。那么可以确定，后面调用的<code>getType</code>方法，实际上是调用了<code>Super</code>类型的静态方法，但到底是哪个重载版本呢？</p><p>其实后面这个也是静态分派，因为第二行代码中<code>Collection&lt;?&gt; collection : collections</code>也显式地将从集合中取出来的对象声明为了<code>Collection</code>类型的引用，所以调用的重载方法版本就是参数为Collection类型的。</p><h1 id="布尔型居然可以用位运算？">4 布尔型居然可以用位运算？</h1><p>我一直以为布尔型位运算只存在于C语言这种语言中，直到我遇见了这道题：</p><p>题目：</p><p>根据下面的代码，<br>String s = null;<br>会抛出NullPointerException异常的有（）。</p><p>A. if( (s!=null) &amp; (s.length()&gt;0) )<br>B. if( (s!=null) &amp;&amp; (s.length()&gt;0) )<br>C. if( (s==null) | (s.length()==0) )<br>D. if( (s==null) || (s.length()==0) )  </p><p>正确答案: A C   你的答案: A C (正确)</p><p>虽然我是选对了，因为我知道根据短路原则BD必不可能嘛，但是我还真不知道布尔型可以用位运算。</p><p>然后我就试了一下这些代码：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">&amp;</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">|</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">|</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">|</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>发现都是可以正常执行的，并且输出依次为：</p><pre><code>truefalsefalsetruetruefalse</code></pre><p>可见和逻辑运算的结果并没有差别，那么true和false底层是通过1和0来表示吗？我在网上搜了一下，有一个人是这么说的：</p><blockquote><p>JVM虚拟机规格标准第二版规定：字节码形态的boolean的false和true，是用int(32bit整型)的0和1表示</p></blockquote><p>那么就假定这是正确的，但通过实验，布尔类型不能和整型互转，也不能参与整型的运算。不是很明白JVM这样设计的用意。</p><p>那么谈到这里，和题目一比较，大概就知道了，这样的位运算符运用在布尔类型上和逻辑运算符的区别就是没有短路原则，可以做个实验验证一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">|</span><span class="token function">returnFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">returnFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>写一段这样的代码，经过调试发现，会执行到<code>returnFalse</code>这个方法中去。所以说是没有短路原则的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哈哈我其实没有想到这个系列真会有续集，上次写完01以后以为不会再写下去了，没想到最近牛客网刷题有些题目还是挺纠结的，这里补一补&lt;/p&gt;
&lt;h1 id=&quot;构造器能带哪些修饰符&quot;&gt;1 构造器能带哪些修饰符&lt;/h1&gt;&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;Which of the follo
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode146-LRU缓存机制</title>
    <link href="https://www.codetool.top/article/leetcode146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.codetool.top/article/leetcode146-LRU缓存机制/</id>
    <published>2020-05-25T03:51:47.000Z</published>
    <updated>2020-05-25T05:33:30.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>运用你所掌握的数据结构，设计和实现一个  <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p><p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p><strong>进阶:</strong></p><p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p><p><strong>示例:</strong></p><pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得密钥 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得密钥 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>如果不限制 <code>O(1)</code> 时间复杂度，用链表就能完成了，但是限制时间复杂度就需要解决链表顺序访问的问题。</p><p>可以通过哈希表+链表解决，如果看过LinkedHashMap的源码就知道，LinkedHashMap本身就可以拓展成LRU缓存，这个我也在<a href="../LinkedHashMap源码分析">LinkedHashMap源码分析</a>中提过。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始大小设为1024，避免leetcode上执行扩容带来的时间损耗</span>        <span class="token comment" spellcheck="true">// 最后一个参数设为true，代表按访问顺序连接</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token number">0.75f</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 重写该方法，可以在每一次添加元素后判断要不要移除队列首部的元素</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  &lt;a href=&quot;https://baike.baidu.com/item/LRU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LRU (最近最少使用) 缓存机制&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>String s = new String(&quot;123&quot;);创建了几个String对象？</title>
    <link href="https://www.codetool.top/article/String-s-new-String-123-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAString%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>https://www.codetool.top/article/String-s-new-String-123-创建了几个String对象？/</id>
    <published>2020-05-24T08:19:05.000Z</published>
    <updated>2020-05-24T09:00:18.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提要">1 提要</h1><p>最近复习看到一道题目很有意思啊：</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>问这样一行代码创建了几个String对象？</p><p>乍一看我其实以为和JDK的版本有关系，因为在<a href="../深入理解java虚拟机第三版读书笔记02">深入理解java虚拟机第三版读书笔记02</a>中<code>1.6.2 intern方法有意思的点</code>曾经提到，JDK7之前，字符串常量池在方法区（永久代）中，而JDK7开始，就将字符串常量池移到了堆中。那么这个题目和这个知识点有关系吗？</p><p>然而仔细一看这行代码，便发现了蹊跷：我们平时定义字符串会使用这样的语法赋值吗？平时常用的给字符串赋值的方法应该是下面这样才对：</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span></code></pre><p>那么这样两行代码有什么区别呢？先从搞清楚<code>&quot;123&quot;</code>是什么开始：</p><h1 id="字符串字面量">2 字符串字面量</h1><p>字符串的字面量和基本类型的字面量有点不同，基本类型可以写<code>1</code>,<code>true</code>,<code>2l</code>这样的字面量。然而在Java中字符串不属于基本类型，String本身是一个类，那么 <strong><code>&quot;123&quot;</code>这样一个字面量肯定也是一个String的实例对象</strong>。</p><p>但是我们之前又提到了“字符串常量池”这个东西，到底什么时候字符串会从常量池中取值呢？下面通过几个例子验证一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String a <span class="token operator">=</span> <span class="token string">"111"</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"111"</span> <span class="token operator">==</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>首先，<code>&quot;111&quot;</code>是一个String的实例对象，将它赋值给<code>a</code>，我们通常说，<strong>在Java中只有值传递，没有引用传递</strong>，就是指这里其实是把<code>&quot;111&quot;</code>的引用地址通过值传递给了<code>a</code>这个引用类型，使得它们指向了同一个对象。</p><p>而后面的输出语句中，再一次出现了<code>&quot;111&quot;</code>这个字面量，通过它和a做<code>==</code>比较，看它们指向的是不是同一个对象，结果输出true，说明<strong>重复出现的字面量其实指向的是同一个对象</strong>，这里可以猜测<strong>第一次出现的字符串字面量就创建了一个String实例，并放入了常量池中，后面出现的相同的字面量都是从常量池中取值</strong>。</p><p>那么既然第一次出现的字面量就会将创建的String实例放入字符串常量池，<code>intern</code>这个方法有什么存在的必要呢？其实这是因为<strong>字符串不仅仅会以字面量的形式赋值</strong>。</p><p>比如下面这个方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"11"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String b <span class="token operator">=</span> <span class="token string">"111"</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>a是通过<code>StringBuilder</code>来构造的，因此没有出现<code>&quot;111&quot;</code>这个字符串字面量，相反而是出现了<code>&quot;11&quot;</code>,<code>&quot;1&quot;</code>这两个字面量，因此在与b进行比较的时候，输出的是false。</p><p>但假设我们仍想在第一行代码中就让<code>&quot;111&quot;</code>进入字符串常量池，就可以使用<code>intern</code>方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"11"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String b <span class="token operator">=</span> <span class="token string">"111"</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这样就会输出<code>true</code></p><p>通过这里的研究可以知道，下面这样的代码就是多此一举：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span> <span class="token string">"111"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>因为第一行其实已经实现了<code>intern</code>的效果。</p><h1 id="如何解答这个问题">3 如何解答这个问题</h1><p>了解完了字符串字面量这个概念，相信回答这个问题也不难了，</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这行代码中，<code>&quot;123&quot;</code>本身是一个String的实例对象，它的来源可能有两种情况：</p><ol><li>若之前字符串常量池中没有<code>&quot;123&quot;</code>，这里就会创建一个字符串，并放入常量池</li><li>若之前字符串常量池中有<code>&quot;123&quot;</code>，这里就会直接指向常量池中的对象。</li></ol><p>而<code>s</code>是怎么来的？看一下这个构造方法（JDK8）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到<strong>这个构造方法实际上是一个浅复制</strong>，只是会将字符串字面量中的<code>value</code>字符数组复制过来。</p><p>所以这个问题应该这样回答：</p><p><strong>如果在这段代码运行之前字符串常量池中已经有<code>&quot;123&quot;</code>了，就只会创建一个String对象，相反则会创建两次，因为字符串字面量第一次出现会创建一个String实例对象。</strong></p><p>与之对应的是，</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span></code></pre><p><strong>这样一行代码倒是有可能一个字符串对象也不创建，因为只是将常量池中对象的引用地址传递了一下。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提要&quot;&gt;1 提要&lt;/h1&gt;&lt;p&gt;最近复习看到一道题目很有意思啊：&lt;/p&gt;
&lt;pre class=&quot; language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;String s &lt;span class=&quot;token operator&quot;&gt;=
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode78-子集</title>
    <link href="https://www.codetool.top/article/leetcode78-%E5%AD%90%E9%9B%86/"/>
    <id>https://www.codetool.top/article/leetcode78-子集/</id>
    <published>2020-05-24T04:03:27.000Z</published>
    <updated>2020-05-24T04:05:01.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong> 解集不能包含重复的子集。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> nums = [1,2,3]<strong>输出:</strong>[  [3],&nbsp; [1],&nbsp; [2],&nbsp; [1,2,3],&nbsp; [1,3],&nbsp; [2,3],&nbsp; [1,2],&nbsp; []]</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>经典DFS，把路径上的全加进去。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">subsets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span><span class="token keyword">int</span> startIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>        ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>            copy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一组&lt;strong&gt;不含重复元素&lt;/strong&gt;的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 解集不能包含重复的子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中的四种内部类</title>
    <link href="https://www.codetool.top/article/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://www.codetool.top/article/Java中的四种内部类/</id>
    <published>2020-05-23T14:26:46.000Z</published>
    <updated>2020-05-23T15:02:57.838Z</updated>
    
    <content type="html"><![CDATA[<p>我发现最近真是越来越没有东西写了。。。不可能天天学习新知识啊，最近在复习阶段了，复习的东西大多数是博客里写过的/(ㄒoㄒ)/~~</p><p>复习Java基础的时候认真看了一下Java的内部类，这东西之前了解过，但是没有写过代码实验一下，今天就来手写代码夯实夯实基础。也懒得写那么多文字了，博客精简一点剩下时间用来复习。</p><p>Java中的内部类分为：</p><ul><li>普通内部类：也叫成员内部类</li><li>局部内部类</li><li>静态内部类</li><li>匿名内部类</li></ul><h1 id="普通内部类">1 普通内部类</h1><p>普通内部类就是直接写在宿主类中的（我这篇文章中称为宿主类，和外部类区分开），并且不带static，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInnerClass</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String outerName <span class="token operator">=</span> <span class="token string">"outer"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//普通内部类</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass1</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 普通内部类可以访问宿主类的一切属性</span>        <span class="token keyword">public</span> String name <span class="token operator">=</span> outerName<span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span><span class="token string">"InnerClass1"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个普通内部类对象</span>        InnerClass1 innerClass1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 宿主类可以访问其属性</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerClass1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>为什么普通内部类可以带<code>public</code>这种访问修饰符呢？外部类可以创建一个它的实例对象吗？</p><p>验证如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInnerClass2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 首先创建一个宿主类的对象</span>        TestInnerClass t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过宿主类的对象new出一个内部类的对象</span>        TestInnerClass<span class="token punctuation">.</span>InnerClass1 innerClass1 <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可以获取内部类public的属性</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerClass1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>普通内部类是依存于宿主类的实例对象存在的，通过宿主类的实例对象才能new出一个内部类的实例，不得不说，这个语法还蛮少见的。</p><p>当然，如果普通内部类声明为private的，外部类就不可以访问了。</p><h1 id="局部内部类">2 局部内部类</h1><p>局部内部类是宿主类的一个方法中的，比较特殊：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInnerClass3</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        String methodName <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 局部内部类，生效范围为方法内部作用域</span>        <span class="token keyword">class</span> <span class="token class-name">InnerClass3</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 可以获取方法中声明的局部变量</span>            <span class="token keyword">public</span> String className <span class="token operator">=</span> methodName<span class="token operator">+</span><span class="token string">": InnerClass3"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在方法中可以使用</span>        InnerClass3 innerClass3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerClass3<span class="token punctuation">.</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是局部内部类有一个特点是不能加上访问权限限定符，例如public、private：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInnerClass3</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        String methodName <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 报错！！！</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass3</span><span class="token punctuation">{</span>            <span class="token keyword">public</span> String className <span class="token operator">=</span> methodName<span class="token operator">+</span><span class="token string">": InnerClass3"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        InnerClass3 innerClass3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerClass3<span class="token punctuation">.</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是可以加上abstract、final这样的修饰符。</p><h1 id="静态内部类">3 静态内部类</h1><p>静态内部类和普通的类最为相似，唯一的区别可以看作就是要通过一个类来获取。这种内部类平时也是用的比较多的，所以这里也不特别说明。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInnerClass4</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String className <span class="token operator">=</span> <span class="token string">"TestInnerClass4"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass4</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 只能获取宿主类的静态字段</span>        <span class="token keyword">private</span> String name <span class="token operator">=</span> className<span class="token operator">+</span><span class="token string">": InnerClass4"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="匿名内部类">4 匿名内部类</h1><p>匿名内部类平时也用的特别多，常见的例子就是new一个Thread：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInnerClass5</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里实际上是创建了一个Thread的子类，并重写了run方法。</p><h1 id="会不会生成单独的class文件">5 会不会生成单独的class文件</h1><p>经过测试，所有内部类都会产生单独的class文件，并且命名是：</p><ul><li>普通内部类和静态内部类都是：<code>(宿主类名)$(内部类名)</code></li><li>局部内部类是：<code>(宿主类名)$(编号)(内部类名)</code></li><li>匿名内部类是：<code>(宿主类名)$(编号)</code></li></ul><h1 id="普通内部类能访问宿主类实例字段的原理">6 普通内部类能访问宿主类实例字段的原理</h1><ol><li>编译器自动为内部类添加一个成员变量，该成员变量的类型和外部类的类型相同，这个成员变量就是指向外部类对象引用。</li><li>编译器自动为内部类的构造方法添加一个参数，参数的类型是外部类的类型，在构造方法内部使用这个参数为1中添加的成员变量赋值。</li><li>在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我发现最近真是越来越没有东西写了。。。不可能天天学习新知识啊，最近在复习阶段了，复习的东西大多数是博客里写过的/(ㄒoㄒ)/~~&lt;/p&gt;
&lt;p&gt;复习Java基础的时候认真看了一下Java的内部类，这东西之前了解过，但是没有写过代码实验一下，今天就来手写代码夯实夯实基础。也懒
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode76-最小覆盖子串</title>
    <link href="https://www.codetool.top/article/leetcode76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode76-最小覆盖子串/</id>
    <published>2020-05-23T08:10:04.000Z</published>
    <updated>2020-05-23T08:50:07.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> S = “ADOBECODEBANC”, T = “ABC”<br><strong>输出:</strong> “BANC”</p></blockquote><p><strong>说明：</strong></p><ul><li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>滑动窗口，用一个hashmap存储原字符串中字符的出现个数，再用一个hashmap存储滑动窗口内目标字符的出现个数，用一个变量记录滑动窗口内有多少个字符满足条件了。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">minWindow</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> needMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            needMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> needMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> match <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> rightTemp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>needMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>rightTemp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> newCount <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>rightTemp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rightTemp<span class="token punctuation">,</span> newCount<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>newCount <span class="token operator">==</span> needMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>rightTemp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    match<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>match <span class="token operator">==</span> needMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    start <span class="token operator">=</span> left<span class="token punctuation">;</span>                    end <span class="token operator">=</span> right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">char</span> leftTemp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>needMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>leftTemp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftTemp<span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>leftTemp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>leftTemp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> needMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>leftTemp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        match<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> end <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch及CyclicBarrier源码分析</title>
    <link href="https://www.codetool.top/article/CountDownLatch%E5%8F%8ACyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/CountDownLatch及CyclicBarrier源码分析/</id>
    <published>2020-05-22T10:36:16.000Z</published>
    <updated>2020-05-22T11:58:22.012Z</updated>
    
    <content type="html"><![CDATA[<p>之前写的一篇博客<a href="../JUC包下的线程协作计数CountDownLatch及CyclicBarrier">JUC包下的线程协作计数CountDownLatch及CyclicBarrier</a>只是介绍了一下这两个工具类的用法，并没有深入探究源码，然而实现方法也比较简单，所以合为一篇来写了，可以借鉴一下设计思想。</p><h1 id="CountDownLatch-源码分析">1 CountDownLatch 源码分析</h1><p>CountDownLatch 的目的是阻塞等待其他线程执行完成，可能是为了满足前置需求，不使用CountDownLatch的时候可以使用join方法来完成这项任务，但CountDownLatch提供了一种更优雅的实现方式。</p><p>CountDownLatch的实现是非常简单的，内部就一个继承了AQS的内部类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 4982264981922014374L<span class="token punctuation">;</span>    <span class="token function">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 只有state为0的时候才能获取资源</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 释放共享资源，仅是将state通过CAS减1</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Decrement count; signal when transition to zero</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Sync比较特殊的地方在于，一般使用AQS的类都将state抽象为资源的数量，acquire则减一，release则加一。而这里<code>CountDownLatch</code>中的<code>Sync</code>确是调用<code>tryReleaseShared</code>将state减一，调用<code>tryAcquireShared</code>不修改state值，但是如果是0的话就返回1。</p><p>那么我们通常使用构造方法构造一个<code>CountDownLatch</code>对象，作用是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"count &lt; 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>就是将这个值传入<code>Sync</code>的构造方法，然后通过上面<code>Sync</code>的源码可以知道就是将state设置为了<code>count</code>这个值。</p><p>构造完<code>CountDownLatch</code>对象之后，我们在线程中要做的事一般就是调用一次<code>countDown()</code>，然后调用<code>await()</code>进行等待。</p><p>而<code>countDown</code>方法仅是调用了一下<code>releaseShared</code>，将state减一：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在<code>Sync</code>类中可以看到，<code>tryReleaseShared</code>这个方法只要不是将资源减为0了，都返回<code>false</code>，因此并不是每次释放资源都会通知共享节点。</p><p>而如果减为0了，根据AQS的逻辑就会进行<code>doReleaseShared</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果减为0了，返回true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而<code>doReleaseShared</code>方法就是从头节点开始向后传播，唤醒共享节点，所以这里就会把所有等待的线程唤醒。</p><p>其实分析到这里就已经看出核心逻辑了，<code>await</code>方法也只是调用了一下<code>acquireSharedInterruptibly</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法就是AQS的实现，如果没有获取到资源就将线程挂起，而只要state不为0是获取不到资源的。</p><p>不过通过源码分析可以知道的是，<code>CountDownLatch</code>是不能复用的，因为在<code>tryReleaseShared</code>方法中，减到0就不能继续往下减了，而调用<code>await</code>方法时，会尝试获取资源，此时state就是0，能获取到资源，所以线程就不会挂起了。</p><h1 id="CyclicBarrier-源码分析">2 CyclicBarrier 源码分析</h1><p>使用 CyclicBarrier 的目的是，线程必须等待参与协作的线程达到某个个数（这里称为barrier值），才一起开始工作（形象地称为冲破屏障）。</p><p>先看一下它的内部类和字段：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrier</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内部类Generation，用来维护屏障是否打破的信息</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Generation</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> broken <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 用来互斥进入屏障</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用来挂起线程，直到到达屏障被冲破</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Condition trip <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 屏障值，构造之后就不会变</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> parties<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当冲破屏障时需要做的任务</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Runnable barrierCommand<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前的Generation</span>    <span class="token keyword">private</span> Generation generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前值，从屏障值开始递减，减为0则冲破屏障，然后又恢复屏障值，等待复用</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><ul><li><code>parties</code>是构造时赋予的屏障值，之后不会改变，只要等待的线程到达这个个数就能冲破屏障。</li><li><code>count</code>，我这里称为当前值，一开始就是屏障值，每等待一个线程就会减一，可以理解为还差多少个线程可以冲破屏障。</li></ul><p>看一下构造方法验证一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>后面这个版本就是还需要传入一个任务，冲破屏障时会执行这个任务。</p><p>然后直接看<code>await</code>方法，因为<code>CyclicBarrier</code>除了构造方法基本上就只会用到这个方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>toe<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cannot happen</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>await</code>方法还有一个带超时时间的版本，不过最终都是会调用<code>dowait</code>:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException<span class="token punctuation">,</span>            TimeoutException <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 锁上，进入屏障</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前的Generation，看看屏障有没有问题</span>        <span class="token keyword">final</span> Generation g <span class="token operator">=</span> generation<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将count值减一</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果count值减为0，可以冲破屏障了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果有command，执行这个任务</span>                <span class="token keyword">final</span> Runnable command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 产生一个新的屏障，并唤醒所有等待的线程</span>                <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果任务执行错误，需要打破屏障，禁止使用</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span>                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果count值没有减为0</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果不带超时</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 使用条件变量挂起</span>                    trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> 0L<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 否则带超时的挂起</span>                    nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">==</span> generation <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> ie<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// We're about to finish waiting even if we had not</span>                    <span class="token comment" spellcheck="true">// been interrupted, so this interrupt is deemed to</span>                    <span class="token comment" spellcheck="true">// "belong" to subsequent execution.</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> generation<span class="token punctuation">)</span>                <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果count值减为0，在<code>nextGeneration</code>这个方法中线程会调用条件变量的<code>signalAll</code>唤醒所有等待的线程：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// signal completion of last generation</span>    trip<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// set up next generation</span>    count <span class="token operator">=</span> parties<span class="token punctuation">;</span>    generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这就是<code>CyclicBarrier</code>的原理。</p><p>并且在<code>dowait</code>这个方法中可以注意到，<code>Generation</code>在每次打破屏障后都会产生一个新的实例替换原有的实例，也就是说，通常获取到的<code>Generation</code>对象中的<code>broken</code>都是false。</p><p>而什么情况下会导致<code>Generation</code>对象的<code>broken</code>变为true而不会被替换呢？通过<code>dowait</code>方法发现，若执行command任务期间发生异常，是不会生成新的<code>Generation</code>对象的，也就是说屏障被打破且不会更新。</p><p>来个例子验证一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    CyclicBarrier cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 个数为2时才会继续执行</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"开始执行……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行这个方法，在3秒之后有两个线程启动，完成了<code>CyclicBarrier</code>的目标，但是由于要求执行的任务会产生一个运行时异常，导致Barrier被打破且不会被还原，产生<code>BrokenBarrierException</code>异常。</p><p>输出：</p><pre><code>Exception in thread &quot;Thread-1&quot; java.lang.ArithmeticException: / by zero    at com.rhett.thread.TestBarrier.lambda$main$0(TestBarrier.java:9)    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:220)    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:220)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at java.lang.Thread.run(Thread.java:748)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.rhett.thread.TestBarrier.lambda$main$1(TestBarrier.java:12)    at java.lang.Thread.run(Thread.java:748)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)    at com.rhett.thread.TestBarrier.lambda$main$1(TestBarrier.java:12)    at java.lang.Thread.run(Thread.java:748)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写的一篇博客&lt;a href=&quot;../JUC包下的线程协作计数CountDownLatch及CyclicBarrier&quot;&gt;JUC包下的线程协作计数CountDownLatch及CyclicBarrier&lt;/a&gt;只是介绍了一下这两个工具类的用法，并没有深入探究源码，然而实现
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码分析" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="多线程" scheme="https://www.codetool.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode131-分割回文串</title>
    <link href="https://www.codetool.top/article/leetcode131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode131-分割回文串/</id>
    <published>2020-05-22T02:42:25.000Z</published>
    <updated>2020-05-22T11:58:23.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong>&nbsp;"aab"<strong>输出:</strong>[  ["aa","b"],  ["a","a","b"]]</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>在字符串中搜索是回文串的子字符串，可以使用dfs。</p><p>但判断子字符串是不是回文串的时候，可以下功夫优化，这里不能使用我在<a href="leetcode125-验证回文串">leetcode125-验证回文串</a>中用到的方法，因为子字符串之间存在很多个重复的单元。</p><p>那么就可以使用动态规划的方法判断子字符串是否为回文串：使用一个二维的dp数组，<strong><code>dp[i][j]</code>代表在字符串中下标i起始，下标j截止的子字符串是否为回文串，</strong>根据回文串的判断方法，可以得到状态转移方程<code>dp[i][j]</code> = <code>s.charAt(i)==s.charAt(j) &amp;&amp; dp[i+1][j-1]</code>。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">partition</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 子字符串是否是回文串，使用动态规划判断</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>startIndex <span class="token operator">>=</span> endIndex<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> chars<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span> <span class="token operator">==</span> chars<span class="token punctuation">[</span>endIndex<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>startIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>endIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>endIndex<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从下标为startIndex处进行dfs搜索</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> startIndex<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startIndex<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>String<span class="token operator">></span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                copy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span>startIndex<span class="token punctuation">,</span>i<span class="token operator">-</span>startIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。&lt;/p&gt;
&lt;p&gt;返回 s 所有可能的分割方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt;&amp;n
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor源码分析-线程池如何实现线程复用？</title>
    <link href="https://www.codetool.top/article/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%EF%BC%9F/"/>
    <id>https://www.codetool.top/article/ThreadPoolExecutor源码分析-线程池如何实现线程复用？/</id>
    <published>2020-05-21T07:59:36.000Z</published>
    <updated>2020-05-21T11:33:15.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的复用问题">1 线程的复用问题</h1><p>在开始看线程池的源码之前，先来看这么一个问题：</p><p>一个Thread对象可以重复地调用<code>start()</code>方法吗？</p><p>试试就知道了：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出是：</p><pre><code>线程启动java.lang.IllegalThreadStateException    at java.lang.Thread.start(Thread.java:708)    at com.rhett.thread.TestThreadPool.test(TestThreadPool.java:22)    ...</code></pre><p>可见线程只能启动一次，并且原因就是以前介绍过的Java线程的状态：</p><p><img src="https://api.codetool.top/img/15804639332329.png" alt></p><p>线程在run()方法执行完之后就会进入<code>TERMINATED</code>状态，Java会负责系统调用对线程进行销毁，自然也不可以再次启动。</p><p>那么我们常常说Java中的线程池可以实现线程复用，是怎么实现的呢？</p><p>一种很直观的想法是，既然线程启动会检查Thread中的Runnable类型的target是否为空，如果不为空则执行其run方法，那么只要每次线程执行完之后替换一下target对象就可以实现线程复用了。但是这种假设已经被我们验证是错误的了：线程根本不能重复调用<code>start</code>方法，无法做到多次启动。</p><p>那么另一种想法就是我们在<a href="../Java线程池详解">Java线程池详解</a>中手动实现的线程池的方法，就是通过阻塞队列实现的生产者消费者模型，只要队列未满，生产者就不断产生新线程，并添加到阻塞队列中，消费者只需要从阻塞队列中取线程对象就可以了。</p><p>这种方法实现线程池，看似没有问题，但并没有实现真正的线程复用，当线程用的快的时候，还是必须不断生成新线程，以满足需要。</p><p>下面就来看看JDK中线程池是怎么实现线程复用的：</p><h1 id="ThreadPoolExecutor源码分析">2 ThreadPoolExecutor源码分析</h1><p>其实ThreadPoolExecutor的一些属性在<a href="../Java线程池详解">Java线程池详解</a>中已经看得挺多的了，不过那篇确实借鉴别人的比较多，也没有深入了解线程复用的原理。</p><p>这里还是可以先把几个核心的内容看一下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ctl：前三位为线程池的状态，后面为线程池中线程的个数</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程池的最大容量</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 对应五种状态，是ctl的前三位</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取线程池的状态（通过获取ctl的前三位）</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取线程池的线程数量（通过获取ctl的低位部分）</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 任务队列  </span><span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 工作线程的集合（核心容器）</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程工厂，可以给线程起名</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> ThreadFactory threadFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 拒绝策略</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> RejectedExecutionHandler handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 救急（非核心）线程空闲状态能存在的最长时间</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最大常驻（核心）线程个数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程池最多同时拥有的线程个数</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认的拒绝策略：让调用者抛出 RejectedExecutionException 异常</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> RejectedExecutionHandler defaultHandler <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>有一些字段暂时看不懂也没有关系，看着看着就懂了，首先就从使用线程池的常用方法<code>execute</code>方法进入源码分析吧：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 传入一个任务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取ctl</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 看看当前工作线程个数是否小于 corePoolSize</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 添加一个核心Worker</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果工作线程个数不小于 corePoolSize，或添加Worker失败</span>    <span class="token comment" spellcheck="true">// 将任务添加到任务队列中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 添加一个非核心的Worker</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果添加非核心的Worker还失败了，则执行拒绝策略</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到，大致是一个这样的流程：</p><p>提交任务：</p><ol><li>若worker数量小于<code>corePoolSize</code>，创建一个核心worker，完成任务</li><li>若如果工作线程个数不小于 corePoolSize，或添加Worker失败，将任务添加到任务队列中</li><li>若以上条件都不满足，但worker数小于<code>maximumPoolSize</code>，创建一个非核心worker来完成任务。</li><li>若以上条件都不满足，执行拒绝策略</li></ol><p>那么就先看一下<code>addWorker</code>这个关键方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程池要关闭的情况，不添加</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取线程池中worker数量</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果大于最大数量，添加失败</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>            <span class="token comment" spellcheck="true">// 如果要创建核心worker，不能大于等于corePoolSize</span>            <span class="token comment" spellcheck="true">// 如果要创建非核心worker，不能大于等于maximumPoolSize</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 通过CAS去修改ctl字段中的worker个数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将任务传给Worker，构造一个实例对象</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>看到这里，想必你也很好奇Worker到底是什么？它是干什么的？</p><p>那么就进一段小插曲，先看下<code>Worker</code>这个内部类，方便后面的理解：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// worker在哪个线程中run </span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// worker初次构造时要执行的任务</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行过的任务数量</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法，传入一个firstTask</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Worker实现了Runnable接口，这里实现了run方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是被一个线程独占的吗</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 尝试让一个线程独占</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 尝试释放独占锁</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//用于中断线程的方法</span>    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>必须要注意到的是<code>Worker</code>实现了<code>Runnable</code>接口，并继承了AQS，用于一个线程的独占。</p><p>其中的构造方法有一句<code>this.thread = getThreadFactory().newThread(this);</code>，是通过<code>ThreadFactory</code>来生成一个<code>Thread</code>对象，那么假设我们构造线程池的时候没有传入<code>ThreadFactory</code>对象，它的默认<code>ThreadFactory</code>对象是什么呢？关于这个可以在简要版的构造函数内看到：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                            <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                            <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                            TimeUnit unit<span class="token punctuation">,</span>                            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>            Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可见默认的<code>ThreadFactory</code>对象是<code>Executors.defaultThreadFactory()</code>，也就是<code>Executors</code>内部类<code>DefaultThreadFactory</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ThreadFactory <span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>那么<code>DefaultThreadFactory</code>的实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicInteger poolNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ThreadGroup group<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String namePrefix<span class="token punctuation">;</span>    <span class="token function">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SecurityManager s <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>                                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        namePrefix <span class="token operator">=</span> <span class="token string">"pool-"</span> <span class="token operator">+</span>                        poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                        <span class="token string">"-thread-"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>                                namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span>            t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可见这里的线程名默认是<code>pool-线程池号-thread-线程号</code>，而线程池号和线程号都是通过一个<code>AtomicInteger</code>记录的，线程池号每构造一个<code>DefaultThreadFactory</code>对象递增1，线程号则是<code>DefaultThreadFactory</code>对象每次生成一个线程则递增1。</p><p>我们还注意到，在上面调用<code>newThread</code>创建线程的时候，把<code>this</code>传进去了，<code>this</code>就是当前的<code>Worker</code>对象，也就是说，<strong>创建出来的线程对象中的Runnable类型的target字段，其实就是一个<code>Worker</code>对象。</strong></p><p>那么大致性的了解了<code>Worker</code>结构之后，我们回到<code>addWorker</code>方法，继续往下看：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//...</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将任务传给Worker，构造一个实例对象</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取创建的线程</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取锁</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 上锁，因为要修改workers集合</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//检查线程池状态</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 如果线程已经启动，报错</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 添加worker到workers集合中</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 更新最大出现过的线程数量</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 解锁</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 启动线程</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果线程启动不成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>        <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看完了这个方法，大致性的概括就是：</p><p>生成一个Thread和Worker对象，将Thread对象赋值到Worker中的内部字段thread，将Worker对象作为Thread启动要执行的任务。</p><p><strong>特别注意，这样创建一个的Thread，在调用start启动后，因为内部的Runnable对象是对应的Worker对象，会去执行Worker对象中的run方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前线程</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取一开始要执行的任务</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//要么执行firstTask，要么从队列中阻塞获取任务）</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//线程池在运行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 打断线程</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//留给子类实现</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 执行任务</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//留给子类实现</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果退出循环有几种可能性，一种是限制了线程池保留闲暇状态Worker的时长并超过了一定时间</span>        <span class="token comment" spellcheck="true">// 另一种是线程被打断</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 准备退出</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>而<code>getTask</code>的实现是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 是否允许闲暇的核心线程超时</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果允许超时，则是限制时间的获取，否则是无时间限制的阻塞获取</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从该方法可以看出，核心线程也可以设置超时，只要将<code>allowCoreThreadTimeOut</code>设置为true。</p><p>那么退出的流程就是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// If abrupt, then workerCount wasn't adjusted</span>        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//移除该worker</span>        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果设置了CoreThread闲暇状态的超时，就不会创建worker</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">>=</span> min<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 添加一个Worker</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>线程池的源码就看到这里，如果要概括一下，大概就是：</p><ol><li>线程池实现线程复用的原理是，并不将用户提交的任务封装为一个Thread对象，而是让创建出来的线程循环地从阻塞队列中获取任务，在线程中执行该任务。</li><li>核心线程是在线程池中的“常驻线程”，而非核心线程只是在允许的范围内创建出来“救急的”。通常允许核心线程无时间限制地存在并从阻塞队列中获取任务，但是也可以设置核心线程的超时，比如下面这个例子：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在这个例子中，我是用<code>ThreadPoolExecutor</code>的构造方法模拟了一个<code>FixedThreadPool</code>，但并不获取一个<code>ExecutorService</code>接口，而是直接获取它的实现类，以便在后面进行一些高级设置。</p><p>这里将线程池设置了固定大小为2，提交的任务就是输出一下当前线程的哈希值，用于分辨是不是同一个线程处理的。 在循环中，每隔1秒提交了一个任务，最终输出如下：</p><pre><code>186870198113517697781868701981</code></pre><p>可见，第一和第三个任务是由同一个线程处理的，这是因为核心线程会一直阻塞等待队列中的任务。</p><p>但是我们只要将上面的源程序加上一行代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置允许核心线程超时</span>    threadPoolExecutor<span class="token punctuation">.</span><span class="token function">allowCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再次运行程序，结果如下：</p><pre><code>186870198113517697781434575218</code></pre><p>却发现每个任务都是由不同的线程处理的，这是因为在构造方法中设置了超时时间，并且允许了核心线程超时，核心线程在这个超时时间之内没有从队列中取到任务，便会销毁。直到下一个任务到来，产生新的Worker。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程的复用问题&quot;&gt;1 线程的复用问题&lt;/h1&gt;&lt;p&gt;在开始看线程池的源码之前，先来看这么一个问题：&lt;/p&gt;
&lt;p&gt;一个Thread对象可以重复地调用&lt;code&gt;start()&lt;/code&gt;方法吗？&lt;/p&gt;
&lt;p&gt;试试就知道了：&lt;/p&gt;
&lt;pre class=&quot; l
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码分析" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="多线程" scheme="https://www.codetool.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode125-验证回文串</title>
    <link href="https://www.codetool.top/article/leetcode125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode125-验证回文串/</id>
    <published>2020-05-21T04:19:57.000Z</published>
    <updated>2020-05-21T04:25:40.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong> 本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> “A man, a plan, a canal: Panama”<br><strong>输出:</strong> true</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> “race a car”<br><strong>输出:</strong> false</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>双指针从两端相向而行进行比较吧，遇到非数字和非字母的字符就跳过。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>next <span class="token operator">=</span> chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>prev<span class="token operator">&lt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>prev<span class="token operator">!=</span>chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>Character<span class="token punctuation">.</span><span class="token function">isLetterOrDigit</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                prev<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>next<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>Character<span class="token punctuation">.</span><span class="token function">isLetterOrDigit</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                next<span class="token operator">--</span><span class="token punctuation">;</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token operator">&lt;</span>next <span class="token operator">&amp;&amp;</span> Character<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Character<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            prev<span class="token operator">++</span><span class="token punctuation">;</span>            next<span class="token operator">--</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 本题中，我们将空字符串定义为有效的回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/str
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线程内部的run方法可以向外抛出异常吗？</title>
    <link href="https://www.codetool.top/article/%E7%BA%BF%E7%A8%8B%E5%86%85%E9%83%A8%E7%9A%84run%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%90%91%E5%A4%96%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%EF%BC%9F/"/>
    <id>https://www.codetool.top/article/线程内部的run方法可以向外抛出异常吗？/</id>
    <published>2020-05-20T08:53:01.000Z</published>
    <updated>2020-05-20T10:06:35.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提出问题">1 提出问题</h1><p>线程的run方法向外可以抛出异常吗，或者能被主线程捕获异常吗？比如下面这段代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"捕获异常！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>能被外部主线程捕获到异常吗？如果你用的是比较智能的IDE，应该在编写这段代码时就会直接报错：<code>未报告的异常错误java.lang.Exception; 必须对其进行捕获或声明以便抛出</code>，可见外部是捕获不到这个异常的，同理，下面这段代码会产生一个RuntimeException，在主线程中也不能对其进行捕获：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"捕获异常！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="处理线程内部异常的方法">2 处理线程内部异常的方法</h1><h2 id="try-catch">2.1 try-catch</h2><p>由此可知，java线程内部产生的异常应当在线程内部进行处理，最典型的方法是在线程内部使用<code>try...catch...</code>捕获异常。</p><p>但是，如果不想使用<code>try-catch</code>，有没有其他的办法呢？</p><h2 id="UncaughtExceptionHandler">2.2 UncaughtExceptionHandler</h2><p>JDK提供了一个类称为<code>UncaughtExceptionHandler</code>，翻译过来是未捕获异常处理器，可以把它看作线程的全局异常处理器，会处理所有的RuntimeException异常，因为它是非受查的。</p><p>给线程设置一个<code>UncaughtExceptionHandler</code>有两个方法，一个是直接使用Thread的成员方法<code>setUncaughtExceptionHandler</code>，是为调用该方法的线程设置异常处理器：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"thread1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">setUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"中进行处理异常："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另一种方法是通过<code>Thread.setDefaultUncaughtExceptionHandler</code>静态方法，为所有线程设置一个异常处理器：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"thread1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">setDefaultUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"中进行处理异常："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面这两段程序运行之后都可以看到异常是在哪进行处理的：</p><pre><code>在thread1中进行处理异常：java.lang.ArithmeticException</code></pre><p>可见还是在子线程中进行处理的，那么有没有能在主线程中处理异常的方法呢？</p><h2 id="TaskFuture-Callable触发异常">2.3 TaskFuture+Callable触发异常</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行这段程序，查看错误流输出：</p><pre><code>Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero    at java.util.concurrent.FutureTask.report(FutureTask.java:122)    at java.util.concurrent.FutureTask.get(FutureTask.java:192)    at com.rhett.thread.TestCatch.main(TestCatch.java:16)Caused by: java.lang.ArithmeticException: / by zero    at com.rhett.thread.TestCatch.lambda$main$0(TestCatch.java:9)    at java.util.concurrent.FutureTask.run(FutureTask.java:266)    at java.lang.Thread.run(Thread.java:748)</code></pre><p>可以看到，触发了一个<code>ExecutionException</code>异常，并且是在主线程内触发的，它的stacktrace信息和caused by信息都说明了是因为子线程中的哪个异常而引起的<code>ExecutionException</code>，通过下面这个程序就可以在主线程中处理异常了：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提出问题&quot;&gt;1 提出问题&lt;/h1&gt;&lt;p&gt;线程的run方法向外可以抛出异常吗，或者能被主线程捕获异常吗？比如下面这段代码：&lt;/p&gt;
&lt;pre class=&quot; language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="多线程" scheme="https://www.codetool.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1371-每个元音包含偶数次的最长子字符串</title>
    <link href="https://www.codetool.top/article/leetcode1371-%E6%AF%8F%E4%B8%AA%E5%85%83%E9%9F%B3%E5%8C%85%E5%90%AB%E5%81%B6%E6%95%B0%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode1371-每个元音包含偶数次的最长子字符串/</id>
    <published>2020-05-20T05:53:38.000Z</published>
    <updated>2020-05-20T06:31:26.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> s = “eleetminicoworoep”<br><strong>输出：</strong> 13<br><strong>解释：</strong> 最长子字符串是 “leetminicowor” ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> s = “leetcodeisgreat”<br><strong>输出：</strong> 5<br><strong>解释：</strong> 最长子字符串是 “leetc” ，其中包含 2 个 e 。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong> s = “bcbcbc”<br><strong>输出：</strong> 6<br><strong>解释：</strong> 这个示例中，字符串 “bcbcbc” 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用官方题解的前缀和+状态压缩！</p><p>这道题不好想，如果用暴力在leetcode绝对超时，可以想到用前缀和的方法。</p><p>前缀和怎么做呢？如果要两个字符串的差值（字符串交集）中，a,e,i,o,u全部为偶数，那么根据数学知识，偶数减偶数是偶数，奇数减奇数也是偶数。也就是说两个字符串中的这五个字母出现的奇偶性必须一样！</p><p>而五个字母，每个字母出现的次数都可奇可偶，组合出来的情况有很多种，在遍历的时候遇到其中一种奇偶性组合，如何知道最早出现的同一种奇偶性组合出现在哪个位置呢？</p><p>这里有一种方法：遍历的时候记录并计算所有字母的个数，然后对每次遍历到的位置，将它的奇偶性组合编码成字符串，例如“奇偶奇偶奇”，代表a,i,u出现奇数个，而e,o出现偶数个。然后就以这个字符串为键，第一次出现的顺序为值存放到哈希表中。后面只要出现相同的奇偶性排列，就把它从哈希表中取出来，就知道最早出现的位置，两个位置一减就是字符串的长度。</p><p>但是这种方法需要构造字符串，并且需要记录五种字母出现的个数，十分麻烦，那么可以利用“状态压缩”+“位运算”的方法：将这种奇偶性排列编码成一个五位的二进制位串，例如二进制的”10101”，代表a,i,u出现奇数个，而e,o出现偶数个。每一个字母都映射到位串的一个位上，而再出现一个字母的时候，就通过异或运算更改对应位上的值。</p><p>例如： “10101” :a,i,u出现奇数个，e,o出现偶数个<br>（再出现一个i）-&gt;”10101”^”100” = “10001”，即a,u出现奇数个，e,i,o出现偶数个。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTheLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果是-1，说明还没有出现这种奇偶性排列</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//第一个全偶的情况出现在还没开始遍历的时候</span>        pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> ch <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                status <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'e'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                status <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'i'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                status <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'o'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                status <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'u'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                status <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">[</span>status<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> pos<span class="token punctuation">[</span>status<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                pos<span class="token punctuation">[</span>status<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/st
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新增高效原子累加器LongAdder源码分析</title>
    <link href="https://www.codetool.top/article/JDK8%E6%96%B0%E5%A2%9E%E9%AB%98%E6%95%88%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8LongAdder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/JDK8新增高效原子累加器LongAdder源码分析/</id>
    <published>2020-05-19T07:23:53.000Z</published>
    <updated>2020-05-19T08:54:25.669Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前写过<a href="../CAS应用之JUC下的原子类/">CAS应用之JUC下的原子类</a>，但是LongAdder这个类没有去看，只是给了一个其他博客的参考链接。今天就自己来分析一下。</p><h1 id="AtomicLong的问题和LongAdder的基本使用">1 AtomicLong的问题和LongAdder的基本使用</h1><p>与LongAdder功能类似的就是<code>AtomicLong</code>了，但我们知道，<code>AtomicLong</code>中只有一个原子变量value，多线程必须通过CAS自旋去尝试修改这个变量，同一时间只能有一个线程修改成功，会产生效率的问题。</p><p>而LongAdder，则是为了解决<code>AtomicLong</code>的效率问题，它的思路是，既然多个线程同时去抢一个原子变量会有效率问题，那么可以将这一个原子变量分为多个原子变量，让多个线程去争抢，就能提高线程CAS成功的概率。</p><p>先看看LongAdder的用法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LongAdder adder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>adder<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> origin <span class="token operator">=</span> adder<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//加1</span>        adder<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加1之前："</span><span class="token operator">+</span> origin<span class="token operator">+</span> <span class="token string">"，加1之后："</span><span class="token operator">+</span>adder<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在我电脑上的运行结果是：</p><pre><code>0加1之前：0，加1之后：1加1之前：1，加1之后：2加1之前：2，加1之后：3加1之前：4，加1之后：5加1之前：0，加1之后：7加1之前：3，加1之后：4加1之前：5，加1之后：7加1之前：7，加1之后：8加1之前：8，加1之后：9加1之前：9，加1之后：10</code></pre><p>可见，加之前和加之后获取的值并不一定相差1，但却很严谨地进行了原子累加操作，最后结果也是10。</p><p>除了通过<code>increment()</code>累加1外，LongAdder还可以通过<code>add()</code>方法增加其他的值。</p><h1 id="源码分析">2 源码分析</h1><p><img src="https://api.codetool.top/img/15898741569888.png" alt></p><p>LongAdder继承自<code>Striped64</code>，核心逻辑还是在<code>Striped64</code>中，体现着JDK尽可能抽取公用复用部分的思想。</p><p>LongAdder的构造器方法没有任何东西，类中也看不到任何代表存储值的字段：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>那么就来看看<code>sum()</code>方法获取的值是从哪来的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> cells<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取base值</span>    <span class="token keyword">long</span> sum <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果Cell数组不为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 遍历Cell数组，并加上每个Cell代表的值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从该方法看出，LongAdder存储的值分布于base和Cell数组中，为它们值的总和。</p><p>那么base和Cell数组在哪里呢？通过定位，发现在<code>Striped64</code>类中：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Cell内部类</span><span class="token annotation punctuation">@sun</span><span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Contended <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Cell</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//可通过构造函数赋值</span>    <span class="token function">Cell</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//提供CAS操作</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">cas</span><span class="token punctuation">(</span><span class="token keyword">long</span> cmp<span class="token punctuation">,</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe UNSAFE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// value字段的偏移地址</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取value字段的偏移地址</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            UNSAFE <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> ak <span class="token operator">=</span> Cell<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>            valueOffset <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>ak<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// CPU的个数</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NCPU <span class="token operator">=</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Cell数组</span><span class="token keyword">transient</span> <span class="token keyword">volatile</span> Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> cells<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> base<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 用于保护cells数组更改的CAS变量</span><span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cellsBusy<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe UNSAFE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// base、cellsbusy字段和Thread threadLocalRandomProbe字段的偏移量</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> BASE<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> CELLSBUSY<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> PROBE<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        UNSAFE <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> sk <span class="token operator">=</span> Striped64<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        BASE <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>            <span class="token punctuation">(</span>sk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"base"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CELLSBUSY <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>            <span class="token punctuation">(</span>sk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"cellsBusy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> tk <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        PROBE <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>            <span class="token punctuation">(</span>tk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"threadLocalRandomProbe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>threadLocalRandomProbe</code>这个字段我们在<a href="../Random在多线程下的问题以及ThreadLocalRandom类分析">Random在多线程下的问题以及ThreadLocalRandom类分析</a>里见过，没想到这里也用上了。</p><p>看完了这些字段后可知，base和cells数组都没有经过初始化，即base默认为0，cells默认为null，这也符合初始化LongAdder值为0的结果。</p><p>那么，来看一下LongAdder的<code>increment()</code>方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">add</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>就是调用了<code>add()</code>函数加1：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">casBase</span><span class="token punctuation">(</span>b <span class="token operator">=</span> base<span class="token punctuation">,</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果Cell数组为null，或长度为0</span>        <span class="token comment" spellcheck="true">// 或要争抢的cell为null</span>        <span class="token comment" spellcheck="true">// 或CAS要争抢的cell失败</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>            <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 交由longAccumulate处理</span>            <span class="token function">longAccumulate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> null<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可见这段代码的逻辑仍是优先对base变量进行CAS操作，当cells数组为空的时候，首先尝试CAS一次base变量，仅当争抢base变量没成功才继续往下走：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">casBase</span><span class="token punctuation">(</span><span class="token keyword">long</span> cmp<span class="token punctuation">,</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASE<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其次，以下任意条件都能触发<code>longAccumulate</code>方法：</p><ul><li>Cell数组为null</li><li>Cell数组长度为0</li><li>要争抢的cell为null</li><li>CAS要争抢的cell失败</li></ul><p>而线程是怎么确定要争抢哪个cell元素呢？通过代码中<br><code>a = as[getProbe() &amp; m]</code>可以看出，是<strong>通过线程中的<code>threadLocalRandomProbe</code>与<code>Cell数组的长度-1</code>做位与运算确定的</strong>。并且Striped64要求Cell的数组长度为2的整数幂，也就是<code>Cell数组的长度-1</code>每一位都是1，位与之后的结果会尽量均匀。</p><p>那我们现在假设Cell数组还没有初始化，即Cell数组还是null，会触发<code>longAccumulate</code>方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">longAccumulate</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> LongBinaryOperator fn<span class="token punctuation">,</span>                            <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果probe为0，代表ThreadLocalRandom对象还没有获取，原因上一篇中看过了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取ThreadLocalRandom对象，同时初始化种子、探针等字段</span>        ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 获取探针</span>        h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否发生碰撞</span>    <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Cell数组是否初始化且长度不为0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果线程对应的Cell为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果cellsBusy没有被锁上</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">// 先获取一个Cell对象</span>                    Cell r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 尝试锁住cellsBusy</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                              <span class="token comment" spellcheck="true">// 将对应的cell赋值为创建的Cell对象</span>                            Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                                <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                                rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>                                created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                            cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>                       wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 线程对应的Cell不为null，尝试CAS更改</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>                                            fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果CAS对应的cell失败</span>            <span class="token comment" spellcheck="true">// 若Cell数组的长度大于CPU个数，或者cells被更改了，都不进行扩容</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> NCPU <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span>                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 否则进行扩容       </span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>                collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 尝试cas锁上cellsBusy</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//进行扩容</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//扩容一倍      </span>                        Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                            rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//更改一下probe探针</span>            h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果cell数组没有初始化，锁上cellsBusy进行初始化</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                                   <span class="token comment" spellcheck="true">//cells没有被更改        </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 初始化一个长度为2的Cell数组</span>                    Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 给线程对应的Cell初始化值</span>                    rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>                    init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果CAS锁cellsBusy变量没有成功，再次尝试CAS base变量，如果成功就不用搞了，失败继续循环</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span>fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>                             <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可见，Cell数组中的元素是懒惰初始化的，并且数组初始容量为2，如果发生碰撞还会对数组进行扩容，不过最终不会超过CPU的个数。</p><p>过程中会反复尝试CAS cellsBusy锁变量，如果失败，还会再次去尝试CAS base变量，如果成功就不需要更改Cell数组了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久以前写过&lt;a href=&quot;../CAS应用之JUC下的原子类/&quot;&gt;CAS应用之JUC下的原子类&lt;/a&gt;，但是LongAdder这个类没有去看，只是给了一个其他博客的参考链接。今天就自己来分析一下。&lt;/p&gt;
&lt;h1 id=&quot;AtomicLong的问题和LongAdder的
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码分析" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="多线程" scheme="https://www.codetool.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
