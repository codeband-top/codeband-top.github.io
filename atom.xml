<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-04-27T15:28:58.172Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树中序遍历-折纸问题</title>
    <link href="https://www.codetool.top/article/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/二叉树中序遍历-折纸问题/</id>
    <published>2020-04-27T15:16:19.000Z</published>
    <updated>2020-04-27T15:28:58.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。</p><p>给定折的次数n,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 1<br><strong>输出:</strong> [“down”]</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一次折叠，会在现有折痕的上方产生一个下的折痕，在折痕的下方产生一个上的折痕。（可以动手尝试理解）</p><p>这样就会形成一个二叉树：</p><p><img src="https://api.codetool.top/img/15880011961390.png" alt></p><p>从纸的上面到下面打印就是二叉树的 RVL 的遍历（右根左，特殊的中序遍历）。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoldPaper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">foldPaper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"down"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fold</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> String type<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fold</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"down"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fold</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"up"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode86-分隔链表</title>
    <link href="https://www.codetool.top/article/leetcode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/leetcode86-分隔链表/</id>
    <published>2020-04-27T06:36:11.000Z</published>
    <updated>2020-04-27T06:39:10.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br><strong>输出:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>双指针法，因为某些节点可能称为新的头节点，需要设置哨兵节点。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">partition</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode before_head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode before <span class="token operator">=</span> before_head<span class="token punctuation">;</span>        ListNode after_head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode after <span class="token operator">=</span> after_head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                before<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                before <span class="token operator">=</span> before<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                after<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                after <span class="token operator">=</span> after<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        after<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        before<span class="token punctuation">.</span>next <span class="token operator">=</span> after_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> before_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组元素左右两边最近较小元素</title>
    <link href="https://www.codetool.top/article/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E6%9C%80%E8%BF%91%E8%BE%83%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/数组元素左右两边最近较小元素/</id>
    <published>2020-04-26T05:40:33.000Z</published>
    <updated>2020-04-26T06:19:06.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。</p><p><strong>实例：</strong></p><blockquote><p><strong>输入:</strong> arr = {3,4,1,5,6,2,7}<br><strong>输出</strong><br>{<br>&nbsp;&nbsp;{-1,&nbsp;2},<br>&nbsp;&nbsp;{&nbsp;0,&nbsp;2},<br>&nbsp;&nbsp;{-1,-1},<br>&nbsp;&nbsp;{&nbsp;2,&nbsp;5},<br>&nbsp;&nbsp;{&nbsp;3,&nbsp;5},<br>&nbsp;&nbsp;{&nbsp;2,-1},<br>&nbsp;&nbsp;{&nbsp;5,-1}<br>}  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>单调栈，或使用动态规划的方式做，都可以达到线性时间复杂度。</p><h2 id="代码">2.2 代码</h2><p>动态规划：（其实也是单调栈的思想）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNearLessNoRepeat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从左到右扫描</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                left <span class="token operator">=</span> res<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从右到左扫描</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                right <span class="token operator">=</span> res<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>单调栈：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNearLessNoRepeat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果当前遍历到的数组的值小，需要弹出</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> popIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> leftLessIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftLessIndex<span class="token punctuation">;</span>                res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> popIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> leftLessIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftLessIndex<span class="token punctuation">;</span>            res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124-二叉树中的最大路径和</title>
    <link href="https://www.codetool.top/article/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode124-二叉树中的最大路径和/</id>
    <published>2020-04-26T05:03:04.000Z</published>
    <updated>2020-04-26T05:15:41.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个节点</strong>，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,2,3]       <strong>1</strong>      <strong>/ \</strong>     <strong>2</strong>   <strong>3</strong><strong>输出:</strong> 6</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [-10,9,20,null,null,15,7]&nbsp;  -10&nbsp; &nbsp;/ \&nbsp; 9 &nbsp;<strong>20</strong>&nbsp; &nbsp; <strong>/ &nbsp;\</strong>&nbsp; &nbsp;<strong>15 &nbsp; 7</strong><strong>输出:</strong> 42</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设计一个函数<code>max_gain</code>，用于返回一个节点与它的左子树或右子树连成的最长路径。</p><p>使用一个全局变量记录递归回溯过程中出现的最大路径长，对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:</p><ol><li>其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径（即递归函数返回的值）</li><li>左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径（在函数中与上面的情况产生的值进行比较，更新最大值）</li></ol><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max_sum <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">max_gain</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left_gain <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max_gain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right_gain <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max_gain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> price_newpath <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> left_gain <span class="token operator">+</span> right_gain<span class="token punctuation">;</span>        max_sum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_sum<span class="token punctuation">,</span> price_newpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left_gain<span class="token punctuation">,</span> right_gain<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">max_gain</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max_sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径&lt;strong&gt;至少包含一个节点&lt;/strong&gt;，且不一定经过根节点。&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>net.ipv4.ip_local_port_range的含义</title>
    <link href="https://www.codetool.top/article/net-ipv4-ip-local-port-range%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://www.codetool.top/article/net-ipv4-ip-local-port-range的含义/</id>
    <published>2020-04-25T15:55:45.000Z</published>
    <updated>2020-04-25T17:18:58.440Z</updated>
    
    <content type="html"><![CDATA[<p>在《深入分析Java Web技术内幕》一书中看到下面这段话：</p><blockquote><p>要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位操作系统的端口号通常由两个字节表示，也就是只有2<sup>16</sup>=65535个，所以一台主机能够同时建立的连接数是有限的，当然操作系统还有一些端口0~1024是受保护的，如80端口、22端口，这些端口都不能被随意占用。  </p><p>在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。</p></blockquote><p>看完这段话我对几个地方都有点质疑：</p><ol><li><code>32位操作系统的端口号通常由两个字节表示</code>，难道64位机器的端口号还能超过两个字节？大于65535的端口从来没见过。应该是和协议规定的有关系，我在<a href="../计网复习05-传输层">计网复习05-传输层</a>中对TCP和UDP的报文格式都有描述，无论是TCP还是UDP的报文头部都有一个两字节的源端口号和两字节的目的端口号，这应该是TCP/IP协议对端口号长度做出的规定。</li><li><code>所以一台主机能够同时建立的连接数是有限的</code>，原因讲的很模糊，他提到和端口的数量有关系，但实际上我们说一个socket连接是由一个四元组唯一标识的，即两个socket（两台主机的ip和端口号），这四个属性中任何一个不一样都可以是的socket连接，而另一台主机是不确定的，所以应该说<code>两台主机之间能够同时建立的连接数是有限的</code>，这里可能上下文是这个意思，但没有表述清楚。</li><li><code>操作系统还有一些端口0~1024是受保护的，如80端口、22端口，这些端口都不能被随意占用</code>和<code>在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。</code>，显然作者对端口号的划分没有很好的理解，后面这句话也有很明显的错误。我在<a href="../计网复习05-传输层">计网复习05-传输层</a>的第一节的思维导图中有总结端口号的分类，但当时没有详谈，看到这段话之后查阅了相关资料，这里详细介绍一下。</li></ol><h1 id="端口的分类">1 端口的分类</h1><p><a href="../计网复习05-传输层">计网复习05-传输层</a>这一篇的思维导图中先把端口号分为了服务端使用的端口（0-49151）和客户端使用的端口（49151-65535）。实际上这是不一定的，没有强制要求服务端和客户端只能使用这个端口范围，这应该是tcp/ip协议的建议，并且很明显这个建议也被广泛采纳，这不意味着服务器就不可以使用（49151-65535）中的端口作为长期服务端口。</p><p>下面介绍的端口分类对应的范围是由IANA（互联网数字分配机构）规定的。</p><h2 id="熟知端口">1.1 熟知端口</h2><p>熟知端口（WellKnown Ports），数值一般为 <code>0 ~ 1023</code>。</p><p>0端口是保留端口，在编程API中（特别是linux socket编程）作为请求系统分配的（动态）端口。</p><p>很多知名的应用层协议会选择这个端口范围内的端口号，例如HTTP服务默认的端口号是80，HTTPS是443，DNS是53、FTP是20、21，SSH是22等。所以一般不推荐没有熟知端口号的应用程序使用这部分的端口号，否则很容易冲突，但<strong>不意味着只有这些应用程序才能使用这部分的端口号，只要不冲突，其他服务也能使用这些端口，但是linux中root权限用户的才可以启用1~1023的服务。</strong></p><h2 id="登记端口号">1.2 登记端口号</h2><p>登记端口号（Registered Ports），数值为 <code>1024 ~ 49151</code>，为没有熟知端口号的应用程序使用的。</p><h2 id="短暂端口号">1.3 短暂端口号</h2><p>短暂端口号（Ephemeral Ports），也被称为动态端口（Dynamic Ports），IANA推荐使用 <code>49152 ~ 65535</code>，留给客户进程选择暂时使用。这是什么意思呢？<strong>客户端使用TCP、UDP协议与服务端进行连接时，通常会从这个端口范围内被随机分配一个未使用的端口，从而与服务端建立socket连接。</strong>这个分配的端口是临时的，仅在通信会话期间有效，所以称为“短暂端口”，与服务器上长期服务的端口区分开。</p><p>虽然说推荐是客户端使用的，但实际上服务器也能使用这一部分的端口号做长期服务。</p><p><code>49152 ~ 65535</code>是IANA推荐使用的短暂端口号范围，而<strong>linux默认使用的短暂端口号范围实际上是32768到60999</strong>，也就是我们使用命令<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>或<code>sysctl -a|grep ip_local_port_range</code>看到的两个数字。linux严格遵守这个配置，作为客户端建立socket连接时只会从这个端口范围获取动态分配的端口。</p><p>下面谈谈如何修改这个值，显然修改这个值能明显提高linux作为客户端能建立的并发连接数。因为tcp常常因为<code>time_wait</code>状态占用大量短暂端口，适当提高这个范围也可以减少端口不够用的影响。</p><p>linux修改方法：</p><pre><code>vi /etc/sysctl.conf</code></pre><p>修改</p><pre><code>net.ipv4.ip_local_port_range = 1024 65535</code></pre><p>然后</p><pre><code>sysctl -p</code></pre><p>生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在《深入分析Java Web技术内幕》一书中看到下面这段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位操作系统的端口号通常由两个字节表示，也就是只有2&lt;sup&gt;16&lt;/sup&gt;=65535个，所以
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode13-罗马数字转整数</title>
    <link href="https://www.codetool.top/article/leetcode13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode13-罗马数字转整数/</id>
    <published>2020-04-25T03:47:19.000Z</published>
    <updated>2020-04-25T04:23:05.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><pre><strong>字符</strong>          <strong>数值</strong>I             1V             5X             10L             50C             100D             500M             1000</pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> “III”<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> “IV”<br><strong>输出：</strong> 4  </p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入：</strong> “IX”<br><strong>输出：</strong> 9  </p></blockquote><p><strong>示例4:</strong></p><blockquote><p><strong>输入：</strong> “LVIII”<br><strong>输出：</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.  </p></blockquote><p><strong>示例5:</strong></p><blockquote><p><strong>输入：</strong> “MCMXCIV”<br><strong>输出：</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于字符串中从左到右每个字符，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">!=</span>chars<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                ans <span class="token operator">+=</span> <span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanChartoNum</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习04-存储管理</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A004-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://www.codetool.top/article/操作系统复习04-存储管理/</id>
    <published>2020-04-24T13:58:15.000Z</published>
    <updated>2020-04-25T13:09:28.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关概念">1 相关概念</h1><p><img src="https://api.codetool.top/img/15877892594926.png" alt></p><h2 id="从写程序到程序运行">1.1 从写程序到程序运行</h2><ul><li>编辑源代码文件</li><li>编译：由源代码文件生成目标模块(高级语言“翻译“为机器语言)</li><li>链接：由目标模块生成装入模块，链接后形成完整的<strong>逻辑地址</strong></li><li>装入：将装入模块装入内存，装入后形成<strong>物理地址</strong></li></ul><p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址。在装入运行后，才会将逻辑地址转换为物理地址。</p><h2 id="链接的三种方式">1.2 链接的三种方式</h2><ul><li>静态链接：<strong>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）</strong>，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式。</li><li>运行时动态链接：<strong>在程序执行中需要该目标模块时，才对它进行链接</strong>。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul><h2 id="装入（装载）的三种方式">1.3 装入（装载）的三种方式</h2><ul><li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，<strong>编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</strong>绝对装入只适用于单道程序环境。</li><li>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</strong><ul><li>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。<strong>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</strong></li></ul></li><li>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此<strong>装入内存后所有的地址依然是逻辑地址</strong>。这种方式需要一个<strong>重定位寄存器</strong>的支持。采用动态重定位时允许程序在内存中发生移动。<ul><li>可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ul></li></ul><h1 id="存储管理的功能">2 存储管理的功能</h1><p><img src="https://api.codetool.top/img/15877892733377.png" alt></p><ul><li>定位(存储分配)：为具体的程序和数据等分配存储单元或存储区工作。</li><li>地址映射：将逻辑地址转换为相应的物理地址。地址空间是程序用来访问信息所用地址单元的集合。</li><li>存储共享：两个或多个进程共用内存中相同区域。目的：节省内存空间，提高内存利用率、实现<strong>进程通信</strong>(数据共享)。</li><li>存储保护：<strong>各道程序只能访问自己的内存区而不能互相干扰</strong>，必须对内存中的程序和数据进行保护，以免受到其他程序有意或无意的破坏。可对进程执行时所产生的所有内存访问地址进行检查，确保进程仅访问它自己的内存区，这就是<strong>地址越界保护</strong>，越界保护依赖于硬件设施，常用的有：界地址寄存器和存储键。</li><li>存储扩充：用户在编制程序时，不应该受内存容量限制，所以要采用一定技术来“扩充”内存的容量，<strong>使用户得到比实际内存容量大的多的内存空间</strong>。<ul><li>覆盖技术：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)。这种实现方式需要程序员手动声明覆盖区，不便于实现。</li><li>交换技术：交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)，换到外存中的进程就称为<strong>挂起态</strong>，<strong>即使进程被换出内存，PCB必须常驻内存</strong>。</li><li>虚拟存储技术：具体实现是在硬件支持下，软硬件相互协作，将内存和外存结合起来统一使用。 </li></ul></li></ul><p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对<strong>文件区空间的管理采用离散分配方式</strong>；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此<strong>通常对换区采用连续分配方式</strong>。总之，对换区的I/O速度比文件区的更快。</p><h1 id="实存管理">3 实存管理</h1><p><img src="https://api.codetool.top/img/15877893676624.png" alt></p><h2 id="连续分配管理方式（分区）">3.1 连续分配管理方式（分区）</h2><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><h3 id="单一连续分配">3.1.1 单一连续分配</h3><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。<strong>内存中只能有一道用户程序，用户程序独占整个用户区空间。</strong></p><p>优点：</p><ul><li>实现简单</li><li>无外部碎片</li><li>可以采用覆盖技术扩充内存</li><li>不一定需要采取内存保护</li></ul><h3 id="固定分区分配">3.1.2 固定分区分配</h3><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是<strong>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>可分为大小相同的分区和大小不同的分区，但依然缺乏灵活性。</p><p>固定分区分配会产生内部碎片：</p><blockquote><p>内部碎片，分配给某进程的内存区域中，有些部分没有用上。<br>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</p></blockquote><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)</p><h3 id="动态分区分配">3.1.3 动态分区分配</h3><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><p>分配与回收方案：</p><ul><li>当作业装入内存时：<ul><li>若有足够空间，分割一个分区给该作业（具体选择策略由分配算法决定）</li><li>若没有足够空间，等待内存资源</li></ul></li><li>空间回收：若两端有空闲区，和空闲区合并</li></ul><p><strong>动态分区会产生外部碎片</strong>：</p><p>动态分区分配算法：</p><ul><li><strong>首次适应算法</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。会出现低地址空闲区用得较频繁的情况，内存各区域使用频率不均。但优点是通常能保留高地址区域的较大分区，更不容易产生外部碎片。<ul><li>为了解决首次适应算法的缺点，可以使用改进后的“<strong>下次适应算法</strong>”，它会接着上一次扫描到的位置继续往下扫描，不会导致各区域使用频率不均。</li></ul></li><li><strong>最佳适应算法</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。缺点：<strong>会产生较多外部碎片</strong>。</li><li><strong>最坏适应算法</strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时<strong>优先使用最大的连续空闲区</strong>，这样分配后剩余的空闲区就不会太小，更方便使用。缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式<strong>会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong></li></ul><h2 id="非连续分配管理方式（分页）">3.2 非连续分配管理方式（分页）</h2><p>程序存放到若不相邻的空间块中。</p><p>将<strong>内存空间分为一个个大小相等的分区</strong>(比如：每个分区4KB)，每个分区就是一个<strong>“页框”</strong>，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)。页框号从0开始。</p><p><strong>将用户进程的地址空间也分为与页框大小相等的一个个区域</strong>，称为<strong>“页”</strong>或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。</p><p>逻辑地址由页号（<code>逻辑地址/页的大小</code>）和页内偏移（<code>逻辑地址%页的大小</code>）构成，<strong><code>物理地址=页号对应的页框号×块长+页内地址</code></strong>。为了方便计算页号、页内偏移量，<strong>页面大小一般设为2的整数幂</strong></p><p>那么如何知道页号对应的页框号？为了能知道进程的每个页面在内存中存放的位置，操作系统要<strong>为每个进程建立一张页表</strong>。</p><p><strong>进程的页表在进程运行的时候也会被装载到页框中。</strong></p><ol><li>进程的每一页对应一个页表项</li><li>每个页表项由<code>“页号”</code>和<code>“块号”</code>（页框号）组成</li><li>页表记录进程页面和实际存放的内存块之间的对应关系</li></ol><h3 id="基本地址变换机构">3.2.1 基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<strong>页表寄存器(PTR)</strong>，存放<strong>页表在内存中的起始地址F和页表长度M。</strong></p><p>进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>地址变换过程：</p><ol><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界，如果越界会触发越界中断（如果页号大于或等于页表长度）</li><li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li><li>用内存块号和页内偏移量得到物理地址</li></ol><p>由于页表中的页表项都是连续存储的，而页表项的大小是相等的，因此页号可以隐含（从0开始的连续计数），只存储块号。</p><h3 id="翻译快表">3.2.2 翻译快表</h3><p>由上述内容我们可以知道，访问进程中的一个逻辑地址需要经过两次访存（第一次查询页表，第二次才是真正的访问逻辑地址对应的物理地址），那有没有办法减少访存次数呢？</p><p>快表（TLB）是一种特殊的高速缓冲存储器（Cache），<strong>内容是页表中的一部分或全部内容</strong>。在操作系统中引入快表是为了加快地址映射速度。</p><p>地址变换过程：</p><ol><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界，如果越界会触发越界中断（如果页号大于或等于页表长度）</li><li>查询快表<ol><li>若快表中没有目标页表项，则需要查询内存中的页表，并将查询到的页表项放入快表</li><li>若查询快表命中，就获取了页号对应的页表项</li></ol></li><li>用内存块号和页内偏移量得到物理地址</li></ol><p>因此，如果查询快表命中，则访问某个逻辑地址仅需一次访存即可。有的系统还支持快表和慢表（对应内存中的页表）同时查找，减少平均耗时。</p><h3 id="多级页表">3.2.3 多级页表</h3><p>如果程序使用空间很大，它的页表也会很大，需要占用很多个连续的页框。我们可以利用索引的思想，为页表也建立索引，使其可以离散存储于内存的各个页框中，称为多级页表。</p><p>系统为每个进程建一张<strong>页目录表</strong>，它的<strong>每个表项对应一个页表页</strong>，而<strong>页表页的每个表项给出了页面和页框的对应关系</strong>，<strong>页目录表是一级页表，页表页是二级页表</strong>。</p><p>使用二级页表后的逻辑地址结构由三部分组成：<strong>一级页号、二级页号和页内偏移</strong></p><p>注意：各级页表的大小不能超过一个页面。</p><h2 id="基本分段存储管理">3.3 基本分段存储管理</h2><p>与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同</p><p><strong>分页存储管理是一维地址结构，分段存储管理是二维地址结构。</strong></p><p>进程的地址空间<strong>按照程序自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p><p>分段系统的<strong>逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成</strong>。段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。</p><p>段表：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能<strong>从物理内存中找到各个逻辑段的存放位置</strong>。为此，需为每个进程建立一张段映射表，简称<strong>段表</strong>。每个段对应一个段表项，其中<strong>记录了该段在内存中的起始位置(又称“基址”)和段的长度。</strong></p><p>分页和分段的区别：</p><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li></ul><h2 id="段页式存储管理">3.4 段页式存储管理</h2><table><thead><tr><th>管理方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table><p>段页式存储管理结合了分页管理和分段管理的优缺点，将进程按逻辑模块分段，再将各段分页(如每个页面4KB)。内存依然按页的大小分为各个页框。</p><p>段页式系统的逻辑地址结构由<strong>段号、页号、页内地址</strong>(页内偏移量)组成。段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少</p><p>因此段页式管理的地址结构也是二维的。</p><p>段页式管理中的段表存储的就不是基址了，而是<strong>页表长度和页表的存放块号</strong>。地址转换时先查询段表，再查询页表。</p><h1 id="虚存管理">4 虚存管理</h1><p><img src="https://api.codetool.top/img/15877894059649.png" alt></p><h2 id="相关概念-1">4.1 相关概念</h2><p>有的时候可以在进程运行时<strong>实时将所需要的页装入内存</strong>，而不需要一次性全部装入，称为<strong>部分装入</strong>。当内存已满而又有新的“部分”需要装入时，要把已在内存的某一“部分”换出去，称为<strong>部分对换</strong></p><p>程序局部性原理：</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</li></ul><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>分页虚存系统的硬件支撑：<strong>内存管理单元MMU</strong>完成逻辑地址到物理地址的转换功能，它接受逻辑地址作为输入，物理地址作为输出，直接送到总线上，对内存单元进行寻址。 MMU的主要功能：</p><ol><li>管理硬件页表基址寄存器。</li><li>分解逻辑地址。</li><li>管理快表TLB。</li><li>访问页表。</li><li>发出缺页中断或越界中断，并将控制权交给内核存储管理处理。</li><li>设置和检查页表中各个特征位。</li></ol><p>虚拟内存的实际容量= <code>min(内存和外存容量之和，CPU寻址范围)</code></p><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统<strong>需要知道每个页面是否已经调入内存</strong>。如果还没调入，那么也需要知道该页面在外存中存放的位置。当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面。<strong>有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖</strong>，因此，操作系统也<strong>需要记录各个页面是否被修改的信息</strong>。</p><p>于是，请求分页存储管理的页表除了对应的内存块号外，还记录了<strong>状态位（是否已调入内存，1为是，0为否）、引用位（可记录最近被访问过几次，或记录上次访问的时间，供置换算法参考）、修改位（页面调入内存后是否被修改过）、外存地址</strong></p><p>在请求分页系统中，每<strong>当要访问的页面不在内存时，便产生一个缺页中断</strong>，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><h2 id="页面置换算法">4.2 页面置换算法</h2><p><strong>最佳页面置换算法OPT：</strong>调入一页而必须淘汰一个旧页时，所淘汰的页应该是<strong>以后不再访问的页或距现在最长时间后再访问的页。</strong>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。<strong>操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</strong></p><p><strong>先进先出页面替换算法FIFO：</strong>基于程序总是按线性顺序来访问物理空间这一假设。算法<strong>淘汰最先调入内存的页，或者说在内存中驻留时间最长的页。</strong>该算法可以使用固定大小的队列实现，队列的大小为系统为进程分配的内存块数。并且该算法的性能不是很好，即使最先调入内存的页面也可能经常用到。</p><p><strong>最近最少用页面替换算法LRU：</strong>算法淘汰的页面是在<strong>最近一段时间里较久未被访问的那页。</strong> 该算法的性能较好，最接近最佳页面置换算法。实现方法：</p><ul><li>该算法可以用固定大小的链表实现，当使用某个页的时候将其连接到链表的尾部。</li><li>引用位法：每页设置一个引用位R，访问某页时，由硬件将页标志位R置1，隔一定时间t将所有页的标志R均清0。发生缺页中断时，从标志位R为0的页中挑选一页淘汰。挑选到要淘汰的页后，也将所有页的标志位R清0。</li><li>计数法：每个页面设置一个多位计数器，又叫最不常用页面替换算法LFU。每当访问一页时，就使它对应的计数器加１。当发生缺页中断时，可选择计数值最小的对应页面淘汰，并将所有计数器全部清０。</li><li>计时法：为每个页面设置一个多位计时器，每当页面被访问时，系统的绝对时间记入计时器。淘汰时比较各页面的计时器的值，选最小值的未使用的页面淘汰。</li><li>老化算法：为每个页设置一个多位寄存器r。当页面被访问时，对应寄存器的最左边位置1；每隔时间t，将r寄存器右移一位；在发生缺页中断时，找最小数值的r寄存器对应的页面淘汰。</li></ul><p><strong>第二次机会页面替换算法SCR：</strong>改进FIFO算法，把FIFO与页表中的”引用位”结合起来使用：  </p><ul><li>检查FIFO中的队首页面(最早进入内存页面)，如果它的”引用位”是0，这个页面既老又没有用，选择该页面淘汰； </li><li>如果”引用位”是1，说明它进入内存较早，但最近仍在使用。把它的”引用位”清0，并把这个页面移到队尾，把它看作是一个新调入的页。</li></ul><p><strong>时钟页面替换算法Clock：</strong>一个页面首次装入内存，其“引用位”置1。内存中的任何页面被访问时， ”引用位”置1。淘汰页面时，从指针当前指向的页面开始扫描循环队列，把迁到的”引用位”是1的页面的”引用位”清0，跳过这个页面；<strong>把所迁到的”引用位”是0的页面淘汰掉</strong>，指针推进一步。扫描循环队列时，如果迁到的所有页面的”引用位”为1，指针就会绕整个循环队列一圈，把碰到的所有页面的”引用位”清0；指针停在起始位置，并淘汰掉这一页，然后，指针推进一步。</p><ul><li>可以结合修改位对时钟页面替换算法进行改进。若用(访问位，修改位)的形式表述，则<ul><li>第一轮：淘汰(0, 0)</li><li>第二轮：淘汰(0, 1) ，并将扫描过的页面访问位都置为0</li><li>第三轮：淘汰(0, 0)</li><li>第四轮：淘汰(0, 1)</li></ul></li></ul><h2 id="页面分配策略">4.3 页面分配策略</h2><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p>分配策略：</p><ul><li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。只要有一个缺页中断产生,进程就会有一页被替换。</li><li>可变分配：先为每个进程分一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。进程执行的某阶段缺页率较高,说明目前局部性较差，系统可多分些页框以降低缺页率，反之说明进程目前的局部性较好,可减少分给进程的页框数。</li></ul><p>置换策略：</p><ul><li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul><p>从何处调入页面：</p><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的<br>部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关概念&quot;&gt;1 相关概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15877892594926.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;从写程序到程序运行&quot;&gt;1.1 从写程序到程序运行&lt;/h2&gt;&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer51-数组中的逆序对</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>https://www.codetool.top/article/剑指offer51-数组中的逆序对/</id>
    <published>2020-04-24T02:01:16.000Z</published>
    <updated>2020-04-24T03:11:34.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> [7,5,6,4]<br><strong>输出：</strong> 5</p></blockquote><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>暴力：双重循环检查，leetcode中超时</p><p>分治思想：使用归并排序的算法，每次给左右两个数组合并的时候，若右边数组中指向的元素小于左边数组指向的元素，则也小于左边数组指向的元素后面的任何一个元素（归并排序合并的时候左右两个数组都是有序的），则此时加上左边数组剩余的元素个数即可。</p><h2 id="代码">2.2 代码</h2><p>归并排序大复习，这里提供两种写法：</p><p>下面是归并排序较简单的写法，就是每次将数组均分成两个子数组，分到不能再分的时候开始合并相邻的两个子数组。这种写法递归中会创建新数组并拷贝，因此时间成本会略高些。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局变量计数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">MergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">+=</span>left<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加上左边数组剩余的元素个数</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是一种递归过程中不用创建数组的归并排序写法，只使用两个和原数组相同大小的数组来回交换数据（做对方的缓存），在局部上操作，时间成本会比上面创建数组的方法更低些，但是是一个量级的，在leetcode中能取得更好的成绩：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个和原数组相同大小的数组</span>        <span class="token keyword">return</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//[start,end]确定一个数组范围，即递归中要排序的范围，返回值为合并过程中的计数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left <span class="token operator">+</span> right <span class="token operator">+</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//[left,right)和[right,end]确定数组的两部分，合并temp数组中的这两部分到nums数组</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> leftSize <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//因为直接使用left和right作为后面使用的双指针，这里保存right原位置作为left指针能移动到的最远处</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//合并过程中计数</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">==</span>leftSize<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">==</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count <span class="token operator">+=</span> <span class="token punctuation">(</span>leftSize <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加上左边部分剩余的元素个数</span>                nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>npm安装node-sass速度慢，卡死的解决方案</title>
    <link href="https://www.codetool.top/article/npm%E5%AE%89%E8%A3%85node-sass%E9%80%9F%E5%BA%A6%E6%85%A2%EF%BC%8C%E5%8D%A1%E6%AD%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://www.codetool.top/article/npm安装node-sass速度慢，卡死的解决方案/</id>
    <published>2020-04-23T05:54:09.000Z</published>
    <updated>2020-04-23T06:05:18.281Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在用npm install安装一个前端项目依赖的时候浪费了我好长时间，即使注册了淘宝镜像，但中间还是会去<code>node.org</code>和<code>github.com</code>上面下载一些东西，中间经常卡死，导致我不停的中止、删node_modules、重新安装。</p><p>日志就是gyp什么什么的错误。</p><p>后来注意到是它在安装node-sass，并且一开始依赖的是python2（我电脑上装的python3），所以会报错python版本问题，语法识别错误什么的，可以用管理员权限打开powershell，使用下面命令安装<code>windows-build-tools</code></p><pre><code>npm install -g windows-build-tools</code></pre><p>或者自己安装python2并配置环境变量</p><p>然后中途卡死的问题主要还是去外网下载的，配置npm的镜像没有用，需要指定一个环境变量：</p><pre><code>npm install --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre><p>做到这一步如果还是失败可能是nodejs和node-gyp的版本不搭，我昨天就是因为一开始用了<code>nodejs14.0.0</code>，版本太高了，后来中间安装的时候又卡死。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天在用npm install安装一个前端项目依赖的时候浪费了我好长时间，即使注册了淘宝镜像，但中间还是会去&lt;code&gt;node.org&lt;/code&gt;和&lt;code&gt;github.com&lt;/code&gt;上面下载一些东西，中间经常卡死，导致我不停的中止、删node_modules
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典08.11-硬币</title>
    <link href="https://www.codetool.top/article/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B808-11-%E7%A1%AC%E5%B8%81/"/>
    <id>https://www.codetool.top/article/程序员面试金典08-11-硬币/</id>
    <published>2020-04-23T05:36:28.000Z</published>
    <updated>2020-04-23T05:42:59.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> n = 5<br><strong>输出:</strong> 2<br><strong>解释:</strong> 有两种方式可以凑成总金额:<br>5=5<br>5=1+1+1+1+1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 4<br><strong>解释:</strong> 有四种方式可以凑成总金额:<br>10=10<br>10=5+5<br>10=5+1+1+1+1+1<br>10=1+1+1+1+1+1+1+1+1+1   </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，不过需要注意排列组合去重</p><h2 id="代码">2.2 代码</h2><p>常见<strong>错误</strong>是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然而却忽略了重复的情况，例如6可以由<code>1+5</code>组合来，也可以由<code>5+1</code>组合来。</p><p>正确的答案其实只是将内外循环换了个顺序，<strong>保证这些数字是按递增的方式组合的</strong>，就能做到去重。：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> coin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode199-二叉树的右视图</title>
    <link href="https://www.codetool.top/article/leetcode199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>https://www.codetool.top/article/leetcode199-二叉树的右视图/</id>
    <published>2020-04-22T04:20:57.000Z</published>
    <updated>2020-04-22T05:01:54.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例：</strong></p><pre><strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]<strong>输出:</strong>&nbsp;[1, 3, 4]<strong>解释:</strong>   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</pre><style>pre,pre>*{    color:#e8eaf6;}</style><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>dfs，注意查找顺序即可，用list存储答案下标代表层数，后找到的不会覆盖先找到的</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt;&amp;nbsp;[1,2,3,
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习03-同步、通信与死锁</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A003-%E5%90%8C%E6%AD%A5%E3%80%81%E9%80%9A%E4%BF%A1%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>https://www.codetool.top/article/操作系统复习03-同步、通信与死锁/</id>
    <published>2020-04-21T17:02:02.000Z</published>
    <updated>2020-04-22T07:41:59.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发进程">1 并发进程</h1><p><img src="https://api.codetool.top/img/15874794302366.png" alt></p><h2 id="顺序程序设计">1.1 顺序程序设计</h2><p>顺序程序设计是把一个程序设计成一个顺序执行的程序模块，顺序的含义不但指一个程序模块内部，也指两个程序模块之间。</p><p>顺序程序设计的特点：</p><ul><li><strong>程序执行的顺序性</strong></li><li><strong>程序环境的封闭性</strong>：运行程序独占全部资源，除初始状态外，其所处的环境由程序本身决定，只有程序本身的动作才能改变其环境</li><li><strong>执行结果的确定性</strong>：程序执行过程中允许被中断，但这种中断对程序的最终结果无影响，也即程序的执行结果与它的执行速率无关</li><li><strong>计算过程的可再现性</strong>：在同一个数据集合上重复执行一个程序会得到相同结果，因而错误也可以重现，便于分析</li></ul><h2 id="并发程序设计">1.2 并发程序设计</h2><h3 id="程序并发机制">1.2.1 程序并发机制</h3><p><strong>进程执行的并发性：</strong> 一组进程的执行在时间上是重叠的。（和并行区分开）</p><p>从宏观上看，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态。</p><p>从微观上看，任一时刻仅有一个进程在处理器上运行。</p><p>并发的实质是一个处理器在几个进程之间的多路复用，并发是<strong>对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</strong></p><h3 id="并发进程的特性">1.2.2 并发进程的特性</h3><p>并发进程之间的关系分为两类：无关的和交互的</p><p><strong>无关的并发进程：</strong> 一组并发进程分别<strong>在不同的变量集合上操作</strong>，一个进程的执行与其他并发进程的进展无关，即一个并发，进程不会改变另一个并发进程的变量值。</p><p><strong>交互的并发进程：</strong> 一组并发进程<strong>共享某些变量</strong>，一个进程的执行可能影响其他并发进程的执行结果。<strong>交互的并发进程之间具有制约关系</strong>，这种交互必须是有控制的,否则会出现不正确的结果。</p><p>对于一组交互的并发进程，若执行的相对速度无法相互控制，则各种与时间有关的错误就可能出现。与时间有关的错误有两种表现形式:</p><ul><li>结果不唯一</li><li>永远等待</li></ul><p>并发多道程序的优点：</p><ul><li>对于单处理器系统，可让处理器和各I/O设备同时工作,发挥硬部件的并行能力。</li><li><strong>对于多处理器系统，可让各进程在不同处理器上物理地并行，加快计算速度。</strong></li><li>简化程序设计任务。 </li></ul><p>并发程序设计的特征：</p><ol><li>并行性：进程的执行在时间上可以重叠，<strong>在单处理器系统中可以并发执行，在多处理器环境中可以并行执行</strong></li><li>共享性：并发进程<strong>通过引用共享变量交换信号</strong>，从而，程序运行的环境不再是封闭的</li><li>制约性：进程并发执行或协同<strong>完成同一任务时，会产生相互制约关系</strong>，必须对它们并发执行的次序加以协调</li><li>交互性：由于并发进程共享某些变量，所以，一个进程的执行可能影响其他进程的执行结果，<strong>程序运行结果可能不确定，计算过程具有不可再现性。</strong>因此，这种交互必须是有控制的，否则会出现不正确的结果</li></ol><h3 id="进程的交互">1.2.3 进程的交互</h3><p>交互进程有两种关系：</p><ul><li><strong>竞争关系</strong>：系统中的多个进程之间<strong>彼此无关，相互并不知道其它进程的存在</strong>，相互之间并不交换信息。但是<strong>由于这些进程共用了一套计算机系统资源,因而必然产生竞争资源的问题</strong>，一个进程的执行可能影响到同其竞争资源的其它进程。操作系统必须协调好诸进程对资源的争用。一旦一个进程要使用已分配给另一个进程的资源，则该进程必须等待。资源竞争产生两个问题:<ul><li>一个是<strong>死锁(Deadlock)问题</strong>，就是一组进程如果都获得了部分资源，还想要得到其他进程所占用的资源，最终所有进程都将陷入死锁</li><li>一个是<strong>饥饿(Starvation)问题</strong>，是指一个进程由于其它进程总是优先于它而被无限期拖延</li><li>既要解决饥饿问题，又要解决死锁问题。解决饥饿问题的最简单策略是FCFS资源分配策略</li><li>竞争关系的进程使用同一资源时，同一时刻最多只允许一个进程使用，其他进程必须等待，我们称这种现象为<strong>进程互斥</strong>。</li></ul></li><li><strong>协作关系</strong>：某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。<strong>当协作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后才被唤醒并继续执行</strong>。这种<strong>协作进程之间相互等待对方消息或信号的协调关系称为进程同步</strong><ul><li>进程间的协作可以是双方不知道对方名字的间接协作（如多个进程通过访问一个公共缓冲区进行松散式协作），也可以是双方知道对方名字的直接协作，进程间通过通信机制紧密协作。</li></ul></li></ul><h1 id="临界区管理">2 临界区管理</h1><p><img src="https://api.codetool.top/img/15874814349435.png" alt></p><h2 id="互斥与临界区">2.1 互斥与临界区</h2><p>并发进程中<strong>与共享变量有关的程序段叫“临界区”</strong>， 共享变量代表的资源叫“临界资源”。 </p><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预知。<strong>如果能保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问是互斥的，就不会造成与时间有关的错误</strong></p><h2 id="临界区调度原则">2.2 临界区调度原则</h2><ul><li><strong>一次至多一个进程能够进入临界区内执行</strong></li><li>如果<strong>已有进程在临界区，其他试图进入的进程应等待</strong></li><li>进入临界区内的进程<strong>应在有限时间内退出</strong>，以便让等待进程中的一个进入</li></ul><p>临界区调度原则可总结为：</p><p>互斥使用、有空让进，<br>忙则等待、有限等待，<br>择一而入、算法可行。</p><p>算法可行是指<strong>不能因为所选的调度策略造成进程饥饿甚至死锁</strong>。</p><h2 id="软件管理临界区">2.3 软件管理临界区</h2><p>软件方法是为在具有一个处理器或共享主存的多处理器上执行的并发进程实现的，这种方法<strong>假定对主存中同一个单元的同时访问必定由存储器进行仲裁，使其串行化。</strong></p><p>临界区管理的尝试：（下面是一段伪代码，非C语言）</p><pre class=" language-c"><code class="language-c">bool inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P1不在其临界区内*/</span>bool inside2<span class="token operator">=</span>false<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*P2不在其临界区内*/</span>cobegin             <span class="token comment" spellcheck="true">/*cobegin和coend表示括号中的进程是一组并发进程*/</span>process <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>inside2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*等待*/</span>      inside1<span class="token operator">=</span>true<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">/*临界区*/</span>                          inside1<span class="token operator">=</span>false<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>process <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>inside1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*等待*/</span>    inside2<span class="token operator">=</span>true<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>    inside2<span class="token operator">=</span>false<span class="token punctuation">;</span><span class="token punctuation">}</span>coend </code></pre><p>这种方法看似没有问题，实则是错误的，</p><p><img src="https://api.codetool.top/img/15874826788391.png" alt></p><p>如上图所示，由于P1执行的时候将inside1设为true存在一定的时间延迟（和上一个操作不是原子的），在这段延迟的时间内，P2发现inside1仍为false，于是也进入临界区执行。出现了两个进程同时进入临界区的情况。</p><p>此外还有可能P1在临界区内失败（异常），导致无法将inside1置为false，使得其他进程再也无法进入临界区。</p><p>除此之外还出现了许多尝试，但仍存在一些无法解决的问题。</p><p>后来出现了两个真正实现了临界区管理的软件方法：Dekker算法和Peterson算法。由于软件实现临界区管理也不是主流，这里不重点研究了。</p><p>Dekker算法的实现：（下面两段代码来自 <a href="https://blog.csdn.net/JustJavaC2016/article/details/78660768）" target="_blank" rel="noopener">https://blog.csdn.net/JustJavaC2016/article/details/78660768）</a></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span><span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> turn<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"P%d is visting\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用关键区。  </span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//检查P1是不是也想用？  </span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果P1想用，则查看P1是否具有访问权限？  </span>            <span class="token punctuation">{</span>                  flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果有，则P0放弃。  </span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>                flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0想使用。  </span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>        turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P1。  </span>        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//P0结束使用。  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1想使用关键区。  </span>        <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//检查P0是不是也想用？  </span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果P0想用，则查看P0是否具有访问权限？  </span>            <span class="token punctuation">{</span>                  flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果有，则P1放弃。  </span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查turn是否属于P1。  </span>                flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// P1想使用。  </span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>              <span class="token function">visit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问Critical Partition。  </span>        turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问完成，将权限给P0。  </span>        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//P1结束使用。  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> err<span class="token punctuation">;</span>      err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>P1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>Peterson算法的实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> true 1  </span><span class="token macro property">#<span class="token directive keyword">define</span> false 0  </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> turn<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">procedure0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//退出while循环的条件就是，要么另一个线程  </span>        <span class="token comment" spellcheck="true">//不想要使用关键区，要么此线程拥有访问权限。  </span>        <span class="token punctuation">{</span>                  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure0 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//critical section  </span>        flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">procedure1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>              flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span>                      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"procedure1 is waiting!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//critical section  </span>            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      pthread_t t1<span class="token punctuation">,</span>t2<span class="token punctuation">;</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> err<span class="token punctuation">;</span>      turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      err <span class="token operator">=</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure0<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>procedure1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><h2 id="硬件管理临界区">2.4 硬件管理临界区</h2><p>使用软件方法实现进程互斥使用临界资源是很困难的，他们通常能实现两个进程之间的互斥，很难控制多个进程的互斥。</p><h3 id="关中断">2.4.1 关中断</h3><p>关中断是实现互斥的最简单方法之一。</p><p>进程在测试标志之前，首先关中断，直到测试完并设置标志之后才开中断。进程在临界区执行期间，<strong>计算机系统不响应中断。因此不会转向调度，也就不会引起进程或线程切换，正在执行标志测试和设置的进程或线程不会被打断，从而保证了互斥。</strong></p><p>关中断方法的缺点:</p><ul><li>关中断时间过长会影响系统效率，限制处理器交叉执行程序的能力</li><li>关中断方法也不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其他处理器上执行相同临界区代码</li></ul><h3 id="测试并设置指令">2.4.2 测试并设置指令</h3><p>其实就是<code>TestAndSet</code>，Java CAS的原理，操作系统层面提供的原子操作指令。</p><p>因为该指令是原子的，就可以使用该指令管理一个互斥量，从而实现临界区管理。</p><p>TS指令实现临界区管理的算法如下：（自旋锁）</p><pre class=" language-c"><code class="language-c">bool s<span class="token operator">=</span>true<span class="token punctuation">;</span>cobeginprocess <span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//i=1,2,...,n</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TS</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*上锁*/</span>    <span class="token comment" spellcheck="true">/*临界区*/</span><span class="token punctuation">;</span>    s<span class="token operator">=</span>true<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/*开锁*/</span><span class="token punctuation">}</span>coend</code></pre><h3 id="对换指令">2.4.3 对换指令</h3><p>对换指令（swap）交换两个字的内容，在Intel 80x86中，对换指令称为<code>XCHG</code>指令</p><p>swap指令也可以看作是同时设置两个值的原子指令实现，所以也可以用于临界区管理，思想类似。</p><p><strong>软件方法和硬件方法都存在忙等问题（当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环测试一个变量直到某个值出现为止），浪费了处理器的时间，不会成为一种通用的方法。</strong></p><h1 id="信号量与PV操作">3 信号量与PV操作</h1><p><img src="https://api.codetool.top/img/15874850424979.png" alt></p><h2 id="信号量机制">3.1 信号量机制</h2><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以<strong>用一个信号量来表示系统中某种资源的数量</strong>，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>一对原语：<code>wait(S)</code>原语和<code>signal(S)</code>原语，常简称为P、V操作。</p><p><code>wait(S)</code>相当于占用一个S资源，<code>signal(S)</code>相当于释放一个S资源。</p><h3 id="整型信号量">3.1.1 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。下面是P、V原语的实现思想：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//初始化整型信号量S，表示当前系统中可用的打印机数</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果资源数不够，就一直循环等待</span>    S <span class="token operator">=</span> S<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果资源数够，则占用一个资源</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S <span class="token operator">=</span> S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>进程Pn：</p><pre class=" language-c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用打印机资源...</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="记录型信号量">3.1.2 记录型信号量</h3><p>（思维导图中的二值信号量和一般信号量都是属于这里的记录型信号量）</p><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*记录型信号量的定义*/</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//剩余资源数</span>    <span class="token keyword">struct</span> process <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等待队列</span><span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果剩余资源数不够</span>        <span class="token comment" spellcheck="true">//使用block原语使进程从运行态进入阻塞</span>        <span class="token comment" spellcheck="true">//并把进程挂到信号量S的等待队列(即阻塞队列)中</span>        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span>    S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//释放资源后，若还有别的进程在等待这种资源</span>        <span class="token comment" spellcheck="true">//则使用wakeup原语唤醒等待队列中的个进程</span>        <span class="token comment" spellcheck="true">//该进程从阻塞态变为就绪态</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里信号量的语义就是资源的个数，并且实现了让权等待，不会形成忙等。</p><h2 id="信号量机制实现进程互斥">3.2 信号量机制实现进程互斥</h2><p>我们可以把临界区看作一种特殊的资源，为临界区抽象出一个互斥信号量<code>mutex</code>，<strong>它是二值的，初值为1</strong>，代表同一个时间只能有一个进程进入临界区。</p><ul><li>在进入临界区之前执行<code>P(mutex)</code></li><li>在退出临界区之后执行<code>V(mutex)</code></li></ul><h2 id="信号量机制实现进程同步">3.3 信号量机制实现进程同步</h2><p>进程同步问题要求多个进程按一定次序先后执行一段代码。这个前驱关系可能是较复杂的，如下图所示，可以<strong>为每一对前驱关系各设置一个同步信号量</strong>，初值为0，<strong>要执行某操作前需要对前驱操作对应的信号量进行P操作，当完成了前驱操作时对对应的信号量执行V操作。</strong></p><p><img src="https://api.codetool.top/img/15874890505885.png" alt></p><pre><code>semaphore a = 0,b = 0,c = 0,d = 0,e = 0,f = 0,g = 0;P1(){    ...    S1;    V(a);    V(b);    ...}P2(){    ...    P(a);    S2;    V(c);    V(d);    ...}P3(){    ...    P(b);    S3;    V(g);    ...}P4(){    ...    P(c);    S4;    V(e);    ...}P5(){    ...    P(d);    S5;    V(f);    ...}P6(){    ...    P(e);    P(f);    P(g);    S6;    ...}</code></pre><h1 id="管程">4 管程</h1><p><img src="https://api.codetool.top/img/15875338871013.png" alt></p><h2 id="管程和条件变量">4.1 管程和条件变量</h2><h3 id="为什么要引入管程">4.1.1 为什么要引入管程</h3><p>信号量机制存在的问题：编写程序困难、易出错。</p><p>管程：</p><ul><li>把分散在各进程中的临界区集中起来进行管理 </li><li>防止进程有意或无意的违法同步操作</li><li>便于用高级语言来书写程序，也便于程序正确性验证</li></ul><h3 id="管程的定义">4.1.2 管程的定义</h3><p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。 </p><p>管程的基本特征:</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问</li><li><strong>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</strong></li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li></ol><p>管程的属性:</p><ul><li>共享性</li><li>安全性</li><li>互斥性</li></ul><h3 id="管程的结构">4.1.3 管程的结构</h3><p>管程是一种特殊的软件模块，有这些部分组成:</p><ol><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><p>例如：(使用类C语言语法模拟管程结构)</p><pre class=" language-cpp"><code class="language-cpp">type ProducerConsumer <span class="token operator">=</span> monitor<span class="token punctuation">{</span>    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//条件变量用来实现同步排队</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//缓冲区中的产品数</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//把产品item放入缓冲区</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span>N<span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Item <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从缓冲区中取出一个产品</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span>N<span class="token number">-1</span><span class="token punctuation">)</span>            <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//生产者进程</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        item <span class="token operator">=</span> 生产一个产品<span class="token punctuation">;</span>        ProducerConsumer<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//消费者进程</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        消费产品item       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="管程的条件变量">4.1.4 管程的条件变量</h3><p>条件变量是出现在管程内的一种数据结构，且<strong>只有在管程中才能被访问</strong>，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它。</p><ul><li><code>wait()</code>：挂起调用进程并释放管程，直到另一个进程在该条件变量上执行<code>signal()</code>。</li><li><code>signal( )</code>：如果存在其他进程由于对条件变量执行<code>wait()</code>而被挂起，便释放之；如果没有进程在等待，那么，信号不被保存。</li></ul><p>这不就是Java <code>sychronized</code>的<code>monitorenter</code>和<code>monitorexit</code>吗！！！</p><h1 id="死锁">5 死锁</h1><p><img src="https://api.codetool.top/img/15875359806127.png" alt></p><h2 id="死锁的产生">5.1 死锁的产生</h2><p>操作系统中的死锁指：如果<strong>在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件</strong>，则称一组进程或系统此时发生死锁。</p><p>死锁产生的例子：</p><p>设系统有打印机、读卡机各一台，被进程Ｐ和Ｑ共享。两个进程并发执行，按下列次序请求和释放资源：</p><table><thead><tr><th align="center">进程Ｐ</th><th align="center">进程Ｑ</th></tr></thead><tbody><tr><td align="center">请求读卡机</td><td align="center">请求打印机</td></tr><tr><td align="center"><strong>请求打印机</strong></td><td align="center"><strong>请求读卡机</strong></td></tr><tr><td align="center">释放读卡机</td><td align="center">释放读卡机</td></tr><tr><td align="center">释放打印机</td><td align="center">释放打印机</td></tr></tbody></table><p>在PV操作中对应</p><table><thead><tr><th align="center">进程Q1</th><th align="center">进程Q2</th></tr></thead><tbody><tr><td align="center">P(S1)</td><td align="center">P(S2)</td></tr><tr><td align="center"><strong>P(S2)</strong></td><td align="center"><strong>P(S1)</strong></td></tr><tr><td align="center">使用r1和r2</td><td align="center">使用r1和r2</td></tr><tr><td align="center">V(S1)</td><td align="center">V(S2);</td></tr><tr><td align="center">V(S2)</td><td align="center">V(S1);</td></tr></tbody></table><p>在第一步中，双方都拿到了请求的资源，但是第二步中请求的资源都被对方所持有，于是都在等待对方释放资源，从而陷入死锁。</p><p>若系统中有m个资源被n个进程共享，每个进程都要求Ｋ个资源，而m &lt; n·K时，即<strong>资源数小于进程所要求的总数时，如果分配不得当就可能引起死锁。</strong></p><p>在著名的哲学家就餐问题中，若五个哲学家同时拿起右手边的餐具，此时左手边的的餐具就被另外一个哲学家占用，所有哲学家都陷入了无止境的等待资源释放状态，即死锁。</p><h2 id="死锁产生的必要条件">5.2 死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</strong>（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li><li><strong>不剥夺条件：</strong> 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件：</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件：</strong> 存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>归根结底，循环等待条件是前三种条件导致的结果。</p><h2 id="解决方法">5.3 解决方法</h2><h3 id="死锁防止">5.3.1 死锁防止</h3><p>死锁防止就是要破坏死锁产生的必要条件。</p><p><strong>破坏互斥条件：</strong> 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备</strong>。例如使用SPOOLing技术将打印机改造为共享设备。</p><p><strong>破坏不剥夺条件：</strong></p><ul><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul><p>该策略的缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><p><strong>破坏请求和保持条件：</strong><br>可以采用静态分配方法，即进程<strong>在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。</strong> 一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都–直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><p><strong>破坏循环等待条件：</strong> 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p><p>该策略的缺点:</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="死锁避免">5.3.2 死锁避免</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>死锁避免就是避免系统进入不安全状态。</p><p>银行家算法的数据结构：</p><p>一个系统有n个进程和m种不同类型的资源,定义包含以下向量和矩阵的数据结构：</p><ul><li>系统每类资源总数：该m个元素的向量为<strong>系统中每类资源数量</strong><code>Resource=(R1,R2,…,Rm)</code></li><li>每类资源未分配数量：该m个元素的向量为<strong>系统中每类资源尚可供分配数量</strong><code>Avilable=(V1,V2,…,Vm)</code></li><li>最大需求矩阵：<strong>每个进程对每类资源的最大需求量</strong>，<code>Claim[I,j]</code>表示进程Pi需Rj类资源最大数</li><li>分配矩阵：表示<strong>进程当前已分得的资源数</strong>，<code>Allocation[i,j]</code>表示进程Pi已分到Rj类资源个数</li><li>尚需矩阵：表示<strong>进程当前尚需资源数</strong>，<code>Need[i,j]</code>表示进程Pi尚需Rj类资源个数</li></ul><p>银行家算法中下列关系式确保成立：</p><ul><li><code>Ri=Vi+∑Allocation[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>所有资源要么已被分配、要么尚可分配</strong></li><li><code>Claim[k,i]≤Rj</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请资源数不能超过系统拥有的资源总数</strong></li><li><code>Allocation[k,i] ≤ Claim[k,i]</code>（对i=1,..,m,k=1,..,n）：表示<strong>进程申请任何类资源数不能超过声明的最大资源需求数</strong></li></ul><p>系统中若要启动一个新进程工作,其对资源Ri的需求仅当满足下列不等式：</p><p><code>Ri ≥ C[(n+1),i]+ ∑C[k,i]</code>  对i=1,..,m,k=1,..,n; </p><p>即应满足<strong>当前系统中所有进程对资源Ri的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</strong></p><p>系统安全性定义：在时刻T0系统是安全的,仅当存在一个进程序列P1,..,Pn,对进程Pk满足公式：</p><p><code>Need[k,i] ≤Available [i]+ ∑Allocation[j,i]</code> 对于k=1,…,n;i=1,…,m; </p><p>即对任何一个进程都能满足其所需要的资源。</p><p>银行家算法的基本思想：</p><ul><li>系统中的所有进程进入进程集合,</li><li>在安全状态下系统收到进程的资源请求后,先把资源<strong>试探性分配</strong>给它。</li><li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到<strong>剩余资源能满足最大需求量的进程</strong>,从而,保证<strong>这个进程运行完毕并归还全部资源</strong>。</li><li>把这个进程从集合中去掉, 系统的剩余资源更多了,<strong>反复执行上述步骤</strong>。</li><li>最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。 </li></ul><h3 id="死锁的检测和解除">5.3.3 死锁的检测和解除</h3><p>该部分参考自：<a href="http://www.360doc.com/content/16/0421/16/478627_552610896.shtml" target="_blank" rel="noopener">死锁的检测和解除</a></p><p>解决死锁问题的一条途径是死锁检测和解除，这种方法<strong>对资源的分配不加任何限制，也不采取死锁避免措施</strong>，但系统定时地运行一个“死锁检测”程序，判断系统内是否已出现死锁，<strong>如果检测到系统已发性了死锁，再采取措施解除它</strong>。</p><p>进程-资源分配图：</p><p>如图所示，用<strong>圆圈代表一个进程</strong>，用<strong>框代表一类资源</strong>。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。<strong>从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</strong></p><p><img src="https://api.codetool.top/img/15875408526262.jpg" alt="初始资源分配图"></p><ol><li>如果进程-资源分配图中无环路，则此时系统没有发生死锁。</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程。</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。可以使用将资源分配图简化的方法来检测系统是否处于死锁状态：</li></ol><p>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且<strong>该有向边对应资源的申请数量小于等于系统中已有空闲资源数量</strong>。如上图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。<strong>消去它所有的请求边和分配边</strong>，使之称为孤立的结点。在上图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p><p><strong>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程</strong>，原来的阻塞进程可能变为非阻塞进程。在上图中，P2 就满足这样的条件。根据上面的方法进行一系列简化后，<strong>若能消去途中所有的边，则称该图是可完全简化的</strong>。</p><p><img src="https://api.codetool.top/img/15875411733947.jpg" alt="资源分配图的化简"></p><p>一旦检测出死锁，就应立即釆取相应的措施。死锁解除算法有：</p><ol><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发进程&quot;&gt;1 并发进程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15874794302366.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;顺序程序设计&quot;&gt;1.1 顺序程序设计&lt;/h2&gt;&lt;p&gt;顺序程序设计是把一个
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode239-滑动窗口最大值</title>
    <link href="https://www.codetool.top/article/leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode239-滑动窗口最大值/</id>
    <published>2020-04-21T06:42:49.000Z</published>
    <updated>2020-04-21T14:17:27.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>进阶：</strong></p><p>你能在线性时间复杂度内解决此题吗？</p><p><strong>示例 1：</strong></p><pre><strong>输入:</strong> <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, 和 <em>k</em> = 3<strong>输出: </strong><code>[3,3,5,5,6,7] <strong>解释: </strong></code>  滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       <strong>3</strong> 1 [3  -1  -3] 5  3  6  7       <strong>3</strong> 1  3 [-1  -3  5] 3  6  7       <strong>5</strong> 1  3  -1 [-3  5  3] 6  7       <strong>5</strong> 1  3  -1  -3 [5  3  6] 7       <strong>6</strong> 1  3  -1  -3  5 [3  6  7]      <strong>7</strong></pre><style>pre > *,pre,code > *{    color: #e8eaf6}</style><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用一个双端队列维护一个单调递减队列（但实际上存放的是数组的下标），每滑动一次窗口，如果进来的元素比队尾下标对应的元素小，则进入队尾，否则将队列尾比该元素小的元素都弹出（类似单调栈的思想），再进入队尾，那么任意时刻队首元素即为当前最大元素的下标，而如果滑动窗口后队首元素的下标等于<code>当前下标-k</code>，说明队首元素过期，应该从队列首部弹出。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> qmax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>qmax<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>qmax<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                qmax<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            qmax<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>qmax<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>i<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                qmax<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>qmax<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面这种方法的思想是记录当前窗口内最大元素的下标，如果滑出去了重新选举最大值，如果没滑出去将进来的元素与当前最大元素比较。它和暴力又不太一样，因为其实重新选举的次数较少，实际leetcode中这种方法反而更快，可能是因为数据量的原因：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//求出前k个元素的最大值索引</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">)</span>maxIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//li是滑动窗口的最左端</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> li <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> li <span class="token operator">&lt;</span> maxes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> li<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//ri是滑动窗口的最右端的索引</span>            <span class="token keyword">int</span> ri <span class="token operator">=</span> li <span class="token operator">+</span> k<span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>maxIdx <span class="token operator">&lt;</span> li<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//最大值的索引不在滑动窗口范围内</span>                maxIdx <span class="token operator">=</span> li<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//求出[li, ri]范围内最大值的索引</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> li <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ri<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">)</span>maxIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>ri<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//最大值的索引在滑动窗口的范围内，并且大于最大值</span>                maxIdx <span class="token operator">=</span> ri<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxes<span class="token punctuation">[</span>li<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>maxIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxes<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1248-统计「优美子数组」</title>
    <link href="https://www.codetool.top/article/leetcode1248-%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D/"/>
    <id>https://www.codetool.top/article/leetcode1248-统计「优美子数组」/</id>
    <published>2020-04-21T05:58:06.000Z</published>
    <updated>2020-04-21T06:22:30.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p><p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中「优美子数组」的数目。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> nums = [1,1,2,1,1], k = 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> nums = [2,4,6], k = 1<br><strong>输出：</strong> 0<br><strong>解释：</strong> 数列中不包含任何奇数，所以不存在优美子数组。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> nums = [2,2,2,1,2,2,1,2,2,2], k = 2<br><strong>输出：</strong> 16</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于一个满足条件的最小子数组，它的左界和右界都应恰好是1，并且包含k个奇数。那么从这个最小子数组延展开，只要是偶数就可以容纳进来，可以组成的子数组个数为 <code>左边连续偶数的个数+1 乘以 右边连续偶数的个数+1</code> 。</p><h2 id="代码">2.2 代码</h2><p>统计偶数间隔，这里我们统计每两个奇数之间（也可能是第一个奇数前面或最后一个奇数后面）偶数有多少个，并将它+1存放到list中，这样连续k个奇数能组成的子数组个数为数组中相隔k的两个元素的乘积：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> preEven<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                preEven<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>preEven<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                preEven<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>preEven<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">+=</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果某个 &lt;strong&gt;连续&lt;/strong&gt; 子数组中恰好有 &lt;code&gt;k&lt;/code&gt; 个奇数数字，我们就认为这
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用一个栈实现另一个栈的排序</title>
    <link href="https://www.codetool.top/article/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.codetool.top/article/用一个栈实现另一个栈的排序/</id>
    <published>2020-04-20T07:43:51.000Z</published>
    <updated>2020-04-20T07:53:28.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>申请一个辅助栈，应让该辅助栈成为一个单调栈，可以这样做：</p><p>原栈每次弹出一个元素，如果比辅助栈顶元素小（或辅助栈内为空）就直接压入辅助栈，如果比辅助栈顶元素大，则先保留该元素，将辅助栈内的比该元素小的元素压回原栈，再将该元素压入辅助栈，如此往复，直到辅助栈成为一个栈顶到栈底递增的栈，再将辅助栈内的元素压回原栈。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortStackByStack</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>help<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>help<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>help<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            help<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>help<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>help<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;一个栈中元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？&lt;/p&gt;
&lt;h1 id=&quot;解法&quot;&gt;2 解法&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode648-单词替换</title>
    <link href="https://www.codetool.top/article/leetcode648-%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/"/>
    <id>https://www.codetool.top/article/leetcode648-单词替换/</id>
    <published>2020-04-20T07:03:52.000Z</published>
    <updated>2020-04-22T09:27:27.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>在英语中，我们有一个叫做 <code>词根</code>(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 <code>继承词</code>(successor)。例如，词根<code>an</code>，跟随着单词 <code>other</code>(其他)，可以形成新的单词 <code>another</code>(另一个)。</p><p>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有<code>继承词</code>用<code>词根</code>替换掉。如果<code>继承词</code>有许多可以形成它的<code>词根</code>，则用最短的词根替换它。</p><p>你需要输出替换之后的句子。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> dict(词典) = [“cat”, “bat”, “rat”]<br>sentence(句子) = “the cattle was rattled by the battery”<br><strong>输出:</strong> “the cat was rat by the bat”</p></blockquote><p><strong>注:</strong></p><ol><li>输入只包含小写字母。</li><li>1 &lt;= 字典单词数 &lt;=1000</li><li>1 &lt;=  句中词语数 &lt;= 1000</li><li>1 &lt;= 词根长度 &lt;= 100</li><li>1 &lt;= 句中词语长度 &lt;= 1000</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这里的词根其实就是字符串的前缀，一开始我以为出现在哪都可以。前缀可以使用字典树搜索。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">{</span>        TrieNode<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        String word<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">replaceWords</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> dict<span class="token punctuation">,</span> String sentence<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TrieNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String word<span class="token operator">:</span>dict<span class="token punctuation">)</span> <span class="token function">insertToTrie</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> sentence<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String prefix <span class="token operator">=</span> <span class="token function">hasPrefix</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>prefix<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prefix<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>words<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*将前缀插入字典树*/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertToTrie</span><span class="token punctuation">(</span>TrieNode root<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        TrieNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token punctuation">.</span>word <span class="token operator">=</span> word<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*从字典树中获取前缀*/</span>    <span class="token keyword">public</span> String <span class="token function">hasPrefix</span><span class="token punctuation">(</span>TrieNode root<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        TrieNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>word<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> cur<span class="token punctuation">.</span>word<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;在英语中，我们有一个叫做 &lt;code&gt;词根&lt;/code&gt;(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 &lt;code&gt;继承词&lt;/code&gt;(successor)。例如，词根&lt;code&gt;an&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用递归函数逆序一个栈</title>
    <link href="https://www.codetool.top/article/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/"/>
    <id>https://www.codetool.top/article/使用递归函数逆序一个栈/</id>
    <published>2020-04-19T06:43:06.000Z</published>
    <updated>2020-04-22T09:27:27.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源：牛客网）">1 原题（来源：牛客网）</h1><p>一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函数来实现，而不能用另外的数据结构。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设计一个函数<code>getAndRemoveLastElement</code>用于获取并移除栈底元素，当栈空的时候进行回溯，并将获取的元素压入栈，就能达到逆序的效果。</p><p>这样做的时间复杂度肯定是没一个辅助队列来的快的，好处是没有使用额外的空间（除了递归栈空间）</p><p>时间复杂度计算：设栈的大小为n，每一次获取栈底元素的时间复杂度是<code>O(n)</code>，栈的大小要从n-&gt;0，就是<code>O(n)+O(n-1)+O(n-2)+...+O(1)</code>=<code>O(n^2)</code> </p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//每次获取栈底元素，最后一次获取的即是栈顶元素</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getAndRemoveLastElement</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//回溯的时候将获取的元素压入</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAndRemoveLastElement</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取并移除栈顶元素</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取栈底元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token function">getAndRemoveLastElement</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//回溯的时候将获取的元素压入</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源：牛客网）&quot;&gt;1 原题（来源：牛客网）&lt;/h1&gt;&lt;p&gt;一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode75-颜色分类</title>
    <link href="https://www.codetool.top/article/leetcode75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>https://www.codetool.top/article/leetcode75-颜色分类/</id>
    <published>2020-04-19T06:09:49.000Z</published>
    <updated>2020-04-19T06:21:07.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [2,0,2,1,1,0]<br><strong>输出:</strong> [0,0,1,1,2,2] </p></blockquote><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>计数排序算是这类问题的通解吧。。不过对于仅有两种或三种元素，可以使用交换方法来解。</p><h2 id="代码">2.2 代码</h2><p>计数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>count2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> count0<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> count1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> count2<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>count0<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>count0<span class="token operator">+</span>count1<span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>三指针交换：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> p0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> p2 <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>p0<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>cur<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>p2<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> cur<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣杯春季个人赛-剧情触发时间</title>
    <link href="https://www.codetool.top/article/leetcode%E4%B8%AA%E4%BA%BA%E8%B5%9B-%E5%89%A7%E6%83%85%E8%A7%A6%E5%8F%91%E6%97%B6%E9%97%B4/"/>
    <id>https://www.codetool.top/article/leetcode个人赛-剧情触发时间/</id>
    <published>2020-04-18T09:50:32.000Z</published>
    <updated>2020-04-22T09:27:27.142Z</updated>
    
    <content type="html"><![CDATA[<p>这次的个人赛真是让我认清了自己的实力。。两道困难题都没做出😭，虽然大家的通过率也不咋地。。</p><p><img src="https://api.codetool.top/img/15872016427419.png" alt></p><p>最后排名</p><p><img src="https://api.codetool.top/img/15872173146160.jpg" alt></p><p>我记录一道做出来的题吧，这道题是一道中等题，通过率如下，虽然题目不难，但由于时间限制的问题，不使用技巧很容易超出时间限制</p><p><img src="https://api.codetool.top/img/15872016956913.png" alt></p><h1 id="原题">1 原题</h1><p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（<code>C</code>），资源储备（<code>R</code>）以及人口数量（<code>H</code>）。在游戏开始时（第 0 天），三种属性的值均为 0。</p><p>随着游戏进程的进行，每一天玩家的三种属性都会对应<strong>增加</strong>，我们用一个二维数组 <code>increase</code> 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 <code>[[1,2,1],[3,4,2]]</code> 表示第一天三种属性分别增加 <code>1,2,1</code> 而第二天分别增加 <code>3,4,2</code>。</p><p>所有剧情的触发条件也用一个二维数组 <code>requirements</code> 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code> 且 <code>H &gt;= h[i]</code> ，则剧情会被触发。</p><p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入： <code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code> <code>requirements = [[2,11,3],[15,10,&gt;7],[9,17,12],[8,1,14]]</code></p><p>输出: <code>[2,-1,3,-1]</code></p><p>解释：</p><p>初始时，C = 0，R = 0，H = 0</p><p>第 1 天，C = 2，R = 8，H = 4</p><p>第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0</p><p>第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2</p><p>剧情 1 和 3 无法触发。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入： <code>increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]]</code> <code>requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]</code></p><p>输出: <code>[-1,4,3,3,3]</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入： <code>increase = [[1,1,1]] requirements = [[0,0,0]]</code></p><p>输出: <code>[0]</code></p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= increase.length &lt;= 10000</code></li><li><code>1 &lt;= requirements.length &lt;= 100000</code></li><li><code>0 &lt;= increase[i] &lt;= 10</code></li><li><code>0 &lt;= requirements[i] &lt;= 100000</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>见代码部分</p><h2 id="代码">2.2 代码</h2><p>我一开始想的是用requirement里面的三元组每隔一天减去increase里面对应的三元组，然后记录答案，但是这种方法无论怎么剪枝优化都会超时，这样做的时间复杂度是<code>O(mn)</code>(m,n为两个数组的大小，我还省去了后面数组赋值的时间复杂度)：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getTriggerTime</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> increase<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> requirements<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>day<span class="token operator">&lt;=</span>increase<span class="token punctuation">.</span>length<span class="token punctuation">;</span>day<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">boolean</span> hasRemain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>day <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                hasRemain <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-=</span> increase<span class="token punctuation">[</span>day<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> increase<span class="token punctuation">[</span>day<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-=</span> increase<span class="token punctuation">[</span>day<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> day<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>day<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>hasRemain<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> realAns <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                realAns<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                realAns<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> realAns<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>后来想到可以计算每一天的属性值，然后二分查找，这样做的时间复杂度就是<code>O(m+nlogm)</code>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getTriggerTime</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> increase<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> requirements<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将increase中的三元组的含义变为每一天的属性值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>increase<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            increase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> increase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            increase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> increase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            increase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+=</span> increase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>requirements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> right <span class="token operator">=</span> increase<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果最后一天仍不满足，设为-1</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>increase<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//二分查找</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>increase<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>increase<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">>=</span>requirements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        left <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                        right <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次的个人赛真是让我认清了自己的实力。。两道困难题都没做出😭，虽然大家的通过率也不咋地。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15872016427419.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最后排名&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器地址栏输入URL，按下回车之后发生了什么？</title>
    <link href="https://www.codetool.top/article/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%EF%BC%8C%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://www.codetool.top/article/在浏览器地址栏输入URL，按下回车之后发生了什么？/</id>
    <published>2020-04-17T18:05:08.000Z</published>
    <updated>2020-04-17T18:48:52.213Z</updated>
    
    <content type="html"><![CDATA[<p>一道经典的面试题~ 这篇文章不会用来讲知识点，如果按一个问题去讲里面的知识点完全形成不了体系，这篇文章只是做一个知识点的串联、回顾，帮助缕清知识点之间的关系，形成知识脉络。</p><p>下面的回答仅针对HTTP/HTTPS协议：（毕竟浏览器还可以ftp、websocket什么的，如果各种协议都谈真没完了）</p><ol><li><p>浏览器检查缓存，<strong>缓存未过期一般会使用强缓存，缓存过期一般会使用协商缓存</strong>，如果协商缓存未命中或没有缓存，继续下一步。</p><ul><li>具体请参考<a href="../HTTP浏览器缓存策略和服务器的缓存控制">HTTP浏览器缓存策略和服务器的缓存控制</a></li></ul></li><li><p>对域名进行DNS解析，<strong>如果客户机有DNS缓存，直接获得对应的IP</strong>，否则向DNS服务器发出请求解析域名，<strong>如果网站配置了CDN，会返回一个cname，指向CDN的全局负载均衡器</strong>，由智能算法为用户分配为其服务的服务器ip。如果没有配置CDN，根据网站的DNS配置返回一个IP。</p><ul><li>DNS相关请参考<a href="../计网复习06-应用层之域名系统DNS/">计网复习06-应用层之域名系统DNS</a>，CDN相关的东西我目前倒是没有写博客讲过，这里可以提一下，其实CDN的核心技术就是全局负载均衡和缓存管理，通常用于静态资源的分发（缓存代理），客户从<strong>边缘节点</strong>上取数据。和CDN性能相关的名词有<strong>命中率</strong>和<strong>回源率</strong>。最近还流行一种<strong>边缘计算</strong>的技术，把计算动态资源的代码和数据也放在cdn的节点上，就可以实现在cdn里获取动态资源而不用回源站。</li></ul></li><li><p>客户机使用IP与服务器建立TCP连接，通过TCP三次握手，建立连接之后如果是HTTPS协议还需要TLS握手，交换密码套件，通过椭圆曲线算法实现密钥交换。</p><ul><li>TCP建立连接三次握手相关内容见<a href="../计网复习05-传输层">计网复习05-传输层</a></li><li>TLS握手的详细过程我也没有写过博客，因为比较理论，我也没有那么权威，自己写不敢保证正确，复制粘贴也没有意思，不过HTTPS原理可以参考<a href="../HTTPS的原理——混合加密、数字签名、CA">HTTPS的原理——混合加密、数字签名、CA</a>。我这里简单提一下TLS的握手：<strong>TLS握手主要目的就是获取CA证书验证服务端身份和密钥交换，即获取后面用于对称加密的密钥。（也成为会话密钥）</strong>客户端和服务器会先协商使用同一个<strong>密码套件</strong>。密码套件的命名是<code>密钥交换算法-签名算法-对称加密算法-分组模式-摘要算法</code>，如<code>ECDHE-RSA-AES256-GCM-SHA384</code>。TLS1.2还有用RSA进行密钥交换，但由于<strong>前向安全</strong>的问题（RSA使用的公私钥是固定的，如果黑客坚持不懈的收集所有监听到的HTTPS报文，一旦有一天私钥泄露，所有之前收集的报文都能被破解），<strong>TLS1.3就完全废弃了使用RSA密钥交换，并推荐使用ECDHE密钥交换</strong>（即ECC+DH，基于椭圆曲线的离散对数问题，每次握手时都会生成一对临时的公钥和私钥，保证了前向安全）。</li><li>传输层再往下的协议我觉得就没必要讲了吧？网络层找IP，数据链路层找MAC，物理层传输。</li></ul></li><li><p>握手完成之后可以发送HTTP/HTTPS报文（对于一个复用的TCP连接我们会遇到队头阻塞等待，不过这里既然是在地址栏输入URL然后回车，肯定是第一次请求，没有这个问题），服务器收到后进行处理。（处理过程不定，如果是动态资源可能会调用后端程序），处理完成之后组成HTTP响应报文发送给客户端。</p><ul><li>网上有的博客说这里会服务器就会断开连接了？？未免知识点太久远了一点了吧，HTTPS1.1就默认长连接了。关于HTTP的版本相关可以参考<a href="../HTTP版本发展与Google的暗中助力">HTTP版本发展与Google的暗中助力</a></li></ul></li><li><p>浏览器下载对应的响应数据，并对HTML（如果是）进行渲染。渲染相关的知识我也不是很清楚，应该是前端比较需要掌握的部分。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道经典的面试题~ 这篇文章不会用来讲知识点，如果按一个问题去讲里面的知识点完全形成不了体系，这篇文章只是做一个知识点的串联、回顾，帮助缕清知识点之间的关系，形成知识脉络。&lt;/p&gt;
&lt;p&gt;下面的回答仅针对HTTP/HTTPS协议：（毕竟浏览器还可以ftp、websocket
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
