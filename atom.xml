<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeBand CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2019-12-30T12:02:18.174Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode69-x的平方根</title>
    <link href="https://www.codetool.top/article/leetcode69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>https://www.codetool.top/article/leetcode69-x的平方根/</id>
    <published>2019-12-30T11:58:11.000Z</published>
    <updated>2019-12-30T12:02:18.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> 4<br><strong>输出：</strong> 2  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> 8<br><strong>输出：</strong> 2<br><strong>说明：</strong> 8 的平方根是 2.82842…,<br>      由于返回类型是整数，小数部分将被舍去。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了防止end * end 超过int范围，这里统一使用使用long</span></span><br><span class="line">        <span class="keyword">long</span> longx = x;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> end = x/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            mid = (end+start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid == longx) <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid &lt; longx) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(start*start&gt;longx) <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid &gt; longx) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(end*end&lt;longx) <span class="keyword">return</span> (<span class="keyword">int</span>)end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;实现 &lt;code&gt;int sqrt(int x)&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 &lt;em&gt;x&lt;/em&gt; 的平方根，其中 &lt;e
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode704-二分查找</title>
    <link href="https://www.codetool.top/article/leetcode704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.codetool.top/article/leetcode704-二分查找/</id>
    <published>2019-12-29T12:04:34.000Z</published>
    <updated>2019-12-29T12:07:49.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> nums = [-1,0,3,5,9,12], target = 9<br><strong>输出：</strong> 4<br><strong>解释：</strong> 9 出现在 nums 中并且下标为 4</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> nums = [-1,0,3,5,9,12], target = 2<br><strong>输出：</strong> -1<br><strong>解释：</strong> 2 不存在 nums 中因此返回 -1</p></blockquote><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找思想</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&gt;target) end = middle-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;target) start = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start]==target) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;n&lt;/code&gt; 个元素有序的（升序）整型数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;targ
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode380-常数时间插入、删除和获取随机元素</title>
    <link href="https://www.codetool.top/article/leetcode380-%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode380-常数时间插入、删除和获取随机元素/</id>
    <published>2019-12-28T14:44:41.000Z</published>
    <updated>2019-12-28T15:50:21.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>设计一个支持在平均 时间复杂度 <strong><em>O(1)</em></strong> 下，执行以下操作的数据结构。</p><ol><li><code>insert(val)</code>：当元素 val 不存在时，向集合中插入该项。</li><li><code>remove(val)</code>：元素 val 存在时，从集合中移除该项。</li><li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有<strong><em>相同的概率</em></strong>被返回。</li></ol><p><strong>示例：</strong></p><blockquote><p>// 初始化一个空的集合。<br>RandomizedSet randomSet = new RandomizedSet();<br><br/><br>// 向集合中插入 1 。返回 true 表示 1 被成功地插入。<br>randomSet.insert(1);<br><br/><br>// 返回 false ，表示集合中不存在 2 。<br>randomSet.remove(2);<br><br/><br>// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。<br>randomSet.insert(2);<br><br/><br>// getRandom 应随机返回 1 或 2 。<br>randomSet.getRandom();<br><br/><br>// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。<br>randomSet.remove(1);<br><br/><br>// 2 已在集合中，所以返回 false 。<br>randomSet.insert(2);<br><br/><br>// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。<br>randomSet.getRandom();  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>初始想法  </li></ol><p>哈希表的插入删除的时间复杂度都是<code>O(1)</code>，获取的时候可以通过EntrySet。<br>所以这道题是不能用HashSet的。</p><p>这样虽然获取随机元素的时候时间复杂度最高可能是<code>O(n)</code>，但仍比遍历一遍Set转ArrayList好很多。</p><ol start="2"><li>正确解法  </li></ol><p>哈希表插入和删除都是<code>O(1)</code>，而顺序表随机访问则是<code>O(1)</code>，可以使用ArrayList来存储所有的数据。但是必须解决ArrayList删除元素的<code>O(n)</code>问题。  </p><p>于是可以：</p><p>在哈希表中用value-index来记录值和在list中的下标的对应关系，如图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15775470173323.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当删除元素时，size减一，用list中最后那个元素替换要删除的那个元素，并且将哈希表中的对应关系改过来（用要删除的元素的index替换list中最后那个元素对应的index）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/1577547151755.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时若要随机访问元素，只需获取list中前3(size)个元素中的一个。</p><p>那么如果需要继续插入元素，只需从list中下标为3(size)处替换掉后面那个元素或是在后面那个元素之前插入（这里如果用插入是使用add(index,value)方法，个人觉得比起set会增加时间复杂度，因为使用add后面的元素都需要向后移动，虽然jdk源码中使用了System.arraycopy即内存拷贝来优化，但是也比直接替换的时间复杂度更高）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15775473303971.png" alt="该图显示的是替换" title="">                </div>                <div class="image-caption">该图显示的是替换</div>            </figure><p>如果不是替换元素而是add操作，这里会变成<code>1-4-2-8-4</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>初始想法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    Object none = <span class="keyword">new</span> Object();</span><br><span class="line">    HashMap&lt;Integer,Object&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.put(val,none);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ran = random.nextInt(map.size());  </span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Object&gt; i:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==ran) <span class="keyword">return</span> i.getKey();</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>正确解法（来源：leetcode用户，添加元素时是直接插入）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Map&lt;Integer,Integer&gt; map; <span class="comment">// 存放值和在 list 的下标位置的映射</span></span><br><span class="line">    List&lt;Integer&gt; list;       <span class="comment">// 存放要插入数据的结构</span></span><br><span class="line">    <span class="keyword">int</span> size;                 <span class="comment">// 数据的长度</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 插入数据，并更新 map 的映射后将长度加一</span></span><br><span class="line">            list.add(size,val);</span><br><span class="line">            map.put(val,size++);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( size == <span class="number">0</span> )&#123; map.remove(val);&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 取到 list 末尾的数据</span></span><br><span class="line">            <span class="keyword">int</span> tailKey = list.get(size-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 然后将要原先 map 中得 val-index 映射改为 tailKey-index</span></span><br><span class="line">            map.put(tailKey,map.get(val));</span><br><span class="line">            <span class="comment">// 在 map 中取得 val 在 list 的位置，然后根据这个位置用末尾元素 tailKey 替代</span></span><br><span class="line">            list.set(map.get(val),tailKey);</span><br><span class="line">            <span class="comment">// 在 map 中删除 val 的映射</span></span><br><span class="line">            map.remove(val);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">         <span class="comment">// rand.nextInt(size) 产生的是 0 到 size（不包括 size） 的数据</span></span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;设计一个支持在平均 时间复杂度 &lt;strong&gt;&lt;em&gt;O(1)&lt;/em&gt;&lt;/strong&gt; 下，执行以下操作的数据结构。&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode347-前K个高频元素</title>
    <link href="https://www.codetool.top/article/leetcode347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode347-前K个高频元素/</id>
    <published>2019-12-28T13:39:09.000Z</published>
    <updated>2019-12-28T13:44:29.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个非空的整数数组，返回其中出现频率前 <strong><em>k</em></strong> 高的元素。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,1,1,2,2,3], k = 2<br><strong>输出：</strong> [1,2]  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [1], k = 1<br><strong>输出：</strong> [1]  </p></blockquote><p><strong>说明:</strong></p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>可以用哈希表记录下出现的次数，然后将哈希表按值排序。（获取entryList用Collections来排序）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">        entryList.sort((entry1, entry2) -&gt; entry2.getValue() - entry1.getValue());</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; i:entryList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;=k) <span class="keyword">break</span>;</span><br><span class="line">            list.add(i.getKey());</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;&lt;em&gt;k&lt;/em&gt;&lt;/strong&gt; 高的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode454-四数相加II</title>
    <link href="https://www.codetool.top/article/leetcode454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://www.codetool.top/article/leetcode454-四数相加II/</id>
    <published>2019-12-27T12:45:57.000Z</published>
    <updated>2019-12-27T13:20:37.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2<sup>28</sup> 到 2<sup>28</sup> - 1 之间，最终结果不会超过 2<sup>31</sup> - 1 。</p><p><strong>例如:</strong></p><blockquote><p><strong>输入：</strong><br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]  </p><p><strong>输出：</strong><br>2</p><p><strong>解释:</strong><br>两个元组如下:     </p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0  </li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0  </li></ol></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>暴力（超出时间限制）：暴力的问题是，只要数组的数目超过两个，便会重复计算很多单元，比如<code>A1+B1+C2</code>和<code>A2+B1+C2</code>其中<code>B1+C2</code>就被反复计算了，他的时间复杂度会成n<sup>N</sup>的形势增长。</li><li>为了解决暴力的时间复杂性幂增长，可以将其降维，两个两个分组，然后作查找表配对总和为0的情况。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>暴力</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;len;a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>;b&lt;len;b++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;len;c++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>;d&lt;len;d++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(A[a]+B[b]+C[c]+D[d]==<span class="number">0</span>)</span><br><span class="line">                            count ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查找表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:B)&#123;</span><br><span class="line">                <span class="comment">//记录下-(i+j)可以对应的次数。</span></span><br><span class="line">                map.put(-i-j,map.getOrDefault(-i-j,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:D)&#123;</span><br><span class="line">                count += map.getOrDefault(i+j,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; ，使得 &lt;c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode3-无重复字符的最长子串</title>
    <link href="https://www.codetool.top/article/leetcode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode3-无重复字符的最长子串/</id>
    <published>2019-12-26T14:18:21.000Z</published>
    <updated>2019-12-26T14:57:35.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> “abcabcbb”<br><strong>输出：</strong> 3<br><strong>解释：</strong> 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> “bbbbb”<br><strong>输出：</strong> 1<br><strong>解释：</strong> 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例3：</strong></p><blockquote><p><strong>输入：</strong> “pwwkew”<br><strong>输出：</strong> 3<br><strong>解释：</strong> 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>滑动窗口，将出现的字符和下标在哈希表中对应起来。</p><p>该问题的关键是获取所有不重复字符子串的长度，比较出最大的长度，我们用last记录当前计算的子串的第一个字符位置。</p><p>那么不重复字符子串的长度的计算方法就是：</p><p>假设从last开始都是不重复字符，如果遇到一个在哈希集中出现过的字符并且是last或last之后的，说明遇到了重复字符，如下图的d，则此时的不重复字符子串<code>adv</code>的长度为第二个d之前的长度<code>3-0=3</code>。然后将last移到v上（第一个d后面的那个元素，这样新子串中就不会有两个d了），便可继续进行操作。</p><p>这样依次进行无重复字符子串的长度计算，当最后遍历到最后一个字符c的时候，都和last以及last之后出现的字符无重复，那么此时最后计算的子串<code>vdfc</code>的长度是<code>5-2+1=4</code>（因为c是计入子串的）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15773707565495.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>那么假设最后一个字符是v，当最后遍历到最后一个字符v的时候，和当前子串中的v重复了(<code>vdfv</code>)，那么和之前计算子串长度的方法一样是<code>5-2=3</code>（最后一个v不计入长度）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15773708371431.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(chars[i])&amp;&amp;map.get(chars[i])&gt;=last)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-last&gt;=max) max = i-last;</span><br><span class="line">                last = map.get(chars[i]) + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == chars.length-<span class="number">1</span>&amp;&amp;i-last+<span class="number">1</span>&gt;=max)&#123;</span><br><span class="line">                max = i-last+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(chars[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode771-宝石与石头</title>
    <link href="https://www.codetool.top/article/leetcode771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
    <id>https://www.codetool.top/article/leetcode771-宝石与石头/</id>
    <published>2019-12-26T14:13:37.000Z</published>
    <updated>2019-12-26T14:17:31.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong>  J = “aA”, S = “aAAbbbb”<br><strong>输出：</strong> 3</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> J = “z”, S = “ZZ”<br><strong>输出：</strong> 0</p></blockquote><p><strong>注意：</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>将代表宝石的字符存放在哈希集中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:J.toCharArray())&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定字符串&lt;code&gt;J&lt;/code&gt; 代表石头中宝石的类型，和字符串 &lt;code&gt;S&lt;/code&gt;代表你拥有的石头。 &lt;code&gt;S&lt;/c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode652-寻找重复的子树</title>
    <link href="https://www.codetool.top/article/leetcode652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode652-寻找重复的子树/</id>
    <published>2019-12-26T05:52:10.000Z</published>
    <updated>2019-12-26T06:00:10.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p><p><strong>示例1:</strong></p><blockquote><pre><code>    1     / \    2   3   /   / \  4   2   4         /      4</code></pre></blockquote><p>下面是两个重复的子树：</p><blockquote><pre><code>  2   /    4  </code></pre></blockquote><p>和</p><blockquote><p>   4</p></blockquote><p>因此，你需要以列表的形式返回上述重复子树的根结点。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>将子树按照某种算法遍历序列化成字符串，作为哈希表的键。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map;</span><br><span class="line">    List&lt;TreeNode&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LRD</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(sb,node);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(StringBuilder str,TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            str.append(<span class="string">'n'</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(str,node.left);</span><br><span class="line">        dfs(str,node.right);</span><br><span class="line">        str.append(String.valueOf(node.val));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfsFindSubtrees(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsFindSubtrees</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfsFindSubtrees(root.left);</span><br><span class="line">        dfsFindSubtrees(root.right);</span><br><span class="line">        String LRD = LRD(root);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(LRD))&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(LRD)==<span class="number">1</span>)&#123;</span><br><span class="line">                list.add(root);</span><br><span class="line">                map.put(LRD,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(LRD,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意&lt;strong&gt;一棵&lt;/strong&gt;的根结点即可。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode36-有效的数独</title>
    <link href="https://www.codetool.top/article/leetcode36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>https://www.codetool.top/article/leetcode36-有效的数独/</id>
    <published>2019-12-26T05:25:23.000Z</published>
    <updated>2019-12-26T05:48:53.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15773390969386.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong><br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br><strong>输出：</strong> true  </p></blockquote><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong><br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br><strong>输出：</strong> false<br><strong>解释：</strong> 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p></blockquote><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>行、列、宫分别分配一个哈希集记录出现的数字。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] globalBoard;</span><br><span class="line">    <span class="comment">//行:0-8,列:9-17,宫:18-26</span></span><br><span class="line">    Set&lt;Character&gt;[] sets = <span class="keyword">new</span> Set[<span class="number">27</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        globalBoard = board;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">9</span> ; x ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>;y&lt;<span class="number">9</span>;y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isValidSingle(x,y)==<span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSingle</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(globalBoard[x][y]==<span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(sets[x].contains(globalBoard[x][y])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sets[x].add(globalBoard[x][y]);</span><br><span class="line">        <span class="keyword">if</span>(sets[<span class="number">9</span>+y].contains(globalBoard[x][y])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sets[<span class="number">9</span>+y].add(globalBoard[x][y]);</span><br><span class="line">        <span class="keyword">if</span>(sets[<span class="number">18</span>+y/<span class="number">3</span>*<span class="number">3</span>+x/<span class="number">3</span>].contains(globalBoard[x][y])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sets[<span class="number">18</span>+y/<span class="number">3</span>*<span class="number">3</span>+x/<span class="number">3</span>].add(globalBoard[x][y]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;判断一个 9x9 的数独是否有效。只需要&lt;strong&gt;根据以下规则&lt;/strong&gt;，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode49-字母异位词分组</title>
    <link href="https://www.codetool.top/article/leetcode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode49-字母异位词分组/</id>
    <published>2019-12-25T14:27:42.000Z</published>
    <updated>2019-12-25T14:30:00.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br><strong>输出：</strong><br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]  </p></blockquote><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>将字符串按字典顺序排序作为键，存储对应的异位字符串的List作为值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String i:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = i.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(String.valueOf(chars)))&#123;</span><br><span class="line">                map.get(String.valueOf(chars)).add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                newList.add(i);</span><br><span class="line">                map.put(String.valueOf(chars),newList);</span><br><span class="line">                list.add(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode219-存在重复元素II</title>
    <link href="https://www.codetool.top/article/leetcode219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>https://www.codetool.top/article/leetcode219-存在重复元素II/</id>
    <published>2019-12-24T14:46:27.000Z</published>
    <updated>2019-12-24T14:49:21.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 <strong>nums [i] = nums [j]</strong>，并且 i 和 j 的差的绝对值最大为 k。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,2,3,1], k = 3<br><strong>输出：</strong> true  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,0,1,1], k = 1<br><strong>输出：</strong> true  </p></blockquote><p><strong>示例3：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,2,3,1,2,3], k = 2<br><strong>输出：</strong> false</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>哈希表，将元素和最后出现的下标对应起来，后面遍历到相同元素时看下标之差是否小于等于k</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-map.get(nums[i])&lt;=k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 &lt;strong&gt;nums [i] = nums [j]&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode350-两个数组的交集II</title>
    <link href="https://www.codetool.top/article/leetcode350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>https://www.codetool.top/article/leetcode350-两个数组的交集II/</id>
    <published>2019-12-23T14:35:59.000Z</published>
    <updated>2019-12-23T14:39:10.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><blockquote><p><strong>输入：</strong> nums1 = [1,2,2,1], nums2 = [2,2]<br><strong>输出：</strong> [2,2]</p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br><strong>输出：</strong> [4,9]</p></blockquote><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>哈希表，遍历第一个数组的时候把值和出现的次数对应起来，遍历第二个数组的时候可以得出并集。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                map.put(i,map.get(i)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> map.put(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(i)-<span class="number">1</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(i);</span><br><span class="line">                &#125;<span class="keyword">else</span> map.put(i,map.get(i)-<span class="number">1</span>);</span><br><span class="line">                nums1[length] = i;</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        System.arraycopy(nums1,<span class="number">0</span>,ret,<span class="number">0</span>,length);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; nums1 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode387-字符串中的第一个唯一字符</title>
    <link href="https://www.codetool.top/article/leetcode387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <id>https://www.codetool.top/article/leetcode387-字符串中的第一个唯一字符/</id>
    <published>2019-12-22T14:32:40.000Z</published>
    <updated>2019-12-22T14:35:09.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>案例:</strong></p><blockquote><p>s = “leetcode”<br>返回 0.<br><br/><br>s = “loveleetcode”,<br>返回 2.  </p></blockquote><p><strong>注意事项：</strong> 您可以假定该字符串只包含小写字母。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>遍历两次数组，第一次将字母和出现的次数放在哈希表中对应起来，第二遍找出哈希表中值为1的字母。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                map.put(i,map.get(i)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i:chars) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(i)==<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例:&lt;/strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode599-两个列表的最小索引总和</title>
    <link href="https://www.codetool.top/article/leetcode599-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode599-两个列表的最小索引总和/</id>
    <published>2019-12-22T12:58:42.000Z</published>
    <updated>2019-12-22T13:16:39.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用<strong>最少的索引</strong>和找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong><br>[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]<br>[“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]<br><strong>输出:</strong> [“Shogun”]<br><strong>解释:</strong> 他们唯一共同喜爱的餐厅是“Shogun”。  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong><br>[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]<br>[“KFC”, “Shogun”, “Burger King”]<br><strong>输出:</strong> [“Shogun”]<br><strong>解释:</strong> 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。    </p></blockquote><p><strong>提示:</strong></p><ol><li>两个列表的长度范围都在 [1, 1000]内。</li><li>两个列表中的字符串的长度将在[1，30]的范围内。</li><li>下标从0开始，到列表的长度减1。</li><li>两个列表都没有重复的元素。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>哈希表，将第一个列表中的字符串和下标对应起来，然后遍历第二个列表找最小下标之和。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> newLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minSum = <span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list1.length;i++)&#123;</span><br><span class="line">            map.put(list1[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(list2[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> n = i + map.get(list2[i]);</span><br><span class="line">                <span class="keyword">if</span>(n&lt;minSum)&#123;</span><br><span class="line">                    list1[<span class="number">0</span>] = list2[i];</span><br><span class="line">                    newLength = <span class="number">1</span>;</span><br><span class="line">                    minSum = n;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == minSum)&#123;</span><br><span class="line">                    list1[newLength] = list2[i];</span><br><span class="line">                    newLength++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] ret = <span class="keyword">new</span> String[newLength];</span><br><span class="line">        System.arraycopy(list1,<span class="number">0</span>,ret,<span class="number">0</span>,newLength);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。&lt;/p&gt;
&lt;p&gt;你需要帮助
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>对象的输入输出-java序列化机制</title>
    <link href="https://www.codetool.top/article/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-java%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.codetool.top/article/对象的输入输出-java序列化机制/</id>
    <published>2019-12-21T14:54:22.000Z</published>
    <updated>2019-12-22T07:50:55.799Z</updated>
    
    <content type="html"><![CDATA[<p>对象序列化和反序列化，在java中体现为两种字节流： <code>ObjectInputStream</code>、<code>ObjectOutputStream</code></p><h1 id="序列化的概念"><a href="#序列化的概念" class="headerlink" title="序列化的概念"></a>序列化的概念</h1><p>指堆内存中的java对象数据，通过某种方式存储到磁盘文件中，或者传递给其他网络节点（网络传输）。这个过程称为序列化，通常是指将数据结构或对象转化成<strong>二进制</strong>的过程。</p><p>反序列化，顾名思义，则是将二进制字节流转化回java对象的过程。</p><p>java序列化是<strong>平台无关的</strong>。</p><h1 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h1><ol><li>对象持久化  </li><li>网络传输对象    </li><li>进程间传递对象  </li></ol><h1 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h1><h2 id="默认序列化"><a href="#默认序列化" class="headerlink" title="默认序列化"></a>默认序列化</h2><ol><li>为类实现一个Serializable接口，这是一个空接口，没有需要实现的方法。</li><li>可以调用ObjectOutputStream.writeObject方法来序列化了。</li><li>调用ObjectInputStream.readObject来反序列化</li></ol><h2 id="自定义序列化过程"><a href="#自定义序列化过程" class="headerlink" title="自定义序列化过程"></a>自定义序列化过程</h2><p>实现Serializable接口之后，重写 writeObject(ObjectOutputStream) 、 readObject(ObjectInputStream) 方法。</p><h1 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h1><p>通常可序列化的类会使用一个序列化ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常<code>InvalidClassException</code>。</p><h1 id="序列化之后的字节流格式"><a href="#序列化之后的字节流格式" class="headerlink" title="序列化之后的字节流格式"></a>序列化之后的字节流格式</h1><p>我们用这样一段代码做实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(System.out);</span><br><span class="line">        Object obj = <span class="keyword">new</span> SerializableObject();</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aced 0005 7372 0012 5365 7269 616c 697a</span><br><span class="line">6162 6c65 4f62 6a65 6374 0b8e b091 7d68</span><br><span class="line">738d 0200 0078 70</span><br></pre></td></tr></table></figure><p>前两个字节固定： <code>ac ed</code></p><p>紧接的是对象序列化格式的版本号： <code>00 05</code></p><p>接下来，73 代表接下来读取到的将是一个对象，72 代表该对象是一个对类的描述：<code>73 72</code></p><p>接下来的两字节描述类名长度：<code>00 12</code>，对应18个字节的全限定类名。</p><p>于是接下来的18字节就是类名的UTF编码：<code>5365 7269 616c 697a 6162 6c65 4f62 6a65 6374</code>，就是类名SerializableObject。</p><p>接下来八个字节是序列化版本ID：<code>0b8e b091 7d68 738d</code></p><p>接下来一个字节<code>02</code>代表了序列化中标识类版本。</p><p>继续往下两个字节就是 <code>00 00</code> , 代表该类中字段的个数，由于我这个类内部为空没有字段，所以这里就是0。</p><p>然后是它包含的字段序列类型描述,其顺序即它们存储的顺序.</p><p>基本类型的组成为：<code>一字节类型描述符 两字节字段名称长度 字段名称</code></p><p>类型描述符：</p><table><thead><tr><th>解码字符</th><th>代表类型</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>L</td><td>对象</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>[</td><td>数组</td></tr></tbody></table><p>字段序列类型描述结束后附加两个字节是固定的<code>78 70</code></p><p>最后是字段信息（内容）的描述，这里都没有。</p><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><ol><li>静态变量不会被序列化(static)，transient则可以限定字段不参与序列化。</li><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象序列化和反序列化，在java中体现为两种字节流： &lt;code&gt;ObjectInputStream&lt;/code&gt;、&lt;code&gt;ObjectOutputStream&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;序列化的概念&quot;&gt;&lt;a href=&quot;#序列化的概念&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="序列化" scheme="https://www.codetool.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>leetcode205-同构字符串</title>
    <link href="https://www.codetool.top/article/leetcode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode205-同构字符串/</id>
    <published>2019-12-21T05:00:29.000Z</published>
    <updated>2019-12-21T05:40:32.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> <strong><em>s</em></strong> = “egg”, <strong><em>t</em></strong> = “add”<br><strong>输出：</strong> true</p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> <strong><em>s</em></strong> = “foo”, <strong><em>t</em></strong> = “bar”<br><strong>输出：</strong> false</p></blockquote><p><strong>示例3：</strong> </p><blockquote><p><strong>输入：</strong> <strong><em>s</em></strong> = “paper”, <strong><em>t</em></strong> = “title”<br><strong>输出：</strong> true</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>相同的字符要对应相同的字符，那么相同字符处于后位置的字符的第一次出现的位置就应该相同。</li><li>哈希表记录对应关系</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>indexOf （作者:hao-fei-hao）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ch2 = t.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.indexOf(ch1[i]) != t.indexOf(ch2[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>哈希表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        Map&lt;Character,Character&gt; mapB = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i)!=map.get(s.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mapB.containsKey(t.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)!=mapB.get(t.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),t.charAt(i));</span><br><span class="line">            mapB.put(t.charAt(i),s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(s.charAt(i))!=t.charAt(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不存在对应的键但是存在对应的值</span></span><br><span class="line">                <span class="keyword">if</span> (map.containsValue(t.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(s.charAt(i),t.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，判断它们
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1-两数之和</title>
    <link href="https://www.codetool.top/article/leetcode1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode1-两数之和/</id>
    <published>2019-12-20T13:41:49.000Z</published>
    <updated>2019-12-20T15:41:39.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br><br/><br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>遍历一次数组，每次在哈希表中将<code>target-当前数的值</code>和<code>当前下标</code>关联起来，则之后遇到的值如果在哈希表中存在，就能得到前面的下标。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(target-nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>今天是我写博客历史上最黑暗的一天</title>
    <link href="https://www.codetool.top/article/%E4%BB%8A%E5%A4%A9%E6%98%AF%E6%88%91%E5%86%99%E5%8D%9A%E5%AE%A2%E5%8E%86%E5%8F%B2%E4%B8%8A%E6%9C%80%E9%BB%91%E6%9A%97%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <id>https://www.codetool.top/article/今天是我写博客历史上最黑暗的一天/</id>
    <published>2019-12-19T08:27:09.000Z</published>
    <updated>2019-12-19T08:44:32.468Z</updated>
    
    <content type="html"><![CDATA[<p>由于我博客中的图片一直是放在了一个公共图床上，这几天我这边加载博客中的图片有点加载不出来，再加上各种因素考虑，打算将我博客中的图片全部转到我自己服务器里面来。</p><p>当然，手动一篇一篇找博客中的图片链接，然后上传到自己的服务器的工作量肯定是非常大的。于是我想到了用python这个小助手（确实没想到后来我的工作量更大了😀）</p><p>我的主要需求就是，找出我博客目录下所有markdown文件中保存在公共图床上的图片链接，然后上传到自己的服务器，获取图片链接，然后替换掉原来的链接。</p><p>最后写出来应该是这样的（为了我的api安全就不展示所有代码了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">''</span><span class="comment"># 我的图床api</span></span><br><span class="line">pattern = re.compile(<span class="string">r'https://s2\S+\.png'</span>)<span class="comment"># 正则匹配我原来的图床链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dirName, subdirList, fileList <span class="keyword">in</span> os.walk(<span class="string">"./"</span>):</span><br><span class="line">    print(<span class="string">'Folder: %s'</span> % dirName)</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> fileList:</span><br><span class="line">        <span class="keyword">if</span> fname != <span class="string">''</span>: <span class="comment"># 排除掉一些文件，或只选择md文件</span></span><br><span class="line">            print(<span class="string">"正在处理"</span>+fname+<span class="string">"文件"</span>)</span><br><span class="line">            fp = open(dirName+<span class="string">"/"</span>+fname,<span class="string">"r+"</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            content = fp.read()</span><br><span class="line">            result = re.findall(pattern,content)</span><br><span class="line">            <span class="keyword">for</span> imgUrl <span class="keyword">in</span> result:</span><br><span class="line">                print(<span class="string">"检测到图片："</span>+imgUrl)</span><br><span class="line">                <span class="comment">#</span></span><br><span class="line">                <span class="comment">#</span></span><br><span class="line">                <span class="comment">#</span></span><br><span class="line">                replaceUrl = <span class="string">''</span> <span class="comment"># 上传到自己服务器，获取replaceUrl</span></span><br><span class="line">                content = content.replace(imgUrl,replaceUrl)</span><br><span class="line">            fp = open(dirName + <span class="string">"/"</span> + fname, <span class="string">"w+"</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            fp.write(content)</span><br><span class="line">            print(<span class="string">"替换成功"</span>)</span><br></pre></td></tr></table></figure><p>那么，我犯了个什么错误呢😀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> fileList:</span><br><span class="line">    <span class="keyword">if</span> fname != <span class="string">''</span>: </span><br><span class="line">        print(<span class="string">"正在处理"</span>+fname+<span class="string">"文件"</span>)</span><br><span class="line">        fp = open(dirName+<span class="string">"/"</span>+fname,<span class="string">"w+"</span>,encoding=<span class="string">'utf-8'</span>) <span class="comment"># w+哦</span></span><br><span class="line">        content = fp.read()</span><br></pre></td></tr></table></figure><p>没错就是要读的时候打开的方式写成了w+</p><p>然后就直接运行了😀</p><p>后果就是哈麻批我markdown源文件全变成空白的了。</p><p>然后我就花了几个小时从我网站上一个一个网页地把他们写回markdown源文件。</p><p>如果现在某篇博客里有什么错误，很有可能就是我没仔细检查。</p><p>真是写博客历史上最黑暗的一天😀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于我博客中的图片一直是放在了一个公共图床上，这几天我这边加载博客中的图片有点加载不出来，再加上各种因素考虑，打算将我博客中的图片全部转到我自己服务器里面来。&lt;/p&gt;
&lt;p&gt;当然，手动一篇一篇找博客中的图片链接，然后上传到自己的服务器的工作量肯定是非常大的。于是我想到了用p
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode705-设计哈希集合</title>
    <link href="https://www.codetool.top/article/leetcode705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/"/>
    <id>https://www.codetool.top/article/leetcode705-设计哈希集合/</id>
    <published>2019-12-18T10:05:23.000Z</published>
    <updated>2019-12-19T08:18:30.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>不使用任何内建的哈希表库设计一个哈希集合</p><p>具体地说，你的设计应该包含以下的功能</p><ul><li><code>add(value)</code>：向哈希集合中插入一个值。</li><li><code>contains(value)</code> ：返回哈希集合中是否存在这个值。</li><li><code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p><strong>示例：</strong></p><blockquote><p>MyHashSet hashSet = new MyHashSet();<br>hashSet.add(1);<br>hashSet.add(2);<br>hashSet.contains(1); // 返回 true<br>hashSet.contains(3); // 返回 false (未找到)<br>hashSet.add(2);<br>hashSet.contains(2); // 返回 true<br>hashSet.remove(2);<br>hashSet.contains(2); // 返回 false (已经被删除)</p></blockquote><p><strong>注意:</strong></p><ul><li>所有的值都在 <code>[0, 1000000]</code>的范围内。</li><li>操作的总数目在<code>[1, 10000]</code>范围内。</li><li>不要使用内建的哈希集合库。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>偷懒，已知值的范围，直接将整数值映射为哈希值，有多少个哈希值建多少个桶，用空间换时间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] exist;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exist = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1000001</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        exist[key] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        exist[key] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exist[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj.add(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;不使用任何内建的哈希表库设计一个哈希集合&lt;/p&gt;
&lt;p&gt;具体地说，你的设计应该包含以下的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add(
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode136-只出现一次的数字</title>
    <link href="https://www.codetool.top/article/leetcode136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://www.codetool.top/article/leetcode136-只出现一次的数字/</id>
    <published>2019-12-18T10:05:23.000Z</published>
    <updated>2019-12-19T08:16:46.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><blockquote><p><strong>输入：</strong> [2,2,1]<br><strong>输出：</strong> 1</p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> [4,1,2,1,2]<br><strong>输出：</strong> 4</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>哈希集<br>第一次出现加到集合中，第二次出现从集合中删除，最后集合中剩下的那个元素即为只出现一次的数。</li><li>亦或<ul><li>两个相同的数亦或的结果为0</li><li>0和n亦或的结果为n<br>=&gt; 则所有数亦或的结果即为只出现一次的数。</li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>哈希集</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) set.remove(i);</span><br><span class="line">            <span class="keyword">else</span> set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>亦或</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res=res^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
</feed>
