<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeBand CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-07T04:46:01.956Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode154-寻找旋转排序数组中的最小值II</title>
    <link href="https://www.codetool.top/article/leetcode154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>https://www.codetool.top/article/leetcode154-寻找旋转排序数组中的最小值II/</id>
    <published>2020-01-07T04:29:31.000Z</published>
    <updated>2020-01-07T04:46:01.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> [1,3,5]<br><strong>输出：</strong> 1   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> [2,2,2,0,1]<br><strong>输出：</strong> 0    </p></blockquote><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>线性查找</li><li>二分查找,参考 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/</a></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>线性查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;min)&#123;</span><br><span class="line">                min=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二分查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> right = right - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记03</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B003/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记03/</id>
    <published>2020-01-06T08:36:25.000Z</published>
    <updated>2020-01-06T13:36:12.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol><li><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数<strong>是否能在常量池中定位到一个类的符号引用</strong>，并且检查这个<strong>符号引用代表的类是否已被加载、解析和初始化过</strong>。如果没有，那必须先执行相应的<strong>类加载过程</strong></p></li><li><p>类加载检查通过后，为新生对象分配内存。有两种方法：</p><ul><li>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个<strong>指针向空闲空间方向挪动一段与对象大小相等的距离</strong>，这种分配方式称为 <strong>“指针碰撞”</strong></li><li>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须<strong>维护一个列表，记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”</li></ul></li><li><p>同步问题：仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决方法：</p><ul><li>对分配内存空间的动作进行同步处理（实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性）</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），是否启用TLAB可以通过<code>-XX：+/-UseTLAB</code>参数来设定。</li></ul></li><li><p>将分配到的内存空间（但不包括对象头）都初始化为零值</p></li><li><p>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。</p></li><li><p>执行<init> ()方法（构造函数）</p></li></ol><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>Markword:存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15783086203644.png" alt="markword" title="">                </div>                <div class="image-caption">markword</div>            </figure><p>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，如果开启指针压缩，可以在64位机上也变成32比特。</p><p>开启指针压缩：<code>-XX:+UseCompressedOops</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15783086492674.png" alt="kclass" title="">                </div>                <div class="image-caption">kclass</div>            </figure><p>数组长度： 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，这部分数据的长度是32比特。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15783093332239.png" alt="实例数据" title="">                </div>                <div class="image-caption">实例数据</div>            </figure><p>这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序会<strong>通过栈上的reference数据来操作堆上的具体对象</strong>。<br>对象访问方式是由虚拟机实现而定的，主流的访问方式主要有<strong>使用句柄和直接指针</strong>两种：</p><ul><li>句柄访问：可能会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据与类型数据</strong>各自具体的地址信息，其结构如图所示：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/1578313342112.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>好处：好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><ul><li>直接指针访问:Java堆中对象的内存布局就必须考虑如何<strong>放置访问类型数据</strong>的相关信息，reference中存储的直接就是<strong>对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示:</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15783134884212.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>好处：速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，HotSpot是使用的这种方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HotSpot虚拟机对象探秘&quot;&gt;&lt;a href=&quot;#HotSpot虚拟机对象探秘&quot; class=&quot;headerlink&quot; title=&quot;HotSpot虚拟机对象探秘&quot;&gt;&lt;/a&gt;HotSpot虚拟机对象探秘&lt;/h1&gt;&lt;h2 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记02</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B002/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记02/</id>
    <published>2020-01-05T12:08:33.000Z</published>
    <updated>2020-01-06T13:33:59.726Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第二章 Java内存区域与内存溢出异常</strong>的内容</p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15782333435215.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li><li>程序计数器是线程私有的，线程轮换之后通过程序计数器确定要执行的指令位置。</li><li>不存在内存溢出。</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>Java虚拟机栈也是线程私有的,它的生命周期与线程相同。</li><li>虚拟机栈描述的是Java方法执行的<strong>线程内存模型</strong>：每个方法被执行的时候，Java虚拟机都<br>会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口等信息</strong>。栈帧的入栈出栈对应一个方法的调用。</li><li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和返回地址。</li><li>局部变量表中的存储空间以 <strong>局部变量槽（Slot）</strong> 来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常，可能会有这两种情况：<ul><li>栈帧过多</li><li>栈帧过大</li></ul></li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。（HotSpot虚拟机的栈容量是不可以动态扩展的，也不会导致这种异常）</li></ul><p>代码演示：通过<code>-Xss</code>参数来设定栈的大小</p><p>（无限递归导致栈帧过多）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*VM Args：-Xss128k</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        stackLength++;         </span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();         </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（栈帧太大）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">        unused6, unused7, unused8, unused9, unused10,              </span><br><span class="line">        unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">        unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">        unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">        unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">        unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">        unused36, unused37, unused38, unused39, unused40, </span><br><span class="line">        unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">        unused46, unused47, unused48, unused49, unused50, </span><br><span class="line">        unused51, unused52, unused53, unused54, unused55, </span><br><span class="line">        unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">        unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">        unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">        unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">        unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">        unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">        unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">        unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">        unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 = </span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 = </span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;             </span><br><span class="line">            test();         </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>是java虚拟机栈的native方法版。<br>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>是各个进程共享的。</li><li>所有的对象实例以及数组都应当在堆上分配，日后可能出现值类型的支持。</li><li>Java堆中可以划分出多个线程私有的<strong>分配缓冲区</strong>，以提升对象分配时的效率。</li><li>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。</li></ul><h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError</code>异常。</p><p>代码演示：<br>(将堆的最小值<code>-Xms</code>参数与最大值<code>-Xmx</code>参数设置为一样即可避免堆自动扩展，通过参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**·</span></span><br><span class="line"><span class="comment">*VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>是各个进程共享的。</li><li>它用于存储<strong>已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</li><li>JAVA8以前HotSpot使用永久代实现方法区，把堆的垃圾回收机制延申至方法区，JAVA8开始使用位于本地内存中的<strong>元空间</strong>实现方法区。</li><li>JAVA虚拟机规范不要求实现垃圾回收。</li><li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</li><li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。</li><li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。</li></ul><h3 id="异常-2"><a href="#异常-2" class="headerlink" title="异常"></a>异常</h3><p>如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。(由于JAVA8后方法区位于本地内存中，很少出现这种情况，一般是涉及到动态加载过多类)</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ul><li>运行时常量池是方法区的一部分。</li><li>类的字节码中有一项信息是常量池表，用于存放编译期生成的<strong>类名、方法名、参数类型与字面量</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</li><li>Java语言并不要求常量一定只有编译期才能产生，String类的intern方法可以将字符串常量放进字符串常量池表。</li></ul><h3 id="异常-3"><a href="#异常-3" class="headerlink" title="异常"></a>异常</h3><p>常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="intern方法有意思的点"><a href="#intern方法有意思的点" class="headerlink" title="intern方法有意思的点"></a>intern方法有意思的点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在JDK 6中运行，会得到两个false，而在JDK 7中运行，会得到一个true和一个false。产生差异的原因是，在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在 Java堆上，所以必然不可能是同一个引用，结果将返回false。</p><p>而JDK 7（以及部分其他虚拟机，例如JRockit）的<strong>intern()方法实现就不需要再拷贝字符串的实例到永久代</strong>了，既然字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。而对str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了（sun.misc.Version类中加载），字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存就是机器的内存，JDK1.4中的NIO可以使用Native函数库直接分配堆外内存</p><p><code>-XX：MaxDirectMemorySize</code>指定可使用的直接内存大小，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第二章 Java内存区域与内存溢出异常&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h1&gt;&lt;fi
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode744-寻找比目标字母大的最小字母</title>
    <link href="https://www.codetool.top/article/leetcode744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/"/>
    <id>https://www.codetool.top/article/leetcode744-寻找比目标字母大的最小字母/</id>
    <published>2020-01-05T09:31:46.000Z</published>
    <updated>2020-01-05T09:40:41.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个只包含小写字母的有序数组<code>letters</code> 和一个目标字母 <code>target</code>，寻找有序数组里面比目标字母大的最小字母。</p><p>数组里字母的顺序是循环的。举个例子，如果目标字母<code>target = &#39;z&#39;</code> 并且有序数组为 <code>letters = [&#39;a&#39;, &#39;b&#39;]</code>，则答案返回 <code>&#39;a&#39;</code>。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “a”<br><strong>输出:</strong> “c”<br><br/><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “c”<br><strong>输出:</strong> “f”<br><br/><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “d”<br><strong>输出:</strong> “f”<br><br/><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “g”<br><strong>输出:</strong> “j”<br><br/><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “j”<br><strong>输出:</strong> “c”<br><br/><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “k”<br><strong>输出:</strong> “c”</p></blockquote><p><strong>注:</strong></p><ol><li><code>letters</code>长度范围在<code>[2, 10000]</code>区间内。</li><li><code>letters</code> 仅由小写字母组成，最少包含两个不同的字母。</li><li>目标字母<code>target</code> 是一个小写字母。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = letters.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid]&lt;=target) start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(letters[start] &lt;= target) <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> letters[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个只包含小写字母的有序数组&lt;code&gt;letters&lt;/code&gt; 和一个目标字母 &lt;code&gt;target&lt;/code&gt;，寻找有序数
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode367-有效的完全平方数</title>
    <link href="https://www.codetool.top/article/leetcode367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode367-有效的完全平方数/</id>
    <published>2020-01-05T08:52:03.000Z</published>
    <updated>2020-01-05T08:55:48.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个正整数 <em>num*，编写一个函数，如果 *num</em> 是一个完全平方数，则返回 True，否则返回 False。</p><p><strong>说明：</strong> 不要使用任何内置的库函数，如  <code>sqrt</code>。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> 16<br><strong>输出:</strong> True  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> 14<br><strong>输出:</strong> False</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找。由于平方后可能会超出int范围要注意long的使用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> end = num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid == num) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid &gt; num) end = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid &lt;num) start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;num*，编写一个函数，如果 *num&lt;/em&gt; 是一个完全平方数，则返回 True，否则返回 False。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50-Pow(x,n)</title>
    <link href="https://www.codetool.top/article/leetcode50-Pow-x-n/"/>
    <id>https://www.codetool.top/article/leetcode50-Pow-x-n/</id>
    <published>2020-01-05T08:10:49.000Z</published>
    <updated>2020-01-05T08:17:50.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>实现 <code>pow(x, n)</code> ，即计算 x 的 n 次幂函数。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> 2.00000, 10<br><strong>输出：</strong> 1024.00000   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> 2.10000, 3<br><strong>输出：</strong> 9.26100  </p></blockquote><p><strong>示例3：</strong></p><blockquote><p><strong>输入：</strong> 2.00000, -2<br><strong>输出：</strong> 0.25000<br><strong>解释：</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>这道题使用暴力解法会超出时间限制。</p><p>自底向上，快速幂。由x<sup>n</sup> = (x<sup>n/2</sup>)<sup>2</sup>得到。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> / x;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">double</span> rest = myPow(x, n % <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> half * half * rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;实现 &lt;code&gt;pow(x, n)&lt;/code&gt; ，即计算 x 的 n 次幂函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记01</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B001/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记01/</id>
    <published>2020-01-04T12:54:41.000Z</published>
    <updated>2020-01-06T06:43:46.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="做笔记之前的感言"><a href="#做笔记之前的感言" class="headerlink" title="做笔记之前的感言"></a>做笔记之前的感言</h1><p>谈到《深入理解java虚拟机》，在业内可太有名了，是国内的一位大神写的一本关于java虚拟机的畅销书，基本上对java稍有深入的程序员都听说过这本书。不过遗憾的是，这本书第二版的创作背景是java7，而在过了这么多年java的更新之后，jvm内部也发生了许多变化，最近听闻这本书的第三版出来了，赶紧买了一本来看。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15781428537860.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以下是<strong>第一章 走进Java</strong>的内容</p><h1 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h1><p>从广义上讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员。如果仅从传统意义上来看，JCP官方所定义的Java技术体系包括了以下几个组成部分：</p><ul><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机实现</li><li>Class文件格式</li><li>Java类库API</li><li>来自商业机构和开源社区的第三方Java类库</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/157814354693.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>JavaEE中对JavaSE中的针对性补充一般以javax.*作为包名。</p><h1 id="java发展史"><a href="#java发展史" class="headerlink" title="java发展史"></a>java发展史</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15781436864850.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>1995年5月23日，<strong>Oak语言</strong>改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。Java语言第一次提出了“Write Once，Run Anywhere”的口号。</p><ul><li>JDK 1.0版本的代表技术包括：Java虚拟机、Applet、AWT等。</li><li>JDK 1.1版的技术代表有：JAR文件格式、JDBC、JavaBeans、RMI等。Java语言的语法也有了一定的增强，如内部类（Inner Class）和反射（Reflection）都是在这时候出现的。</li><li>JDK 1.4同样带来了很多新的技术特性，如<strong>正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器</strong>。</li><li>JDK 5在Java语法易用性上做出了非常大的改进。如：<strong>自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）</strong>等语法特性都是在JDK 5中加入的。在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包等。</li><li>JDK 6的改进包括：提供初步的动态语言支持（通过内置Mozilla JavaScript<br>Rhino引擎实现）、提供编译期注解处理器和微型HTTP服务器API，等等。同时，这个版本对<strong>Java虚拟机内部</strong>做了大量改进，包括<strong>锁与同步、垃圾收集、类加载</strong>等方面的实现都有相当多的改动。</li><li>JDK 7包含的改进有：提供新的<strong>G1收集器</strong>、加强对非Java语言的调用支持（JSR-292，这项特性在到JDK 11还有改动）、可并行的类加载架构等。</li><li>JDK 8提供了那些曾在JDK 7中规划过，但最终未能在JDK 7中完成的功能，主要包括：对<strong>Lambda表达式</strong>的支持，这让Java语言拥有了流畅的函数式表达能力、内置Nashorn JavaScript引擎的支持、<strong>新的时间、日期API、彻底移除HotSpot的永久代</strong>。</li><li>除了<strong>Jigsaw</strong>外，JDK 9还增强了若干工具（JS Shell、JLink、JHSDB等），整顿了<br>HotSpot各个模块各自为战的日志系统，支持HTTP 2客户单API等91个JEP。</li><li>JDK 11发布，这是一个LTS版本的JDK，包含17个JEP，其中有<strong>ZGC这样的革命性的垃圾收集器</strong>出现。</li><li>JDK 12发布，只包含8个JEP，其中主要有<strong>Switch表达式、Java微测试套件（JMH）</strong>等新功能，最引人注目的特性无疑是加入了由RedHat领导开发的Shen-andoah垃圾收集器。</li></ul><h1 id="java虚拟机家族"><a href="#java虚拟机家族" class="headerlink" title="java虚拟机家族"></a>java虚拟机家族</h1><p>虚拟机始祖：Sun Classic/Exact VM</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15781220438809.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="java技术的未来"><a href="#java技术的未来" class="headerlink" title="java技术的未来"></a>java技术的未来</h1><h2 id="无语言倾向"><a href="#无语言倾向" class="headerlink" title="无语言倾向"></a>无语言倾向</h2><p>2018年4月，Oracle Labs新公开了一项黑科技：<strong>Graal VM</strong></p><p>Graal VM被官方称为“Universal VM”和“Polyglot VM”，这是一个在HotSpot虚拟机基础上增强而成的<strong>跨语言全栈虚拟机</strong>，可以作为“任何语言”的运行平台使用，这里“任何语言”包括了Java、Scala、Groovy、Kotlin等基于Java虚拟机之上的语言，还包括了C、C++、Rust等基于LLVM的语言，同时支持其他像JavaScript、Ruby、Python和R语言等。Graal VM可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言使用已经编写好的本地库文件。</p><h2 id="新一代即时编译器"><a href="#新一代即时编译器" class="headerlink" title="新一代即时编译器"></a>新一代即时编译器</h2><p>HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2），通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统</p><p>自<strong>JDK 10</strong>起，HotSpot中又加入了一个全新的即时编译器：<strong>Graal编译器</strong>，看名字就可以联想到它是来自于前一节提到的Graal VM。Graal编译器是以<strong>C2编译器替代者</strong>的身份登场的。C2的历史已经非常长了，可以追溯到Cliff Click大神读博士期间的作品，这个由C++写成的编译器尽管目前依然效果拔群，但已经复杂到连Cliff Click本人都不愿意继续维护的程度。而Graal编译器本身就是由Java语言写成，实现时又刻意与C2采用了同一种名为“Sea-of-Nodes”的高级中间表示（High IR）形式，使其能够更容易借鉴C2的优点。Graal编译器比C2编译器晚了足足二十年面世，有着极其充沛的后发优势，在保持输出相近质量的编译代码的同时，开发效率和扩展性上都要显著优于C2编译器，这决定了C2编译器中优秀的代码优化技术可以轻易地移植到Graal编译器上，但是反过来Graal编译器中行之有效的优化在 C2编译器里实现起来则异常艰难。这种情况下，Graal的编译效果短短几年间迅速追平了C2，甚至某些测试项中开始逐渐反超C2编译器。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。</p><h2 id="向Native迈进"><a href="#向Native迈进" class="headerlink" title="向Native迈进"></a>向Native迈进</h2><p>微服务架构的兴起促进java<strong>提前编译技术</strong>的发展</p><p>Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器（Native Image Generator），用于为用户程序建立基于Substrate VM 的本地运行时镜像。这个构造器采用指针分析（Points-To Analysis）技术，从用户提供的程序入口出发，搜索所有可达的代码。在搜索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样一来，Substrate VM就可以直接从目标程序开始运行，而无须重复进行Java虚拟机的初始化过程。但相应地，原理上也决定了Substrate VM必须要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。基于这个假设，Substrate VM才能探索整个编译空间，并通过静态分析推算出所有虚方法调用的目标方法。</p><h2 id="灵活的胖子"><a href="#灵活的胖子" class="headerlink" title="灵活的胖子"></a>灵活的胖子</h2><p>经过一系列的重构与开放，HotSpot虚拟机逐渐从时间的侵蚀中挣脱出来，虽然代码复杂度还在增长，体积仍在变大，但其架构并未老朽，而是拥有了越来越多的开放性和扩展性，使得HotSpot成为一个能够联动外部功能，能够应对各种场景，能够学会十八般武艺的身手灵活敏捷的“胖子”。</p><h2 id="语言语法持续增强"><a href="#语言语法持续增强" class="headerlink" title="语言语法持续增强"></a>语言语法持续增强</h2><p>随着Java每半年更新一次的节奏，新版本的Java中会出现越来越多其他语言里已有的优秀特性，相信博采众长的Java，还能继续保持现在的勃勃生机相当长时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;做笔记之前的感言&quot;&gt;&lt;a href=&quot;#做笔记之前的感言&quot; class=&quot;headerlink&quot; title=&quot;做笔记之前的感言&quot;&gt;&lt;/a&gt;做笔记之前的感言&lt;/h1&gt;&lt;p&gt;谈到《深入理解java虚拟机》，在业内可太有名了，是国内的一位大神写的一本关于java虚拟机
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode658-找到K个最接近的元素</title>
    <link href="https://www.codetool.top/article/leetcode658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode658-找到K个最接近的元素/</id>
    <published>2020-01-04T12:08:07.000Z</published>
    <updated>2020-01-04T12:44:46.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5], k=4, x=3<br><strong>输出:</strong> [1,2,3,4] </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5], k=4, x=-1<br><strong>输出:</strong> [1,2,3,4] </p></blockquote><p><strong>说明:</strong></p><ol><li>k 的值为正数，且总是小于给定排序数组的长度。</li><li>数组不为空，且长度不超过 104</li><li>数组里的每个元素与 x 的绝对值不超过 104</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>按照差值排序</li><li>双指针</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(List&lt;Integer&gt; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     Collections.sort(arr, (a,b) -&gt; a == b ? a - b : Math.abs(a-x) - Math.abs(b-x));</span><br><span class="line">     arr = arr.subList(<span class="number">0</span>, k);</span><br><span class="line">     Collections.sort(arr);</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>双指针（作者：liweiwei1419）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> removeNums = size - k;</span><br><span class="line">        <span class="keyword">while</span> (removeNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - arr[left] &lt;= arr[right] - x) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            removeNums--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; left + k; i++) &#123;</span><br><span class="line">            res.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个排序好的数组，两个整数 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt;，从数组中找到最靠近 &lt;code&gt;x&lt;/cod
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode34--在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://www.codetool.top/article/leetcode34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://www.codetool.top/article/leetcode34-在排序数组中查找元素的第一个和最后一个位置/</id>
    <published>2020-01-03T09:58:04.000Z</published>
    <updated>2020-01-03T10:00:44.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [5,7,7,8,8,10], target = 8<br><strong>输出：</strong> [3,4]   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [5,7,7,8,8,10], target = 6<br><strong>输出：</strong> [-1,-1]    </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找，找到一个目标值时向两边继续查找最初和最末出现的地方。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(end == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[mid]!=target &amp;&amp;start&lt;=end)&#123;</span><br><span class="line">            mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) end = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]!=target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mid_cache = mid;</span><br><span class="line">        <span class="keyword">int</span> end_cache = end;</span><br><span class="line">        end = mid;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) end = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos[<span class="number">0</span>] = start;</span><br><span class="line">        start = mid_cache;</span><br><span class="line">        end = end_cache;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            mid = start + (end-start+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) start = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) end = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos[<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">return</span> pos;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个按照升序排列的整数数组 &lt;code&gt;nums&lt;/code&gt;，和一个目标值 &lt;code&gt;target&lt;/code&gt;。找出给定目标值在数
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode153-寻找旋转排序数组中的最小值</title>
    <link href="https://www.codetool.top/article/leetcode153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode153-寻找旋转排序数组中的最小值/</id>
    <published>2020-01-03T07:59:23.000Z</published>
    <updated>2020-01-07T04:45:58.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> [3,4,5,1,2]<br><strong>输出：</strong> 1   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> [4,5,6,7,0,1,2]<br><strong>输出：</strong> 0    </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>线性查找</li><li>二分查找，找出旋转点</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>线性查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;min)&#123;</span><br><span class="line">                min=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二分查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= head) start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; head) end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start]&gt;head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode162-寻找峰值</title>
    <link href="https://www.codetool.top/article/leetcode162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode162-寻找峰值/</id>
    <published>2020-01-03T07:22:04.000Z</published>
    <updated>2020-01-03T07:34:16.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> nums = [1,2,3,1]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 3 是峰值元素，你的函数应该返回其索引 2。  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> nums = [1,2,1,3,5,6,4]<br><strong>输出:</strong> 1 或 5<br><strong>解释:</strong> 你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>线性查找，从第一个元素开始，第一个打破单调递增的元素。</li><li>二分查找，看中间元素值的的趋势（斜率）</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>线性查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cache = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(n&lt;nums.length &amp;&amp;nums[n]&gt;=cache)&#123;</span><br><span class="line">            cache = nums[n];</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>二分查找（来源：leetcode官方）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 &lt;code&gt;nums&lt;/code&gt;，其中 &lt;code&gt;nums[i]
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode278-第一个错误的版本</title>
    <link href="https://www.codetool.top/article/leetcode278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>https://www.codetool.top/article/leetcode278-第一个错误的版本/</id>
    <published>2020-01-02T13:17:40.000Z</published>
    <updated>2020-01-02T13:20:58.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例：</strong></p><blockquote><p>给定 n = 5，并且 version = 4 是第一个错误的版本。<br><br/><br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br><br/><br>所以，4 是第一个错误的版本。   </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)) end = mid;</span><br><span class="line">            <span class="keyword">else</span> start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode33-搜索旋转排序数组</title>
    <link href="https://www.codetool.top/article/leetcode33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode33-搜索旋转排序数组/</id>
    <published>2020-01-01T14:03:54.000Z</published>
    <updated>2020-01-01T14:15:51.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,5,6,7,0,1,2], target = 0<br><strong>输出：</strong> 4   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,5,6,7,0,1,2], target = 3<br><strong>输出：</strong> -1    </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找，需要注意、区分一些情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> head = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(target == head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;<span class="comment">//mid比target大</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;head)&#123;<span class="comment">//target在左边</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&gt;=head) end = mid-<span class="number">1</span>;<span class="comment">//mid在左边</span></span><br><span class="line">                    <span class="keyword">else</span> start = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target在右边</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&gt;=head) start = mid+<span class="number">1</span>;<span class="comment">//mid在左边</span></span><br><span class="line">                    <span class="keyword">else</span> end = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;<span class="comment">//mid比target小</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;head)&#123;<span class="comment">//target在左边</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid]&gt;=head) start = mid+<span class="number">1</span>;<span class="comment">//mid在左边</span></span><br><span class="line">                    <span class="keyword">else</span> end = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target在右边</span></span><br><span class="line">                    start = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>2019年的最后一天，我想说些什么</title>
    <link href="https://www.codetool.top/article/2019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%EF%BC%8C%E6%88%91%E6%83%B3%E8%AF%B4%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>https://www.codetool.top/article/2019年的最后一天，我想说些什么/</id>
    <published>2019-12-31T11:22:37.000Z</published>
    <updated>2020-01-01T10:39:44.969Z</updated>
    
    <content type="html"><![CDATA[<p>首先，祝所有朋友们新年快乐♥</p><p>时间过得挺快的，我是2018年8月19日创立的博客，到现在也有一年多的时间了。</p><p>看着年龄随年份的增长是一件很奇妙的事情，我是00年出生的，这意味着，我永远不需要进行年龄的计算，到了2020年也就20岁了。如果是十年前的我，对大学阶段不是很了解，我会觉得20岁真好啊，大概已经开始工作，不再忍受每天繁重的作业任务了。</p><p>可是实际上，我对20岁感到挺恐惧的。这种恐惧，或许是来源于不知大四的我会有什么去向，不知道我是否有能力去胜任一份工作，未知永远是骇人的。又或许是，我明白自己已经不会再年轻了。</p><p>最近有一句话在网上很火：“我的青春又回来了”。大概涉足不同圈子的人有不同的理解，对于热爱lol的我来说，如果有那么一瞬间会让我感到“我的青春又回来了”，大概就是最近德玛西亚杯决赛上“猪狗大战”的那场BO5。这么说或许有点离谱，毕竟我初入LOL坑是在高一那一年，那一年是英雄联盟的S5，是EDG的辉煌年份。所以当看到蓝方和红方分别为EDG和RNG的时候，我不禁有些恍惚，似乎回到了S5的LPL，正盛的EDG和粉丝众多的RNG开战一刻。</p><p>但“青春回来”的时刻永远是那么短暂，总是有那么多一瞬提醒我“青春将不再回来了”，作为一个猪仔，厂长今年休赛期从现役选手位上淡出转为主教练令我颇为感慨，厂长的英雄联盟之路比我长得多。他是LPL的一号选手，也是EDG的灵魂人物，S5到S9，不仅是选手一批一批地更替，战队也出现了许多我不认识的战队。然而我永远知道EDG的厂长会一直在场，一直打下去，因为他要追逐他的电竞梦。“一代人终将老去，但总有人正年轻”。</p><p>我高二高三时尤其喜欢玩英雄联盟，现在却也不怎么接触了，主要是没人一起玩，少了很多乐趣，偶尔和高中同学一起五黑，又能回忆起当年网吧五连坐的激情，只是技术已大不如前。我特别喜欢我的高中时期，虽然那时的我并不轻松，却带有抹不去的青春气息。</p><p>回到现在，我常常想，当初创立这个博客的初心是什么呢。我记得，从入这个专业起，我很早就开始捣鼓服务器了，从使用简单的wordpress开始搭建网站，那时为了避免备案使用了国外的服务器，因此网速也非常的慢，我却乐此不彼地研究着一个个的可以用服务器实现的有趣的功能。2018年8月19日，我决定搞一个个人的编程相关的博客，我想，那时的我只是三分钟热度，导致写了几篇博客之后就很久一段时间没有更新。2019年11月8日，我从同学处听说了Hexo这个框架，出于把我的博客继续搞下去的念头，我使用hexo重新搭建了这个网站，现在一直保持一天大于一更的写文章速度，我觉得这既是对我学习成果的一种总结，也是督促我学习的一种方式。</p><p>看着我的博客的文章数目越来越多，我是非常欣喜的，然而我知道我还有许多的知识需要学习，大四的逼近时常让我赶到压力，我没有过考研的打算，所以明年的秋招我只能放手一搏，可是我非常担心我的能力不够，随着最近了解java架构越多，越感到自己所学的那点知识的匮乏程度，深深感到了自己的无力感。</p><p>今天就说到这，写的挺杂的，不管怎样，2020冲冲冲！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，祝所有朋友们新年快乐♥&lt;/p&gt;
&lt;p&gt;时间过得挺快的，我是2018年8月19日创立的博客，到现在也有一年多的时间了。&lt;/p&gt;
&lt;p&gt;看着年龄随年份的增长是一件很奇妙的事情，我是00年出生的，这意味着，我永远不需要进行年龄的计算，到了2020年也就20岁了。如果是十年前
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode374-猜数字大小</title>
    <link href="https://www.codetool.top/article/leetcode374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/"/>
    <id>https://www.codetool.top/article/leetcode374-猜数字大小/</id>
    <published>2019-12-31T11:17:27.000Z</published>
    <updated>2019-12-31T11:21:11.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 <strong>1</strong> 到 <strong>n</strong> 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 <code>guess(int num)</code>，它会返回 3 个可能的结果（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p><blockquote><p>-1 : 我的数字比较小<br> 1 : 我的数字比较大<br> 0 : 恭喜！你猜对了！  </p></blockquote><p><strong>示例 :</strong>  </p><blockquote><p><strong>输入：</strong> n = 10, pick = 6<br><strong>输出：</strong> 6  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找，注意求中位数的公式不要用<code>(start+end)/2</code>容易溢出，应该用<code>start+(end-start)/2</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span></span><br><span class="line"><span class="comment">   @param num, your guess</span></span><br><span class="line"><span class="comment">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="comment">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess(mid)==<span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(guess(mid)==-<span class="number">1</span>) end = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid)==<span class="number">1</span>) start = mid+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;我们正在玩一个猜数字游戏。 游戏规则如下：&lt;br&gt;我从 &lt;strong&gt;1&lt;/strong&gt; 到 &lt;strong&gt;n&lt;/strong&gt; 选择
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode69-x的平方根</title>
    <link href="https://www.codetool.top/article/leetcode69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>https://www.codetool.top/article/leetcode69-x的平方根/</id>
    <published>2019-12-30T11:58:11.000Z</published>
    <updated>2019-12-30T12:02:18.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> 4<br><strong>输出：</strong> 2  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> 8<br><strong>输出：</strong> 2<br><strong>说明：</strong> 8 的平方根是 2.82842…,<br>      由于返回类型是整数，小数部分将被舍去。</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了防止end * end 超过int范围，这里统一使用使用long</span></span><br><span class="line">        <span class="keyword">long</span> longx = x;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> end = x/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            mid = (end+start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid == longx) <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid &lt; longx) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(start*start&gt;longx) <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid &gt; longx) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(end*end&lt;longx) <span class="keyword">return</span> (<span class="keyword">int</span>)end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;实现 &lt;code&gt;int sqrt(int x)&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 &lt;em&gt;x&lt;/em&gt; 的平方根，其中 &lt;e
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode704-二分查找</title>
    <link href="https://www.codetool.top/article/leetcode704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.codetool.top/article/leetcode704-二分查找/</id>
    <published>2019-12-29T12:04:34.000Z</published>
    <updated>2019-12-29T12:07:49.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> nums = [-1,0,3,5,9,12], target = 9<br><strong>输出：</strong> 4<br><strong>解释：</strong> 9 出现在 nums 中并且下标为 4</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> nums = [-1,0,3,5,9,12], target = 2<br><strong>输出：</strong> -1<br><strong>解释：</strong> 2 不存在 nums 中因此返回 -1</p></blockquote><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二分查找思想</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&gt;target) end = middle-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;target) start = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start]==target) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;n&lt;/code&gt; 个元素有序的（升序）整型数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;targ
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode380-常数时间插入、删除和获取随机元素</title>
    <link href="https://www.codetool.top/article/leetcode380-%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode380-常数时间插入、删除和获取随机元素/</id>
    <published>2019-12-28T14:44:41.000Z</published>
    <updated>2019-12-31T11:57:39.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>设计一个支持在平均 时间复杂度 <strong><em>O(1)</em></strong> 下，执行以下操作的数据结构。</p><ol><li><code>insert(val)</code>：当元素 val 不存在时，向集合中插入该项。</li><li><code>remove(val)</code>：元素 val 存在时，从集合中移除该项。</li><li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有<strong><em>相同的概率</em></strong>被返回。</li></ol><p><strong>示例：</strong></p><blockquote><p>// 初始化一个空的集合。<br>RandomizedSet randomSet = new RandomizedSet();<br><br/><br>// 向集合中插入 1 。返回 true 表示 1 被成功地插入。<br>randomSet.insert(1);<br><br/><br>// 返回 false ，表示集合中不存在 2 。<br>randomSet.remove(2);<br><br/><br>// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。<br>randomSet.insert(2);<br><br/><br>// getRandom 应随机返回 1 或 2 。<br>randomSet.getRandom();<br><br/><br>// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。<br>randomSet.remove(1);<br><br/><br>// 2 已在集合中，所以返回 false 。<br>randomSet.insert(2);<br><br/><br>// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。<br>randomSet.getRandom();  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>初始想法  </li></ol><p>哈希表的插入删除的时间复杂度都是<code>O(1)</code>，获取的时候可以通过EntrySet。<br>所以这道题是不能用HashSet的。</p><p>这样虽然获取随机元素的时候时间复杂度最高可能是<code>O(n)</code>，但仍比遍历一遍Set转ArrayList好很多。</p><ol start="2"><li>正确解法  </li></ol><p>哈希表插入和删除都是<code>O(1)</code>，而顺序表随机访问则是<code>O(1)</code>，可以使用ArrayList来存储所有的数据。但是必须解决ArrayList删除元素的<code>O(n)</code>问题。  </p><p>于是可以：</p><p>在哈希表中用value-index来记录值和在list中的下标的对应关系，如图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15775470173323.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当删除元素时，size减一，用list中最后那个元素替换要删除的那个元素，并且将哈希表中的对应关系改过来（用要删除的元素的index替换list中最后那个元素对应的index）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/1577547151755.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>此时若要随机访问元素，只需获取list中前3(size)个元素中的一个。</p><p>那么如果需要继续插入元素，只需从list中下标为3(size)处替换掉后面那个元素或是在后面那个元素之前插入（这里如果用插入是使用add(index,value)方法，个人觉得比起set会增加时间复杂度，因为使用add后面的元素都需要向后移动，虽然jdk源码中使用了System.arraycopy即内存拷贝来优化，但是也比直接替换的时间复杂度更高）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15775473303971.png" alt="该图显示的是替换" title="">                </div>                <div class="image-caption">该图显示的是替换</div>            </figure><p>如果不是替换元素而是add操作，这里会变成<code>1-4-2-8-4</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>初始想法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    Object none = <span class="keyword">new</span> Object();</span><br><span class="line">    HashMap&lt;Integer,Object&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.put(val,none);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ran = random.nextInt(map.size());  </span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Object&gt; i:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==ran) <span class="keyword">return</span> i.getKey();</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>正确解法（来源：leetcode用户，添加元素时是直接插入）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Map&lt;Integer,Integer&gt; map; <span class="comment">// 存放值和在 list 的下标位置的映射</span></span><br><span class="line">    List&lt;Integer&gt; list;       <span class="comment">// 存放要插入数据的结构</span></span><br><span class="line">    <span class="keyword">int</span> size;                 <span class="comment">// 数据的长度</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 插入数据，并更新 map 的映射后将长度加一</span></span><br><span class="line">            list.add(size,val);</span><br><span class="line">            map.put(val,size++);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( size == <span class="number">0</span> )&#123; map.remove(val);&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 取到 list 末尾的数据</span></span><br><span class="line">            <span class="keyword">int</span> tailKey = list.get(size-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 然后将要原先 map 中得 val-index 映射改为 tailKey-index</span></span><br><span class="line">            map.put(tailKey,map.get(val));</span><br><span class="line">            <span class="comment">// 在 map 中取得 val 在 list 的位置，然后根据这个位置用末尾元素 tailKey 替代</span></span><br><span class="line">            list.set(map.get(val),tailKey);</span><br><span class="line">            <span class="comment">// 在 map 中删除 val 的映射</span></span><br><span class="line">            map.remove(val);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">         <span class="comment">// rand.nextInt(size) 产生的是 0 到 size（不包括 size） 的数据</span></span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;设计一个支持在平均 时间复杂度 &lt;strong&gt;&lt;em&gt;O(1)&lt;/em&gt;&lt;/strong&gt; 下，执行以下操作的数据结构。&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode347-前K个高频元素</title>
    <link href="https://www.codetool.top/article/leetcode347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode347-前K个高频元素/</id>
    <published>2019-12-28T13:39:09.000Z</published>
    <updated>2019-12-28T13:44:29.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个非空的整数数组，返回其中出现频率前 <strong><em>k</em></strong> 高的元素。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,1,1,2,2,3], k = 2<br><strong>输出：</strong> [1,2]  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [1], k = 1<br><strong>输出：</strong> [1]  </p></blockquote><p><strong>说明:</strong></p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>可以用哈希表记录下出现的次数，然后将哈希表按值排序。（获取entryList用Collections来排序）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">        entryList.sort((entry1, entry2) -&gt; entry2.getValue() - entry1.getValue());</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; i:entryList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;=k) <span class="keyword">break</span>;</span><br><span class="line">            list.add(i.getKey());</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;&lt;em&gt;k&lt;/em&gt;&lt;/strong&gt; 高的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode454-四数相加II</title>
    <link href="https://www.codetool.top/article/leetcode454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://www.codetool.top/article/leetcode454-四数相加II/</id>
    <published>2019-12-27T12:45:57.000Z</published>
    <updated>2019-12-27T13:20:37.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2<sup>28</sup> 到 2<sup>28</sup> - 1 之间，最终结果不会超过 2<sup>31</sup> - 1 。</p><p><strong>例如:</strong></p><blockquote><p><strong>输入：</strong><br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]  </p><p><strong>输出：</strong><br>2</p><p><strong>解释:</strong><br>两个元组如下:     </p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0  </li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0  </li></ol></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li>暴力（超出时间限制）：暴力的问题是，只要数组的数目超过两个，便会重复计算很多单元，比如<code>A1+B1+C2</code>和<code>A2+B1+C2</code>其中<code>B1+C2</code>就被反复计算了，他的时间复杂度会成n<sup>N</sup>的形势增长。</li><li>为了解决暴力的时间复杂性幂增长，可以将其降维，两个两个分组，然后作查找表配对总和为0的情况。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li>暴力</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;len;a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>;b&lt;len;b++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;len;c++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>;d&lt;len;d++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(A[a]+B[b]+C[c]+D[d]==<span class="number">0</span>)</span><br><span class="line">                            count ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查找表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:B)&#123;</span><br><span class="line">                <span class="comment">//记录下-(i+j)可以对应的次数。</span></span><br><span class="line">                map.put(-i-j,map.getOrDefault(-i-j,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:D)&#123;</span><br><span class="line">                count += map.getOrDefault(i+j,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; ，使得 &lt;c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
