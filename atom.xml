<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-24T19:04:58.773Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode103-二叉树的锯齿形层次遍历</title>
    <link href="https://www.codetool.top/article/leetcode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode103-二叉树的锯齿形层次遍历/</id>
    <published>2020-01-24T18:52:24.000Z</published>
    <updated>2020-01-24T19:04:58.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;/ \<br>&nbsp;&nbsp;9&nbsp;&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;7  </p></blockquote><p>返回锯齿形层次遍历如下：</p><blockquote><p>[<br>&nbsp;&nbsp;[3],<br>&nbsp;&nbsp;[20,9],<br>&nbsp;&nbsp;[15,7]<br>]  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>用两个栈来交替存储某一层和下一层的节点:</p><p>读取第一个栈的时候，从左向右的读取节点，将它们的子节点从左向右入第二个栈，能使读取第二个栈的时候是以从右向左的顺序出栈的。</p><p>读取第二个栈的时候，从右向左的读取节点，将它们的子节点从右向左入第一个栈，能使读取第一个栈的时候是以从左向右的顺序出栈的。</p><p>这样交替使用两个栈，可以实现两层之间的顺序反转。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当前层的节点按从左向右的顺序依次出栈，子节点按从左向右的顺序入second栈，实现顺序逆转</span>            cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> second<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> second<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下一层的节点按从右向左的顺序依次出栈，子节点按从右向左的顺序入first栈，实现顺序逆转</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> second<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/cod
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>愿广大国人都能平安度过这个春节</title>
    <link href="https://www.codetool.top/article/%E6%84%BF%E5%B9%BF%E5%A4%A7%E5%9B%BD%E4%BA%BA%E9%83%BD%E8%83%BD%E5%B9%B3%E5%AE%89%E5%BA%A6%E8%BF%87%E8%BF%99%E4%B8%AA%E6%98%A5%E8%8A%82/"/>
    <id>https://www.codetool.top/article/愿广大国人都能平安度过这个春节/</id>
    <published>2020-01-24T16:30:44.000Z</published>
    <updated>2020-01-24T16:51:20.114Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2020年1月25日，农历正月初一，是咱们国家的传统佳节——春节。我一直觉得春节是中国很重要的一个文化符号，我相信对于所有华人来说，春节的特殊性已经融于血液之中，是不可替代的节日。我在这里恭祝所有华人新年快乐，鼠年大吉。</p><p>同时我也希望，大家应时刻把自己的健康安全放在第一位，在2019-nCoV（武汉肺炎）肆虐之际，要时刻注意清洁卫生，出门戴好口罩，这段时间尽量避免和别人接触。</p><p>截至目前，大多数省级行政区都启动了突发公共卫生事件一级响应，这件事的重要程度不言而喻，我也有在持续关注疫情的动态。我相信只要大家齐心协力，我们一定能打好这场攻坚战，我们也不用太过恐慌，保护好自己就是最重要的。</p><p>目前已经可以看到很多市民的防范意识都有提高，我觉得我们现在做的一切都在步入正轨。</p><p>希望这个春节所有人都平平安安！武汉加油！中国加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是2020年1月25日，农历正月初一，是咱们国家的传统佳节——春节。我一直觉得春节是中国很重要的一个文化符号，我相信对于所有华人来说，春节的特殊性已经融于血液之中，是不可替代的节日。我在这里恭祝所有华人新年快乐，鼠年大吉。&lt;/p&gt;
&lt;p&gt;同时我也希望，大家应时刻把自己的
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode85-最大矩形</title>
    <link href="https://www.codetool.top/article/leetcode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode85-最大矩形/</id>
    <published>2020-01-24T05:19:04.000Z</published>
    <updated>2020-01-24T05:53:01.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong><br>[<br>&nbsp;&nbsp;[“1”,”0”,”1”,”0”,”0”],<br>&nbsp;&nbsp;[“1”,”0”,”1”,”1”,”1”],<br>&nbsp;&nbsp;[“1”,”1”,”1”,”1”,”1”],<br>&nbsp;&nbsp;[“1”,”0”,”0”,”1”,”0”]<br>]<br><strong>输出:</strong> 6  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题可以分解成若干<a href="../leetcode84-柱状图中最大的矩形/">leetcode84-柱状图中最大的矩形</a>的子问题，可以使用相同的方法。</p><p>我们从上往下动态规划二维数组，每增加一行就会出现不同的柱状区域。</p><p><img src="https://api.codetool.top/img/15798449822257.png" alt></p><p>从每一次得到的最大矩形面积中获取最大值，就是该题的答案</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> line<span class="token operator">:</span>matrix<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//每增加一行改变height数组</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span><span class="token punctuation">)</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max<span class="token operator">=</span>area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt;&lt;br
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode84-柱状图中最大的矩形</title>
    <link href="https://www.codetool.top/article/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode84-柱状图中最大的矩形/</id>
    <published>2020-01-23T19:01:50.000Z</published>
    <updated>2020-01-23T19:12:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://api.codetool.top/img/15798062014581.png" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://api.codetool.top/img/15798062338069.png" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [2,1,5,6,2,3]<br><strong>输出：</strong> 10</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode42-接雨水/">leetcode42-接雨水</a>较为相似。</p><p>对于每列来说，以当前列高为高的最大矩形区域的宽度区域为被左边最近较矮一列和右边最近较矮一列围起来的宽度。</p><p>如果两边有一边没有比当前列矮的一列，则左边算作-1，右边算作length。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.to
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记09</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B009/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记09/</id>
    <published>2020-01-23T13:14:13.000Z</published>
    <updated>2020-01-23T17:22:36.645Z</updated>
    
    <content type="html"><![CDATA[<p>续<a href="../深入理解java虚拟机第三版读书笔记08">深入理解java虚拟机第三版读书笔记08</a></p><h1 id="类加载器">1 类加载器</h1><p><strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>称为类加载器。类加载器可以用户自定义，是java语言流行的一项原因</p><h2 id="类与类加载器">1.1 类与类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>或者说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><h2 id="双亲委派模型">1.2 双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap<br>ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p><p>自JDK 1.2以来，Java一直保持着<strong>三层类加载器、双亲委派的类加载架构。</strong></p><p>对于JDK8及之前版本的Java，绝大多数程序都会使用到以下3个系统提供的类加载器来进行加载</p><ul><li>启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在 <code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</li><li>扩展类加载器（Extension Class Loader）：这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application Class Loader）：这个类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是<strong>程序中默认的类加载器</strong>。</li></ul><p><img src="https://api.codetool.top/img/15797991285820.png" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。（子加载器将部分动作委派给父加载器）</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有<strong>当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><p>好处是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类<code>java.lang.Object</code>都是交给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>实现双亲委派模型的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，检查请求的类是否已经被加载过了</span>    Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>            <span class="token comment" spellcheck="true">// 说明父类加载器无法完成加载请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时</span>            <span class="token comment" spellcheck="true">// 再调用本身的findClass方法来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;续&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记08&quot;&gt;深入理解java虚拟机第三版读书笔记08&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;类加载器&quot;&gt;1 类加载器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;通过一个类的全限定名来获取描述该类的二进制字节流&lt;/strong&gt;称为类加
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码实例探究</title>
    <link href="https://www.codetool.top/article/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.codetool.top/article/Java字节码实例探究/</id>
    <published>2020-01-23T10:22:05.000Z</published>
    <updated>2020-01-23T13:11:56.515Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a>中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。</p><p>java源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">40000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个类有方法有实例变量有静态变量，在JDK8环境下编译后的字节码开头部分如下图：</p><p><img src="https://api.codetool.top/img/15797791725139.png" alt="该文件开头部分"></p><p>我们来逐字节分析：</p><h1 id="魔数、次版本号、主版本号">1 魔数、次版本号、主版本号</h1><p>00~03：<code>CA FE BA BE</code>，魔数。</p><p>04~05：<code>00 00</code> Minor Version，次版本号<br>06~07：<code>00 34</code> 十进制52，Major Version，主版本号，两者对应JDK8</p><h1 id="常量池">2 常量池</h1><p>08~09：<code>00 2F</code> 十进制47，代表常量池内项的数量。</p><p>10开始为常量池中的各表：</p><p><strong>#1</strong><br>0A：<code>0A</code> 十进制10，代表<code>CONSTANT_Methodref_info</code>类型，<br>0B~0E：<code>00 0A 00 1E</code> #10，#30</p><p><strong>#2</strong><br>0F：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>10~13：<code>00 09 00 1F</code> #9，#31</p><p><strong>#3</strong><br>14：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>15~18：<code>00 20 00 21</code> #32，#33</p><p><strong>#4</strong><br>19：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>1A~1D：<code>00 09 00 22</code> #9，#34</p><p><strong>#5</strong><br>1E：<code>0A</code> 十进制9，代表<code>CONSTANT_Methodref_info</code>类型，<br>1F~22：<code>00 23 00 24</code> #35，#36</p><p><strong>#6</strong><br>1E：<code>03</code> 十进制3，代表<code>CONSTANT_Integer_info</code>类型，<br>15~18：<code>00 00 9C 40</code> 40000</p><p><strong>#7</strong><br>28：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>29~2C：<code>00 09 00 25</code> #9，#37</p><p><strong>#8</strong><br>2D：<code>08</code> 十进制8，代表<code>CONSTANT_String_info</code>类型，<br>2E~2F：<code>00 26</code> #38</p><p><strong>#9</strong><br>30：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>31~32：<code>00 27</code> #39</p><p><strong>#10</strong><br>33：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>34~35：<code>00 28</code> #40</p><p><strong>#11</strong><br>36：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>37~38：<code>00 01</code>代表长度为1，39：<code>69</code> 代表字符<code>&#39;i&#39;</code></p><p><strong>#12</strong><br>3A：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>3B~3C：<code>00 01</code>代表长度为1，3D：<code>49</code> 代表字符<code>&#39;I&#39;</code></p><p>剩余常量池的项我们用javap得到（其实累了）：</p><pre><code>#13 = Utf8               j#14 = Utf8               str#15 = Utf8               Ljava/lang/String;#16 = Utf8               &lt;init&gt;#17 = Utf8               ()V#18 = Utf8               Code#19 = Utf8               LineNumberTable#20 = Utf8               LocalVariableTable#21 = Utf8               this#22 = Utf8               LMain;#23 = Utf8               main#24 = Utf8               ([Ljava/lang/String;)V#25 = Utf8               args#26 = Utf8               [Ljava/lang/String;#27 = Utf8               &lt;clinit&gt;#28 = Utf8               SourceFile#29 = Utf8               Main.java#30 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V#31 = NameAndType        #11:#12        // i:I#32 = Class              #41            // java/lang/System#33 = NameAndType        #42:#43        // out:Ljava/io/PrintStream;#34 = NameAndType        #14:#15        // str:Ljava/lang/String;#35 = Class              #44            // java/io/PrintStream#36 = NameAndType        #45:#46        // println:(Ljava/lang/String;)V#37 = NameAndType        #13:#12        // j:I#38 = Utf8               Hello World!#39 = Utf8               Main#40 = Utf8               java/lang/Object#41 = Utf8               java/lang/System#42 = Utf8               out#43 = Utf8               Ljava/io/PrintStream;#44 = Utf8               java/io/PrintStream#45 = Utf8               println#46 = Utf8               (Ljava/lang/String;)V</code></pre><h1 id="访问标志、类索引、父类索引、接口索引集合">3 访问标志、类索引、父类索引、接口索引集合</h1><p>跳过常量池，到了<strong>访问标志：</strong></p><p>01C1~01C2：<code>00 21</code>，代表<code>ACC_SUPER</code>（0x0020）和<code>ACC_PUBLIC</code>（0x0001）。</p><p>接着是<strong>类索引：</strong></p><p>01C3~01C4：<code>00 09</code> 代表常量池中#9，#9又指向#39，可以得知是Main，即类名</p><p><strong>父类索引：</strong></p><p>01C5~01C6：<code>00 0A</code> 代表常量池中#10，#10又指向#40，可以得知是<code>java/lang/Object</code></p><p><strong>接口索引集合：</strong></p><p>01C7~01D8：<code>00 00</code> 代表接口索引集合中没有数据，长度是0</p><h1 id="字段表集合">4 字段表集合</h1><p>01C9~01CA: <code>00 03</code> 十进制3，代表字段表中有三项数据：</p><p>第一个字段：</p><p>01CB~01CC: <code>00 02</code> ，访问标志，代表<code>ACC_PRIVATE</code>（0x0002）<br>01CD~01CE：<code>00 0B</code> ，name_index，指向常量池#11，#11代表<code>&#39;i&#39;</code><br>01CF~01D0：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D1~01D2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第二个字段：</p><p>01D3~01D4: <code>00 0A</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PRIVATE</code>（0x0002）<br>01D5~01D6：<code>00 0D</code> ，name_index，指向常量池#13，#13代表<code>&#39;j&#39;</code><br>01D7~01D8：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D9~01DA：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第三个字段：</p><p>01DB~01DC: <code>00 09</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PUBLIC</code>（0x0001）<br>01DD~01DE：<code>00 0E</code> ，name_index，指向常量池#14，#14代表<code>&quot;str&quot;</code><br>01DF~01E0：<code>00 0F</code> , discriptor_index，指向常量池#15，#15代表<code>&quot;Ljava/lang/String;&quot;</code>（即String类型）<br>01E1~01E2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><h1 id="方法表集合">5 方法表集合</h1><p>01E3~01E4：<code>00 03</code> ，十进制3，代表方法表中有三项数据：</p><p><strong>第一个方法：</strong></p><p>01E5~01E6: <code>00 01</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）<br>01E7~01E8：<code>00 10</code> ，name_index，指向常量池#16，#16代表<code>&quot;&lt;init&gt;&quot;</code>（即对象构造器）<br>01E9~01EA：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参、无返回值）<br>01EB~01EC：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>01ED~01EE: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>01EF~01F2：<code>00 00 00 39</code>，代表Code内容长度为57个字节。</p><p>接下来57个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>01F3~022B</p><pre><code>Code:stack=2, locals=1, args_size=1    0: aload_0    1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V    4: aload_0    5: bipush        10    7: putfield      #2                  // Field i:I    10: returnLineNumberTable:    line 7: 0    line 8: 4LocalVariableTable:    Start  Length   Slot    Name    Signature    0      11       0       this    LMain;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>aload_0      </p></blockquote><p>将局部变量表slot 0加载到操作数栈，那么局部变量表slot 0原来存放的是什么呢？非静态方法局部变量表0位置一开始都是存放的this，即调用方法的当前对象。这句话就是把this入操作数栈。</p><blockquote><p>invokespecial #1</p></blockquote><p>this调用#1代表的方法，我们查常量表#1，#1又指向#10和#30，#10指向#40，是<code>java/lang/Object</code>，#30是<code>&quot;&lt;init&gt;&quot;:()V</code>，即调用父类Object的构造方法。</p><blockquote><p>aload_0</p></blockquote><p>再次加载this</p><blockquote><p>bipush 10</p></blockquote><p>将常量10压入操作数栈。</p><blockquote><p>putfield #2</p></blockquote><p>putfield是设置对象的字段值，通过查常量表，#2代表<code>Main</code>中的<code>i:I</code>，这句话就把栈里的两个操作数：<code>10</code>设置给<code>this.i</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第二个方法：</strong></p><p>022C~022D: <code>00 09</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）和<code>ACC_STATIC</code>（0x0008）<br>022E~022F：<code>00 17</code> ，name_index，指向常量池#23，#23代表<code>&quot;main&quot;</code><br>0230~0231：<code>00 18</code> , discriptor_index，指向常量池#24，#24代表<code>&quot;([Ljava/lang/String;)V&quot;</code>（即参数为String数组、无返回值）<br>0232~0233：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>0234~0235: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>0236~0239：<code>00 00 00 38</code>，代表Code内容长度为56个字节。</p><p>接下来56个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>023A~0271</p><pre><code>Code:stack=2, locals=1, args_size=1    0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;    3: getstatic     #4                  // Field str:Ljava/lang/String;    6: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V    9: returnLineNumberTable:    line 12: 0    line 13: 9LocalVariableTable:    Start  Length  Slot  Name   Signature        0      10     0  args   [Ljava/lang/String;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>getstatic #3      </p></blockquote><p>获取一个类的静态字段，通过查常量表可知#3是<code>java/lang/System</code>的<code>out:Ljava/io/PrintStream;</code>即获取<code>System.out</code></p><blockquote><p>getstatic #4</p></blockquote><p>获取一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>即获取str字段。</p><blockquote><p>invokevirtual #5</p></blockquote><p>调用#5方法，通过查常量表可知#5是<code>java/io/PrintStream</code>的<code>println:(Ljava/lang/String;)V</code>，即在操作栈的基础上调用<code>System.out.println(str)</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第三个方法：</strong></p><p>0272~0273: <code>00 08</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）<br>0274~0275：<code>00 1B</code> ，name_index，指向常量池#27，#27代表<code>&quot;&lt;clinit&gt;&quot;</code>（即类构造器）<br>0276~0277：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参无返回值）<br>0278~0279：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>027A~027B: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>027C~027F：<code>00 00 00 27</code>，代表Code内容长度为39个字节。</p><p>接下来39个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>0280~02A6</p><pre><code>Code:stack=1, locals=0, args_size=0    0: ldc           #6                  // int 40000    2: putstatic     #7                  // Field j:I    5: ldc           #8                  // String Hello World!    7: putstatic     #4                  // Field str:Ljava/lang/String;    10: returnLineNumberTable:    line 9: 0    line 10: 5</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>ldc #6     </p></blockquote><p>把一个常量#6加载到操作数栈，通过查常量表可知#6是40000。</p><blockquote><p>putstatic #7</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#7是<code>Main</code>的<code>j:I</code>，即设置j的值为40000。（注意这里与第一个方法不同的是，设置小于等于short最大值的值的时候常数放在字节码中，而大于short最大值的常量放在常量表中）</p><blockquote><p>ldc #8</p></blockquote><p>把一个常量#8加载到操作数栈，通过查常量表可知#8是<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>putstatic #4</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>，即将str的值设置为<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>return</p></blockquote><p>返回</p><h1 id="属性表">6 属性表</h1><p>02A7~02A8：<code>00 01</code> attributes_count，代表属性表中有一项数据<br>02A9~02AA：<code>00 1C</code> attribute_name_index，指向常量池#28，#28代表<code>&quot;SourceFile&quot;</code>（记录源文件名称）<br>02AB~02AE: <code>00 00 00 02</code> 代表属性内容长度为2个字节。<br>02AF~02B0: <code>00 1D</code> 代表属性的值，指向常量池#29，#29代表<code>&quot;Main.java&quot;</code>  </p><p>到此，该class文件的字节码全部分析完</p><p><img src="https://api.codetool.top/img/15797822431714.png" alt="该文件结尾部分"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记06&quot;&gt;深入理解java虚拟机第三版读书笔记06&lt;/a&gt;中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。&lt;/p&gt;
&lt;p&gt;java源码：&lt;/p&gt;
&lt;pre class=&quot; language
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="Class文件" scheme="https://www.codetool.top/tags/Class%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode71-简化路径</title>
    <link href="https://www.codetool.top/article/leetcode71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.codetool.top/article/leetcode71-简化路径/</id>
    <published>2020-01-23T06:40:01.000Z</published>
    <updated>2020-01-23T07:10:01.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> “/home/“<br><strong>输出：</strong> “/home”<br><strong>解释：</strong> 注意，最后一个目录名后面没有斜杠。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> “/../“<br><strong>输出：</strong> “/“<br><strong>解释：</strong> 从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> “/home//foo/“<br><strong>输出：</strong> “/home/foo”<br><strong>解释：</strong> 在规范路径中，多个连续斜杠需要用一个斜杠替换。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> “/a/./b/../../c/“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong> “/a/../../b/../c//.//“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 6：</strong></p><blockquote><p><strong>输入：</strong> “/a//b////c/d//././/..”<br><strong>输出：</strong> “/a/b/c”  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用栈的思想来解决该问题，将给定的字符串使用<code>&quot;/&quot;</code>分割，会得到由空字符串、<code>&quot;.&quot;</code>、<code>&quot;..&quot;</code>、目录名组成的字符串数组，然后根据它们的特点对元素进行入栈出栈等操作。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">simplifyPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//因为最后要遍历栈，这里用ArrayList来模拟栈</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>dirs<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//空字符串和"."都表示当前目录</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">||</span> i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//".."表示上一级目录，出栈一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>                     stack<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//其他目录名入栈</span>            <span class="token keyword">else</span> stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过"/"连接起来</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>stack<span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;以 Unix 风格给出一个文件的&lt;strong&gt;绝对路径&lt;/strong&gt;，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（&lt;code&gt;.&lt;/code&gt;）表示当前目录本身；此外
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42-接雨水</title>
    <link href="https://www.codetool.top/article/leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://www.codetool.top/article/leetcode42-接雨水/</id>
    <published>2020-01-22T17:09:42.000Z</published>
    <updated>2020-01-22T17:39:56.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://api.codetool.top/img/15797131314307.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong> 6</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一列能存下的雨水单位等于<code>左右最高两列当中的较矮一列与当前高度的高度差</code>。</p><p><img src="https://api.codetool.top/img/15797135878580.png" alt></p><p>如图，第五列的积雨水量，等于左边最高一列（第四列left）和右边最高一列（第八列right）的较矮一列（left）与当前列高度的高度差（2-1=1）</p><p>如果两边有一边没有比当前列高的列，则当前列不会积水。</p><h2 id="代码">2.2 代码</h2><p>我一开始是这样写的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新左边所有列的right</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新右边所有列的left</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null <span class="token operator">||</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>时间复杂度达到了N<sup>2</sup>级别，那么如何优化呢？</p><ol><li>不必使用null来表示没有比当前列高的列，即使两列相等，高度差也是0，相当于不积水。</li><li>利用动态规划的思想，如果前一列的left比当前列高，则当前列的left也等于前一列的left。对于right也是一样的。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从左向右更新left</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从右向左更新right</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15797131314307.png&quot; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode95-不同的二叉搜索树II</title>
    <link href="https://www.codetool.top/article/leetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://www.codetool.top/article/leetcode95-不同的二叉搜索树II/</id>
    <published>2020-01-22T15:12:01.000Z</published>
    <updated>2020-01-22T15:20:18.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong><br>[<br>&nbsp;&nbsp;[1,null,3,2],<br>&nbsp;&nbsp;[3,2,null,1],<br>&nbsp;&nbsp;[3,1,null,null,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[1,null,2,null,3]<br>]<br><strong>解释:</strong><br>以上的输出对应以下 5 种不同结构的二叉搜索树：<br>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题的思想和<a href="../leetcode96-不同的二叉搜索树">leetcode96-不同的二叉搜索树</a>类似，通过各种左右组合情况得到为一个list返回。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">></span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含null的list使得for嵌套能正常工作</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含本数字的list</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自由组合左子树和右子树的情况</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode left<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode right<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96-不同的二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode96-不同的二叉搜索树/</id>
    <published>2020-01-22T14:15:52.000Z</published>
    <updated>2020-01-22T15:16:07.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:  </p><p>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于每一个n对应的数量应该是相同的，我们从1~n中任选一个做根节点（假设是第i个），那么左右两边各有<code>F(i-1)</code>和<code>F(n-i)</code>中情况，将它们相乘就是此时第i个元素做根节点的情况。如此递归计算总数量。</p><h2 id="代码">2.2 代码</h2><p>我一开始的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是发现这样写消耗非常多时间，leetcode执行用时<code>1700 ms</code>。</p><p>优化的思路主要是：</p><ol><li>end和start并不关键，只要start-end（即范围内的数字数量,用n表示）相同，对应的值就相同。</li><li>假如优化上条，很多<code>F(n)</code>单元会被重复计算，可以使用数组做缓存。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记08</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B008/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记08/</id>
    <published>2020-01-22T08:54:44.000Z</published>
    <updated>2020-01-22T19:37:45.581Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第七章 虚拟机类加载机制</strong>的内容</p><h1 id="概述">1 概述</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。在Java语言里面，<strong>类型的加载、连接和初始化过程都是在程序运行期间完成的</strong>，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性。</p><h1 id="类加载的时机">2 类加载的时机</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载<br>（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://api.codetool.top/img/15796958251344.png" alt></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而<strong>解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始</strong>，这是为了支持Java语言的运行时绑定特性。</p><p>加载阶段并没有严格规定开始的时机，而有且只有六种情况必须立即对类进行“初始化”：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>使用java.lang.reflect包的方法对类型进行反射调用</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p>这六种操作称为主动引用，其他引用称为被动引用，不会触发初始化。</p><p>接口的初始化稍有不同：对于第三点，接口只有真正用到父接口的时候才会使父接口初始化。</p><h1 id="类加载的过程">3 类加载的过程</h1><h2 id="加载">3.1 加载</h2><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>其中第一步自由度就很高，从ZIP压缩包中读取、从网络中获取、运行时计算生成等等。</p><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，<strong>开发人员通过定义自己的类加载器去控制字节流的获取方式</strong>（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><p><strong>数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。</strong>但数组类与类加载器仍然有很密切的关系，因为<strong>数组类的元素类型（指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载</strong>，一个数组类（下面简称为C）创建过程遵循以下规则：</p><ul><li>如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li><li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。</li><li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li></ul><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，但加载阶段提前开始于连接阶段。</p><h2 id="验证">3.2 验证</h2><p>这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>尽管Java代码编译时会拒绝编译一些致命错误，但字节码可以被轻易修改，字节码检查也是必不可少的。</p><h3 id="文件格式验证">3.2.1 文件格式验证</h3><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>……</li></ul><p>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有<strong>通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</strong></p><h3 id="元数据验证">3.2.2 元数据验证</h3><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li><li>……</li></ul><p>第二阶段的主要目的是<strong>对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</strong></p><h3 id="字节码验证">3.2.3 字节码验证</h3><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li></ul><p>目的是通过数据流分析和控制流分析，<strong>确定程序语义是合法的、符合逻辑的</strong>，不会危害虚拟机安全。</p><h3 id="符号引用验证">3.2.4 符号引用验证</h3><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作在解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、&lt;package&gt;）是否可被当前类访问。</li><li>……</li></ul><p>符号引用验证的主要目的是<strong>确保解析行为能正常执行</strong>，如果无法通过符号引用验证，Java虚拟机将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常，典型的如：<code>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError</code>等。</p><p>验证阶段不是必需的，如果程序运行使用的所有字节码都是安全的，可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备">3.3 准备</h2><p>准备阶段是正式<strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</strong>。（初始值指的是零值，类初始化阶段中调用类构造器方法才会对类变量赋值）</p><p>特殊情况：如果字段存在ConstantValue属性（声明为final，会在字段表的属性表中增加一项ConstantValue属性），那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p><h2 id="解析">3.4 解析</h2><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>。</p><p>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><p>而符号引用只是能无歧义定位到目标的一套自定符号表述。</p><p>解析阶段发生的具体时间并未强制规定，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>对同一个符号引用可以进行多次解析请求，虚拟机也可以缓存解析的结果，但对于<code>invokedynamic</code>指令不能缓存，执行到该条指令时才能解析，它对应的引用称为“动态调用点限定符”。</p><blockquote><p>invokedynamic本是为了支持如JRuby、 Scala等动态语言，JDK8后Lambda表达式和接口的默认方法的底层也会用到invokedynamic。</p></blockquote><h3 id="类或接口的解析">3.4.1 类或接口的解析</h3><p>将符号代表的类的全限定名交给当前类的类加载器来加载，如果是数组类型，则是加载它的数组元素类型，再由虚拟机生成对应的数组类型。</p><p>之后，验证当前类是否具有对该类的访问权限，若没有抛出异常<code>java.lang.IllegalAccessError</code></p><h3 id="字段解析">3.4.2 字段解析</h3><p>要解析一个未被解析过的字段符号引用，会先找到字段表中对应的所属类并解析。</p><ol><li>如果该类本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果该类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则。如果该类不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p><p>如果一个字段具有多义性（如果不严格按照顺序可能多种方式都能找到），javac可能会拒绝编译。</p><h3 id="方法解析">3.4.3 方法解析</h3><p>方法解析也会先找到方法表中对应的所属类并解析。</p><ol><li>类的方法和接口的方法符号引用的常量类型定义是分开的，如果发现该类是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError 异常。</li><li>如果通过了第一步，在该类中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该类的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该类实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明该类是一个抽象类，这时候查找结束，抛出 <code>java.lang.AbstractMethodError</code>异常。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p><h3 id="接口方法解析">3.4.4 接口方法解析</h3><p>接口方法解析也会先找到方法表中对应的所属类并解析。</p><ol><li>与类的方法解析相反，如果发现该类是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>否则，在该接口中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该接口的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>如果多重继承多个父接口都有该方法，可能会返回其中一个方法的直接引用，在编译期间javac也可能拒绝编译。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><p>JDK9模块化之后也可能抛出<code>java.lang.IllegalAccessError</code>异常。</p><h2 id="初始化">3.5 初始化</h2><p>初始化阶段就是<strong>执行类构造器&lt;clinit&gt;()方法的过程。</strong>&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p><p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，顺序为出现的顺序。</p><p>Java虚拟机会保证在子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在Java虚拟机中第一个被执行的&lt;clinit&gt;()方法的类型肯定是java.lang.Object。</p><p>这个方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</p><p>在多线程环境下，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第七章 虚拟机类加载机制&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode779-第K个语法符号</title>
    <link href="https://www.codetool.top/article/leetcode779-%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <id>https://www.codetool.top/article/leetcode779-第K个语法符号/</id>
    <published>2020-01-21T18:06:24.000Z</published>
    <updated>2020-01-21T18:11:32.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><p>给定行数 <code>N</code> 和序数 <code>K</code>，返回第 <code>N</code> 行中第 <code>K</code>个字符。（<code>K</code>从1开始）</p><p><strong>例子：</strong></p><blockquote><p><strong>输入:</strong> N = 1, K = 1<br><strong>输出:</strong> 0  </p><p><strong>输入:</strong> N = 2, K = 1<br><strong>输出:</strong> 0</p><p><strong>输入:</strong> N = 2, K = 2<br><strong>输出:</strong> 1  </p><p><strong>输入:</strong> N = 4, K = 5<br><strong>输出:</strong> 1   </p><p><strong>解释:</strong><br>第一行: 0<br>第二行: 01<br>第三行: 0110<br>第四行: 01101001  </p></blockquote><p><strong>注意:</strong></p><ol><li><code>N</code> 的范围 <code>[1, 30]</code>.</li><li><code>K</code> 的范围 <code>[1, 2^(N-1)]</code>.</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归分析要查找的字符是上一行的哪个数字得到的，然后根据奇偶性得到目标字符</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthGrammar</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>K<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">kthGrammar</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">kthGrammar</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;在第一行我们写上一个 &lt;code&gt;0&lt;/code&gt;。接下来的每一行，将前一行中的&lt;code&gt;0&lt;/code&gt;替换为&lt;code&gt;01&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;替换为&lt;code&gt;10&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode70-爬楼梯</title>
    <link href="https://www.codetool.top/article/leetcode70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>https://www.codetool.top/article/leetcode70-爬楼梯/</id>
    <published>2020-01-21T05:58:10.000Z</published>
    <updated>2020-01-21T06:11:07.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong> 给定 n 是一个正整数。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 2<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有两种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶<br>2.  2 阶  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有三种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶 + 1 阶<br>2.  1 阶 + 2 阶<br>3.  2 阶 + 1 阶</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>实际上是斐波那契数问题：</p><p>假设现在要走三阶楼梯，那么第一次走一阶楼梯时，还有f(2)种可能性，第一次走两阶楼梯时，还有f(1)种可能性，则f(3)=f(2)+f(1)，以此类推。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode509-斐波那契数</title>
    <link href="https://www.codetool.top/article/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode509-斐波那契数/</id>
    <published>2020-01-20T18:39:37.000Z</published>
    <updated>2020-01-21T06:11:11.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p></blockquote><p>给定 <code>N</code>，计算 <code>F(N)</code>。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 2<br><strong>输出：</strong> 1<br><strong>解释：</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 4<br><strong>输出：</strong> 3<br><strong>解释：</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.</p></blockquote><p><strong>提示：</strong></p><ul><li><code>0 ≤ N ≤ 30</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，由于很多递归单元会被重复计算，需要做缓存。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为&lt;strong&gt;斐波那契数列&lt;/strong&gt;。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记07</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B007/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记07/</id>
    <published>2020-01-20T17:41:55.000Z</published>
    <updated>2020-01-23T10:17:17.175Z</updated>
    
    <content type="html"><![CDATA[<p>附：</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">Java虚拟机规范-Java虚拟机指令集：JDK8</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-6.html" target="_blank" rel="noopener">Java虚拟机规范-Java虚拟机指令集：JDK13</a></p><p>续<a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a></p><h1 id="字节码指令简介">1 字节码指令简介</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为<strong>操作数</strong>，Operand）构成。</p><h2 id="字节码数据类型">1.1 字节码数据类型</h2><p>字节码指令集中存在大量与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。</p><p>因为操作码一字节的限制，并非每种数据类型和每一种操作都有对应的指令，有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><p>下表列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作：</p><table><thead><tr><th>opcode</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th><th>char</th><th>reference</th></tr></thead><tbody><tr><td>Tipush</td><td>bipush</td><td>sipush</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Tconst</td><td></td><td></td><td>iconst</td><td>lconst</td><td>fconst</td><td>dconst</td><td></td><td>aconst</td></tr><tr><td>Tload</td><td></td><td></td><td>iload</td><td>lload</td><td>fload</td><td>dload</td><td></td><td>aload</td></tr><tr><td>Tstore</td><td></td><td></td><td>istore</td><td>lstore</td><td>fstore</td><td>dstore</td><td></td><td>astore</td></tr><tr><td>Taload</td><td>baload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>caload</td><td>aaload</td></tr><tr><td>Tastore</td><td>bastore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>castore</td><td>aastore</td></tr><tr><td>Tadd</td><td></td><td></td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td><td></td><td></td></tr><tr><td>Tsub</td><td></td><td></td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td><td></td><td></td></tr><tr><td>Tmul</td><td></td><td></td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td><td></td><td></td></tr><tr><td>Tdiv</td><td></td><td></td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td><td></td><td></td></tr><tr><td>Tneg</td><td></td><td></td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td><td></td><td></td></tr><tr><td>Tshl</td><td></td><td></td><td>ishl</td><td>lshl</td><td></td><td></td><td></td><td></td></tr><tr><td>Tshr</td><td></td><td></td><td>ishr</td><td>lshr</td><td></td><td></td><td></td><td></td></tr><tr><td>Tushr</td><td></td><td></td><td>iushr</td><td>lushr</td><td></td><td></td><td></td><td></td></tr><tr><td>Tand</td><td></td><td></td><td>iand</td><td>land</td><td></td><td></td><td></td><td></td></tr><tr><td>Tor</td><td></td><td></td><td>ior</td><td>lor</td><td></td><td></td><td></td><td></td></tr><tr><td>Txor</td><td></td><td></td><td>ixor</td><td>lxor</td><td></td><td></td><td></td><td></td></tr><tr><td>i2T</td><td>i2b</td><td>i2s</td><td></td><td>i2l</td><td>i2f</td><td>i2d</td><td></td><td></td></tr><tr><td>12T</td><td></td><td></td><td>12i</td><td></td><td>12f</td><td>12d</td><td></td><td></td></tr><tr><td>f2T</td><td></td><td></td><td>f2i</td><td>f2l</td><td></td><td>f2d</td><td></td><td></td></tr><tr><td>d2T</td><td></td><td></td><td>d2i</td><td>d2l</td><td>d2f</td><td></td><td></td><td></td></tr><tr><td>Tcmp</td><td></td><td></td><td></td><td>lcmp</td><td></td><td></td><td></td><td></td></tr><tr><td>Tcmpl</td><td></td><td></td><td></td><td></td><td>fcmpl</td><td>dcmpl</td><td></td><td></td></tr><tr><td>Tcmpg</td><td></td><td></td><td></td><td></td><td>fcmpg</td><td>dcmpg</td><td></td><td></td></tr><tr><td>if_TempOP</td><td></td><td></td><td>if_icmpOP</td><td></td><td></td><td></td><td></td><td>if_acmpOP</td></tr><tr><td>Treturn</td><td></td><td>ireturn</td><td>lreturn</td><td>fretun</td><td>dretun</td><td></td><td></td><td>areturn</td></tr></tbody></table><p><strong>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。</strong>编译器会在编译期或运行期将<strong>byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型</strong>数据，将<strong>boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型</strong>数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p><h2 id="加载和存储指令">1.2 加载和存储指令</h2><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：</p><ul><li>将一个<strong>局部变量加载到操作数栈</strong>：iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、 dload_&lt;n&gt;、aload、aload_&lt;n&gt;</li><li>将一个数值从<strong>操作数栈存储到局部变量表</strong>：istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、 fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</li><li>将一个<strong>常量加载到操作数栈</strong>：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</li><li>扩充局部变量表的访问索引的指令：wide</li></ul><p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p><p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。除了这点不同以外，它们的语义与原生的通用指令是完全一致的（<strong>例如iload_0的语义与操作数为0时的iload指令语义完全一致</strong>）。</n></n></p><h2 id="运算指令">1.3 运算指令</h2><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p><p>大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><p>非精确的结果必须舍入为可被表示的最接近的精确值；如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的，称为向最接近数舍入模式。而在把浮点数转换为整数时，使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</p><p>在对long类型数值进行比较时，Java虚拟机采用带符号的比较方式，而对浮点数值进行比较时<br>（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（Nonsignaling Comparison）方式进行。</p><p>iinc直接在局部变量槽slot上运算。</p><h2 id="类型转换指令">1.4 类型转换指令</h2><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening<br>Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p><ul><li>int类型到long、float或者double类型</li><li>long类型到float、double类型</li><li>float类型到double类型</li></ul><p>与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f</code>。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p><h2 id="对象创建与访问指令">1.5 对象创建与访问指令</h2><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><h2 id="操作数栈管理指令">1.6 操作数栈管理指令</h2><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、 dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul><h2 id="控制转移指令">1.7 控制转移指令</h2><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：<br>·条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne<br>·复合条件分支：tableswitch、lookupswitch<br>·无条件分支：goto、goto_w、jsr、jsr_w、ret</p><h2 id="方法调用和返回指令">1.8 方法调用和返回指令</h2><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</p><h2 id="异常处理指令">1.9 异常处理指令</h2><p>在Java程序中<strong>显式抛出异常的操作（throw语句）都由athrow指令来实现</strong>，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p><p>而在Java虚拟机中，<strong>处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。</strong></p><h2 id="同步指令">1.10 同步指令</h2><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，<strong>如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。</strong>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;附：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java虚拟机规范-Java虚拟机指令集：JD
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode24-两两交换链表中的节点</title>
    <link href="https://www.codetool.top/article/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.codetool.top/article/leetcode24-两两交换链表中的节点/</id>
    <published>2020-01-20T12:55:44.000Z</published>
    <updated>2020-01-20T13:00:14.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，自底向上</p><p>终止点：</p><ol><li>head为null，返回null</li><li>head的next为null，代表此时是倒数第一个元素（链表节点是奇数个），直接返回head</li></ol><p>否则，直接交换当前节点和下一个节点，下一个节点的next使用<code>swapPairs()</code>计算</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你不能只是单纯的改变节点内部的值&lt;/strong&gt;，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode559-N叉树的最大深度</title>
    <link href="https://www.codetool.top/article/leetcode559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://www.codetool.top/article/leetcode559-N叉树的最大深度/</id>
    <published>2020-01-20T12:39:39.000Z</published>
    <updated>2020-01-20T12:42:58.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>我们应返回其最大深度，3。</p><p><strong>说明:</strong></p><ol><li>树的深度不会超过 <code>1000</code>。</li><li>树的节点总不会超过 <code>5000</code>。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>自底向上，每个节点是所有孩子节点的深度的最大值+1</li><li>自顶向下，依次更新最大高度</li></ol><h2 id="代码">2.2 代码</h2><p>自底向上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> depth<span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>level<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> level<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自顶向下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> depth<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> cur<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">></span>depth<span class="token punctuation">)</span> depth <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span>            <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，找到其最大深度。&lt;/p&gt;
&lt;p&gt;最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode429-N叉树的层序遍历</title>
    <link href="https://www.codetool.top/article/leetcode429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode429-N叉树的层序遍历/</id>
    <published>2020-01-19T18:36:06.000Z</published>
    <updated>2020-01-19T18:43:26.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其层序遍历:</p><pre><code>[     [1],     [3,2,4],     [5,6]]</code></pre><p><strong>说明:</strong> </p><ol><li>树的深度不会超过 1000。</li><li>树的节点总数不会超过 5000。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似<a href="../leetcode102-二叉树的层次遍历/">leetcode102-二叉树的层次遍历</a>，通过DFS或BFS实现。</p><h2 id="代码">2.2 代码</h2><p>迭代（BFS）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以null作为每层结束的标志符</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Node node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Node child<span class="token operator">:</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//若队首为null说明这一层的节点的子节点已经全部加入队列了，需要加入一个null</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>递归（DFS）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span>            <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> level<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>level<span class="token punctuation">)</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;层序遍历&lt;/em&gt;。 (即从左到右，逐层遍历)。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetoo
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode590-N叉树的后序遍历</title>
    <link href="https://www.codetool.top/article/leetcode590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode590-N叉树的后序遍历/</id>
    <published>2020-01-19T18:23:52.000Z</published>
    <updated>2020-01-19T18:25:30.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其前序遍历: <code>[5,6,3,2,4,1]</code>.</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似二叉树的后序遍历，递归回溯时将根节点加入集合中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;后序遍历&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1579
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode589-N叉树的前序遍历</title>
    <link href="https://www.codetool.top/article/leetcode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode589-N叉树的前序遍历/</id>
    <published>2020-01-18T18:52:50.000Z</published>
    <updated>2020-01-18T18:59:06.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似二叉树的前序遍历，递归将根节点加入集合中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;前序遍历&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1579
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
