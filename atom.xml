<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-05-03T15:38:47.526Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Feign调用会将对象嵌套的Map转为LinkedHashMap的问题</title>
    <link href="https://www.codetool.top/article/%E5%85%B3%E4%BA%8EFeign%E8%B0%83%E7%94%A8%E4%BC%9A%E5%B0%86Object%E8%BD%AC%E4%B8%BALinkedHashMap%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/关于Feign调用会将Object转为LinkedHashMap的问题/</id>
    <published>2020-05-03T14:14:02.000Z</published>
    <updated>2020-05-03T15:38:47.526Z</updated>
    
    <content type="html"><![CDATA[<p>又踩到Feign坑了←_←（冷笑话）</p><h1 id="问题复现">1 问题复现</h1><p>方法提供者，返回一个<code>Result</code>对象，并将一个<code>MemberVo</code>对象封装到了Result对象中的一个哈希表中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据用户id获取登录信息"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/member/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Result <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String id<span class="token punctuation">)</span><span class="token punctuation">{</span>    MemberVo loginInfoVo <span class="token operator">=</span> memberService<span class="token punctuation">.</span><span class="token function">getLoginInfo</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Result<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> loginInfoVo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Result的结构：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否成功</span>    <span class="token keyword">private</span> Integer code<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回码</span>    <span class="token keyword">private</span> String message<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回消息</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回数据</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p>Feign客户端：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"service-ucenter"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> MemberFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MemberFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/ucenter/member/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Feign调用该方法，想从Result对象的哈希表中取出<code>MemberVo</code>对象：</p><pre class=" language-java"><code class="language-java">Result userInfo <span class="token operator">=</span> memberFeign<span class="token punctuation">.</span><span class="token function">getUserInfo</span><span class="token punctuation">(</span>memberId<span class="token punctuation">)</span><span class="token punctuation">;</span>MemberVo memberVo <span class="token operator">=</span> <span class="token punctuation">(</span>MemberVo<span class="token punctuation">)</span> userInfo<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>就这两句话，看起来合情合理，我一开始也觉得应该没问题，结果报错：</p><pre><code>java.util.LinkedHashMap cannot be cast to com.guli.ucenter.entity.vo.MemberVo</code></pre><h1 id="问题分析">2 问题分析</h1><p><img src="https://api.codetool.top/img/15885189465959.png" alt></p><p>调试发现，Feign调用后取到的Result对象的data已经不是一个HashMap了，而是一个<code>LinkedHashMap</code>，里面存放的item对应的value，也变成了一个<code>LinkedHashMap</code>，保留了原来<code>MemberVo</code>对象的属性，但并不是一个<code>MemberVo</code>对象。</p><p>原因其实不难想到，毕竟Feign调用的实质还是HTTP请求，中间还是经过了Json与对象的互转，转换过程中要进行对象关系映射，只能根据给它的类获取结构，而Result中data声明为一个Map接口，转换为LinkedHashMap也说得通，至于原来哈希表中的对象，根据Result类结构完全无法获知里面的哈希表中的数据到底是什么类型，当然也无法将它转换回原来的类对象。</p><p>可以猜测Feign会将Map接口（体现为json的object）和map中的对象（也体现为json中的object）都会转换为LinkedHashMap实例，至于为什么是LinkedHashMap而不是HashMap可能是为了维持键值对之间的顺序。</p><h1 id="解决方案">3 解决方案</h1><p>关于解决方案，我想到的是，要么把LinkedHashMap当原来的类对象使用，毕竟也可以获取所有的属性和值；要么就专门为Feign调用设计一个方法，不要返回嵌套Map的Result对象；要么就将LinkedHashMap转为原来的类对象。</p><p>最后我选择了专门为Feign调用设计一个方法😀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又踩到Feign坑了←_←（冷笑话）&lt;/p&gt;
&lt;h1 id=&quot;问题复现&quot;&gt;1 问题复现&lt;/h1&gt;&lt;p&gt;方法提供者，返回一个&lt;code&gt;Result&lt;/code&gt;对象，并将一个&lt;code&gt;MemberVo&lt;/code&gt;对象封装到了Result对象中的一个哈希表中：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="OpenFeign" scheme="https://www.codetool.top/tags/OpenFeign/"/>
    
  </entry>
  
  <entry>
    <title>leetcode17-电话号码的字母组合</title>
    <link href="https://www.codetool.top/article/leetcode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://www.codetool.top/article/leetcode17-电话号码的字母组合/</id>
    <published>2020-05-03T05:31:19.000Z</published>
    <updated>2020-05-03T05:34:45.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://api.codetool.top/img/1588483945107.png" alt></p><p><strong>示例:</strong></p><blockquote><p><strong>输入：</strong> “23”<br><strong>输出：</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>dfs就嗯搜 →_→</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>String digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        chars <span class="token operator">=</span> digits<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Character<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Character<span class="token operator">></span> list<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Character c<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span><span class="token function">numToChars</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>Character<span class="token operator">></span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>            copy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">numToChars</span><span class="token punctuation">(</span><span class="token keyword">char</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">'2'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'3'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'4'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'5'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'j'</span><span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'6'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'m'</span><span class="token punctuation">,</span><span class="token string">'n'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'7'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'8'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'t'</span><span class="token punctuation">,</span><span class="token string">'u'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'9'</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">'w'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode40-组合总和II</title>
    <link href="https://www.codetool.top/article/leetcode40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>https://www.codetool.top/article/leetcode40-组合总和II/</id>
    <published>2020-05-02T05:15:56.000Z</published>
    <updated>2020-05-02T05:41:37.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,<strong>所求解集为:</strong>[  [1, 7],  [1, 2, 5],  [2, 6],  [1, 1, 6]]</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,<strong>所求解集为:</strong>[&nbsp; [1,2,2],&nbsp; [5]]</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode39-组合总和">leetcode39-组合总和</a>的区别是，数组中的每个数字只能使用一次，并且数组中可能存在相同的数字。</p><p>该题要求反映到搜索树中，就是<strong>不允许同层出现相同的数字，而允许上下层之间存在相同的数字。</strong> </p><p>我们使用上道题的代码进行改造，如下所示：</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>candidates <span class="token operator">=</span> candidates<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>target<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">,</span><span class="token keyword">int</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> minIndex<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>candidates<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果当前元素等于上一元素，则跳过（不允许同层出现相同的数字）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>minIndex <span class="token operator">&amp;&amp;</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> candidates<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> copyList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                copyList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>copyList<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//允许搜索的最小的下标加一（允许上下层之间存在相同的数字）</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>copyList<span class="token punctuation">,</span>target<span class="token operator">-</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数字和为 &lt;code&gt;target&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习06-文件管理</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A006-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://www.codetool.top/article/操作系统复习06-文件管理/</id>
    <published>2020-05-01T16:57:34.000Z</published>
    <updated>2020-05-02T19:11:02.520Z</updated>
    
    <content type="html"><![CDATA[<p>文件就是一组有意义的信息/数据集合</p><h1 id="文件系统概述">1 文件系统概述</h1><p><img src="https://api.codetool.top/img/1588414733878.png" alt></p><p>文件系统是操作系统中负责存取和管理信息的模块，它<strong>用统一的方式管理用户和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法。</strong></p><p>文件系统面向用户的功能：</p><ul><li>文件按名存取</li><li>文件目录建立和维护</li><li>实现逻辑文件到物理文件的转换</li><li>文件存储空间的分配和管理</li><li>提供合适的文件存取方法</li><li>实现文件的共享、保护和保密</li><li>提供一组可供用户使用的文件操作</li></ul><p>文件系统优点：</p><ul><li>用户使用方便 </li><li>文件安全可靠 </li><li>实现文件共享</li></ul><p>文件系统的分层结构：</p><ul><li>文件管理层：实现文件的逻辑结构，为用户提供各种文件系统调用，及文件访问权限的设置等工作；</li><li>目录管理层：负责查找文件描述符，进而找到需要访问的文件，及进行访问权限检查等工作；此外，还需完成目录的添加、删除、重排等操作。</li><li>磁盘管理层：将文件的逻辑地址转换成磁盘的物理地址，即由逻辑块号找到柱面号、磁道号和扇区号，具体的数据传输操作由设备管理实现。</li></ul><p>操作系统向上提供的几个最基本的功能：</p><ul><li>创建文件(create系统调用)</li><li>删除文件(delete系统调用)</li><li>读文件(read系统调用)</li><li>写文件(write系统调用)</li><li>打开文件(open系统调用)</li><li>关闭文件(close系统调用)</li></ul><h1 id="文件">2 文件</h1><p><img src="https://api.codetool.top/img/15884147865374.png" alt></p><h2 id="文件概念和命名">2.1 文件概念和命名</h2><p>文件是由文件名字标识的<strong>一组信息的集合。</strong> 文件是一个抽象机制，提供了把文件保存在磁盘上，用户不必了解信息存储细节且便于读取的方法，这一抽象机制中最重要的是<strong>文件命名。</strong></p><h2 id="文件类型和属性">2.2 文件类型和属性</h2><p>一个文件有哪些属性?</p><ul><li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</li><li>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性,因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li>类型：指明文件的类型</li><li>位置：文件存放的路径(让用户使用)、在外存中的地址(操作系统使用，对用户不可见)</li><li>大小：指明文件大小</li><li>创建时间、上次修改时间</li><li>文件所有者信息</li><li>保护信息：对文件进行保护的访问控制信息</li></ul><p>文件保护属性用于防止文件被破坏，称为文件保护。包括两个方面：</p><ol><li>防止系统崩溃所造成的文件破坏；防止方法：<ul><li>定时转储 </li><li>多副本 </li></ul></li><li>防止文件主和其他用户有意或无意的非法操作所造成的文件不安全性。防止方法：<ul><li>访问控制——防止文件主和其他用户有意或无意的非法操作所造成的文件不安全性，基本思想是建立三元组：<code>(用户、对象、存取权限)</code>。Linux把用户分为文件主、同组用户、其他用户三类，定义存取权限<code>可读r、可写w、可执行x</code>，文件属性共有10位：<code>-rwxrwxrwx</code></li></ul></li></ol><p>类型：</p><p>操作系统支持不同类型文件：</p><ul><li>普通文件</li><li>目录文件</li><li>特别文件：块设备文件、字符设备文件、管道文件。 </li></ul><h1 id="文件目录">3 文件目录</h1><p><img src="https://api.codetool.top/img/15884344103252.png" alt></p><h2 id="文件控制块和文件目录">3.1 文件控制块和文件目录</h2><p>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。<strong>目录文件中的一条记录就是一个“文件控制块(FCB)”</strong>（或者说FCB的有序集合称为“文件目录”）。FCB实现了文件名和文件之间的映射。使用户(用户程序)可以实现“按名存取”。<strong>FCB中包含了文件的基本信息(文件名、物理地址、逻辑结构、物理结构等)，存取控制信息(是否可读/可写、禁止访问的用户名单等)，使用信息(如文件的建立时间、修改时间等)。最重要、最基本的还是文件名、文件存放的物理地址。</strong></p><h2 id="Linux中的inode">3.2 Linux中的inode</h2><p>Linux系统的FCB中的文件名和其他管理信息分开，其他信息单独组成一个数据结构，称为索引节点inode。<strong>目录项中只保留文件名（最长256个字节）和inode号（4个字节）。</strong></p><p>索引节点：为了减小目录表大小，将FCB中除了文件名之外的描述信息都都放索引节点中。<strong>由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I/O的次数就少了很多。</strong> <strong>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</strong>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h1 id="文件组织与数据存储">4 文件组织与数据存储</h1><p><img src="https://api.codetool.top/img/15884344294573.png" alt></p><p>卷是存储介质的物理单位（例如Windows系统上的C盘、D盘、E盘，通常是把一个磁盘分成多个卷，有的技术也可以将多个磁盘合为一个卷使用），<strong>磁盘上的最小存储单位称为扇区。（体现在磁盘上就是盘面上的扇形区域）</strong></p><p><strong>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块、页面的大小相同（通常为4KB）,每块一般包含2的整数次幂个地址。</strong> 同样类似的是，文件的逻辑地址也可以分为<code>(逻辑块号，块内地址)</code>，操作系统同样需要将逻辑地址转换为外存的物理地址(物理块号，块内地址)的形式。块内地址的位数取决于磁盘块的大小。</p><p><strong>扇区和磁盘块的区别：扇区是物理设备的概念，磁盘块是文  件系统中的概念。</strong></p><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位。</p><p><strong>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</strong></p><h2 id="文件的逻辑结构">4.1 文件的逻辑结构</h2><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种：</p><ul><li>无结构文件(如文本文件)——<strong>由一些二进制或字符流组成</strong>，又称 <strong>“流式文件”</strong></li><li>有结构文件(如数据库表)——<strong>由一组相似的记录组成</strong>，又称 <strong>“记录式文件”</strong>每条记录又若干个数据项组成。<strong>一般来说，每条记录有一个数据项可作为关键字(作为识别不同记录的ID)。</strong> 根据各条记录的长度(占用的存储空间)是否相等，又可分为定长记录和可变长记录两种。</li></ul><h2 id="文件的物理结构">4.2 文件的物理结构</h2><h3 id="操作系统对非空闲磁盘块的管理">4.2.1 操作系统对非空闲磁盘块的管理</h3><p>文件分配方式：</p><ul><li><strong>连续分配</strong>方式要求每个文件在磁盘上占有一组连续的块。这种方式只需转换块号就行，块内地址保持不变。用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项(FCB)，<code>物理块号=起始块号+逻辑块号</code>当然，还需要检查用户提供的逻辑块号是否合法(逻辑块号≥长度就不合法)。<ul><li>优点：连续分配的文件在顺序读/写时速度最快</li><li>缺点：物理上采用连续分配的文件不方便拓展。存储空间利用率低，会产生难以利用的磁盘碎片。</li></ul></li><li><strong>链接分配</strong>采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。<ul><li>隐式链接：文件目录中记录了文件存放的起始块号和结束块号。当然，也可以增加一个字段来表示文件的长度。<strong>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的。</strong><ul><li>优点：采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。</li><li>缺点：采用链式分配(隐式链接)方式的文件，只支持顺序访问，不支持随机访问，IO访问较频繁，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul></li><li>显式链接：文件目录中只需记录文件的起始块号，把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT，File Allocation Table)。<strong>一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。</strong><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问（给定一个逻辑块号，可直接转换为物理块号）。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间。</li></ul></li></ul></li><li><strong>索引分配</strong>允许文件离散地分配在各个磁盘块中，<strong>系统会为每个文件建立一张索引表， 索引表中记录了文件的各个逻辑块对应的物理块</strong>(索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系)。<strong>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</strong> 索引表中的表项是连续存储的，因此，索引表中的逻辑块号可以是隐含的。若每个磁盘块1KB，一个索引表项4B（块号大小），则一个磁盘块只能存放256个索引项，如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的。为了解决这个问题，可以使用三种方式：<ul><li>链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。但链接结构不能随机访问，效率很低。</li><li>多层索引：建立多层索引(原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</li><li>混合索引：<strong>（Linux采用的多级索引的结构）</strong>多种索引分配方式的结合。例如，<strong>一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块)，又包含一级间接索引(指向单层索引表)、还包含两级间接索引(指向两层索引表)。</strong></li></ul></li></ul><h3 id="构造文件物理结构的方法">4.2.2 构造文件物理结构的方法</h3><ul><li>顺序文件：文件中的记录一个接一个地顺序排列(逻辑上)，记录可以是定长的或可变长的。各个记录在物理上可以<strong>顺序存储</strong>或<strong>链式存储</strong>。（物理上可以连续存放也可以离散存放）<ul><li>链式存储（使用链式存储的顺序文件又称为连接文件）：无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找。</li><li>顺序存储：<ul><li>可变长记录：无法实现随机存取。每次只能从第一个记录开始依次往后查找。</li><li>定长记录：<ul><li>可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L</li><li>若采用串结构（记录的物理顺序和关键字顺序没有关系），无法快速找到某关键字对应的记录</li><li>若采用顺序结构，可以快速找到某关键字对应的记录(如折半查找)</li></ul></li></ul></li></ul></li><li>索引文件：建立一张索引表以加快文件检索速度。每条记录对应一个索引项。文件中的这些记录在物理上可以离散地存放。<strong>索引表本身是定长记录的顺序文件</strong>。因此可以快速找到第i个记录对应的索引项。可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。另外，可以用不同的数据项建立多个索引表。如：学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。<ul><li><strong>索引文件可以利用分组、多级索引的方式来减小索引的大小。</strong></li></ul></li></ul><h1 id="文件系统功能及实现">5 文件系统功能及实现</h1><p><img src="https://api.codetool.top/img/15884448293617.png" alt></p><h2 id="文件共享">5.1 文件共享</h2><p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。</p><p><strong>基于索引结点的共享方式(硬链接)</strong>：索引结点中设置一个链接计数变量count,用于表示链接到本索引结点上的用户目录项数。</p><ul><li>若count= 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。</li><li>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li><li>当count=0时系统负责删除文件。</li></ul><p><strong>基于符号链的共享方式(软链接)</strong>：是一种特殊类型的文件（Link类型），记录了指向文件的存放路径，类似于Windows操作系统的“快捷方式”。当原文件删除，链接文件仍可以存在，但使用link文件已经找不到原文件了。</p><p>在linux中创建硬链接：<code>ln source target</code>，创建软链接：<code>ln -s source target</code>。</p><h2 id="文件空间管理">5.2 文件空间管理</h2><p>管理磁盘中的空闲块的方式：</p><ul><li>位示图：每个二进制位对应一个盘块。例如，“0” 代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如一个字的字长是16位，字中的每一位对应一个盘块。因此可以用<code>(字号，位号)</code>对应一个盘块号。</li><li>空闲区表：<strong>使用一张空闲表，每条记录中含有第一个空闲盘块号和空闲盘块数两个信息（即起始位置和大小）。</strong> 它的分配方式与内存管理中的动态分区分配很类似，为一 一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</li><li>空闲块链：以盘块为单位组成一条空闲链。<strong>若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</strong></li><li>空闲块列表</li><li>成组空闲块链：假设将存储空间分成512字节一块，每100块划分一组。<strong>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。超级块和每组第一块登记下一组空闲块的盘物理块号和所有空闲块号。</strong> </li></ul><p>空闲区表法、空闲块链法不适用于大型文件系统，因为空闲表或空闲链表可能过大。<strong>UNIX系统中采用了成组空闲块链法对磁盘空闲块进行管理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件就是一组有意义的信息/数据集合&lt;/p&gt;
&lt;h1 id=&quot;文件系统概述&quot;&gt;1 文件系统概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1588414733878.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;文件系统是操作系统中负责存
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JWT结构及io.jsonwebtoken.jjwt工具使用</title>
    <link href="https://www.codetool.top/article/JWT%E7%BB%93%E6%9E%84%E5%8F%8Aio-jsonwebtoken-jjwt%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.codetool.top/article/JWT结构及io-jsonwebtoken-jjwt工具使用/</id>
    <published>2020-05-01T14:54:39.000Z</published>
    <updated>2020-05-01T15:56:22.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JsonWebToken介绍">1 JsonWebToken介绍</h1><p>JsonWebToken（简称JWT）是实现token技术的一种解决方案，它包含三部分，分别是： <strong>头部（header ），载荷（payload ），签名 （signature）</strong>。</p><p>他们按照 <code>A.B.C</code> 的格式拼接起来，其中C由A和B生成，他们之间的格式为 <code>Base64(header).Base64(payload).H256(A.B)</code>（也可以使用不同的签名算法，默认情况下是HS256）。需要注意的是<strong>header和payload都是使用<code>Base64URL</code>算法对象序列化之后的字符串</strong>. </p><p>名词解释：</p><p><strong>HS256：</strong> HMACSHA256，一种消息摘要算法<br><strong>Base64URL：</strong>  Base64中用的三个字符是<code>&quot;+&quot;</code>，<code>&quot;/&quot;</code>和<code>&quot;=&quot;</code>，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：<code>&quot;=&quot;</code>去掉，<code>&quot;+&quot;</code>用<code>&quot;-&quot;</code>替换，<code>&quot;/&quot;</code>用<code>&quot;_&quot;</code>替换，这就是Base64URL算法。</p><h1 id="结构">2 结构</h1><h2 id="头部-header">2.1 头部(header)</h2><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，一般很少改动直接使用默认的即可            </p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span><span class="token punctuation">,</span>    <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">}</span></code></pre><p><code>alg</code>属性表示<strong>签名的算法</strong>（algorithm）；<code>typ</code>属性表示这个<strong>令牌（token）的类型（type）</strong>，JWT 令牌统一写为<code>JWT</code>。</p><h2 id="载荷-playload">2.2 载荷(playload)</h2><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。</p><p><strong>可自行指定字段，很灵活</strong>，也有固定字段表示特定含义（但不一定要包含特定字段，只是推荐）。下面是官方推荐的字段：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"iss"</span><span class="token operator">:</span> <span class="token string">"签发者"</span><span class="token punctuation">,</span>    <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"当前令牌的描述说明"</span><span class="token punctuation">,</span>    <span class="token property">"aud"</span><span class="token operator">:</span> <span class="token string">"接收方"</span><span class="token punctuation">,</span>    <span class="token property">"exp"</span><span class="token operator">:</span> <span class="token string">"过期时间"</span><span class="token punctuation">,</span>    <span class="token property">"iat"</span><span class="token operator">:</span> <span class="token string">"创建时间"</span><span class="token punctuation">,</span>    <span class="token property">"nbf"</span><span class="token operator">:</span> <span class="token string">"在什么时间之前，该Token不可用"</span><span class="token punctuation">,</span>    <span class="token property">"jti"</span><span class="token operator">:</span> <span class="token string">"Token唯一标识"</span><span class="token punctuation">}</span></code></pre><p>下面就是一个例子：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>    <span class="token property">"admin"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><h2 id="签名-signature">2.3 签名(signature)</h2><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，<strong>需要指定一个密钥（secret）</strong>。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><p><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload) , secret)</code></p><p>密钥在摘要算法中起盐值的作用。</p><p><strong>算出签名以后，将header和payload用Base64URL算法对象序列化，然后把这三部分用“.”拼接起来就是生成的token了。</strong></p><h1 id="io-jsonwebtoken-jjwt工具使用">3 io.jsonwebtoken.jjwt工具使用</h1><p>maven依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.jsonwebtoken<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jjwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>下面是一个示例工具类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> io<span class="token punctuation">.</span>jsonwebtoken<span class="token punctuation">.</span>Claims<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>jsonwebtoken<span class="token punctuation">.</span>Jws<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>jsonwebtoken<span class="token punctuation">.</span>Jwts<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>jsonwebtoken<span class="token punctuation">.</span>SignatureAlgorithm<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletRequest<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JwtUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//过期时间</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> EXPIRE <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//签名密钥</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String SECRET <span class="token operator">=</span> <span class="token string">"ukc8BDbRigUDaY6pZFfWus2jZWLPHO"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**    * 使用用户id和nickname获取一个token字符串    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getJwtToken</span><span class="token punctuation">(</span>String id<span class="token punctuation">,</span> String nickname<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用builder构造一个JwtToken</span>        String JwtToken <span class="token operator">=</span> Jwts<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//头部信息</span>                <span class="token punctuation">.</span><span class="token function">setHeaderParam</span><span class="token punctuation">(</span><span class="token string">"typ"</span><span class="token punctuation">,</span> <span class="token string">"JWT"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setHeaderParam</span><span class="token punctuation">(</span><span class="token string">"alg"</span><span class="token punctuation">,</span> <span class="token string">"HS256"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//载荷中的推荐信息</span>                <span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span><span class="token string">"guli-user"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setIssuedAt</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> EXPIRE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//载荷中的自定义信息</span>                <span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token string">"nickname"</span><span class="token punctuation">,</span> nickname<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//签名</span>                <span class="token punctuation">.</span><span class="token function">signWith</span><span class="token punctuation">(</span>SignatureAlgorithm<span class="token punctuation">.</span>HS256<span class="token punctuation">,</span> SECRET<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//Base64URL前两部分并连接签名，获取token</span>                <span class="token punctuation">.</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> JwtToken<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断传入的token字符串是否存在与有效     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkToken</span><span class="token punctuation">(</span>String jwtToken<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>jwtToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//使用parser解析jwt信息</span>            Jwts<span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>SECRET<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>jwtToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果格式不对，会抛出UnsupportedJwtException异常</span>        <span class="token comment" spellcheck="true">//如果验证签名失败，会抛出SignatureException异常</span>        <span class="token comment" spellcheck="true">//如果token过期，会抛出ExpiredJwtException异常</span>        <span class="token comment" spellcheck="true">//如果字符串为空，会抛出IllegalArgumentException异常</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断HttpServletRequest中头部携带的token是否存在与有效     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkToken</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String jwtToken <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>jwtToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            Jwts<span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>SECRET<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>jwtToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据token获取用户id     * @param request     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getMemberIdByJwtToken</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String jwtToken <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>jwtToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        Jws<span class="token operator">&lt;</span>Claims<span class="token operator">></span> claimsJws <span class="token operator">=</span> Jwts<span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>SECRET<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parseClaimsJws</span><span class="token punctuation">(</span>jwtToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//getBody获取用户在载荷中定义的信息</span>        Claims claims <span class="token operator">=</span> claimsJws<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JsonWebToken介绍&quot;&gt;1 JsonWebToken介绍&lt;/h1&gt;&lt;p&gt;JsonWebToken（简称JWT）是实现token技术的一种解决方案，它包含三部分，分别是： &lt;strong&gt;头部（header ），载荷（payload ），签名 （signat
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="安全" scheme="https://www.codetool.top/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode39-组合总和</title>
    <link href="https://www.codetool.top/article/leetcode39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode39-组合总和/</id>
    <published>2020-05-01T05:20:51.000Z</published>
    <updated>2020-05-01T06:01:44.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> candidates = <code>[2,3,6,7], </code>target = <code>7</code>,<strong>所求解集为:</strong>[  [7],  [2,2,3]]</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> candidates = [2,3,5]<code>, </code>target = 8,<strong>所求解集为:</strong>[&nbsp; [2,2,2,2],&nbsp; [2,3,3],&nbsp; [3,5]]</pre><h1 id="解法">2 解法</h1><p>本题解同步发于leetcode题解：<a href="https://leetcode-cn.com/problems/combination-sum/solution/java-dfsrang-ni-zhi-dao-zu-he-zen-yao-qu-zhong-jia/" target="_blank" rel="noopener">Java DFS，让你知道组合怎么去重&amp;剪枝&amp;回溯到底是什么</a></p><h2 id="思想">2.1 思想</h2><p>该题难点在于组合的去重，如果直接不加条件的dfs很容易找到相同的组合，例如示例一可以找出<code>[2,2,3]</code>和<code>[2,3,2]</code>、<code>[3,2,2]</code>，它们实质上是同一个组合。<strong>如果要进行去重，可以考虑给组合添加一个限制条件，例如我们要求，找到的组合中前面的数必须大于等于后面的数。</strong></p><p>那么为了只找到满足条件的组合，可以先将<code>candidates</code>数组从小到大排序，每次dfs选取一个元素之后，我们就不再选取比它大的元素（即后面只在下标小于等于它的元素中查找）。这样就可以做到查找到的组合满足前面的数总是大于等于后面的数。</p><p>这样的dfs查找，如果画出树状图的话，会看到这个搜索树<strong>因为某些部分条件不满足，于是不再向下查找，称为“剪枝”。</strong></p><p><img src="https://api.codetool.top/img/15883122816465.png" alt></p><p><img src="https://api.codetool.top/img/15883122947821.png" alt></p><p>那么其他题解说的“回溯算法”是什么呢，其实<strong>用递归实现的DFS就必然会经过回溯，当条件不满足时，递归函数需要返回到上一层节点，继续查找，称为“回溯”。</strong></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先对candidates从小到大排序</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>candidates <span class="token operator">=</span> candidates<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>target<span class="token punctuation">,</span>candidates<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//maxIndex表示允许在candidates搜索到的最大下标</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">,</span><span class="token keyword">int</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>maxIndex<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> copyList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                copyList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>copyList<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//当选取下标为i的节点后，下一步只允许在下标小于等于i的元素中查找</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>copyList<span class="token punctuation">,</span>target<span class="token operator">-</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;无重复元素&lt;/strong&gt;的数组 &lt;code&gt;candidates&lt;/code&gt; 和一个目标数 &lt;code&gt;target&lt;/code&gt; ，找出 &lt;code&gt;candidates&lt;/code&gt; 中所有可以使数
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Handler dispatch failed; nested exception is java.lang.NoSuchMethodError</title>
    <link href="https://www.codetool.top/article/%E5%B0%8F%E5%BF%83%E6%9B%B4%E6%96%B0%E5%88%B0Idea-2020-01%E3%80%82%E3%80%82%E3%80%82/"/>
    <id>https://www.codetool.top/article/小心更新到Idea-2020-01。。。/</id>
    <published>2020-04-30T13:53:43.000Z</published>
    <updated>2020-04-30T14:17:04.845Z</updated>
    
    <content type="html"><![CDATA[<p>【原文】</p><p>idea前段时间不是出了2020.01嘛。。我很快就装了</p><p>这段时间一直用着lombok，今天运行项目lombok注解都失效了 <strong>（事实证明不是lombok失效了）</strong> ，检查了一下注解也在，依赖也在，插件也在，配置也配置了，可就是没有用。</p><p>不知道是为什么，反正我就是归为Idea新版bug的原因。。</p><p>我现在就一个一个的给那些实体类加getter/setter，太浪费时间了/(ㄒoㄒ)/~~</p><hr><p><strong>事后：可能并不是lombok注解失效，我错怪IDEA了</strong></p><p>我一开始运行项目用到某一个方法报错：</p><pre><code>Handler dispatch failed; nested exception is java.lang.NoSuchMethodError</code></pre><p>然后后面是什么get、set方法没找到，我还以为是<code>@Data</code>失效了，后面我把所有的实体类加了一遍getter/setter发现还是不行😀</p><p>最后百度了一下发现是因为<strong>maven项目重复依赖</strong>：</p><blockquote><p>造成这个错误的原因可能为: A-module的pom依赖了B-module和C-module, 然而B-module的pom也依赖了C-module导致</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【原文】&lt;/p&gt;
&lt;p&gt;idea前段时间不是出了2020.01嘛。。我很快就装了&lt;/p&gt;
&lt;p&gt;这段时间一直用着lombok，今天运行项目lombok注解都失效了 &lt;strong&gt;（事实证明不是lombok失效了）&lt;/strong&gt; ，检查了一下注解也在，依赖也在，插件也在
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode38-外观数列</title>
    <link href="https://www.codetool.top/article/leetcode38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode38-外观数列/</id>
    <published>2020-04-30T05:45:04.000Z</published>
    <updated>2020-04-30T05:50:42.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><pre>1.     12.     113.     214.     12115.     111221</pre><p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  <code>&quot;one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> 1<br><strong>输出:</strong> “1”<br><strong>解释：</strong> 这是一个基本样例。  </p></blockquote><p>示例 2:</p><blockquote><p><strong>输入:</strong> 4<br><strong>输出:</strong> “1211”<br><strong>解释：</strong> 当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，比较简单。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">countAndSay</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        strings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> strings<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>chars<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            strings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> strings<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：&lt;/p&gt;
&lt;pre&gt;1.     1
2.     11
3.     21
4.     1211
5.     111221
&lt;/pre
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OpenFeign使用Hystrix报错：Ambiguous mapping. Cannot map xx method...</title>
    <link href="https://www.codetool.top/article/OpenFeign%E6%8A%A5%E9%94%99%EF%BC%9AAmbiguous-mapping-Cannot-map-xx-method/"/>
    <id>https://www.codetool.top/article/OpenFeign报错：Ambiguous-mapping-Cannot-map-xx-method/</id>
    <published>2020-04-29T14:06:31.000Z</published>
    <updated>2020-04-29T14:17:32.617Z</updated>
    
    <content type="html"><![CDATA[<p>今天做项目的时候，feign调用的时候写了一个Hystrix的服务降级处理类，但是运行时报了以下错误：</p><pre><code>Ambiguous mapping. Cannot map &#39;com.guli.vod.feign.VodFeign&#39; method com.guli.vod.feign.VodFeign#removeVideo(String)to {DELETE /vod/video/{id}}: There is already &#39;vodFallback&#39; bean methodcom.guli.vod.fallback.VodFallback#removeVideo(String) mapped.</code></pre><p>原来写的FeignClient：(这里吐槽一下，Restful api根本没办法设计批量删除的路径嘛，DELETE方法又不推荐使用请求体，而且将资源id放在请求体里也不符合Restful url的语义)</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"service-vod"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> VodFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/vod"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">VodFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/video/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String videoId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/video/delete-batch"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideoList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"videoIdList"</span><span class="token punctuation">)</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> videoIdList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>服务降级处理类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VodFallback</span> <span class="token keyword">implements</span> <span class="token class-name">VodFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideo</span><span class="token punctuation">(</span>String videoId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Result<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token string">"time out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideoList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> videoIdList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Result<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token string">"time out"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>原因在于<code>VodFallback</code>实现了<code>VodFeign</code>接口后，把<code>@RequestMapping</code>的路径映射也继承了过去，而两个类都会注册bean实例对象，就会出现映射冲突的问题，最后我是将FeignClient的<code>@RequestMapping</code>都写在了方法上，成功解决：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"service-vod"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> VodFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">VodFeign</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/vod/video/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> String videoId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/vod/video/delete-batch"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Result <span class="token function">removeVideoList</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"videoIdList"</span><span class="token punctuation">)</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> videoIdList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做项目的时候，feign调用的时候写了一个Hystrix的服务降级处理类，但是运行时报了以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ambiguous mapping. Cannot map &amp;#39;com.guli.vod.feign.VodFeign&amp;#39; me
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="OpenFeign" scheme="https://www.codetool.top/tags/OpenFeign/"/>
    
      <category term="Hystrix" scheme="https://www.codetool.top/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>leetcode74-搜索二维矩阵</title>
    <link href="https://www.codetool.top/article/leetcode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.codetool.top/article/leetcode74-搜索二维矩阵/</id>
    <published>2020-04-29T12:46:39.000Z</published>
    <updated>2020-04-29T12:48:19.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例1:</strong></p><pre><strong>输入:</strong>matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 3<strong>输出:</strong> true</pre><p><strong>示例2:</strong></p><pre><strong>输入:</strong>matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13<strong>输出:</strong> false</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>先进行行的二分搜索，找出在哪一行之后再对列进行二分搜索。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">||</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> width <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span>width<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> row <span class="token operator">=</span> start<span class="token punctuation">;</span>        start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        end <span class="token operator">=</span> width<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1095-山脉数组中查找目标值</title>
    <link href="https://www.codetool.top/article/leetcode1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode1095-山脉数组中查找目标值/</id>
    <published>2020-04-29T06:32:06.000Z</published>
    <updated>2020-04-29T06:51:09.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>（这是一个 <strong>交互式问题</strong> ）</p><p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p><p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p><p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p><p><strong>首先</strong>，<code>A.length &gt;= 3</code></p><p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 i 使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p><ul><li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li><li><code>MountainArray.length()</code> - 会返回该数组的长度</li></ul><p><strong>注意：</strong>  </p><p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> <strong>不是一个正确答案</strong>。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> array = [1,2,3,4,5,3,1], target = 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> array = [0,1,2,4,2,1], target = 3<br><strong>输出：</strong> -1<br><strong>解释：</strong> 3 在数组中没有出现，返回 -1。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li><li><code>0 &lt;= target &lt;= 10^9</code></li><li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>超过 <code>100</code> 次调用的提交将被视为错误答案，数据规模又小于等于一万，很明显是要用<code>logn</code>的时间复杂度求解，因为是有序数组，也很容易想到二分查找。由于这个数组不是完全有序的，可以分成升序和降序的两部分，则可以先找出峰顶值，然后对两部分进行二分查找。</p><h2 id="代码">2.2 代码</h2><p>（作者：liweiwei1419）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findInMountainArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> MountainArray mountainArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> mountainArr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤 1：先找到山顶元素所在的索引</span>        <span class="token keyword">int</span> mountaintop <span class="token operator">=</span> <span class="token function">findMountaintop</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤 2：在前有序且升序数组中找 target 所在的索引</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">findFromSortedArr</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mountaintop<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 步骤 3：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引</span>        <span class="token keyword">return</span> <span class="token function">findFromInversedArr</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> mountaintop <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回山顶元素</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findMountaintop</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 取左中位数，因为进入循环，数组一定至少有 2 个元素</span>            <span class="token comment" spellcheck="true">// 因此，左中位数一定有右边元素，数组下标不会发生越界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果当前的数比右边的数小，它一定不是山顶</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFromSortedArr</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFromInversedArr</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;（这是一个 &lt;strong&gt;交互式问题&lt;/strong&gt; ）&lt;/p&gt;
&lt;p&gt;给你一个 &lt;strong&gt;山脉数组&lt;/strong&gt; &lt;code&gt;mountainArr&lt;/code&gt;，请你返回能够使得 &lt;code&gt;mountainArr
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习05-设备管理</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A005-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>https://www.codetool.top/article/操作系统复习05-设备管理/</id>
    <published>2020-04-28T14:58:05.000Z</published>
    <updated>2020-05-02T08:34:45.267Z</updated>
    
    <content type="html"><![CDATA[<p>设备管理的功能：</p><ul><li>外围设备中断处理</li><li>缓冲区管理</li><li>外围设备的分配和去配     </li><li>外围设备驱动调度</li><li>虚拟设备及其实现</li></ul><h1 id="I-O硬件原理">1 I/O硬件原理</h1><p><img src="https://api.codetool.top/img/15880927472084.png" alt></p><h2 id="IO系统">1.1 IO系统</h2><p>I/O系统是<strong>I/O设备及其接口线路、控制部件、通道和管理软件的总称。</strong> <code>I/O</code>就是“输入/输出”(Input/Output)</p><h3 id="I-O设备">1.1.1 I/O设备</h3><p>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p>I/O设备按使用特性分类：</p><ul><li>人机交互类外设：鼠标、键盘、打印机等——用于人机交互，数据传输速度慢。</li><li>存储设备：移动硬盘、光盘等——用于数据存储，数据传输速度快。</li><li>网络通信设备：调制解调器等——用于网络通信，数据传输速度介于上述二者之间。</li></ul><p>I/O设备按信息交换的单位分类：</p><ul><li>块设备：如磁盘等——<strong>数据传输的基本单位是“块”，传输速率较高，可寻址</strong>，即对它可随机地读/写任一块。</li><li>字符设备：鼠标、键盘等——<strong>数据传输的基本单位是字符，传输速率较慢，不可寻址</strong>，在输入/输出时常采用中断驱动方式</li></ul><h2 id="设备控制器">1.2 设备控制器</h2><p>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件（称设备控制器或适配器）作为CPU和I/O设备机械部件之间的“中介”，<strong>用于实现CPU对设备的控制</strong>。</p><p>如果没有控制器，复杂操作必须由操作系统来解决，引入控制器后，通过传递简单参数就可进行I/O操作，大大简化系统的设计，<strong>有利于计算机系统对各类控制器和设备的兼容性</strong>。</p><p>主要功能:</p><ol><li><strong>接收和识别CPU或通道发来的命令</strong>：如CPU发来的<code>read/write</code>命令，I/O控制器中会有相应的<strong>控制寄存器来存放命令和参数</strong>。</li><li>实现<strong>数据交换</strong>,包括设备和控制器间的数据传输：I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</li><li><strong>发现和记录设备及自身的状态信息</strong>，供CPU处理：I/O控制器中会有相应的状态寄存器，用于记录I/O设备的当前状态。如:1表示空闲，0表示忙碌。</li><li><strong>设备地址识别</strong>：类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</li></ol><p>它是一个可编址设备,当它连接多台设备时,则应具有多个设备地址。</p><h2 id="I-O控制方式">1.3 I/O控制方式</h2><h3 id="轮询方式">1.3.1 轮询方式</h3><p>又称<strong>程序直接控制方式</strong>，使用<strong>查询指令</strong>测试设备控制器的<strong>忙闲状态位</strong>，决定内存和设备是否能交换数据。</p><p><img src="https://api.codetool.top/img/15880934336329.png" alt></p><p>轮询程序中用到的三种指令：</p><ol><li>查询指令：查询设备是否就绪</li><li>读/写指令：当设备就绪时，执行数据交换</li><li>转移指令：当设备未就绪时，执行转移指令转向查询指令继续查询。</li></ol><p>特点：</p><ul><li>CPU干预的频率很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。</li><li>每次读写一个字</li><li>需要CPU的帮助</li></ul><p>缺点:<br>CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。</p><h3 id="中断方式">1.3.2 中断方式</h3><p>中断方式要求<strong>CPU与设备控制器及设备之间有中断请求线</strong>，控制器的状态寄存器有相应<strong>中断允许位</strong>。</p><p>在CPU发出读/写命令后，可<strong>将等待I/O的进程阻塞</strong>，先切换到别的进程执行。<strong>当I/O完成后，控制器会向CPU发出一个中断信号</strong>，CPU检测到中断信号后，会<strong>保存当前进程的运行环境信息，转去执行中断处理程序处理该中断</strong>。处理中断的过程中，CPU<strong>从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。</strong>接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行</p><p><img src="https://api.codetool.top/img/15880937593363.png" alt></p><p>注意：</p><ol><li><strong>CPU会在每个指令周期的末尾检查中断</strong></li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，<strong>如果中断发生的频率太高，也会降低系统性能</strong></li></ol><p>特点：</p><ul><li>每次I/O操作开始之前、完成之后需要CPU介入。等待I/O完成的过程中CPU可以切换到别的进程执行。</li><li>每次读写一个字</li><li>需要CPU的帮助</li></ul><p>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</p><h3 id="DMA方式">1.3.3 DMA方式</h3><p>与“中断驱动方式”相比，DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的I/0控制）有这样几个改进:</p><ol><li><strong>数据的传送单位是“块”</strong>。不再是一一个字、一个字的传送</li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备。<strong>不再需要CPU的帮助</strong>。</li><li><strong>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</strong></li></ol><p>步骤：</p><ol><li>CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</li><li>控制器会根据CPU提出的要求完成数据的读/写工作，<strong>整块数据的传输完成后，才向CPU发出中断信号</strong></li></ol><p><img src="https://api.codetool.top/img/15880942153789.png" alt></p><p>DMA方式需以下设施：</p><ol><li>内存地址寄存器：在输入时表示数据应放到内存中的什么位置，输出时表示要输出的数据放在内存中的什么位置中。</li><li>数据计数器：表示剩余要读/写的字节数。</li><li>数据缓冲寄存器或数据缓冲区：暂存从设备到内存，或从内存到设备的数据。</li><li>设备地址寄存器：暂存存储设备中的地址。</li><li>中断机制和控制逻辑：通过中断机制通知CPU</li></ol><p>特点：</p><ul><li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</li><li>每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</li><li>数据传输不再需要经过CPU</li></ul><p>缺点: CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。<strong>如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</strong></p><h3 id="通道方式">1.3.4 通道方式</h3><p>为获得CPU和外围设备间更高的并行工作能力，为让种类繁多，物理特性各异的外围设备能以标准的接口连接到系统中，计算机系统引入了自成独立体系的通道结构。</p><p><strong>通道也是一种硬件，可以识别并执行一系列通道指令，完成一部分CPU的工作。</strong></p><p>采用通道后的I/O操作过程：</p><ol><li>CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备，之后CPU就切换到其他进程执行了。</li><li><strong>通道执行内存中的通道程序</strong>（其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息）</li><li><strong>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</strong></li></ol><p>特点：</p><ul><li><strong>CPU干预的频率极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</strong></li><li>每次读/写一组数据块</li><li>CPU、通道、I/O设备可并行工作，<strong>资源利用率很高</strong>。</li></ul><p>缺点：需要专门的通道硬件支持。</p><h1 id="I-O软件原理">2 I/O软件原理</h1><p><img src="https://api.codetool.top/img/15880927712226.png" alt></p><h2 id="I-O软件设计目标和原则">2.1 I/O软件设计目标和原则</h2><p>I/O软件总体设计目标:</p><ul><li>高效率</li><li>通用性</li></ul><p>I/O软件总体设计要考虑的问题： </p><ul><li>设备无关性</li><li>出错处理</li><li>同步（阻塞）—异步（中断驱动）传输</li><li>独占性外围设备和共享性外围设备</li></ul><h2 id="I-O软件组织成四个层次">2.2 I/O软件组织成四个层次</h2><ul><li>I/O中断处理程序。</li><li>I/O设备驱动程序。</li><li>独立于设备的操作系统I/O软件。</li><li>用户空间的I/O软件。</li></ul><p>越往上越接近硬件，越往下越靠近用户</p><h3 id="I-O中断处理程序">2.2.1 I/O中断处理程序</h3><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p><p>I/O中断的类型和功能：</p><ul><li>通知用户程序<strong>I/O操作沿链推进程度</strong></li><li>通知用户程序<strong>I/O操作正常结束</strong></li><li>通知用户程序发现的<strong>I/O操作异常</strong></li><li>通知程序<strong>外围设备上重要的异步信号</strong></li></ul><p>I/O中断的处理原则：（根据不同的中断原因做相应的处理）</p><ul><li>操作正常结束处理</li><li>操作发生故障或特殊事件的中断处理</li><li>人为要求而产生的中断处理</li><li>外围设备的异步信号处理</li></ul><h3 id="设备驱动程序">2.2.2 设备驱动程序</h3><p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p><p>设备驱动程序<strong>包括与设备相关的代码</strong>，其工作是：<strong>把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行</strong>，如设备名转化为端口地址、逻辑记录转化为物理记录、逻辑操作转化为物理操作等。</p><p>设备驱动程序主要功能：</p><ol><li>设备初始化</li><li>执行设备驱动例程</li><li>执行中断处理例程</li></ol><h3 id="独立于设备的操作系统I-O软件">2.2.3 独立于设备的操作系统I/O软件</h3><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>设备无关软件完成的功能：</p><ul><li>对设备驱动程序的统一接口（向用户提供，如read/write系统调用）</li><li>设备命名</li><li>设备保护：<strong>在unix系统中，设备被看做是一种特殊的文件</strong>，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</li><li>提供独立于设备的块大小</li><li>缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li><li>块设备的存储分配</li><li>独占性外围设备的分配和释放</li><li>错误报告</li><li>文件和I/O设备的命名方式</li><li>如何保护对设备的未授权访问 </li><li>屏蔽不同磁盘扇区大小并向高层软件提供统一大小的逻辑块</li><li>块设备和字符设备需要缓冲技术</li><li>设备分配和状态跟踪</li></ul><p>错误处理多数由驱动程序完成，设备独立性软件需要对一些设备的错误进行处理。</p><p>缓冲技术、驱动调度技术、设备分配会在后面讲到。</p><h3 id="用户空间的I-O软件">2.2.4 用户空间的I/O软件</h3><p>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。</p><ul><li>用户空间的I/O软件：I/O系统调用通常先是库函数调用<code>count=write(fd，buffer，nbytes)；</code></li><li>非库函数实现的I/O系统调用：SPOOLing系统 </li></ul><p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用(Windows API)</p><h2 id="I-O操作过程总览">2.3 I/O操作过程总览</h2><ol><li>进程对已打开文件的文件描述符执行读库函数；</li><li>独立设备I/O软件检查参数正确性。<strong>高速缓存中有要读的信息块，从缓冲区直接读到用户区，完成I/O请求；</strong></li><li>若数据不在缓冲区，执行物理I/O，实现<strong>将设备逻辑名转换成物理名，检查对设备操作的权限，将I/O请求排队，阻塞进程且等待I/O完成</strong>；</li><li>内核<strong>启动设备驱动程序，分配存放读出块的缓冲区，准备接收数据，且向设备控制寄存器发启动命令，或建立DMA传输</strong>，启动I/O；</li><li><strong>设备控制器操作设备，执行数据传输</strong>；</li><li><strong>DMA控制器控制一块传输完成，硬件产生I/O结束中断</strong>；</li><li><strong>CPU响应中断，转向磁盘中断处理程序</strong>。</li><li>当应用进程被再次调度执行时，从I/O系统调用的断点恢复执行。 </li></ol><h1 id="缓冲技术">3 缓冲技术</h1><p><img src="https://api.codetool.top/img/15880927834414.png" alt></p><h2 id="缓冲技术概念">3.1 缓冲技术概念</h2><p>缓冲区是一个存储区域，<strong>可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</strong></p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合(如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。</p><p>引入缓冲技术的目的：</p><ul><li>改善中央处理器与外围设备之间速度不配的矛盾，</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>协调逻辑记录大小与物理记录大小不一致</li><li>提高CPU和I/O设备的并行性</li></ul><p>实现缓冲技术的基本思想：</p><ul><li>进程执行写操作输出数据时，向系统申请一个缓冲区，<strong>若为顺序写请求，则不断把数据填到缓冲区，直到被装满。</strong>此后，进程继续它的计算，系统将缓冲区内容写到I/O设备上。</li><li>进程执行操作输入数据时，向系统申请一个缓冲区，<strong>系统将一个物理记录的内容读到缓冲区，根据进程要求，把当前需要的逻辑记录从缓冲区中选出并传送给进程。</strong></li><li>在输出数据时，只有在系统还来不及腾空缓冲而进程又要写数据时，它才需要等待；</li><li>在输入数据时，仅当缓冲区空而进程又要从中读取数据时，它才被迫等待。</li></ul><h1 id="驱动调度技术">4 驱动调度技术</h1><p><img src="https://api.codetool.top/img/15880928021600.png" alt></p><h2 id="驱动调度技术的概念">4.1 驱动调度技术的概念</h2><p>驱动调度能<strong>减少为若干个I/O请求服务所需的总时间</strong>，提高系统效率、除了<strong>I/O请求的优化排</strong>序外，<strong>信息在辅助存储器上的排列方式</strong>，<strong>存储空间分配方法</strong>都能影响存取访问速度。</p><h2 id="存储设备的物理结构">4.2 存储设备的物理结构</h2><p>顺序存取存储设备是严格依赖信息的物理位置进行定位和读写的存储设备，具有存储容量大、稳定可靠、卷可装卸和便于保存等优点。</p><p>磁盘是一种直接(随机)存取存储设备。每个物理记录有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置。</p><p><strong>访问磁盘记录参数：盘面号、磁道号、扇区号。</strong></p><p><img src="https://api.codetool.top/img/15881495266638.jpg" alt="磁盘结构"></p><h2 id="移臂调度的算法">4.3 移臂调度的算法</h2><ul><li>“先来先服务” 算法：磁盘臂是随机移动的，<strong>按照I/O请求的次序寻道</strong>，不考虑各 I/O 请求间的相对次序和移动臂当前所处位置，进程等待 I/O 请求时间会很长，寻道性能较差。</li><li>“最短查找时间优先”算法：<strong>每次选择离当前磁头最近的磁道</strong>，与FIFO 算法相比有较好寻道性能。</li><li>“扫描”算法：<strong>磁盘臂每次沿一个方向移动，扫过所有柱面，遇到最近的I/O请求便进行处理，直到最后一个柱面后，再向相反方向移动回来。</strong></li><li>“分步扫描”算法：<strong>进程重复请求访问同一柱面会垄断设备，造成“磁臂粘性”，导致其他柱面访问请求长时间得不到服务</strong>，采用“分步扫描”算法可以避免这类问题。具体做法是：将 I/O 请求分为长度为N的子队列，<strong>按FIFO算法依次处理每个子队列，而每个子队列采用扫描算法</strong>，处理完一个后再服务下一个子队列，以避免出现磁臂粘住现象。这种调度算法能保证每个I/O请求的等待时间不致太长，当 N 值很大时，接近于“扫描”算法性能；当N＝１时，接近于 FIFO算法性能。</li><li>“电梯调度”算法：<strong>是扫描算法的一种改进，无访问请求时，移动臂停止不动</strong>，有访问请求时，移动臂按电梯规律移动。</li><li>“循环扫描”算法：为适应有大量柱面均匀分布的存取请求进入系统而设计的扫描方式。移动臂总是从０柱面至最大号柱面顺序扫描，<strong>然后，直接返回０柱面重复进行，归途中不再提供服务</strong>，构成一个循环，缩短处理新来请求的最大延迟。</li></ul><h1 id="设备分配">5 设备分配</h1><p><img src="https://api.codetool.top/img/15880928246319.png" alt></p><h2 id="设备独立性">5.1 设备独立性</h2><p>用户不指定特定设备，指定逻辑设备，使得用户作业和物理设备独立开来，通过其它途径建立逻辑设备和物理设备之间对应关系，这种特性为“设备独立性”。</p><p>好处：用户与物理的外围设备无关，系统增减或变更外围设备时程序不必修改；易于对付输入输出设备的故障。</p><p>从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类，相应的管理和分配外围设备的技术可分成：独占方式、共享方式和虚拟方式。</p><p>从进程运行的安全性上考虑，设备分配有两种方式:</p><ul><li>安全分配方式:为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。</li></ul><p>优点:破坏了“请求和保持”条件，不会死锁<br>缺点:对于一个进程来说，CPU和I/O设备只能串行工作</p><ul><li>不安全分配方式:进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。</li></ul><p>优点:进程的计算任务和I/O任务可以并行处理，使进程迅速推进<br>缺点:有可能发生死锁(需要考虑死锁避免、死锁的检测和解除)</p><h2 id="设备分配的数据结构">5.2 设备分配的数据结构</h2><p>设备分配的数据结构：设备类表和设备表。</p><p>系统中拥有一张<strong>设备类表</strong>，每类设备对应于表中一栏，包括内容有：<strong>设备类、总台数、空闲台数和设备表起始地址等。</strong></p><p>每一类设备都有各自的<strong>设备表</strong>，用来登记这类设备中每一台设备的状态，包含的内容有：<strong>物理设备名、逻辑设备名、占有设备的进程号、已分配/未分配、好/坏等。</strong></p><p>采用通道结构的系统中，设备分配的数据结构设置：系统设备表、通道控制表、控制器控制表和设备控制表。</p><p>常用的I/O设备分配算法有先请求先服务，优先级高者先服务等。此外，在多进程请求I/O设备分配时，应防止因循环等待对方所占用的设备而产生死锁，应预先进行性检查。</p><h1 id="虚拟设备">6 虚拟设备</h1><p><img src="https://api.codetool.top/img/15880928415734.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设备管理的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外围设备中断处理&lt;/li&gt;
&lt;li&gt;缓冲区管理&lt;/li&gt;
&lt;li&gt;外围设备的分配和去配     &lt;/li&gt;
&lt;li&gt;外围设备驱动调度&lt;/li&gt;
&lt;li&gt;虚拟设备及其实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;I-O硬件原理&quot;&gt;1 
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode260-只出现一次的数字III</title>
    <link href="https://www.codetool.top/article/leetcode260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
    <id>https://www.codetool.top/article/leetcode260-只出现一次的数字III/</id>
    <published>2020-04-28T04:55:15.000Z</published>
    <updated>2020-04-28T06:24:45.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong> [1,2,1,3,2,5]<br><strong>输出:</strong> [3,5]</p></blockquote><p><strong>注意：</strong></p><ol><li>结果输出的顺序并不重要，对于上面的例子， <code>[5, 3]</code> 也是正确答案。</li><li>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>如果不限制常数空间复杂度用哈希表计数可以很容易做出来，但是限制了空间复杂度，可以用位运算：</p><p>只看题目，和<a href="../leetcode136-只出现一次的数字">leetcode136-只出现一次的数字</a>很相似，对于唯一一个只出现一次的数字，我们可以通过异或将其找出，这道题有两个只出现一次的数字，如果将所有的数字异或，结果并不能显示是哪两个数字只出现一次。可以想办法将这些数字分为两组，并将两个不同的数字分到不同的组中，再进行查找。</p><p>那么如何将两个不同的数字分到两个不同的组中呢，可以使用第一次将全部数字异或的结果，得到的结果其实就是这两个数字异或的结果。因为这两个数字不一样，得到的异或结果也必定有至少一位是1。只要将这一位是1的数字分为一组，是0的数字分为一组，就能将所有数字分为两组，而这两组中只有一个只出现一次的数字，异或的结果就是这个数字。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">singleNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            k <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到k中最靠近低位的1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用掩码进行与运算，结果是0分为一组，结果是1分为一组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                a <span class="token operator">^=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                b <span class="token operator">^=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中序遍历-折纸问题</title>
    <link href="https://www.codetool.top/article/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/二叉树中序遍历-折纸问题/</id>
    <published>2020-04-27T15:16:19.000Z</published>
    <updated>2020-04-27T15:28:58.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。</p><p>给定折的次数n,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 1<br><strong>输出:</strong> [“down”]</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一次折叠，会在现有折痕的上方产生一个下的折痕，在折痕的下方产生一个上的折痕。（可以动手尝试理解）</p><p>这样就会形成一个二叉树：</p><p><img src="https://api.codetool.top/img/15880011961390.png" alt></p><p>从纸的上面到下面打印就是二叉树的 RVL 的遍历（右根左，特殊的中序遍历）。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FoldPaper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">foldPaper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"down"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fold</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> String type<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fold</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"down"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fold</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">"up"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode86-分隔链表</title>
    <link href="https://www.codetool.top/article/leetcode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/leetcode86-分隔链表/</id>
    <published>2020-04-27T06:36:11.000Z</published>
    <updated>2020-04-27T06:39:10.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br><strong>输出:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>双指针法，因为某些节点可能称为新的头节点，需要设置哨兵节点。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">partition</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode before_head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode before <span class="token operator">=</span> before_head<span class="token punctuation">;</span>        ListNode after_head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode after <span class="token operator">=</span> after_head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                before<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                before <span class="token operator">=</span> before<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                after<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                after <span class="token operator">=</span> after<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        after<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        before<span class="token punctuation">.</span>next <span class="token operator">=</span> after_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> before_head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组元素左右两边最近较小元素</title>
    <link href="https://www.codetool.top/article/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E6%9C%80%E8%BF%91%E8%BE%83%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/数组元素左右两边最近较小元素/</id>
    <published>2020-04-26T05:40:33.000Z</published>
    <updated>2020-04-26T06:19:06.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源牛客网）">1 原题（来源牛客网）</h1><p>给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。</p><p><strong>实例：</strong></p><blockquote><p><strong>输入:</strong> arr = {3,4,1,5,6,2,7}<br><strong>输出</strong><br>{<br>&nbsp;&nbsp;{-1,&nbsp;2},<br>&nbsp;&nbsp;{&nbsp;0,&nbsp;2},<br>&nbsp;&nbsp;{-1,-1},<br>&nbsp;&nbsp;{&nbsp;2,&nbsp;5},<br>&nbsp;&nbsp;{&nbsp;3,&nbsp;5},<br>&nbsp;&nbsp;{&nbsp;2,-1},<br>&nbsp;&nbsp;{&nbsp;5,-1}<br>}  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>单调栈，或使用动态规划的方式做，都可以达到线性时间复杂度。</p><h2 id="代码">2.2 代码</h2><p>动态规划：（其实也是单调栈的思想）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNearLessNoRepeat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从左到右扫描</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                left <span class="token operator">=</span> res<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从右到左扫描</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                right <span class="token operator">=</span> res<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>单调栈：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNearLessNoRepeat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果当前遍历到的数组的值小，需要弹出</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> popIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> leftLessIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftLessIndex<span class="token punctuation">;</span>                res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> popIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> leftLessIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftLessIndex<span class="token punctuation">;</span>            res<span class="token punctuation">[</span>popIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源牛客网）&quot;&gt;1 原题（来源牛客网）&lt;/h1&gt;&lt;p&gt;给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode124-二叉树中的最大路径和</title>
    <link href="https://www.codetool.top/article/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode124-二叉树中的最大路径和/</id>
    <published>2020-04-26T05:03:04.000Z</published>
    <updated>2020-04-26T05:15:41.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个节点</strong>，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,2,3]       <strong>1</strong>      <strong>/ \</strong>     <strong>2</strong>   <strong>3</strong><strong>输出:</strong> 6</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [-10,9,20,null,null,15,7]&nbsp;  -10&nbsp; &nbsp;/ \&nbsp; 9 &nbsp;<strong>20</strong>&nbsp; &nbsp; <strong>/ &nbsp;\</strong>&nbsp; &nbsp;<strong>15 &nbsp; 7</strong><strong>输出:</strong> 42</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设计一个函数<code>max_gain</code>，用于返回一个节点与它的左子树或右子树连成的最长路径。</p><p>使用一个全局变量记录递归回溯过程中出现的最大路径长，对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:</p><ol><li>其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径（即递归函数返回的值）</li><li>左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径（在函数中与上面的情况产生的值进行比较，更新最大值）</li></ol><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> max_sum <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">max_gain</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left_gain <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max_gain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right_gain <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max_gain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> price_newpath <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> left_gain <span class="token operator">+</span> right_gain<span class="token punctuation">;</span>        max_sum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max_sum<span class="token punctuation">,</span> price_newpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left_gain<span class="token punctuation">,</span> right_gain<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">max_gain</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max_sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径&lt;strong&gt;至少包含一个节点&lt;/strong&gt;，且不一定经过根节点。&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>net.ipv4.ip_local_port_range的含义</title>
    <link href="https://www.codetool.top/article/net-ipv4-ip-local-port-range%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://www.codetool.top/article/net-ipv4-ip-local-port-range的含义/</id>
    <published>2020-04-25T15:55:45.000Z</published>
    <updated>2020-04-25T17:18:58.440Z</updated>
    
    <content type="html"><![CDATA[<p>在《深入分析Java Web技术内幕》一书中看到下面这段话：</p><blockquote><p>要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位操作系统的端口号通常由两个字节表示，也就是只有2<sup>16</sup>=65535个，所以一台主机能够同时建立的连接数是有限的，当然操作系统还有一些端口0~1024是受保护的，如80端口、22端口，这些端口都不能被随意占用。  </p><p>在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。</p></blockquote><p>看完这段话我对几个地方都有点质疑：</p><ol><li><code>32位操作系统的端口号通常由两个字节表示</code>，难道64位机器的端口号还能超过两个字节？大于65535的端口从来没见过。应该是和协议规定的有关系，我在<a href="../计网复习05-传输层">计网复习05-传输层</a>中对TCP和UDP的报文格式都有描述，无论是TCP还是UDP的报文头部都有一个两字节的源端口号和两字节的目的端口号，这应该是TCP/IP协议对端口号长度做出的规定。</li><li><code>所以一台主机能够同时建立的连接数是有限的</code>，原因讲的很模糊，他提到和端口的数量有关系，但实际上我们说一个socket连接是由一个四元组唯一标识的，即两个socket（两台主机的ip和端口号），这四个属性中任何一个不一样都可以是的socket连接，而另一台主机是不确定的，所以应该说<code>两台主机之间能够同时建立的连接数是有限的</code>，这里可能上下文是这个意思，但没有表述清楚。</li><li><code>操作系统还有一些端口0~1024是受保护的，如80端口、22端口，这些端口都不能被随意占用</code>和<code>在Linux中可以通过查看/proc/sys/net/ipv4/ip_local_port_range文件来知道当前这个主机可以使用的端口范围。</code>，显然作者对端口号的划分没有很好的理解，后面这句话也有很明显的错误。我在<a href="../计网复习05-传输层">计网复习05-传输层</a>的第一节的思维导图中有总结端口号的分类，但当时没有详谈，看到这段话之后查阅了相关资料，这里详细介绍一下。</li></ol><h1 id="端口的分类">1 端口的分类</h1><p><a href="../计网复习05-传输层">计网复习05-传输层</a>这一篇的思维导图中先把端口号分为了服务端使用的端口（0-49151）和客户端使用的端口（49151-65535）。实际上这是不一定的，没有强制要求服务端和客户端只能使用这个端口范围，这应该是tcp/ip协议的建议，并且很明显这个建议也被广泛采纳，这不意味着服务器就不可以使用（49151-65535）中的端口作为长期服务端口。</p><p>下面介绍的端口分类对应的范围是由IANA（互联网数字分配机构）规定的。</p><h2 id="熟知端口">1.1 熟知端口</h2><p>熟知端口（WellKnown Ports），数值一般为 <code>0 ~ 1023</code>。</p><p>0端口是保留端口，在编程API中（特别是linux socket编程）作为请求系统分配的（动态）端口。</p><p>很多知名的应用层协议会选择这个端口范围内的端口号，例如HTTP服务默认的端口号是80，HTTPS是443，DNS是53、FTP是20、21，SSH是22等。所以一般不推荐没有熟知端口号的应用程序使用这部分的端口号，否则很容易冲突，但<strong>不意味着只有这些应用程序才能使用这部分的端口号，只要不冲突，其他服务也能使用这些端口，但是linux中root权限用户的才可以启用1~1023的服务。</strong></p><h2 id="登记端口号">1.2 登记端口号</h2><p>登记端口号（Registered Ports），数值为 <code>1024 ~ 49151</code>，为没有熟知端口号的应用程序使用的。</p><h2 id="短暂端口号">1.3 短暂端口号</h2><p>短暂端口号（Ephemeral Ports），也被称为动态端口（Dynamic Ports），IANA推荐使用 <code>49152 ~ 65535</code>，留给客户进程选择暂时使用。这是什么意思呢？<strong>客户端使用TCP、UDP协议与服务端进行连接时，通常会从这个端口范围内被随机分配一个未使用的端口，从而与服务端建立socket连接。</strong>这个分配的端口是临时的，仅在通信会话期间有效，所以称为“短暂端口”，与服务器上长期服务的端口区分开。</p><p>虽然说推荐是客户端使用的，但实际上服务器也能使用这一部分的端口号做长期服务。</p><p><code>49152 ~ 65535</code>是IANA推荐使用的短暂端口号范围，而<strong>linux默认使用的短暂端口号范围实际上是32768到60999</strong>，也就是我们使用命令<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>或<code>sysctl -a|grep ip_local_port_range</code>看到的两个数字。linux严格遵守这个配置，作为客户端建立socket连接时只会从这个端口范围获取动态分配的端口。</p><p>下面谈谈如何修改这个值，显然修改这个值能明显提高linux作为客户端能建立的并发连接数。因为tcp常常因为<code>time_wait</code>状态占用大量短暂端口，适当提高这个范围也可以减少端口不够用的影响。</p><p>linux修改方法：</p><pre><code>vi /etc/sysctl.conf</code></pre><p>修改</p><pre><code>net.ipv4.ip_local_port_range = 1024 65535</code></pre><p>然后</p><pre><code>sysctl -p</code></pre><p>生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在《深入分析Java Web技术内幕》一书中看到下面这段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要能够建立一个TCP连接，必须知道对方的IP和一个未被使用的端口号，由于32位操作系统的端口号通常由两个字节表示，也就是只有2&lt;sup&gt;16&lt;/sup&gt;=65535个，所以
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode13-罗马数字转整数</title>
    <link href="https://www.codetool.top/article/leetcode13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode13-罗马数字转整数/</id>
    <published>2020-04-25T03:47:19.000Z</published>
    <updated>2020-04-25T04:23:05.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><pre><strong>字符</strong>          <strong>数值</strong>I             1V             5X             10L             50C             100D             500M             1000</pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> “III”<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> “IV”<br><strong>输出：</strong> 4  </p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入：</strong> “IX”<br><strong>输出：</strong> 9  </p></blockquote><p><strong>示例4:</strong></p><blockquote><p><strong>输入：</strong> “LVIII”<br><strong>输出：</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.  </p></blockquote><p><strong>示例5:</strong></p><blockquote><p><strong>输入：</strong> “MCMXCIV”<br><strong>输出：</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于字符串中从左到右每个字符，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">!=</span>chars<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                ans <span class="token operator">+=</span> <span class="token function">romanChartoNum</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanChartoNum</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">500</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习04-存储管理</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A004-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://www.codetool.top/article/操作系统复习04-存储管理/</id>
    <published>2020-04-24T13:58:15.000Z</published>
    <updated>2020-04-25T13:09:28.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关概念">1 相关概念</h1><p><img src="https://api.codetool.top/img/15877892594926.png" alt></p><h2 id="从写程序到程序运行">1.1 从写程序到程序运行</h2><ul><li>编辑源代码文件</li><li>编译：由源代码文件生成目标模块(高级语言“翻译“为机器语言)</li><li>链接：由目标模块生成装入模块，链接后形成完整的<strong>逻辑地址</strong></li><li>装入：将装入模块装入内存，装入后形成<strong>物理地址</strong></li></ul><p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址。在装入运行后，才会将逻辑地址转换为物理地址。</p><h2 id="链接的三种方式">1.2 链接的三种方式</h2><ul><li>静态链接：<strong>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）</strong>，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式。</li><li>运行时动态链接：<strong>在程序执行中需要该目标模块时，才对它进行链接</strong>。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul><h2 id="装入（装载）的三种方式">1.3 装入（装载）的三种方式</h2><ul><li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，<strong>编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</strong>绝对装入只适用于单道程序环境。</li><li>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</strong><ul><li>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。<strong>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</strong></li></ul></li><li>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此<strong>装入内存后所有的地址依然是逻辑地址</strong>。这种方式需要一个<strong>重定位寄存器</strong>的支持。采用动态重定位时允许程序在内存中发生移动。<ul><li>可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ul></li></ul><h1 id="存储管理的功能">2 存储管理的功能</h1><p><img src="https://api.codetool.top/img/15877892733377.png" alt></p><ul><li>定位(存储分配)：为具体的程序和数据等分配存储单元或存储区工作。</li><li>地址映射：将逻辑地址转换为相应的物理地址。地址空间是程序用来访问信息所用地址单元的集合。</li><li>存储共享：两个或多个进程共用内存中相同区域。目的：节省内存空间，提高内存利用率、实现<strong>进程通信</strong>(数据共享)。</li><li>存储保护：<strong>各道程序只能访问自己的内存区而不能互相干扰</strong>，必须对内存中的程序和数据进行保护，以免受到其他程序有意或无意的破坏。可对进程执行时所产生的所有内存访问地址进行检查，确保进程仅访问它自己的内存区，这就是<strong>地址越界保护</strong>，越界保护依赖于硬件设施，常用的有：界地址寄存器和存储键。</li><li>存储扩充：用户在编制程序时，不应该受内存容量限制，所以要采用一定技术来“扩充”内存的容量，<strong>使用户得到比实际内存容量大的多的内存空间</strong>。<ul><li>覆盖技术：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)。这种实现方式需要程序员手动声明覆盖区，不便于实现。</li><li>交换技术：交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)，换到外存中的进程就称为<strong>挂起态</strong>，<strong>即使进程被换出内存，PCB必须常驻内存</strong>。</li><li>虚拟存储技术：具体实现是在硬件支持下，软硬件相互协作，将内存和外存结合起来统一使用。 </li></ul></li></ul><p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对<strong>文件区空间的管理采用离散分配方式</strong>；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此<strong>通常对换区采用连续分配方式</strong>。总之，对换区的I/O速度比文件区的更快。</p><h1 id="实存管理">3 实存管理</h1><p><img src="https://api.codetool.top/img/15877893676624.png" alt></p><h2 id="连续分配管理方式（分区）">3.1 连续分配管理方式（分区）</h2><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><h3 id="单一连续分配">3.1.1 单一连续分配</h3><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。<strong>内存中只能有一道用户程序，用户程序独占整个用户区空间。</strong></p><p>优点：</p><ul><li>实现简单</li><li>无外部碎片</li><li>可以采用覆盖技术扩充内存</li><li>不一定需要采取内存保护</li></ul><h3 id="固定分区分配">3.1.2 固定分区分配</h3><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是<strong>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>可分为大小相同的分区和大小不同的分区，但依然缺乏灵活性。</p><p>固定分区分配会产生内部碎片：</p><blockquote><p>内部碎片，分配给某进程的内存区域中，有些部分没有用上。<br>外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</p></blockquote><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)</p><h3 id="动态分区分配">3.1.3 动态分区分配</h3><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><p>分配与回收方案：</p><ul><li>当作业装入内存时：<ul><li>若有足够空间，分割一个分区给该作业（具体选择策略由分配算法决定）</li><li>若没有足够空间，等待内存资源</li></ul></li><li>空间回收：若两端有空闲区，和空闲区合并</li></ul><p><strong>动态分区会产生外部碎片</strong>：</p><p>动态分区分配算法：</p><ul><li><strong>首次适应算法</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。会出现低地址空闲区用得较频繁的情况，内存各区域使用频率不均。但优点是通常能保留高地址区域的较大分区，更不容易产生外部碎片。<ul><li>为了解决首次适应算法的缺点，可以使用改进后的“<strong>下次适应算法</strong>”，它会接着上一次扫描到的位置继续往下扫描，不会导致各区域使用频率不均。</li></ul></li><li><strong>最佳适应算法</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。缺点：<strong>会产生较多外部碎片</strong>。</li><li><strong>最坏适应算法</strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时<strong>优先使用最大的连续空闲区</strong>，这样分配后剩余的空闲区就不会太小，更方便使用。缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式<strong>会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong></li></ul><h2 id="非连续分配管理方式（分页）">3.2 非连续分配管理方式（分页）</h2><p>程序存放到若不相邻的空间块中。</p><p>将<strong>内存空间分为一个个大小相等的分区</strong>(比如：每个分区4KB)，每个分区就是一个<strong>“页框”</strong>，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)。页框号从0开始。</p><p><strong>将用户进程的地址空间也分为与页框大小相等的一个个区域</strong>，称为<strong>“页”</strong>或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。</p><p>逻辑地址由页号（<code>逻辑地址/页的大小</code>）和页内偏移（<code>逻辑地址%页的大小</code>）构成，<strong><code>物理地址=页号对应的页框号×块长+页内地址</code></strong>。为了方便计算页号、页内偏移量，<strong>页面大小一般设为2的整数幂</strong></p><p>那么如何知道页号对应的页框号？为了能知道进程的每个页面在内存中存放的位置，操作系统要<strong>为每个进程建立一张页表</strong>。</p><p><strong>进程的页表在进程运行的时候也会被装载到页框中。</strong></p><ol><li>进程的每一页对应一个页表项</li><li>每个页表项由<code>“页号”</code>和<code>“块号”</code>（页框号）组成</li><li>页表记录进程页面和实际存放的内存块之间的对应关系</li></ol><h3 id="基本地址变换机构">3.2.1 基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<strong>页表寄存器(PTR)</strong>，存放<strong>页表在内存中的起始地址F和页表长度M。</strong></p><p>进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>地址变换过程：</p><ol><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界，如果越界会触发越界中断（如果页号大于或等于页表长度）</li><li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li><li>用内存块号和页内偏移量得到物理地址</li></ol><p>由于页表中的页表项都是连续存储的，而页表项的大小是相等的，因此页号可以隐含（从0开始的连续计数），只存储块号。</p><h3 id="翻译快表">3.2.2 翻译快表</h3><p>由上述内容我们可以知道，访问进程中的一个逻辑地址需要经过两次访存（第一次查询页表，第二次才是真正的访问逻辑地址对应的物理地址），那有没有办法减少访存次数呢？</p><p>快表（TLB）是一种特殊的高速缓冲存储器（Cache），<strong>内容是页表中的一部分或全部内容</strong>。在操作系统中引入快表是为了加快地址映射速度。</p><p>地址变换过程：</p><ol><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界，如果越界会触发越界中断（如果页号大于或等于页表长度）</li><li>查询快表<ol><li>若快表中没有目标页表项，则需要查询内存中的页表，并将查询到的页表项放入快表</li><li>若查询快表命中，就获取了页号对应的页表项</li></ol></li><li>用内存块号和页内偏移量得到物理地址</li></ol><p>因此，如果查询快表命中，则访问某个逻辑地址仅需一次访存即可。有的系统还支持快表和慢表（对应内存中的页表）同时查找，减少平均耗时。</p><h3 id="多级页表">3.2.3 多级页表</h3><p>如果程序使用空间很大，它的页表也会很大，需要占用很多个连续的页框。我们可以利用索引的思想，为页表也建立索引，使其可以离散存储于内存的各个页框中，称为多级页表。</p><p>系统为每个进程建一张<strong>页目录表</strong>，它的<strong>每个表项对应一个页表页</strong>，而<strong>页表页的每个表项给出了页面和页框的对应关系</strong>，<strong>页目录表是一级页表，页表页是二级页表</strong>。</p><p>使用二级页表后的逻辑地址结构由三部分组成：<strong>一级页号、二级页号和页内偏移</strong></p><p>注意：各级页表的大小不能超过一个页面。</p><h2 id="基本分段存储管理">3.3 基本分段存储管理</h2><p>与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同</p><p><strong>分页存储管理是一维地址结构，分段存储管理是二维地址结构。</strong></p><p>进程的地址空间<strong>按照程序自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p><p>分段系统的<strong>逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成</strong>。段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。</p><p>段表：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能<strong>从物理内存中找到各个逻辑段的存放位置</strong>。为此，需为每个进程建立一张段映射表，简称<strong>段表</strong>。每个段对应一个段表项，其中<strong>记录了该段在内存中的起始位置(又称“基址”)和段的长度。</strong></p><p>分页和分段的区别：</p><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li></ul><h2 id="段页式存储管理">3.4 段页式存储管理</h2><table><thead><tr><th>管理方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table><p>段页式存储管理结合了分页管理和分段管理的优缺点，将进程按逻辑模块分段，再将各段分页(如每个页面4KB)。内存依然按页的大小分为各个页框。</p><p>段页式系统的逻辑地址结构由<strong>段号、页号、页内地址</strong>(页内偏移量)组成。段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少</p><p>因此段页式管理的地址结构也是二维的。</p><p>段页式管理中的段表存储的就不是基址了，而是<strong>页表长度和页表的存放块号</strong>。地址转换时先查询段表，再查询页表。</p><h1 id="虚存管理">4 虚存管理</h1><p><img src="https://api.codetool.top/img/15877894059649.png" alt></p><h2 id="相关概念-1">4.1 相关概念</h2><p>有的时候可以在进程运行时<strong>实时将所需要的页装入内存</strong>，而不需要一次性全部装入，称为<strong>部分装入</strong>。当内存已满而又有新的“部分”需要装入时，要把已在内存的某一“部分”换出去，称为<strong>部分对换</strong></p><p>程序局部性原理：</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</li></ul><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>分页虚存系统的硬件支撑：<strong>内存管理单元MMU</strong>完成逻辑地址到物理地址的转换功能，它接受逻辑地址作为输入，物理地址作为输出，直接送到总线上，对内存单元进行寻址。 MMU的主要功能：</p><ol><li>管理硬件页表基址寄存器。</li><li>分解逻辑地址。</li><li>管理快表TLB。</li><li>访问页表。</li><li>发出缺页中断或越界中断，并将控制权交给内核存储管理处理。</li><li>设置和检查页表中各个特征位。</li></ol><p>虚拟内存的实际容量= <code>min(内存和外存容量之和，CPU寻址范围)</code></p><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统<strong>需要知道每个页面是否已经调入内存</strong>。如果还没调入，那么也需要知道该页面在外存中存放的位置。当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面。<strong>有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖</strong>，因此，操作系统也<strong>需要记录各个页面是否被修改的信息</strong>。</p><p>于是，请求分页存储管理的页表除了对应的内存块号外，还记录了<strong>状态位（是否已调入内存，1为是，0为否）、引用位（可记录最近被访问过几次，或记录上次访问的时间，供置换算法参考）、修改位（页面调入内存后是否被修改过）、外存地址</strong></p><p>在请求分页系统中，每<strong>当要访问的页面不在内存时，便产生一个缺页中断</strong>，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><h2 id="页面置换算法">4.2 页面置换算法</h2><p><strong>最佳页面置换算法OPT：</strong>调入一页而必须淘汰一个旧页时，所淘汰的页应该是<strong>以后不再访问的页或距现在最长时间后再访问的页。</strong>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。<strong>操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</strong></p><p><strong>先进先出页面替换算法FIFO：</strong>基于程序总是按线性顺序来访问物理空间这一假设。算法<strong>淘汰最先调入内存的页，或者说在内存中驻留时间最长的页。</strong>该算法可以使用固定大小的队列实现，队列的大小为系统为进程分配的内存块数。并且该算法的性能不是很好，即使最先调入内存的页面也可能经常用到。</p><p><strong>最近最少用页面替换算法LRU：</strong>算法淘汰的页面是在<strong>最近一段时间里较久未被访问的那页。</strong> 该算法的性能较好，最接近最佳页面置换算法。实现方法：</p><ul><li>该算法可以用固定大小的链表实现，当使用某个页的时候将其连接到链表的尾部。</li><li>引用位法：每页设置一个引用位R，访问某页时，由硬件将页标志位R置1，隔一定时间t将所有页的标志R均清0。发生缺页中断时，从标志位R为0的页中挑选一页淘汰。挑选到要淘汰的页后，也将所有页的标志位R清0。</li><li>计数法：每个页面设置一个多位计数器，又叫最不常用页面替换算法LFU。每当访问一页时，就使它对应的计数器加１。当发生缺页中断时，可选择计数值最小的对应页面淘汰，并将所有计数器全部清０。</li><li>计时法：为每个页面设置一个多位计时器，每当页面被访问时，系统的绝对时间记入计时器。淘汰时比较各页面的计时器的值，选最小值的未使用的页面淘汰。</li><li>老化算法：为每个页设置一个多位寄存器r。当页面被访问时，对应寄存器的最左边位置1；每隔时间t，将r寄存器右移一位；在发生缺页中断时，找最小数值的r寄存器对应的页面淘汰。</li></ul><p><strong>第二次机会页面替换算法SCR：</strong>改进FIFO算法，把FIFO与页表中的”引用位”结合起来使用：  </p><ul><li>检查FIFO中的队首页面(最早进入内存页面)，如果它的”引用位”是0，这个页面既老又没有用，选择该页面淘汰； </li><li>如果”引用位”是1，说明它进入内存较早，但最近仍在使用。把它的”引用位”清0，并把这个页面移到队尾，把它看作是一个新调入的页。</li></ul><p><strong>时钟页面替换算法Clock：</strong>一个页面首次装入内存，其“引用位”置1。内存中的任何页面被访问时， ”引用位”置1。淘汰页面时，从指针当前指向的页面开始扫描循环队列，把迁到的”引用位”是1的页面的”引用位”清0，跳过这个页面；<strong>把所迁到的”引用位”是0的页面淘汰掉</strong>，指针推进一步。扫描循环队列时，如果迁到的所有页面的”引用位”为1，指针就会绕整个循环队列一圈，把碰到的所有页面的”引用位”清0；指针停在起始位置，并淘汰掉这一页，然后，指针推进一步。</p><ul><li>可以结合修改位对时钟页面替换算法进行改进。若用(访问位，修改位)的形式表述，则<ul><li>第一轮：淘汰(0, 0)</li><li>第二轮：淘汰(0, 1) ，并将扫描过的页面访问位都置为0</li><li>第三轮：淘汰(0, 0)</li><li>第四轮：淘汰(0, 1)</li></ul></li></ul><h2 id="页面分配策略">4.3 页面分配策略</h2><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p>分配策略：</p><ul><li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。只要有一个缺页中断产生,进程就会有一页被替换。</li><li>可变分配：先为每个进程分一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。进程执行的某阶段缺页率较高,说明目前局部性较差，系统可多分些页框以降低缺页率，反之说明进程目前的局部性较好,可减少分给进程的页框数。</li></ul><p>置换策略：</p><ul><li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul><p>从何处调入页面：</p><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的<br>部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关概念&quot;&gt;1 相关概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15877892594926.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;从写程序到程序运行&quot;&gt;1.1 从写程序到程序运行&lt;/h2&gt;&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
