<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-11-05T17:17:13.051Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写给Java程序员的Go语言学习指南（一）</title>
    <link href="https://www.codetool.top/article/%E5%86%99%E7%BB%99Java%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.codetool.top/article/写给Java程序员的Go语言学习指南（一）/</id>
    <published>2020-11-01T14:38:30.000Z</published>
    <updated>2020-11-05T17:17:13.051Z</updated>
    
    <content type="html"><![CDATA[<p>Hello我的读者们（假装有）好久不见，作为一个Javaer转Gopher已经有一段时间了，近期打算写一个对Java程序员友好的转型Go语言的系列文章（说不定有些人有这个需求呢），因为没有系统学习过Go语言，所以写这个系列的目的还包括巩固一下自己的Go语言基础，目前我还是一个Go语言新手，所以我的一些理解不一定正确，如果我以后对这个系列中提到的内容有了更深的理解，会回来修订的。</p><p>这个系列的目标读者是有一定编程基础的Java码农，因此我在后面讲Go语言基础的时候不会详尽的讲一些所有编程语言中都较普遍的语法，而倾向于讲Go中的特色语法，并将其和Java进行比较，带你快速上手Go。</p><p>另外，作为一个已经工作了的社会人儿~以后的文章会偏原创的，尽量写我参阅官方文档和实际工作中学到的内容，避免总是借鉴别人的内容。</p><p>那么进入正题，首先，当我们初学一门技术的时候，都得了解清楚这门技术的优缺点，明白我们为什么需要学习这门技术。</p><p>所以，同样的，让我们先来解决这个问题：<strong>为什么要学习Go语言?</strong></p><h1 id="为什么要学习Go语言">1 为什么要学习Go语言</h1><h2 id="Go语言的介绍">1.1 Go语言的介绍</h2><p>首先，Go语言是一门高级语言，并且是一门<strong>服务端语言</strong>，这是最基础的，可以拿它和Java、Python这样的语言进行比较，但不太适合将其与SHELL、JavaScript、C这类语言进行比较。</p><p>Go语言也是一门<code>C-like</code>语言，这是指它属于<code>C-family</code>中的一员，是C语言的衍生语言。但我个人觉得Go语言的语言和C、Java并不是非常相似，特别是当你遇到没有while、变量名在类型前、面向接口编程等语法特性时，可能需要好好适应一会儿。</p><p>所以，既然有这么多后端语言了，我们为什么还要学习Go语言呢，下面就来看看Go语言的一些特点。</p><h2 id="Go语言的特点">1.2 Go语言的特点</h2><h3 id="语法简单">1.2.1 语法简单</h3><p>Go语言相比起其他面向对象的语言少了很多高级特性，例如不存在泛型、没有继承、没有如Java一般诸多内建的工具类、集合类，也没有如Python一些非常简化的语法如列表生成式、map-reduce。在某些观点中，这些高级特性有时会使代码变得臃肿、可读性降低，而<strong>Go的语法非常简单，除了作为一门编程语言最基本的流程控制、变量声明、运算操作之外，其他的功能并没有太多，这使得Go代码的可读性较好，但同样会造成一些不方便。</strong></p><p>智者见仁，仁者见智，有些人也觉得Go语言的代码可读性差，关于这点，你可以看下面几篇我的leetcode刷题笔记，比较一下Java、Go、Python的写法各具有什么特点。</p><ul><li><a href="../leetcode1-两数之和">leetcode1-两数之和</a></li><li><a href="../leetcode2-两数相加">leetcode2-两数相加</a></li></ul><h2 id="轻量的协程支持">1.3 轻量的协程支持</h2><p>Go语言的并发模型也是Go语言引以为傲的特性之一。</p><p>关于协程（coroutinue）是什么，可以看我的另一篇笔记<a href="../深入理解java虚拟机第三版读书笔记12">深入理解java虚拟机第三版读书笔记12</a>，通俗来说，协程就是由应用程序模拟的线程（用户级线程），操作系统感知不到协程的存在，协程比线程更轻量，由于是应用程序实现的调度模型，因此协程间的调度不需要经过内核，也不需要频繁的两态转换。</p><p>在Go语言中，协程是内建支持的，并且创建一个协程的方法也非常简单，仅需一个关键词<code>go</code>：</p><iframe src="https://run.codetool.top/?id=40" frameborder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><h2 id="跨平台的编译">1.4 跨平台的编译</h2><p>Go语言使用了提前编译（Ahead of Time，AOT）的技术，因此Go语言程序在运行时是很快的。但是AOT有个问题就是只能编译成指定平台的机器码，无法“一次编译，到处运行”。</p><p>那么这里说的“跨平台”的编译是指什么呢？默认我们使用<code>go build</code>编译出来的可执行文件都是当前操作系统可执行的文件，但假如我想在windows下编译一个linux下可执行文件，可以这样做：</p><pre><code>SET CGO_ENABLED=0  // 禁用CGOSET GOOS=linux  // 目标平台是linuxSET GOARCH=amd64  // 目标处理器架构是amd64go build</code></pre><blockquote><p>CGO是Go语言提供的一个能够在go代码中直接调用C的库函数的功能，使用了CGO的代码是不支持跨平台编译的</p></blockquote><p>可以看到，只需要指定目标操作系统的平台和处理器架构，即可实现“跨平台”地编译Go语言可执行文件。</p><p>其他的例子：</p><ol><li>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</li></ol><pre><code>// linuxCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build// windowsCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</code></pre><ol start="2"><li>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</li></ol><pre><code>// macCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build// windowsCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</code></pre><ol start="3"><li>Windows下编译Mac平台64位可执行程序：</li></ol><pre><code>SET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build</code></pre><h1 id="安装-amp-Go指令">2 安装 &amp; Go指令</h1><h2 id="安装">2.1 安装</h2><p>安装当然是去官网下载了：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> ，如果这个网站打不开，可以找国内的一些镜像资源站进行下载。</p><p>这个系列使用的Go语言版本是1.14.7，希望读者尽量选用比这个版本或更高版本。</p><p>作为一个Java码农，安装对你肯定不是问题了，但重要的是在安装完Go之后有几个环境变量需要配置（Go的特色）：</p><ul><li>GoRoot：Go的安装目录</li><li>GoPath：Go的工作区目录，建议自己建一个</li></ul><p>可以参考一下我MacOS上的配置：</p><pre><code>GOPATH=/Users/rhett/go_reposGOROOT=/usr/local/go</code></pre><h2 id="Go指令">2.2 Go指令</h2><p>Go指令当然要看官方的帮助文档了：</p><pre><code># goGo is a tool for managing Go source code.Usage:    go &lt;command&gt; [arguments]The commands are:    bug         start a bug report    build       compile packages and dependencies    clean       remove object files and cached files    doc         show documentation for package or symbol    env         print Go environment information    fix         update packages to use new APIs    fmt         gofmt (reformat) package sources    generate    generate Go files by processing source    get         download and install packages and dependencies    install     compile and install packages and dependencies    list        list packages or modules    mod         module maintenance    run         compile and run Go program    test        test packages    tool        run specified go tool    version     print Go version    vet         report likely mistakes in packages</code></pre><p>这里不详细讲各个指令了（说不定之后会单独写一篇文章来讲这些指令），使用<code>go help [command]</code>都可以看到对应的帮助文档，后面我们也会常常用到一些指令。</p><h1 id="Go语言的HelloWorld">3 Go语言的HelloWorld</h1><p>又到了我最喜欢的入门经典HelloWorld环节，直接上代码：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() {    fmt.Println(&quot;hello world!&quot;)}</code></pre><iframe src="https://run.codetool.top/?id=42" frameborder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p>其中：</p><ul><li>package 语句声明当前文件所属的包</li><li>import 语句用于引入包，这里fmt是一个内建包</li><li>func 声明函数</li><li>fmt.Println 是Go语言中的输出语句，借助了内建包fmt的功能。</li></ul><p>现在我还没有提到Go语言的IDE，那么在不借助IDE的条件下，我来教你如何运行起这样一个Go代码文件：</p><p>假设你已经向一个名为<code>main.go</code>的文件中写入了这段代码，当你的文件不在GoPath目录及其子目录下的时候，可以使用<code>go run [文件名]</code>直接编译+运行这个程序：</p><pre><code># go run main.gohello world!</code></pre><p>或者你可以先编译再运行：</p><pre><code># go build main.go# ./mainhello world!</code></pre><p>你也许已经发现，<code>go build</code>得到的产物就是一个可执行文件。</p><p>你也可以使用类似GCC的语法为编译产物取个名字：</p><pre><code># go build -o helloworld main.go# ./helloworldhello world!</code></pre><h1 id="Go语言常见FAQ（持续更新翻译）">4 Go语言常见FAQ（持续更新翻译）</h1><p>学习任何一门语言时，其官方文档才是最权威的，对于Go语言来说，我觉得学习Go语言必读的是官网的<a href="https://golang.org/doc/faq" target="_blank" rel="noopener">FAQ list</a>，里面阐述了Go语言的设计理念和设计思想，也解决了一些初学者容易产生的误区。</p><p>这里列出的FAQ，作为初学者不一定需要立刻看完，尤其是除了设计理念的后面的一些问题，我的建议是学完了Go预言的基本语法之后，可以回来看一看这部分内容。</p><p>下面翻译一些我觉得特别重要的Q&amp;A：</p><h2 id="Go语言设计的指导原则是什么？">4.1 Go语言设计的指导原则是什么？</h2><p>在设计Go语言之初，Java和C++是在Google内部最常用的服务端语言。我们认为这些语言（Java和C++）具有过多需要重复记忆的教条。一些程序员希望转向高效、流畅的语言（如Python），但代价是失去效率和类型安全。我们觉得应该用一种语言就能兼顾效率，安全性和流畅性。</p><p>Go语言尝试减少关键字的数量和含义。在整个设计过程中，我们试过减少复杂性：没有前向声明，也没有头文件；一切都只被声明一次。初始化语句的表达力强，且易于使用。关键字的语法简洁明了。复杂的变量声明例如<code>foo.Foo* myFoo = new(foo.Foo)</code>通过使用<code>:=</code>这个声明并初始化的操作符被简化。并且或许最根本是，Go语言中没有类型层次（继承）：一个类型只能是它自己，而不必去声明它和其他类型的关系。通过这些简化，Go可以在不牺牲设计的精巧性的前提下变得具有表现力并易于理解。</p><p>另一个重要的设计原则是保持类型概念的正交【博主注：正交性，由Orthogonality翻译而来，这里可以理解为类型之间的独立性，降低耦合度】。可以为任何类型实现接口方法；结构体代表数据，而接口代表抽象，等等。正交性使人们更容易理解当一些类型组合时代表了什么。</p><h2 id="Unicode标识符是怎么回事？">4.2 Unicode标识符是怎么回事？</h2><p>在设计Go语言时，我们要确保它不是以ASCII码为中心的，这意味着要扩展一些语言标识符限于7位ASCII范围的空间。目前Go语言的规则（标识符字符必须是Unicode定义的字符或数字）易于理解和实现，但有一定的限制。例如，组合字符不被允许，并且排除了某些语言，例如梵文。</p><p>这条规则还有另一个问题。由于在Go语言中exported（包外可见）的标识符必须以大写字母开头，因此，不能使某些语言的字符组成的标识符exported。目前唯一的解决方案是使用<code>X日本語</code>这样的形式，这显然不能令人满意。</p><p>自从Go语言的最早版本发布以来，我们就一直在思考如何最好地扩展标识符空间以兼容不同地区的程序员可以使用他们自己的语言。确切地说，这个问题如何解决仍然是讨论的活跃话题，并且Go语言的未来版本在标识符定义方面可能会更加宽松。例如，它可能会采用<a href="http://unicode.org/reports/tr31/" target="_blank" rel="noopener">Unicode组织关于标识符的建议</a>中的一些想法。但是无论发生什么情况，都必须在兼容（或扩展）字母大小写确定标识符可见性的方式下完成，这仍然是Go最受欢迎的功能之一。</p><p>目前，我们有一个简单的规则，可以在以后扩展而又不会破坏旧代码的兼容性，该规则修复了因允许歧义标识符的规则而引起的bug。</p><hr><p>理解：Go语言的标识符不受限于ascii字符，可以使用很多语言的字符，但没有必要。</p><h2 id="为什么Go语言没有泛型">4.3 为什么Go语言没有泛型</h2><p>在某个时间点我们可能会添加泛型的支持。即使有些程序员觉得这是一件紧急的事，但我们并不觉得。</p><p>Go语言的目标是编写出长时间易维护的服务端程序。其设计集中在伸缩性，可读性和并发性等方面。当时，多态编程对于实现该语言的目标似乎并不重要，因此为了简单起见而被略去。</p><p>Go语言现在已经更加成熟，可以考虑实现某种形式的泛型编程。但是，仍然存在一些警告。</p><p>泛型很方便，但是它以类型系统和runtime的复杂性为代价。我们一直在思考但始终尚未找到一种能平衡其带来的价值与复杂度之间的方案。同时，Go语言内置的map和slice以及其能够使用<code>interface{}</code>构造容器的能力（带有显式拆箱），意味着一些情况下它能写出和泛型能实现的功能相似的代码（可能不是那么平滑）。</p><p>这个话题保持open状态。要查看之前Go语言尝试过的设计泛型编程的失败案例，请参阅<a href="https://github.com/golang/go/issues/15292" target="_blank" rel="noopener">此提案</a>。</p><h2 id="为什么Go语言没有异常？">4.4 为什么Go语言没有异常？</h2><p>我们认为如同<code>try-catch-finally</code>这种习惯用法将异常耦合到逻辑控制结构会导致代码混乱。它还有鼓励程序员将许多常见的错误（例如无法打开文件）标记为异常的倾向。</p><p>Go语言采用了不同的错误处理方法。对于简单的错误处理，Go的多返回值会使报告错误变得容易，而不需要返回值重载。规范的<code>error</code>类型，与Go语言的其他一些特性相结合，能使错误处理令人愉悦，同时与其他语言完全不同。</p><p>Go还具有一些内建函数，可以发出信号并从真正“异常”的状况中恢复（recover）。恢复（recover）机制仅在发生错误后被破坏的一部分函数状态中执行，该机制足以处理灾难，但不需要任何额外的控制结构，如果使用得当，可以生成整洁干净的错误处理代码。</p><p>相关详细信息，请参见<a href="https://golang.org/doc/articles/defer_panic_recover.html" target="_blank" rel="noopener">Defer, Panic, and Recover</a>。另外，<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a>这篇博客文章描述了Go语言中错误即为值对象从而可以在错误处理中发挥的巨大作用。</p><h2 id="为什么基于CSP的思想设计Go语言中的并发？">4.5 为什么基于CSP的思想设计Go语言中的并发？</h2><p>并发和多线程编程长时间因其难以学习而闻名，我们认为其中一部分原因是<a href="https://en.wikipedia.org/wiki/POSIX_Threads" target="_blank" rel="noopener">pthreads</a>这样复杂的设计造成的，另一部分原因则是过于强调互斥锁、条件变量、内存屏障这样的底层细节。即使底层有这些互斥锁，更高层次的语言接口应该能写出更简单的代码。</p><p>Hoare设计的CSP（Communicating Sequential Processes）模型是为高级语言提供并发支持的最成功模型之一。Occam和Erlang是基于CSP思想设计的两种最知名的语言。Go的并发原语来自贡献出将channel作为最高等对象的重要思想的家族树的不同分支（不知道咋翻译，原句：<code>Go&#39;s concurrency primitives derive from a different part of the family tree whose main contribution is the powerful notion of channels as first class objects.</code>）。几种早期语言的经验表明，CSP模型非常适合过程语言框架。</p><h2 id="为什么用goroutine代替线程？">4.6 为什么用goroutine代替线程？</h2><p>Goroutines是为了让并发编程更易于使用做出的努力之一。有一个存在了一段时间的想法是，将一个独立执行的函数协程服用到一组线程上去。当一个协程阻塞时, 例如通过一个产生阻塞的系统调用, runtime会自动将同一线程中其他协程转移到另一个runnable的线程中，这样它们就不会被阻塞，而程序员看不到这些底层实现。这样会使我们使用goroutine的成本很低：它们在栈上的开销很小，通常只有几kb。</p><p>为了使栈空间使用更少, Go语言的runtime使用可扩容的、与goroutine绑定的私有栈。 新创建的goroutine只会被分配几个kb, 而这通常已足够使用。当这些空间不够时， runtime会自动扩容（缩容）内存以容纳栈空间，这容许许多goroutine共存于现代容量巨大的内存中。每个函数调用的CPU开销平均只有三条简单的指令，在同一片内存空间创建成百上千的goroutine是十分有用的。如果不用goroutine而是使用线程, 系统资源会被更容易消耗殆尽。</p><h2 id="Go是一门面向对象的语言吗？">4.7 Go是一门面向对象的语言吗？</h2><p>可以说是或者不是。尽管Go语言的类型和方法允许面向对象风格的编程, 但没有类型层级（继承）。Go语言中“接口”的概念提供了一种我们认为更易使用并在某种程度上更通用的使用方法。Go语言有一些方法可以将类型嵌入到其他类型中，以实现类似（但不完全相同）其他语言中继承的功能。还有, Go语言的方法比C++或Java中的更通用：它们可以为任何数据类型定义, 例如“拆箱”的整数这样的内置的类型。方法的实现并不限定在结构体（类）中。</p><p>并且，Go语言中缺少类型继承导致Go中的”对象“比C++、Java中的更轻量。</p><h2 id="怎样能够动态分派方法呢？">4.8 怎样能够动态分派方法呢？</h2><p>Go语言中只有一种途径可以动态分派方法：通过接口。结构体或其他确定的类型的方法总是静态解析的。</p><h2 id="为什么Go语言不支持重载方法或操作符？">4.9 为什么Go语言不支持重载方法或操作符？</h2><p>如果不去做类型匹配，方法分派会非常简单。其他语言的经验告诉我们大量相同名称但不同方法签名的函数有时会很有用，但在实践中可能会造成混淆。仅通过名称匹配并要求类型一致是一个主要使得Go类型系统简化的决定。</p><p>至于操作符重载, 貌似其必要性不超过其便利性。没有它，语言能更加简化。</p><h2 id="可以将-T转换为-interface-吗？">4.10 可以将[]T转换为[]interface{}吗？</h2><p>不能直接转换，没有相同内存指向的类型直接转换是不符合语言规范的。单有必要单独地将原切片中的元素逐一地复制到目标切片中去。例如下面这段代码将<code>int</code>切片复制到<code>interface{}</code>切片中去：</p><pre><code class="go">t := []int{1, 2, 3, 4}s := make([]interface{}, len(t))for i, v := range t {    s[i] = v}</code></pre><h2 id="如果T1和T2所指同一个类型，可以将-T1转换为-T2吗？">4.11 如果T1和T2所指同一个类型，可以将[]T1转换为[]T2吗？</h2><p>下面这段例子中最后一行代码是不能编译的：</p><pre><code class="go">type T1 inttype T2 intvar t1 T1var x = T2(t1) // OKvar st1 []T1var sx = ([]T2)(st1) // NOT OK</code></pre><p>Go语言中，类型是紧密绑定到方法的, 每个命名类型都有属于自己的一个方法集合（可能是空的）。 大体上的规则是，你可以改变转换后的类型名称（同时也会改变它的方法集合），但你不能改变一个集合类型中元素的类型名和方法集合. 并且Go语言要求显式的类型转换。</p><h2 id="为什么error的nil值不等于nil">4.12 为什么error的nil值不等于nil?</h2><p>在底层, 接口被实现为两个部分, 一个类型T和值V。V是一个确定的值例如整数、结构体或指针, 但不会是接口本身, 并且有一个类型T。举个例子，如果我们在接口中存储一个整数3, 最终的接口值为 <code>T=int, V=3</code>。值V也被称为接口的动态值，鉴于在程序执行过程中，一个给定的接口变量在不同时间可能会有不同的值V。</p><p>仅当V和T都没有设定时，一个接口值才是nil（<code>T=nil, V is not set</code>），特别的，一个nil接口总是有一个nil类型。如果我们存储一个<code>*int</code>类型的nil指针在接口中, 内部类型仍会为<code>*int</code>而不管值V是什么（<code>T=*int, V=nil</code>）。因为这样一个接口即使其值V为nil，它也可以不是一个nil。</p><p>这样的情形可能会变得令人疑惑，特别是一个nil存储在接口例如error中进行返回：</p><pre><code class="go">func returnsError() error {    var p *MyError = nil    if bad() {        p = ErrBad    }    return p // Will always return a non-nil error.}</code></pre><p>如果一切顺利，这个函数会返回一个nil p，于是这个返回值是容纳在一个error接口中的 (T=*MyError, V=nil)。这意味着如果调用者将这个返回的error与nil比较，看起来似乎总会是有错误发生，即使实际一切正常。为了返回一个正确的nil error给调用者，这个函数必须返回一个显式的nil：</p><pre><code class="go">func returnsError() error {    if bad() {        return ErrBad    }    return nil}</code></pre><p>在函数中返回错误，为了保证错误被正确创建，在方法签名中使用error类型代替一个精确的错误类型（例如<code>*MyError</code>）总是一个好的实践（就像我们上面做的那样）。举个例子, <a href="https://golang.org/pkg/os/#Open" target="_blank" rel="noopener">os.Open</a> 始终返回一个error，如果不是nil，则必是一个特定类型<a href="https://golang.org/pkg/os/#PathError" target="_blank" rel="noopener">*os.PathError</a>。</p><p>类似这样的情况在使用接口时都会出现。记住只要接口中存储了任何具体值，它就不会为nil。想了解更多信息，请参阅<a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">The Laws of Reflection</a></p><hr><p>代码示例：</p><iframe src="https://run.codetool.top/?id=41" frameborder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><h2 id="Go语言中的常量是什么样的？">4.13 Go语言中的常量是什么样的？</h2><p>尽管Go语言对数字类型的变量之间的类型转换要求很严格, 常量却灵活多了。字面常量例如23，3.14159和<code>math.Pi</code>可以占用理想的内存空间、任意的精度，且不会上溢或下溢。例如<code>math.Pi</code>的值在源码中限定在63位，但涉及这个数的常量表达式却可以超过float64的计算精度。仅当这个常量或常量表达式被赋值给一个内存中的变量时，它才成为了一个“电子化”的数字并按照浮点数的标准舍去精度。</p><p>另外，因为他们只是数字，没有指定类型，所以Go语言中的常量比变量更容易使用，避免了类型转换问题的尴尬。你可以写这样的表达式：</p><pre><code class="go">sqrt2 := math.Sqrt(2)</code></pre><p>编译器不会报错，因为在调用<code>math.Sqrt</code>函数时可以把参数2安全地将类型、精度转换为float64.</p><p><a href="https://blog.golang.org/constants" target="_blank" rel="noopener">Constants</a> 这篇博客详细地探讨了该主题。</p><h2 id="64位机器上的int占用多大空间？">4.14 64位机器上的int占用多大空间？</h2><p><code>int</code>和<code>uint</code>的大小是独立实现的，但在一个给定的平台上占用的空间总是相同的，在32位机器上编译器使用32位整数，而64位机器上使用64位整数（尽管从历史上看，这不总是正确的）。为了实现可移植性，需要特定大小的值应该使用带有显式大小的类型，例如<code>int64</code>。。</p><p>另外，出于编程人员在使用浮点数时必须注意精度带来的影响的考虑，浮点数和复数的大小总是限定的（没有<code>float</code>或<code>complex</code>这两种基本类型）。浮点数字面量默认使用的类型是<code>float64</code>，例如<code>foo := 3.0</code>声明了一个<code>float64</code>的变量。如果要使用字面常量初始化一个<code>float32</code>的变量，必须通过下面的变量声明显式指定类型：</p><pre><code class="go">var foo float32 = 3.0</code></pre><p>或者，你可以通过类型转换做到同样的效果：<code>foo := float32(3.0)</code></p><h2 id="如何知道变量是在堆上还是在栈上分配？">4.15 如何知道变量是在堆上还是在栈上分配？</h2><p>从程序正确性的角度来看，你不需要关心。只要保留有引用，Go语言中的每个变量都会持续存在。至于实际选择的存储位置不会影响编程时的语义。</p><p>然而了解存储位置确实对于编写高效的程序有帮助。Go编译器会尽可能在函数的私有堆栈帧中分配该函数的本地变量。但是，如果编译器无法证明函数返回后该变量就不会被引用，则编译器必须在堆上分配该变量，以避免悬空指针错误。同样，如果局部变量很大，则将其分配在堆而不是栈上可能更为合理。</p><p>在当前的编译器中，如果使用了变量的地址，则该变量大概率是在堆上分配。但是，基本的逃逸分析可以识别某些变量不会逃出函数作用范围的情况，此时变量可以分配在栈上。</p><h2 id="哪些操作是原子的？互斥量又是什么？">4.16 哪些操作是原子的？互斥量又是什么？</h2><p>Go语言并发操作相关的描述可以参阅文档<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">Go Memory Model document</a>。</p><p>低级的同步和并发原语可以在<code>sync</code>和<code>sync/atomic</code>中找到。这两个包适用于一些简单的任务例如增加引用计数或保证小规模的互斥。</p><p>为了支持更高级别的操作，例如分布式服务器之间的协作，使用更高层次的技术可以方便写出更好的程序, Go语言通过gorountine和channel提供了对于这些的支持。 例如，你可以将你的程序构建成同一时间只有一个goroutine负责一块特定的数据处理。这种方法在<a href="https://www.youtube.com/watch?v=PAAkCSZUG1c" target="_blank" rel="noopener">Go proverb</a>中有所介绍。</p><p><strong>不要通过共享内存来通信，你应该使用通过通信来共享内存。</strong></p><p>参阅<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">Share Memory By Communicating</a>代码部分，还有它的<a href="https://blog.golang.org/codelab-share" target="_blank" rel="noopener">关联文章</a>是对于这一概念详细的讨论。</p><p>大型并发程序很可能会同时借助这两个工具包的功能。</p><h2 id="为什么goroutine没有ID">4.17 为什么goroutine没有ID?</h2><p>Goroutine没有名称，他们是无名工作者. 它们不向编程人员暴露出唯一标识符、名称或数据结构。有些人会对此感到惊奇，期望着之后会出现能返回一些能用来访问和控制goroutine的Go语句。</p><p>Goroutine是匿名的最根本的原因是，只有这样，在编写并发代码时，所有的Go语句都能被使用。否则在使用命名线程和goroutine的时候会限制于使用它们的库中。</p><p>这是一个命名goroutine造成复杂度的例证：一旦某个人对goroutine进行命名并围绕它创建了模型，它就变得非常特别，并且人们会倾向于将所有的计算任务与这个goroutine关联起来，而忽视了使用多个可能共享的goroutine进行处理的可能性。倘若 <code>net/http</code> 包为每一个request状态关联一个goroutine，客户端在处理一个请求时将不能使用更多的goroutine。</p><p>另外，在一些要求在主线程上处理所有计算的图形系统的库的经验表明，当在一个并发语言中部署时，这种情况的尴尬和局限性。特殊线程和goroutine的存在迫使编程人员对程序进行不必要的操作以避免操作了错误的线程而导致的崩溃和其他问题。</p><p>对于那些特定的goroutine确实尤为特别的情况，Go语言提供了一些诸如channel的功能，通过灵活使用它来与特定goroutine交互。</p><h2 id="为什么-和–是语句而不是表达式？为什么使用后缀而不是前缀？">4.18 为什么++和–是语句而不是表达式？为什么使用后缀而不是前缀？</h2><p>如果没有指针运算，则前缀和后缀增量运算符的便利性将会下降。将它们从表达式中彻底删除，可以简化表达式语法，并且还消除了围绕++和–的求值顺序的混乱问题（考虑<code>f(i++)</code>和<code>p[i] = q[++i]</code>）。简化的意义重大。而至于后缀和前缀，两者都可以正常工作，但后缀版本更传统。STL坚持使用前缀增量运算符，STL是一种语言的标准库，而具有讽刺意味的是，这种语言的名称包含后缀增量运算符。</p><p>博主注：解释一下，这里是一个冷笑话，因STL指的是C++的Standard Template Library（标准模板库），而C++的名称你懂的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello我的读者们（假装有）好久不见，作为一个Javaer转Gopher已经有一段时间了，近期打算写一个对Java程序员友好的转型Go语言的系列文章（说不定有些人有这个需求呢），因为没有系统学习过Go语言，所以写这个系列的目的还包括巩固一下自己的Go语言基础，目前我还是一
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="GoLang" scheme="https://www.codetool.top/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>为什么说Java只有值传递？</title>
    <link href="https://www.codetool.top/article/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/"/>
    <id>https://www.codetool.top/article/为什么说Java只有值传递？/</id>
    <published>2020-06-26T03:20:14.000Z</published>
    <updated>2020-06-26T04:20:10.684Z</updated>
    
    <content type="html"><![CDATA[<p>先说一下。。以后可能不会怎么写Java相关的博客了，因为找到了字节跳动的实习工作，用Go/Python开发后端，所以这几天在抓紧时间学Go，在学Go的时候，了解到Go语言只有值传递，我突然就想起网上对Java是引用传递还是值传递有很多种说法，那么我的看法是：Java中同样只有值传递。理由且听我慢慢道来。</p><h1 id="最简单的验证方法">1 最简单的验证方法</h1><p>其实要验证Java只有值传递有个非常简单的方法。首先我们要了解值传递和引用传递的区别是什么，其实“引用传递”这个词，在C++语言中听到得最多，在值传递中，实参是传入对象的一份拷贝，因此对参数的修改不会影响传入的对象。而在引用传递中，传递的是对象的一个别名，若创建引用后，原对象的地址发生改变，引用的对象依然不会改变，而这种机制目前我只在C++语言中听说过。（主要还是学过的编程语言太少）</p><p>这种机制甚至在C语言中都没有，那么C语言要通过函数去改变一个参数该怎么办呢？正确的做法是<strong>指针传递</strong>。</p><pre><code class="c">void swap(int *a,int *b){    int temp;    temp = *a    *a = *b;    *b = temp;}</code></pre><p><strong>指针传递</strong>可以改变传入的参数，那么它是引用传递吗？并不是，它只是传递了指针的值，而函数内部因为获取了指针的值，于是可以通过指针获取指向的对象，从而修改它。</p><p><strong>指针传递</strong>在C++中也可以使用，而C++要实现同样的功能还可以使用引用传递：</p><pre><code class="cpp">void swap(int&amp; a, int&amp; b){    int swap = a;    a = b;    b = swap;}</code></pre><p>那么这两种方法有什么区别呢？区别就是，在指针传递的方法中，改变指针的值，外部并不会变化。</p><p>例如下面这段代码（引用传递）输出10，引用发生改变：</p><iframe src="https://run.codetool.top/?id=36" frameborder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p>而下面这段代码（指针传递）则还是输出5，因为外部的指针不会随之发生改变：</p><iframe src="https://run.codetool.top/?id=38" frameborder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p>那么，通过这两个示例，我们就可以写出一段Java代码来验证一下Java中是引用传递还是值传递：</p><iframe src="https://run.codetool.top/?id=39" frameborder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p>既然网上很多资料说，Java除了基本类型，都是引用传递，那么我们这里就写了一个类进行测试，在函数内部去修改了一下获取的参数。</p><p>你可以尝试运行这段代码，输出的结果仍是：<code>TestObject{value=1}</code>，说明它和C++中的<strong>指针传递</strong>的机制是一样的。这也是为什么我认为Java中都是值传递的原因。</p><h1 id="Java中不是没有指针吗？">2 Java中不是没有指针吗？</h1><p>Java只是对使用者封装了指针的概念，我们看下面这行代码：</p><pre><code class="java">Object o = new Object();</code></pre><p><code>new Object()</code>实际上是在堆上创建了一个对象，<strong>而<code>o</code>这个局部变量，是分配在栈上的，一个八字节的引用（reference）类型，指向堆上的对象</strong> </p><p>所以可以认为<code>o</code>就是一个指针，具体的机制在<a href="../深入理解java虚拟机第三版读书笔记03">深入理解java虚拟机第三版读书笔记03–1.3 对象的访问定位</a>中也有提到，<strong>HotSpot使用的对象访问定位的方式是直接指针访问，栈上的reference数据存储的就是对象在堆中的地址。</strong></p><p>因此我倾向于认为，Java的这种传参方式，类似于C++中的指针传递，并没有引用传递的概念，因此可以说，Java中只有值传递。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先说一下。。以后可能不会怎么写Java相关的博客了，因为找到了字节跳动的实习工作，用Go/Python开发后端，所以这几天在抓紧时间学Go，在学Go的时候，了解到Go语言只有值传递，我突然就想起网上对Java是引用传递还是值传递有很多种说法，那么我的看法是：Java中同样只
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="https://www.codetool.top/tags/Java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1413-逐步求和得到正数的最小值</title>
    <link href="https://www.codetool.top/article/leetcode1413-%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode1413-逐步求和得到正数的最小值/</id>
    <published>2020-06-21T13:28:43.000Z</published>
    <updated>2020-06-21T13:30:58.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 <strong>正数</strong> startValue 作为初始值。</p><p>你需要从左到右遍历 <code>nums</code> 数组，并将 startValue 依次累加上 <code>nums</code> 数组中的值。</p><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 <strong>正数</strong> 作为 startValue 。</p><p><strong>示例 1:</strong></p><pre><strong>输入：</strong>nums = [-3,2,-3,4,2]<strong>输出：</strong>5<strong>解释：</strong>如果你选择 startValue = 4，在第三次累加时，和小于 1 。<strong>                累加求和&nbsp;               startValue = 4 | startValue = 5 | nums</strong>&nbsp;                 (4 <strong>-3</strong> ) = 1  | (5 <strong>-3</strong> ) = 2    |  -3&nbsp;                 (1 <strong>+2</strong> ) = 3  | (2 <strong>+2</strong> ) = 4    |   2&nbsp;                 (3 <strong>-3</strong> ) = 0  | (4 <strong>-3</strong> ) = 1    |  -3&nbsp;                 (0 <strong>+4</strong> ) = 4  | (1 <strong>+4</strong> ) = 5    |   4&nbsp;                 (4 <strong>+2</strong> ) = 6  | (5 <strong>+2</strong> ) = 7    |   2</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [1,2]<strong>输出：</strong>1<strong>解释：</strong>最小的 startValue 需要是正数。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>nums = [1,-2,-3]<strong>输出：</strong>5</pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>找到最小的前缀和，算出与1的差值。（如果大于等于1则返回1）</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int minStartValue(int[] nums) {        int min = nums[0];        for(int i = 1;i &lt; nums.length;i++){            nums[i] += nums[i-1];            if(nums[i]&lt;min) min = nums[i];         }        return min&gt;=1 ? 1 : 1-min;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。你可以选定任意的 &lt;strong&gt;正数&lt;/strong&gt; startValue 作为初始值。&lt;/p&gt;
&lt;p&gt;你需要从左到右遍历 &lt;code&gt;nums&lt;/code&gt; 数组，并将 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题解链接合集</title>
    <link href="https://www.codetool.top/article/leetcode%E9%A2%98%E8%A7%A3%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86/"/>
    <id>https://www.codetool.top/article/leetcode题解链接合集/</id>
    <published>2020-06-20T05:06:52.000Z</published>
    <updated>2020-07-05T10:31:21.645Z</updated>
    
    <content type="html"><![CDATA[<p>慢慢更，把以前做过的题解整理在一起，方便找一些。</p><h1 id="leetcode">1 leetcode</h1><ul><li><a href="../leetcode1-两数之和">leetcode1-两数之和</a> （已二刷）</li><li><a href="../leetcode2-两数相加">leetcode2-两数相加</a> （已二刷）</li><li><a href="../leetcode3-无重复字符的最长子串">leetcode3-无重复字符的最长子串</a> （已二刷）</li><li><a href="../leetcode4-寻找两个有序数组的中位数">leetcode4-寻找两个有序数组的中位数</a></li><li><a href="../leetcode5-最长回文子串">leetcode5-最长回文子串</a></li><li><a href="../leetcode7-整数反转">leetcode7-整数反转</a></li><li><a href="../leetcode8-字符串转换整数atoi">leetcode8-字符串转换整数atoi</a></li><li><a href="../leetcode9-回文数">leetcode9-回文数</a></li><li><a href="../leetcode11-盛最多水的容器">leetcode11-盛最多水的容器</a></li><li><a href="../leetcode12-整数转罗马数字">leetcode12-整数转罗马数字</a></li><li><a href="../leetcode13-罗马数字转整数">leetcode13-罗马数字转整数</a></li><li><a href="../leetcode14-最长公共前缀">leetcode14-最长公共前缀</a></li><li><a href="../leetcode15-三数之和">leetcode15-三数之和</a></li><li><a href="../leetcode16-最接近的三数之和">leetcode16-最接近的三数之和</a></li><li><a href="../leetcode17-电话号码的字母组合">leetcode17-电话号码的字母组合</a></li><li><a href="../leetcode18-四数之和">leetcode18-四数之和</a></li><li><a href="../leetcode19-删除链表的倒数第N个节点">leetcode19-删除链表的倒数第N个节点</a></li><li><a href="../leetcode20-有效的括号">leetcode20-有效的括号</a></li><li><a href="../leetcode21-合并两个有序链表">leetcode21-合并两个有序链表</a></li><li><a href="../leetcode22-括号生成/">leetcode22-括号生成</a></li><li><a href="../leetcode23-合并K个排序链表">leetcode23-合并K个排序链表</a></li><li><a href="../leetcode24-两两交换链表中的节点">leetcode24-两两交换链表中的节点</a></li><li><a href="../leetcode25-K个一组翻转链表">leetcode25-K个一组翻转链表</a></li><li><a href="../leetcode26-删除排序数组中的重复项">leetcode26-删除排序数组中的重复项</a></li><li><a href="../leetcode27-移除元素">leetcode27-移除元素</a></li><li><a href="../leetcode28-实现strStr">leetcode28-实现strStr</a></li><li><a href="../leetcode32-最长有效括号">leetcode32-最长有效括号</a></li><li><a href="../leetcode33-搜索旋转排序数组">leetcode33-搜索旋转排序数组</a></li><li><a href="../leetcode34-在排序数组中查找元素的第一个和最后一个位置/">leetcode34-在排序数组中查找元素的第一个和最后一个位置</a></li><li><a href="../leetcode35-搜索插入位置">leetcode35-搜索插入位置</a></li><li><a href="../leetcode36-有效的数独">leetcode36-有效的数独</a></li><li><a href="../leetcode38-外观数列">leetcode38-外观数列</a></li><li><a href="../leetcode39-组合总和">leetcode39-组合总和</a></li><li><a href="../leetcode40-组合总和II">leetcode40-组合总和II</a></li><li><a href="../leetcode41-缺失的第一个正数">leetcode41-缺失的第一个正数</a></li><li><a href="../leetcode42-接雨水">leetcode42-接雨水</a></li><li><a href="../leetcode45-跳跃游戏II">leetcode45-跳跃游戏II</a></li><li><a href="../leetcode46-全排列">leetcode46-全排列</a></li><li><a href="../leetcode47-全排列II">leetcode47-全排列II</a></li><li><a href="../leetcode49-字母异位词分组">leetcode49-字母异位词分组</a></li><li><a href="../leetcode50-Pow-x-n">leetcode50-Pow(x,n)</a></li><li><a href="../leetcode53-最大子序和">leetcode53-最大子序和</a></li><li><a href="../leetcode54-螺旋矩阵">leetcode54-螺旋矩阵</a></li><li><a href="../leetcode55-跳跃游戏">leetcode55-跳跃游戏</a></li><li><a href="../leetcode56-合并区间">leetcode56-合并区间</a> （已二刷）</li><li><a href="../leetcode57-插入区间">leetcode57-插入区间</a></li><li><a href="../leetcode59-螺旋矩阵II">leetcode59-螺旋矩阵II</a></li><li><a href="../leetcode60-第k个排列">leetcode60-第k个排列</a></li><li><a href="../leetcode61-旋转链表">leetcode61-旋转链表</a></li><li><a href="../leetcode62-不同路径">leetcode62-不同路径</a></li><li><a href="../leetcode63-不同路径II">leetcode63-不同路径II</a></li><li><a href="../leetcode64-最小路径和">leetcode64-最小路径和</a></li><li><a href="../leetcode66-加一">leetcode66-加一</a></li><li><a href="../leetcode67-二进制求和">leetcode67-二进制求和</a></li><li><a href="../leetcode69-x的平方根">leetcode69-x的平方根</a></li><li><a href="../leetcode70-爬楼梯">leetcode70-爬楼梯</a></li><li><a href="../leetcode71-简化路径">leetcode71-简化路径</a></li><li><a href="../leetcode72-编辑距离">leetcode72-编辑距离</a></li><li><a href="../leetcode73-矩阵置零">leetcode73-矩阵置零</a></li><li><a href="../leetcode74-搜索二维矩阵">leetcode74-搜索二维矩阵</a></li><li><a href="../leetcode75-颜色分类">leetcode75-颜色分类</a></li><li><a href="../leetcode76-最小覆盖子串">leetcode76-最小覆盖子串</a></li><li><a href="../leetcode77-组合">leetcode77-组合</a></li><li><a href="../leetcode78-子集">leetcode78-子集</a></li><li><a href="../leetcode79-单词搜索">leetcode79-单词搜索</a></li><li><a href="../leetcode80-删除排序数组中的重复项II">leetcode80-删除排序数组中的重复项II</a></li><li><a href="../leetcode81-搜索旋转排序数组II">leetcode81-搜索旋转排序数组II</a></li><li><a href="../leetcode82-删除排序链表中的重复元素II">leetcode82-删除排序链表中的重复元素II</a></li><li><a href="../leetcode83-删除排序链表中的重复元素">leetcode83-删除排序链表中的重复元素</a></li><li><a href="../leetcode84-柱状图中最大的矩形">leetcode84-柱状图中最大的矩形</a></li><li><a href="../leetcode85-最大矩形">leetcode85-最大矩形</a></li><li><a href="../leetcode86-分隔链表">leetcode86-分隔链表</a></li><li><a href="../leetcode88-合并两个有序数组">leetcode88-合并两个有序数组</a></li><li><a href="../leetcode94-二叉树的中序遍历">leetcode94-二叉树的中序遍历</a></li><li><a href="../leetcode95-不同的二叉搜索树II">leetcode95-不同的二叉搜索树II</a></li><li><a href="../leetcode96-不同的二叉搜索树">leetcode96-不同的二叉搜索树</a></li><li><a href="../leetcode98-验证二叉搜索树">leetcode98-验证二叉搜索树</a></li><li><a href="../leetcode99-恢复二叉搜索树">leetcode99-恢复二叉搜索树</a></li><li><a href="../leetcode100-相同的树">leetcode100-相同的树</a></li><li><a href="../leetcode101-对称二叉树">leetcode101-对称二叉树</a></li><li><a href="../leetcode102-二叉树的层次遍历">leetcode102-二叉树的层次遍历</a></li><li><a href="../leetcode103-二叉树的锯齿形层次遍历">leetcode103-二叉树的锯齿形层次遍历</a></li><li><a href="../leetcode104-二叉树的最大深度">leetcode104-二叉树的最大深度</a></li><li><a href="../leetcode105-从前序与中序遍历序列构造二叉树">leetcode105-从前序与中序遍历序列构造二叉树</a></li><li><a href="../leetcode106-从中序与后序遍历序列构造二叉树">leetcode106-从中序与后序遍历序列构造二叉树</a></li><li><a href="../leetcode108-将有序数组转换为二叉搜索树">leetcode108-将有序数组转换为二叉搜索树</a></li><li><a href="../leetcode110-平衡二叉树">leetcode110-平衡二叉树</a></li><li><a href="../leetcode111-二叉树的最小深度">leetcode111-二叉树的最小深度</a></li><li><a href="../leetcode112-路径总和">leetcode112-路径总和</a></li><li><a href="../leetcode116-填充每个节点的下一个右侧节点指针">leetcode116-填充每个节点的下一个右侧节点指针</a></li><li><a href="../leetcode117-填充每个节点的下一个右侧节点指针II">leetcode117-填充每个节点的下一个右侧节点指针II</a></li><li><a href="../leetcode118-杨辉三角">leetcode118-杨辉三角</a></li><li><a href="../leetcode119-杨辉三角II">leetcode119-杨辉三角II</a></li><li><a href="../leetcode121-买卖股票的最佳时机">leetcode121-买卖股票的最佳时机</a></li><li><a href="../leetcode122-买卖股票的最佳时机II">leetcode122-买卖股票的最佳时机II</a></li><li><a href="../leetcode123-买卖股票的最佳时机III">leetcode123-买卖股票的最佳时机III</a></li><li><a href="../leetcode124-二叉树中的最大路径和">leetcode124-二叉树中的最大路径和</a></li><li><a href="../leetcode125-验证回文串">leetcode125-验证回文串</a></li><li><a href="../leetcode128-最长连续序列">leetcode128-最长连续序列</a></li><li><a href="../leetcode131-分割回文串">leetcode131-分割回文串</a></li><li><a href="../leetcode133-克隆图">leetcode133-克隆图</a></li><li><a href="../leetcode134-加油站">leetcode134-加油站</a></li><li><a href="../leetcode135-分发糖果">leetcode135-分发糖果</a></li><li><a href="../leetcode136-只出现一次的数字">leetcode136-只出现一次的数字</a></li><li><a href="../leetcode138-复制带随机指针的链表">leetcode138-复制带随机指针的链表</a></li><li><a href="../leetcode141-环形链表">leetcode141-环形链表</a></li><li><a href="../leetcode142-环形链表II">leetcode142-环形链表II</a></li><li><a href="../leetcode144-二叉树的前序遍历">leetcode144-二叉树的前序遍历</a></li><li><a href="../leetcode145-二叉树的后序遍历">leetcode145-二叉树的后序遍历</a></li><li><a href="../leetcode146-LRU缓存机制">leetcode146-LRU缓存机制</a></li><li><a href="../leetcode150-逆波兰表达式求值">leetcode150-逆波兰表达式求值</a></li><li><a href="../leetcode724-寻找数组的中心索引">leetcode724-寻找数组的中心索引</a> （已二刷）</li><li><a href="../leetcode1413-逐步求和得到正数的最小值">leetcode1413-逐步求和得到正数的最小值</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;慢慢更，把以前做过的题解整理在一起，方便找一些。&lt;/p&gt;
&lt;h1 id=&quot;leetcode&quot;&gt;1 leetcode&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;../leetcode1-两数之和&quot;&gt;leetcode1-两数之和&lt;/a&gt; （已二刷）&lt;/li&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典08.01-三步问题</title>
    <link href="https://www.codetool.top/article/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B808-01-%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/程序员面试金典08-01-三步问题/</id>
    <published>2020-06-19T15:40:47.000Z</published>
    <updated>2020-06-19T15:51:15.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> n = 3<br><strong>输出:</strong> 4<br><strong>说明:</strong> 有四种走法</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> n = 5<br><strong>输出：</strong> 13</p></blockquote><p><strong>提示：</strong></p><ol><li>n范围在[1, 1000000]之间</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，注意溢出的问题。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int waysToStep(int n) {        if (n &lt;= 2) {            return n;        }        int[] dp = new int[n+1];        dp[1] = 1;        dp[2] = 2;        dp[3] = 4;        for (int i = 4; i &lt; n+1; i++) {            dp[i] = (dp[i-1] + (dp[i-2] + dp[i-3]) % 1000000007) % 1000000007;        }        return dp[n];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1028-从先序遍历还原二叉树</title>
    <link href="https://www.codetool.top/article/leetcode1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode1028-从先序遍历还原二叉树/</id>
    <published>2020-06-18T03:08:25.000Z</published>
    <updated>2020-06-18T03:34:38.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>我们从二叉树的根节点 <code>root</code> 开始进行深度优先搜索。</p><p>在遍历中的每个节点处，我们输出 <code>D</code> 条短划线（其中 <code>D</code> 是该节点的深度），然后输出该节点的值。（如果节点的深度为 <em><code>D</code></em>，则其直接子节点的深度为 <em><code>D + 1</code></em>。根节点的深度为 <em><code>0</code></em>）。</p><p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p><p>给出遍历输出 <code>S</code>，还原树并返回其根节点 <code>root</code>。</p><p><strong>示例 1:</strong></p><p><img src="https://api.codetool.top/img/15924511889636.png" alt></p><blockquote><p><strong>输入：</strong> “1-2–3–4-5–6–7”<br><strong>输出：</strong> [1,2,5,3,4,6,7]</p></blockquote><p><strong>示例 2:</strong></p><p><img src="https://api.codetool.top/img/15924512241063.png" alt></p><blockquote><p><strong>输入：</strong> “1-2–3—4-5–6—7”<br><strong>输出：</strong> [1,2,5,3,null,6,null,4,null,7]</p></blockquote><p><strong>示例 3:</strong></p><p><img src="https://api.codetool.top/img/15924512434233.png" alt></p><blockquote><p><strong>输入：</strong> “1-401–349—90–88”<br><strong>输出：</strong> [1,401,null,349,88,90]</p></blockquote><p><strong>提示：</strong></p><ul><li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li><li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>好感动。。我也只能写得出这样的困难题了。</p><p>用栈来模拟DFS的过程，并记录当前节点的深度和上一个节点的深度，如果当前节点的深度 = 上一个节点的深度+1，那么说明当前节点是上一个节点的子节点，否则需要将栈中的元素弹出。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public TreeNode recoverFromPreorder(String S) {        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        int num = 0;        int prevDepth = -1;        int depth = 0;        char[] chars = S.toCharArray();        TreeNode root = null;        for(int i = 0;i&lt;chars.length;i++){            // 是数字            if(Character.isDigit(chars[i])){                num = num*10+(chars[i]-&#39;0&#39;);                // 若是一个数字的结尾字符                if(i==chars.length-1 || !Character.isDigit(chars[i+1])){                    TreeNode node = new TreeNode(num);                    // 如果depth为0，记录当前节点为根节点                    if(depth == 0) root = node;                    // 如果depth不等于prevDepth+1，说明该节点不是上一个节点的子节点，需要从栈中弹出相应的元素个数                    if(depth != prevDepth + 1){                        for(int n = 0;n&lt;prevDepth+1-depth;n++)                            stack.pop();                    }                    // 将该节点添加到上一个节点的子节点                    if(!stack.isEmpty()){                        TreeNode prev = stack.peek();                        if(prev.left == null){                            prev.left = node;                        }else prev.right = node;                    }                    stack.push(node);                    num = 0;                    prevDepth = depth;                    depth = 0;                }            }            // 是中划线，深度+1            else depth ++;        }        return root;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;我们从二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 开始进行深度优先搜索。&lt;/p&gt;
&lt;p&gt;在遍历中的每个节点处，我们输出 &lt;code&gt;D&lt;/code&gt; 条短划线（其中 &lt;code&gt;D&lt;/code&gt; 是该节点的深度），然后输出该
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1014-最佳观光组合</title>
    <link href="https://www.codetool.top/article/leetcode1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/"/>
    <id>https://www.codetool.top/article/leetcode1014-最佳观光组合/</id>
    <published>2020-06-17T09:46:36.000Z</published>
    <updated>2020-06-17T09:55:42.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定正整数数组 <code>A</code>，<code>A[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的距离为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入：</strong> [8,1,5,2,6]<br><strong>输出：</strong> 11<br><strong>解释：</strong> i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</p></blockquote><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 50000</code></li><li><code>1 &lt;= A[i] &lt;= 1000</code></li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p><code>A[i] + A[j] + i - j</code>可以视作<code>A[i] + i</code>+<code>A[j] - j</code>。</p><p>那么可以一次遍历，用一个变量max，记录遍历中出现的最大的<code>A[i] + i</code>，并与遍历过程中出现的<code>A[j] - j</code>相加，比较出<code>A[i] + i</code>+<code>A[j] - j</code>的最大值。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int maxScoreSightseeingPair(int[] A) {        int ans = 0;        int max = A[0] + 0;        for (int j = 1; j &lt; A.length; j++) {            ans = Math.max(ans, max + A[j] - j);            max = Math.max(max, A[j] + j);        }        return ans;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定正整数数组 &lt;code&gt;A&lt;/code&gt;，&lt;code&gt;A[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个观光景点的评分，并且两个景点 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 之间的距离为 &lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode403-青蛙过河</title>
    <link href="https://www.codetool.top/article/leetcode403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/"/>
    <id>https://www.codetool.top/article/leetcode403-青蛙过河/</id>
    <published>2020-06-16T03:30:26.000Z</published>
    <updated>2020-06-16T06:38:01.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。</p><p>给定石子的位置列表（用单元格序号升序表示）， <strong>请判定青蛙能否成功过河</strong>（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。</p><p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p><strong>请注意：</strong></p><ul><li>石子的数量 ≥ 2 且 &lt; 1100；</li><li>每一个石子的位置序号都是一个非负整数，且其 &lt; 2<sup>31</sup>；</li><li>第一个石子的位置永远是0。</li></ul><p><strong>示例 1:</strong></p><pre><strong>[0,1,3,5,6,8,12,17]</strong>总共有8个石子。第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,第三个石子在序号为3的单元格的位置， 以此定义整个数组...最后一个石子处于序号为17的单元格的位置。返回 <strong>true</strong>。即青蛙可以成功过河，按照如下方案跳跃： 跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</pre><p><strong>示例 2:</strong></p><pre><strong>[0,1,2,3,4,8,9,11]</strong>返回 <strong>false。</strong>青蛙没有办法过河。 这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>见代码部分</p><h2 id="代码">2.2 代码</h2><p>记忆化搜索+二分查找：</p><pre><code class="java">class Solution {    int[] stones;    Boolean canCross[][];    public boolean canCross(int[] stones) {        this.stones = stones;        if(stones[1]!=1) return false;        int n = stones.length;        canCross = new Boolean[n][n+1];        return dfs(0, 1);    }    public boolean dfs(int k, int step) {        if(k &lt; 0 || step &lt; 1) return false;        if(canCross[k][step]!=null) return canCross[k][step];        Boolean result = k == stones.length-1 ||             dfs(Arrays.binarySearch(stones, stones[k]+step+1), step+1) ||            dfs(Arrays.binarySearch(stones, stones[k]+step), step) ||            dfs(Arrays.binarySearch(stones, stones[k]+step-1), step-1);        canCross[k][step] = result;        return result;    }}</code></pre><p>使用这种方法特别骚的是，我看到有人交了下面这段代码成为了全站最快题解：</p><pre><code class="java">class Solution {    public boolean canCross(int[] stones) {        int n = stones.length;        for(int i = 1; i &lt; n; i++)            if(stones[i] - stones[i-1] &gt; i) return false;        return dfs(stones, 0, 1);    }    public boolean dfs(int[] stones, int k, int step) {        if(k &lt; 0 || step &lt; 1) return false;        return k == stones.length-1 ||            dfs(stones, Arrays.binarySearch(stones, stones[k]+step+1), step+1) ||            dfs(stones, Arrays.binarySearch(stones, stones[k]+step), step) ||            dfs(stones, Arrays.binarySearch(stones, stones[k]+step-1), step-1);    }}</code></pre><p>这个写法甚至没有对搜索结果进行记忆化处理。只是因为一开始顺序遍历一遍排除了一些步数不可能达到的情况，然后进行搜索，但是可能由于测试用例大多都是因为这个原因而判错。并且配合这种搜索算法可能比较巧，使得很多用例都快速通过了。</p><p>记忆化递归一般都能转换为动态规划，并且能避免一些递归调用带来的复杂度，因此一般都会更快，然而对于这道题，由于动态规划没有二分的优化，导致动态规划实际更慢一些：</p><pre><code class="java">class Solution {    public boolean canCross(int[] stones) {        int n = stones.length;        boolean[][] dp = new boolean[n][n+1];        dp[0][1] = true;        for(int i = 1;i&lt;n;i++){            for(int j = 0 ;j&lt;i;j++){                int step = stones[i] - stones[j];                if(step&lt;0||step&gt;n||!dp[j][step]) continue;                dp[i][step] = true;                if(step - 1 &gt;= 0) dp[i][step-1] = true;                if(step + 1 &lt;= n) dp[i][step+1] = true;                if(i == n - 1) return true;            }        }        return false;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。&lt;/p&gt;
&lt;p&gt;给定石子的位置列表（用单元格序号升序表示）， &lt;strong&gt;请判定
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode123-买卖股票的最佳时机III</title>
    <link href="https://www.codetool.top/article/leetcode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>https://www.codetool.top/article/leetcode123-买卖股票的最佳时机III/</id>
    <published>2020-06-16T03:07:55.000Z</published>
    <updated>2020-06-16T03:31:42.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [3,3,5,0,0,3,1,4]<br><strong>输出:</strong> 6<br><strong>解释:</strong> 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> [7,6,4,3,1]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 在这个情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>可以看这篇题解学习一下这种多维动态规划的思想：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/</a></p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int maxProfit(int[] prices) {        if(prices.length == 0) return 0;        // 第一个维度代表当前是第几天，第二个维度是已买入几次，第三个维度是当前是否持有股票。        int[][][] dp = new int[prices.length][3][2];        for (int i = 0; i &lt; prices.length; i++) {            for (int k = 2; k &gt;= 1; k--) {                if(i==0){                    dp[i][k][0]=0;                    dp[i][k][1]=-prices[0];                    continue;                }                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);                dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);            }        }        return dp[prices.length - 1][2][0];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 你不能同时参与多笔交易
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode83-删除排序链表中的重复元素</title>
    <link href="https://www.codetool.top/article/leetcode83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode83-删除排序链表中的重复元素/</id>
    <published>2020-06-16T01:40:05.000Z</published>
    <updated>2020-06-16T01:45:59.653Z</updated>
    
    <content type="html"><![CDATA[<p>今天打算多刷几道算法题</p><h1 id="原题">1 原题</h1><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> 1-&gt;1-&gt;2<br><strong>输出:</strong> 1-&gt;2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;3<br><strong>输出:</strong> 1-&gt;2-&gt;3</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>较简单</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public ListNode deleteDuplicates(ListNode head) {        ListNode cur = head;        while(cur != null &amp;&amp; cur.next != null) {            if(cur.val == cur.next.val) {                cur.next = cur.next.next;            } else {                cur = cur.next;            }        }        return head;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天打算多刷几道算法题&lt;/p&gt;
&lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/st
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer44-数字序列中某一位的数字</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://www.codetool.top/article/剑指offer44-数字序列中某一位的数字/</id>
    <published>2020-06-15T03:52:01.000Z</published>
    <updated>2020-06-15T03:56:52.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> n = 3<br><strong>输出:</strong> 3 </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> n = 11<br><strong>输出:</strong> 0  </p></blockquote><p><strong>限制:</strong></p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><p>注意：本题与主站 400 题相同：<a href="https://leetcode-cn.com/problems/nth-digit/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nth-digit/</a></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>确定下标处在几位数区间（10,11…99两位数区间，100,101…999三位数区间，…)</li><li>确定下标在该区间的第几个数上（如：101是三位数区间的第2个数）</li><li>计算下标所处的实际数字以及在第几位</li></ol><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int findNthDigit(int n) {        if(n &lt; 10) return n;        // 防止溢出        long base = 10;        long k = 90;        long num_n = 2;        while(n&gt;=base){            long newBase = k*num_n+base;            if(n&lt;=newBase){                long count = (n-base)/num_n;                long in_count = (n-base)%num_n;                long num = (long)Math.pow(10,num_n-1)+count;                return (int) (long) (String.valueOf(num).charAt((int) in_count) - &#39;0&#39;);            }            base = newBase;            k = k*10;            num_n+=1;        }        return 0;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。&lt;/p&gt;
&lt;p&gt;请写一
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1300-转变数组后最接近目标值的数组和</title>
    <link href="https://www.codetool.top/article/leetcode1300-%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>https://www.codetool.top/article/leetcode1300-转变数组后最接近目标值的数组和/</id>
    <published>2020-06-14T03:32:41.000Z</published>
    <updated>2020-06-14T03:54:59.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个整数数组 <code>arr</code> 和一个目标值 <code>target</code> ，请你返回一个整数 <code>value</code> ，使得将数组中所有大于 <code>value</code> 的值变成 <code>value</code> 后，数组的和最接近  <code>target</code> （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 <code>target</code> 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 <code>arr</code> 中的数字。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> arr = [4,9,3], target = 10<br><strong>输出：</strong> 3<br><strong>解释：</strong> 当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> arr = [2,3,5], target = 10<br><strong>输出：</strong> 5</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> arr = [60864,25176,27249,21296,20204], target = 56803<br><strong>输出：</strong> 11361</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^4</code></li><li><code>1 &lt;= arr[i], target &lt;= 10^5</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>先排序，然后遍历累加，如果到某个元素的时候，若后面都加这个数，总和会大于target，说明这个数及后面的数都应该被削减。削减的值算一下平均数就好。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int findBestValue(int[] arr, int target) {        Arrays.sort(arr);        //已算入的总和        int sum = 0;        for(int i = 0;i &lt; arr.length;i++){            int leftCount = arr.length-i;            int extra = sum+arr[i]*leftCount-target;            if(extra&gt;=0){                // 算一个后面累加最接近target的平均值                return arr[i]-extra/leftCount-(2*(extra%leftCount)&gt;=leftCount?1:0);            }            sum+=arr[i];        }        return arr[arr.length-1];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt; ，请你返回一个整数 &lt;code&gt;value&lt;/code&gt; ，使得将数组中所有大于 &lt;code&gt;value&lt;/code&gt; 的值变
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer35-复杂链表的复制</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>https://www.codetool.top/article/剑指offer35-复杂链表的复制/</id>
    <published>2020-06-13T11:26:19.000Z</published>
    <updated>2020-06-18T03:37:33.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1:</strong></p><p><img src="https://api.codetool.top/img/15924514074768.png" alt></p><blockquote><p><strong>输入:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br><strong>输出:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]  </p></blockquote><p><strong>示例 2:</strong></p><p><img src="https://api.codetool.top/img/15924514252157.png" alt></p><blockquote><p><strong>输入:</strong> head = [[1,1],[2,1]]<br><strong>输出:</strong> [[1,1],[2,1]]  </p></blockquote><p><strong>示例 3:</strong></p><p><img src="https://api.codetool.top/img/1592451441117.png" alt></p><blockquote><p><strong>输入：</strong> head = [[3,null],[3,0],[3,null]]<br><strong>输出：</strong> [[3,null],[3,0],[3,null]]  </p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> head = []<br><strong>输出：</strong> []<br><strong>解释：</strong> 给定的链表为空（空指针），因此返回 null。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p><strong>注意：</strong> 本题与主站 138 题相同：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我第一个想到的居然是Spring IOC解决循环依赖的思想。。先扫描一遍把节点都缓存下来，并用HashMap记录新旧节点的对应关系，然后再扫描一遍设置random节点。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public Node copyRandomList(Node head) {        Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;();        Node sentinel = new Node(0);        Node curOld = head;        Node curNew = sentinel;        while(curOld!=null ){            Node copy = new Node(curOld.val);            curNew.next = copy;            curNew = copy;            map.put(curOld,copy);            curOld = curOld.next;        }        for(Map.Entry&lt;Node,Node&gt; entry:map.entrySet()){            Node old = entry.getKey();            if(old.random != null)                map.get(old).random = map.get(old.random);        }        return sentinel.next;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;请实现 &lt;code&gt;copyRandomList&lt;/code&gt; 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 &lt;code&gt;next&lt;/code&gt; 指针指向下一个节点，还有一
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode32-最长有效括号</title>
    <link href="https://www.codetool.top/article/leetcode32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://www.codetool.top/article/leetcode32-最长有效括号/</id>
    <published>2020-06-12T07:40:04.000Z</published>
    <updated>2020-06-12T10:05:28.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> “(()”<br><strong>输出:</strong> 2<br><strong>解释:</strong> 最长有效括号子串为 “()”</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> “)()())”<br><strong>输出:</strong> 4<br><strong>解释:</strong> 最长有效括号子串为 “()()” </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>见代码部分</p><h2 id="代码">2.2 代码</h2><p>动态规划解法：</p><p><code>dp[i]</code>代表截至到某个元素的包含有效括号的子串的最长长度（必须包含该字符）。</p><p>那么若<code>s.charAt(i) == &#39;(&#39;</code>，则<code>dp[i]</code>必为0。若<code>s.charAt(i) == &#39;)&#39;</code>，分情况：</p><ul><li><code>s.charAt(i-1) == &#39;(&#39;</code>，则字符串是<code>...()</code>的形式，此时的<code>dp[i] == dp[i-2]+2</code>。</li><li><code>s.charAt(i-1) == &#39;)&#39;</code>，则字符串是<code>...))</code>的形式，此时要看与<code>s.charAt(i-1)</code>相匹配的左括号的前一个字符是否为<code>(</code>，若是，则<code>dp[i] == dp[i-1]+2+dp[prev-1]</code>，若不是，则<code>dp[i] == 0</code>。</li></ul><pre><code class="java">class Solution {    public int longestValidParentheses(String s) {        int max = 0;        int[] dp = new int[s.length()];        for(int i = 1;i&lt;dp.length;i++){            if(s.charAt(i) != &#39;(&#39;){                 if(s.charAt(i-1) == &#39;(&#39;){                    int prev = i&gt;=2?dp[i-2]:0;                    dp[i] = prev + 2;                    if(dp[i]&gt;max) max = dp[i];                }else{                    int prev = i-dp[i-1]-1;                    if(prev&gt;=0 &amp;&amp; s.charAt(prev) == &#39;(&#39;){                        dp[i] = dp[i-1]+2 + (prev==0?0:dp[prev-1]);                        if(dp[i]&gt;max) max = dp[i];                    }                }            }        }        return max;    }}</code></pre><p>栈的解法需要一些精妙的设计，要保证栈底必须有一个元素（始终留下一个最左边没参与匹配的下标在栈内）：</p><pre><code class="java">public class Solution {    public int longestValidParentheses(String s) {        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        stack.push(-1);        int max = 0;        for (int i = 0; i &lt; s.length(); i++) {            if (s.charAt(i) == &#39;(&#39;) {                stack.push(i);            } else {                stack.pop();                if (stack.empty()) {                    stack.push(i);                } else {                    max = Math.max(max, i - stack.peek());                }            }        }        return max;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个只包含 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt; 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer47-礼物的最大价值</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <id>https://www.codetool.top/article/剑指offer47-礼物的最大价值/</id>
    <published>2020-06-12T06:46:17.000Z</published>
    <updated>2020-06-12T06:48:33.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> <code>[&nbsp; [1,3,1],&nbsp; [1,5,1],&nbsp; [4,2,1]]</code><strong>输出:</strong> <code>12</code><strong>解释:</strong> 路径 1→3→5→2→1 可以拿到最多价值的礼物</pre><p>提示:</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划：<code>value[i][j] = Math.max(top,left)+grid[i][j]</code>，正好层次顺序扫描一遍就行。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int maxValue(int[][] grid) {        int height = grid.length;        int width = grid[0].length;        int[][] value = new int[height][width];        for(int i = 0;i&lt;height;i++){            for(int j = 0;j&lt;width;j++){                int top = i == 0?0:value[i-1][j];                int left = j == 0?0:value[i][j-1];                value[i][j] = Math.max(top,left)+grid[i][j];             }        }        return value[height-1][width-1];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer45-把数组排成最小的数</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>https://www.codetool.top/article/剑指offer45-把数组排成最小的数/</id>
    <published>2020-06-11T13:23:51.000Z</published>
    <updated>2020-06-11T13:27:14.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [10,2]<br><strong>输出:</strong> “102”</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [3,30,34,5,9]<br><strong>输出:</strong> “3033459”</p></blockquote><p><strong>提示:</strong></p><ul><li><code>0 &lt; nums.length &lt;= 100</code></li></ul><p><strong>说明:</strong></p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>将数组排序，类似于动态规划的思想，两个数之间相互连接比较一下。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public String minNumber(int[] nums) {        String[] strings = new String[nums.length];        for(int i = 0;i&lt;nums.length;i++){            strings[i] = String.valueOf(nums[i]);        }        Arrays.sort(strings,(s1,s2)-&gt;{            String link1 = s1+s2;            String link2 = s2+s1;            for(int i = 0;i&lt;link1.length();i++){                if(link1.charAt(i)!=link2.charAt(i)) return link1.charAt(i)-link2.charAt(i);            }            return 0;        });        StringBuilder sb = new StringBuilder();        for(String i:strings){            sb.append(i);        }        return sb.toString();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquot
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer50-第一个只出现一次的字符</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://www.codetool.top/article/剑指offer50-第一个只出现一次的字符/</id>
    <published>2020-06-10T14:39:58.000Z</published>
    <updated>2020-06-10T14:56:34.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例:</strong></p><pre>s = "abaccdeff"返回 "b"s = "" 返回 " "</pre><p><strong>限制：</strong></p><p><code>0 &lt;= s 的长度 &lt;= 50000</code></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>既然是第一个只出现一次的字符，我觉得可以用LinkedHashMap，Entries是自然按照插入顺序排序的，遍历的时候也好找。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public char firstUniqChar(String s) {        Map&lt;Character,Integer&gt; counts = new LinkedHashMap&lt;&gt;();        for(char i:s.toCharArray()){            counts.put(i,counts.getOrDefault(i,0)+1);        }        Set&lt;Map.Entry&lt;Character,Integer&gt;&gt; entries = counts.entrySet();        for(Map.Entry&lt;Character,Integer&gt; entry:entries){            if(entry.getValue() == 1) return entry.getKey();        }        return &#39; &#39;;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;s = &quot;aba
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty+Docker重构我的在线运行代码项目</title>
    <link href="https://www.codetool.top/article/%E4%BD%BF%E7%94%A8Netty-Docker%E9%87%8D%E6%9E%84%E6%88%91%E7%9A%84%E5%9C%A8%E7%BA%BF%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.codetool.top/article/使用Netty-Docker重构我的在线运行代码项目/</id>
    <published>2020-06-10T13:05:46.000Z</published>
    <updated>2020-06-12T15:01:44.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目介绍">1 项目介绍</h1><p>很久很久以前，做过一个在线运行代码的项目，见：</p><p><a href="../在线运行C++、java、python代码的小项目实现">在线运行C++、java、python代码的小项目实现</a></p><p>做这个项目的初衷，是可以在博客里嵌入一段可运行的代码，提升阅读体验。不过后来发现，除了一些Java的基础知识，也没什么知识点是单个文件可以演示出来的，所以到后面用的就不多了。</p><p>不过还是一直想把这个项目更新重构一下，毕竟之前做的那个版本安全问题太严重了（只需要写一段空循环代码，就能让CPU长时间处于100%负载，甚至还可以通过文件API去控制修改我服务器上的一些文件，而我之前是一直把这个项目跑在主力服务器上的，只是因为我的博客访问量太小，也没什么人会用这个东西，而且即使会用通常也不会想着搞点破坏，才让我这个安全漏洞百出的项目跑了这么久）</p><h1 id="技术点">2 技术点</h1><p>重构之后，我使用了 <code>Netty + Websocket + Docker</code> 的技术点，<code>WebSocket</code>用于提升一些功能性，因为有一些代码的运行时间是可以很长的（例如循环输出代码），而用户不能等待很长一段时间都没有响应，于是可以通过<code>Websocket</code>在程序运行期间即时返回一些已输出信息。</p><p>之所以为什么选用<code>Netty</code>开发<code>Websocket</code>服务端，其实主流目前使用Java开发<code>Websocket</code>服务端的技术一般就是<code>Netty</code>和<code>SpringBoot</code>，我选用<code>Netty</code>一方面是考虑平时使用<code>Netty</code>开发不多，可以通过这次项目练习巩固一下。另一方面是因为，之前考虑着和同学配合，使用Java与Go实现后端功能，由Go语言来在服务器上运行代码，然后Java和Go后端（进程间通信）通过socket连接来实现，那么Netty正好也方便socket开发。</p><p>使用<code>Docker</code>的原因则是考虑安全性了，因为使用<code>Docker</code>可以实现隔离式地运行代码，每次运行一段代码都即时创建一个容器来完成，这样即使一次运行破坏了容器也没有关系，缺点就是创建容器比较消耗时间，响应时间比较长。而对于空循环消耗系统资源的情况，目前是考虑使用超时机制来保障安全，限制一段代码最多只能运行10秒，以后可以进一步进行优化。</p><h1 id="连接Docker的关键技术——docker-java">3 连接Docker的关键技术——docker-java</h1><p>Docker服务可以通过监听端口，通过TCP、HTTP连接暴露API，供远程调用。</p><p>maven依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;    &lt;artifactId&gt;docker-java&lt;/artifactId&gt;    &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>我学习这个的使用主要是通过下面这两篇文章：</p><ul><li><a href="https://blog.csdn.net/qq_36956154/article/details/81335886" target="_blank" rel="noopener">Docker-java在java中连接Docker（一）–简单连接_杨-CSDN博客_docker-java</a></li><li><a href="https://blog.csdn.net/qq_36956154/article/details/82180551" target="_blank" rel="noopener">Docker-java在java中连接Docker（二）–安全连接_杨-CSDN博客_docker-javax509</a></li></ul><p>主要是看第二篇文章，让服务器上的Docker服务暴露一个端口，供远程连接，并通过证书来保证安全连接。</p><h1 id="开发WebSocket服务端">4 开发WebSocket服务端</h1><p>这部分可以看以前的文章：<a href="../Netty心跳检测和基于Websocket协议的服务端开发">Netty心跳检测和基于Websocket协议的服务端开发</a></p><p>启动类：</p><pre><code class="java">public class WebsocketServer {    private static final int port = 7000;    /**     * 绑定端口并启动服务器     * @param port     * @throws Exception     */    public void bind(int port) throws Exception{        //配置服务器的NIO线程组        EventLoopGroup bossGroup = new NioEventLoopGroup();        EventLoopGroup workerGroup = new NioEventLoopGroup();        try{            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup,workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, 1024)                    .childHandler(new WebSocketChannelInitializer());            System.out.println(&quot;---------服务器正在启动---------&quot;);            ChannelFuture future = serverBootstrap.bind(port).sync();            //等待服务端监听端口关闭            future.channel().closeFuture().sync();        }finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }    public static void main(String[] args) throws Exception {        new WebsocketServer().bind(port);    }}</code></pre><p>通道初始化：</p><pre><code class="java">public class WebSocketChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; {    @Override    protected void initChannel(SocketChannel ch) throws Exception {        //向管道加入处理器        //得到管道        ChannelPipeline pipeline = ch.pipeline();        //基于HTTP的编解码器        pipeline.addLast(new HttpServerCodec());        //以块方式传输数据        pipeline.addLast(new ChunkedWriteHandler());        //HTTP数据在传输过程中是分段，HttpObjectAggregator可以将多个段聚合        pipeline.addLast(new HttpObjectAggregator(1024));        //将http协议升级为websocket协议，参数代表请求的uri        pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/runcode&quot;));        pipeline.addLast(new TextWebsocketFrameHandler());    }}</code></pre><p>自定义一个WebSocket帧的处理器：</p><pre><code class="java">public class TextWebsocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; {    private DockerJavaClient dockerJavaClient = new DockerJavaClient();    /**     * 读取Websocket客户端发来的信息     * @param ctx     * @param msg     * @throws Exception     */    @Override    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {        try{            CodeWrapper codeWrapper = CodeWrapperUtil.fromJson(msg.text());            dockerJavaClient.exec(CodeLang.valueOf(codeWrapper.getLangType().toUpperCase()),codeWrapper.getContent(),ctx);            log.info(&quot;收到客户端信息：&quot;+msg.text());        }catch (Exception e){            log.warn(&quot;执行过程中出现异常：&quot;);            e.printStackTrace();            ctx.channel().writeAndFlush(new TextWebSocketFrame(&quot;发生意外，运行出错！&quot;));        }    }    /**     * 建立连接     * @param ctx     * @throws Exception     */    @Override    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {        log.info(&quot;与客户端建立连接&quot;);    }    /**     * 连接关闭     * @param ctx     * @throws Exception     */    @Override    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {        log.info(&quot;与客户端断开连接&quot;);    }    /**     * 捕获异常     * @param ctx     * @param cause     * @throws Exception     */    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        log.error(&quot;异常发生&quot;+cause.getMessage());        ctx.close();//关闭连接    }}</code></pre><h1 id="各种编程语言的枚举">5 各种编程语言的枚举</h1><p>直接看代码：</p><pre><code class="java">/** * 编程语言及其相关属性的枚举 * @author RhettPeng */public enum CodeLang {    /**     * Python语言     */    PYTHON3{        @Override        public String getImageName() {            return &quot;python:3&quot;;        }        @Override        public String getContainerNamePrefix() {            return &quot;python-running-script-&quot;;        }        @Override        public String[][] getExecCommand(String fileName) {            return new String[][]{{"python",fileName}};        }        @Override        public String getFileName() {            return &quot;temp.py&quot;;        }    },    /**     * C++语言     */    CPP{        @Override        public String getImageName() {            return &quot;gcc:7.3&quot;;        }        @Override        public String getContainerNamePrefix() {            return &quot;cpp-running-file-&quot;;        }        @Override        public String[][] getExecCommand(String fileName) {            return new String[][]{{"g++",fileName,"-o","temp"},{"./temp"}};        }        @Override        public String getFileName() {            return &quot;temp.cpp&quot;;        }    },    /**     * JAVA语言     */    JAVA{        @Override        public String getImageName() {            return &quot;openjdk:11&quot;;        }        @Override        public String getContainerNamePrefix() {            return &quot;java-running-file-&quot;;        }        @Override        public String[][] getExecCommand(String fileName) {            // jdk11可以不经过javac            return new String[][]{{"java",fileName}};        }        @Override        public String getFileName() {            return &quot;Untitled.java&quot;;        }    },    /**     * Go语言     */    GOLANG{        @Override        public String getImageName() {            return &quot;golang:1.14&quot;;        }        @Override        public String getContainerNamePrefix() {            return &quot;golang-running-file-&quot;;        }        @Override        public String[][] getExecCommand(String fileName) {            // Go可不经过编译            return new String[][]{{"go","run",fileName}};        }        @Override        public String getFileName() {            return &quot;temp.go&quot;;        }    };    private static final String SRC_PATH = &quot;/root/sourcecode/&quot;;    public String getImageName(){        return null;    }    public String getContainerNamePrefix(){        return null;    }    // 代表将一个文件运行起来需要执行的指令，供Docker EXEC调用    public String[][] getExecCommand(String fileName){        return null;    }    public String getFileName(){return null;}}</code></pre><p>这部分的功能，我一开始是考虑使用接口或枚举二者选其一来完成，后来还是选择了枚举，虽然使用接口实现更容易拓展，但枚举一可以实现单例，二能避免写很多冗杂的小类。</p><h1 id="Docker客户端的开发">6 Docker客户端的开发</h1><p>这个类是实现核心功能的类了，我一开始的思路是，在宿主机上创建几个用于存放用户源代码的目录，接收用户传来的代码后通过File API在宿主机上创建对应的文件，然后创建容器时通过数据卷绑定，让容器运行源文件。</p><p>但是这样的思路我在实现的时候遇到了一些问题，例如多个用户同时运行一段Java代码，会创建多个Java容器，由于多个容器之间是共享数据卷的，因此创建的文件名不能相同，否则会冲突，而Java文件的命名要求又必须和public类相同，因此会比较麻烦。</p><p>最终我通过创建容器的时候通过EXEC，直接将代码写入容器中的一个文件，而不经过宿主机，得到了更高的隔离性，不过这样也遇到了一些麻烦，比如我一开始是这样写的：</p><pre><code class="java">/*** 将程序代码写入容器中的一个文件* @param dockerClient* @param containerId* @param langType* @param sourcecode* @return 文件名* @throws InterruptedException*/private String writeFileToContainer(DockerClient dockerClient,String containerId,CodeLang langType,String sourcecode) throws InterruptedException {    String workDir = &quot;/usr/src/myapp&quot;;    String fileName = langType.getFileName();    String path = workDir + &quot;/&quot; + fileName;    // 创建一个指令请求    ExecCreateCmdResponse createCmdResponse = dockerClient.execCreateCmd(containerId)            // 通过重定向符写入文件            .withCmd(&quot;echo&quot;, &quot;&#39;&quot;+sourcecode+&quot;&#39;&quot;, &quot;&gt;&quot; , path)            .exec();    // 执行指令    dockerClient.execStartCmd(createCmdResponse.getId())            .exec(new ExecStartResultCallback(System.out,System.err))            .awaitCompletion();    return fileName;}</code></pre><p>主要思路是通过<code>echo</code>+重定向符，将源代码写入容器中的一个文件，但是这样写最终却发现没有创建任何文件!</p><p>后来通过搜索发现，<strong>使用<code>Docker EXEC</code>的时候，重定向符确实会失效，这是因为EXEC的环境其实不在用户SHELL中</strong>，如果要使用重定向符，需要这样修改：</p><pre><code class="java">/*** 将程序代码写入容器中的一个文件* @param dockerClient* @param containerId* @param langType* @param sourcecode* @return* @throws InterruptedException*/private String writeFileToContainer(DockerClient dockerClient,String containerId,CodeLang langType,String sourcecode) throws InterruptedException {    String workDir = &quot;/usr/src/myapp&quot;;    String fileName = langType.getFileName();    String path = workDir + &quot;/&quot; + fileName;    // 通过重定向符写入文件，注意必须要带前面两个参数，否则重定向符会失效，和Docker CMD的机制有关    ExecCreateCmdResponse createCmdResponse = dockerClient.execCreateCmd(containerId)            .withCmd(&quot;/bin/sh&quot;,&quot;-c&quot;, &quot;echo &#39;&quot;+sourcecode+&quot;&#39; &gt; &quot;+path)            .exec();    dockerClient.execStartCmd(createCmdResponse.getId())            .exec(new ExecStartResultCallback(System.out,System.err))            .awaitCompletion();    return fileName;}</code></pre><p>最终整个类：</p><pre><code class="java">/** * @author RhettPeng */public class DockerJavaClient {    /**     * 计数器，用于给容器名取后缀     */    private static int counter = 0;    /**     * 获取一个docker连接     * @return     */    public DockerClient getDockerClient(){        DockerCmdExecFactory dockerCmdExecFactory = new JerseyDockerCmdExecFactory().withReadTimeout(10000)                .withConnectTimeout(2000);        DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder()                .withDockerHost(&quot;tcp://8.129.170.210:2375&quot;)                .withDockerTlsVerify(true)                .withDockerCertPath(&quot;D:\\certs\\docker&quot;)                .withDockerConfig(&quot;D:\\certs\\docker&quot;)                .withRegistryUrl(&quot;https://index.docker.io/v1/&quot;)                .withRegistryUsername(&quot;Rhett&quot;)                .withRegistryPassword(&quot;123456&quot;)                .withRegistryEmail(&quot;995632825@qq.com&quot;)                .build();        return DockerClientBuilder.getInstance(config)                .withDockerCmdExecFactory(dockerCmdExecFactory).build();    }    /**     * 创建运行代码的容器     * @param dockerClient     * @param langType     * @return     */    private String createContainer(DockerClient dockerClient,CodeLang langType){        // 创建容器请求        CreateContainerResponse containerResponse = dockerClient.createContainerCmd(langType.getImageName())                .withName(langType.getContainerNamePrefix()+counter)                .withWorkingDir(&quot;/usr/src/myapp&quot;)                .withStdinOpen(true)                .exec();        return containerResponse.getId();    }    /**     * 将程序代码写入容器中的一个文件     * @param dockerClient     * @param containerId     * @param langType     * @param sourcecode     * @return     * @throws InterruptedException     */    private String writeFileToContainer(DockerClient dockerClient,String containerId,CodeLang langType,String sourcecode) throws InterruptedException {        String workDir = &quot;/usr/src/myapp&quot;;        String fileName = langType.getFileName();        String path = workDir + &quot;/&quot; + fileName;        // 通过重定向符写入文件，注意必须要带前面两个参数，否则重定向符会失效，和Docker CMD的机制有关        ExecCreateCmdResponse createCmdResponse = dockerClient.execCreateCmd(containerId)                .withCmd(&quot;/bin/sh&quot;,&quot;-c&quot;, &quot;echo &#39;&quot;+sourcecode+&quot;&#39; &gt; &quot;+path)                .exec();        dockerClient.execStartCmd(createCmdResponse.getId())                .exec(new ExecStartResultCallback(System.out,System.err))                .awaitCompletion();        return fileName;    }    /**     * 在容器上EXEC一条CMD命令     * @param dockerClient docker客户端     * @param command 命令，EXEC数组     * @param containerId 容器ID     * @param timeout 超时时间（单位为秒）     * @param ctx     * @param isFinal 是否是最后一条指令     * @throws InterruptedException     */    private void runCommandOnContainer(DockerClient dockerClient, String[] command, String containerId,                                       int timeout,ChannelHandlerContext ctx,boolean isFinal) throws InterruptedException {        ExecCreateCmdResponse createCmdResponse = dockerClient.execCreateCmd(containerId)                .withAttachStdout(true)                .withAttachStderr(true)                .withCmd(command)                .exec();        dockerClient.execStartCmd(createCmdResponse.getId())                .exec(new RunCodeResultCallback(ctx,isFinal))                .awaitCompletion(timeout,TimeUnit.SECONDS);    }    /**     * 执行一个程序     * @param langType 编程语言类型     * @param sourcecode 源代码     * @throws InterruptedException     * @throws IOException     */    public void exec(CodeLang langType, String sourcecode, ChannelHandlerContext ctx){        DockerClient dockerClient = getDockerClient();        // 计数器加一        counter++;        // 创建容器        String containerId = createContainer(dockerClient, langType);        // 运行容器        dockerClient.startContainerCmd(containerId).exec();        try {            writeFileToContainer(dockerClient, containerId, langType, sourcecode);            String[][] commands = langType.getExecCommand(langType.getFileName());            for(int i = 0;i&lt;commands.length;i++){                runCommandOnContainer(dockerClient, commands[i], containerId, 10, ctx,i==commands.length-1);            }        }catch (Exception e){            e.printStackTrace();        }finally {            // 移除容器            dockerClient.killContainerCmd(containerId).exec();            dockerClient.removeContainerCmd(containerId).exec();            counter--;            try {                dockerClient.close();            } catch (IOException exception) {                exception.printStackTrace();            }        }    }}</code></pre><h1 id="将Docker的响应返回给用户">7 将Docker的响应返回给用户</h1><p>至于怎么将Docker的响应返回给用户，就是在EXEC执行指令的时候，通过一个结果回调，让它持有WebSocket处理器的一个引用，这样收到一个响应就能立刻返回给用户：</p><pre><code class="java">/** * 接收到docker信息的回调 * @author RhettPeng */@Slf4jpublic class RunCodeResultCallback extends ResultCallbackTemplate&lt;ExecStartResultCallback, Frame&gt; {    private ChannelHandlerContext ctx;    private boolean isFinal;    private long startTime;    public RunCodeResultCallback(ChannelHandlerContext ctx,boolean isFinal) {        this.ctx = ctx;        this.isFinal = isFinal;        if(isFinal) {            startTime = System.currentTimeMillis();        }    }    @Override    public void onNext(Frame frame) {        log.info(&quot;收到docker响应&quot;);        if (frame != null) {            String msg = new String(frame.getPayload());            switch (frame.getStreamType()) {                case STDOUT:                case RAW:                case STDERR:                    ctx.channel().writeAndFlush(new TextWebSocketFrame(msg));                    break;                default:                    break;            }        }    }    @Override    public void onComplete() {        if(isFinal){            long endTime = System.currentTimeMillis();            ctx.channel().writeAndFlush(new TextWebSocketFrame(&quot;程序运行结束，总耗费时间：&quot;+(endTime-startTime)/1000.0+&quot;s&quot;));        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目介绍&quot;&gt;1 项目介绍&lt;/h1&gt;&lt;p&gt;很久很久以前，做过一个在线运行代码的项目，见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../在线运行C++、java、python代码的小项目实现&quot;&gt;在线运行C++、java、python代码的小项目实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做
      
    
    </summary>
    
    
      <category term="项目/编程理论" scheme="https://www.codetool.top/categories/%E9%A1%B9%E7%9B%AE-%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="CodeMirror" scheme="https://www.codetool.top/tags/CodeMirror/"/>
    
      <category term="项目" scheme="https://www.codetool.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Docker" scheme="https://www.codetool.top/tags/Docker/"/>
    
      <category term="Netty" scheme="https://www.codetool.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典17.01-不用加号的加法</title>
    <link href="https://www.codetool.top/article/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B817-01-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%8F%B7%E7%9A%84%E5%8A%A0%E6%B3%95/"/>
    <id>https://www.codetool.top/article/程序员面试金典17-01-不用加号的加法/</id>
    <published>2020-06-09T05:26:22.000Z</published>
    <updated>2020-06-09T05:54:53.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> a = 1, b = 1<br><strong>输出:</strong> 2</p></blockquote><p><strong>提示：</strong></p><ul><li><code>a</code>, <code>b</code> 均可能是负数或 0</li><li>结果不会溢出 32 位整数</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>位运算，如果把两个数看作二进制，异或之后的结果就是未算入进位部分的结果。而需要进位的数可以通过两个数的与运算得到。</p><h2 id="代码">2.2 代码</h2><pre><code class="java">class Solution {    public int add(int a, int b) {        int sum = 0, carry = 0;        while(b != 0) {            sum = a ^ b;            // 异或计算未进位的部分            carry = (a &amp; b) &lt;&lt; 1;   // 进位部分            a = sum;                // 保存未进位部分，再次计算            b = carry;              // 保存进位部分，再次计算        }        return a;    // 最后无进位，异或的结果即加法结果    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode990-等式方程的可满足性</title>
    <link href="https://www.codetool.top/article/leetcode990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/"/>
    <id>https://www.codetool.top/article/leetcode990-等式方程的可满足性/</id>
    <published>2020-06-08T04:47:47.000Z</published>
    <updated>2020-06-08T05:03:23.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> [“a==b”,”b!=a”]<br><strong>输出：</strong> false<br><strong>解释：</strong> 如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> [“b==a”,”a==b”]<br><strong>输出：</strong> true<br><strong>说明：</strong> 我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> [“a==b”,”b==c”,”a==c”]<br><strong>输出：</strong> true</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> [“a==b”,”b!=c”,”c==a”]<br><strong>输出：</strong> false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong> [“c==c”,”b==d”,”x!=z”]<br><strong>输出：</strong> true</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol><h1 id="解法">2 解法</h1><p>本题解同步发于leetcode题解：<a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/jian-ji-de-javabing-cha-ji-by-codetool/" target="_blank" rel="noopener">简洁的Java并查集</a></p><h2 id="思想">2.1 思想</h2><p>见代码部分</p><h2 id="代码">2.2 代码</h2><p>我写的这个代码没有任何优化但是很简洁，使用的HashMap实现的并查集（如果不了解并查集建议先去学习一下哦，还是蛮实用的一个数据结构的）</p><p>比较重要的思路是一定要<strong>先将字符串方程按相等到不等来排序，相等的方程用于建立并查集，不等的方程用于判断是否出错（即不等的两个代数是否出现在了同一个集合中）。</strong></p><pre><code class="java">class Solution {    public boolean equationsPossible(String[] equations) {        // 并查集        Map&lt;Character,Character&gt; father = new HashMap&lt;&gt;();        // 先将字符串方程从相等到不等排序        Arrays.sort(equations,(s1,s2)-&gt;{            if(s1.charAt(1)==s2.charAt(1)) return 0;            return s1.charAt(1)==&#39;=&#39;?-1:1;        });        for(String s:equations){            char[] chars = s.toCharArray();            char first = chars[0];            char second = chars[3];            // 获取根代表            while(father.containsKey(first) ) first = father.get(first);            while(father.containsKey(second)) second = father.get(second);            // 如果是不等，但根代表相同，说明出错            if(chars[1] == &#39;!&#39;){                if(first == second) return false;            // 如果是相等，跳过根代表相同的情况，把一个根代表连接到另一个根代表上（合并集合）            }else{                if(first == second) continue;                father.put(first, second);            }        }        return true;    }}</code></pre><p>刚看了下官方的题解并没有先排序，而是进行了两次遍历，第一次处理相等的，第二次处理不等的，确实比我写的时间复杂度要好，那么按这个思路修改之后就是：</p><pre><code class="java">class Solution {    public boolean equationsPossible(String[] equations) {        Map&lt;Character,Character&gt; father = new HashMap&lt;&gt;();        //建立并查集        for(String s:equations){            char[] chars = s.toCharArray();            if(chars[1] == &#39;=&#39;){                char first = chars[0];                char second = chars[3];                while(father.containsKey(first) ) first = father.get(first);                while(father.containsKey(second)) second = father.get(second);                if(first == second) continue;                father.put(first, second);            }        }        //检查是否有错        for(String s:equations){            char[] chars = s.toCharArray();            if(chars[1] == &#39;!&#39;){                char first = chars[0];                char second = chars[3];                while(father.containsKey(first) ) first = father.get(first);                while(father.containsKey(second)) second = father.get(second);                if(first == second) return false;            }        }        return true;    }}</code></pre><p>可以发现有一些重复代码，如果抽取成一个函数会更简洁，还有哈希集可以写成数组，时间成本会更低一些，感兴趣的小伙伴自己试试优化啦(<em>^_^</em>)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 &lt;code&gt;equations[i]&lt;/code&gt; 的长度为 &lt;code&gt;4&lt;/code&gt;，并采用两种不同的形式之一：&lt;code&gt;&amp;quot;a==b&amp;quot;&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
