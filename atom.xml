<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-04-12T07:02:56.706Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode79-单词搜索</title>
    <link href="https://www.codetool.top/article/leetcode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.codetool.top/article/leetcode79-单词搜索/</id>
    <published>2020-04-12T06:54:58.000Z</published>
    <updated>2020-04-12T07:02:56.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例:</strong></p><pre style="color:#e8eaf6">board =[  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]给定 word = "<strong style="color:#e8eaf6">ABCCED</strong>", 返回 <strong style="color:#e8eaf6">true</strong>给定 word = "<strong style="color:#e8eaf6">SEE</strong>", 返回 <strong style="color:#e8eaf6">true</strong>给定 word = "<strong style="color:#e8eaf6">ABCB</strong>", 返回 <strong style="color:#e8eaf6">false</strong></pre><p><strong>提示：</strong></p><ul><li><code>board</code> 和 <code>word</code> 中只包含大写和小写英文字母。</li><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>1 &lt;= word.length &lt;= 10^3</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>因为同一个位置的字符不能用两次，得标记，dfs回溯的时候必须把标记清除。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>board <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>board<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!=</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> ans <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向上</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向左</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向右</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//清除标记</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>下面是利用短路或剪枝后的版本，按理说更快，leetcode测试也差不多：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>board <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>board<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!=</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向上</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向左</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向右</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//清除标记</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯法" scheme="https://www.codetool.top/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>缓存一致性协议MESI</title>
    <link href="https://www.codetool.top/article/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEMESI/"/>
    <id>https://www.codetool.top/article/缓存一致性协议MESI/</id>
    <published>2020-04-11T11:46:48.000Z</published>
    <updated>2020-04-11T14:20:20.591Z</updated>
    
    <content type="html"><![CDATA[<p>明明记得在哪里学过这部分内容，还看到过一个贼好的图。。今天找了很久又没找着，这就是学了不记笔记的后果。。</p><p>本文参考资源：</p><p><a href="https://blog.csdn.net/yhb1047818384/article/details/79604976" target="_blank" rel="noopener">CPU体系结构之cache小结_运维_Hober-CSDN博客</a></p><p><a href="https://www.cnblogs.com/bjlhx/p/10658938.html" target="_blank" rel="noopener">001-CPU多级缓存架构 - bjlhx15 - 博客园</a></p><p><a href="https://blog.csdn.net/qq_26222859/article/details/52240256" target="_blank" rel="noopener">volatile与内存屏障_Java_weiqing的博客-CSDN博客</a></p><p>极客时间《深入浅出计算机组成原理》</p><h1 id="缓存一致性问题">1 缓存一致性问题</h1><p>在现代的CPU（大多数）上，所有的内存访问都需要通过层层的缓存来进行。也有些例外，比如，对映射成内存地址的I/O口、写合并（Write-combined）内存，这些访问至少会绕开这个流程的一部分。但这两者都是罕见的场景（意味着绝大多数的用户态代码都不会遇到这两种情况）。并且由于程序通常具有良好的时间局部性和空间局部性，缓存对提高程序运行的效率起到很大帮助。</p><p><img src="https://api.codetool.top/img/15866064656454.png" alt="存储器层次"></p><p>然而上面这张图没有表示清楚的是，三级缓存和CPU核心之间的关系：（由于没有找到之前看过的那张图特意找了三张图好表示清楚）</p><p><img src="https://api.codetool.top/img/15866065781911.png" alt></p><p><img src="https://api.codetool.top/img/15866062735456.png" alt></p><p><img src="https://api.codetool.top/img/158660677492.png" alt></p><p>L1是最接近CPU的，它容量最小，速度最快，<strong>每个核上都有一个L1 Cache（准确地说每个核上有两个L1 Cache，一个存数据 L1d Cache，一个存指令 L1i Cache）</strong></p><p>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下<strong>每个核上都有一个独立的L2 Cache</strong>；二级缓存就是一级缓存的缓冲器：一级缓存制造成本很高因此它的容量有限，二级缓存的作用就是存储那些CPU处理时需要用到、一级缓存又无法存储的数据。</p><p>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是最慢的一级，<strong>在同一个CPU插槽之间的核共享一个L3 Cache</strong>。三级缓存和内存可以看作是二级缓存的缓冲器，它们的容量递增，但单位制造成本却递减。</p><p><img src="https://api.codetool.top/img/15866073161132.png" alt="我电脑上的CPU cache"></p><p>高速缓存行的结构这里不提，有时间把CSAPP里面的笔记放上来。</p><p>那么这样设计的问题是什么呢？因为 CPU 的每个核各有各的缓存，互相之间的操作又是各自独立的，就会带来缓存一致性（Cache Coherence）的问题。</p><p>这里需要先提到cache写机制</p><h2 id="cache写机制">1.1 cache写机制</h2><p>Write-through（直写模式）<strong>在数据更新时，同时写入缓存Cache和后端存储</strong>。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。</p><p>Write-back（回写模式）<strong>在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储</strong>。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p><h2 id="缓存一致性问题-1">1.2 缓存一致性问题</h2><p>试想下面这样一个情况。</p><ol><li>CPU1 读取了一个字节，以及它和它相邻的字节被读入CPU1的高速缓存。</li><li>CPU2 做了上面同样的工作。这样CPU1，CPU2的高速缓存拥有同样的数据。</li><li>CPU1 修改了那个字节，被修改后，那个字节被放回CPU1的高速缓存行。但是该信息并没有被写入RAM。</li><li>CPU2 访问该字节，但由于CPU1并未将数据写入RAM（回写模式），导致了数据不同步。</li></ol><p>为了解决这个缓存不一致的问题，我们就需要有一种机制，来同步两个不同核心里面的缓存数据。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。</p><p>第一点叫<strong>写传播（Write Propagation）</strong>。写传播是说，在一个CPU 核心里，我们的 Cache 数据更新，必须能够传播到其他的对应节点的 Cache Line 里。</p><p>第二点叫<strong>事务的串行化（Transaction Serialization）</strong>，事务串行化是说，我们在一个 CPU 核心里面的读取和写入，在其他的节点看起来，顺序是一样的。</p><p>写传播很容易理解。既然我们数据写完了，自然要同步到其他 CPU 核的 Cache 里。而事务的串行化，则是指假设很短时间内，一个数据被两次修改，并且分别是由两个CPU核心处理的，当它们同步数据更改到其他核心的时候，可能会出现顺序不一致的问题，即对不同的核心表现为修改的顺序不一致，造成最终结果不一致。</p><p>而在 CPU Cache 里做到事务串行化，需要做到两点，第一点是<strong>一个 CPU 核心对于数据的操作，需要同步通信给到其他 CPU 核心</strong>。第二点是，<strong>如果两个 CPU 核心里有同一个数据的 Cache，那么对于这个 Cache 数据的更新，需要有一个“锁”的概念。只有拿到了对应 Cache Block 的“锁”之后，才能进行对应的数据更新</strong>。接下来，我们就看看实现了这两个机制的 MESI 协议。</p><h1 id="总线嗅探与MESI协议">2 总线嗅探与MESI协议</h1><h2 id="总线嗅探">2.1 总线嗅探</h2><p>要解决缓存一致性问题，首先要解决的是多个 CPU 核心之间的数据传播问题。最常见的一种解决方案呢，叫作<strong>总线嗅探</strong>。</p><p>这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p><p>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议。不过其中最常用的，就是今天我们要讲的 MESI 协议。和很多现代的 CPU 技术一样，MESI 协议也是在 Pentium 时代，被引入到 Intel CPU 中的。</p><h2 id="MESI协议">2.2 MESI协议</h2><p>MESI 协议，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，<strong>只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 Cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。</strong></p><p>相对于写失效协议，还有一种叫作写广播（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的 CPU 核心，同时更新各个核心里的 Cache。</p><p>写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的 CPU 核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他 CPU 核心。</p><p>MESI 协议的由来呢，来自于我们对 Cache Line 的四个不同的标记，分别是：</p><ul><li>M：代表已修改（Modified）</li><li>E：代表独占（Exclusive）</li><li>S：代表共享（Shared）</li><li>I：代表已失效（Invalidated）</li></ul><p><img src="https://api.codetool.top/img/15866087435201.png" alt="MESI状态机"></p><p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。所谓的“已修改”，就是“脏”的 Cache Block。Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面。而所谓的“已失效”，自然是这个 Cache Block 里面的数据已经失效了，我们不可以相信这个 Cache Block 里面的数据。</p><p>然后，我们再来看“独占”和“共享”这两个状态。这就是 MESI 协议的精华所在了。<strong>无论是独占状态还是共享状态，缓存里面的数据都是“干净”的。</strong>这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，Cache Block 里面的数据和主内存里面的数据是一致的。</p><p>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，<strong>在独占状态下，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</strong></p><p><strong>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，它就会变成共享状态。</strong>这个共享状态是因为，这个时候，另外一个 CPU 核心，也把对应的 Cache Block，从内存里面加载到了自己的 Cache 里来。</p><p>而<strong>在共享状态下，因为同样的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，都变成无效的状态，然后再更新当前 Cache 里面的数据。</strong>这个广播操作，一般叫作 RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权。</p><table cellspacing="0" cellpadding="0" border="1"><tbody><tr><td valign="top"><p align="center">当前状态</p></td><td valign="top"><p align="center">事件</p></td><td valign="top"><p align="center">行为</p></td><td valign="top"><p align="center">下一个状态</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">I(Invalid)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E；</p><p align="left">如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S；</p><p align="left">如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S</p></td><td valign="top"><p align="center">E/S</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">从内存中取数据，在Cache中修改，状态变成M；</p><p align="left">如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存；</p><p align="left">如果其它Cache有这份数据，则其它Cache的Cache line状态变成I</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">既然是Invalid，别的核的操作与它无关</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">既然是Invalid，别的核的操作与它无关</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">E(Exclusive)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">从Cache中取数据，状态不变</p></td><td valign="top"><p align="center">E</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">修改Cache中的数据，状态变成M</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">数据和其它核共用，状态变成了S</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">数据被修改，本Cache line不能再使用，状态变成I</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">S(Shared)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">从Cache中取数据，状态不变</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">修改Cache中的数据，状态变成M，</p><p align="left">其它核共享的Cache line状态变成I</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">状态不变</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">数据被修改，本Cache line不能再使用，状态变成I</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">M(Modified)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">从Cache中取数据，状态不变</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">修改Cache中的数据，状态不变</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据，</p><p align="left">状态变成I</p></td><td valign="top"><p align="center">I</p></td></tr></tbody></table><h1 id="MESI协议与java-volatile关键字的关系">3 MESI协议与java volatile关键字的关系</h1><p><a href="https://www.zhihu.com/question/296949412" target="_blank" rel="noopener">既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？ - 知乎</a></p><p>volatile的语义有：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序</li></ol><p>对于x86的体系结构，voltile变量的访问代码会被java编译器生成不乱序的，带有lock指令前缀的机器码。而lock的实现还要区分，这个数据在不在CPU核心的专有缓存中（一般是指L1/L2）。如果在，MESI才有用武之地。如果不满足就会要用其他手段，涉及到内存屏障。</p><p>通过反汇编可以发现，Java中volatile变量修饰的共享变量在进行写操作时候会多出一行汇编：</p><pre><code>lock addl $0×0,(%esp);</code></pre><p>在x86架构中，Lock前缀指令可以用作storeLoad barrier，在支持SSE2拓展指令集的cpu上还可以使用mfence指令。在多核处理器环境中，lock前缀指令保证了某个处理器对共享内存的独占使用。<strong>内存屏障不仅仅是MESI这么简单。</strong></p><p>多处理器总线嗅探:</p><ol><li>为了提高处理速度,处理器不直接和内存进行通信,而是先将系统内存的数据读到内部缓存后在进行操作,但<strong>写回操作</strong>不知道这个更改何时回写到内存。</li><li>但是对变量使用volatile进行写操作时，JVM就会向处理器发送一条lock前缀的指令,将这个变量所在的缓存行的数据写回到系统内存。</li><li>在多处理器中,为了保证各个处理器的缓存一致性，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行设置为无效状态，就相当于<strong>写回时发现状态标识为0失效</strong>，当这个处理器对数据进行修改操作时,会重新从系统内存中读取数据到CPU缓存中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;明明记得在哪里学过这部分内容，还看到过一个贼好的图。。今天找了很久又没找着，这就是学了不记笔记的后果。。&lt;/p&gt;
&lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yhb1047818384/article/details/7
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode887-鸡蛋掉落</title>
    <link href="https://www.codetool.top/article/leetcode887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/"/>
    <id>https://www.codetool.top/article/leetcode887-鸡蛋掉落/</id>
    <published>2020-04-11T02:20:33.000Z</published>
    <updated>2020-04-11T03:16:01.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code>  共有 <code>N</code> 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p><p>你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。</p><p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> K = 1, N = 2<br><strong>输出：</strong> 2<br><strong>解释：</strong><br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> K = 2, N = 6<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> K = 3, N = 14<br><strong>输出：</strong> 4</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= K &lt;= 100</code></li><li><code>1 &lt;= N &lt;= 10000</code></li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题是一道经典的谷歌面试题，思路李永乐老师讲过：<a href="https://www.bilibili.com/video/BV1KE41137PK" target="_blank" rel="noopener">复工复产找工作？先来看看这道面试题：双蛋问题_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>总而言之就是动态规划，定义dp(k,n)为最小移动次数，假设第一次在x层楼处扔下鸡蛋，如果鸡蛋碎了，代表F&lt;x，即还需要<code>dp(k-1,x-1)</code>次移动才能求出，如果鸡蛋没碎，还需要<code>dp(k,n-x)</code>次移动才能求出，取他们俩的最大值加一，然而光用这个思路在leetcode中会超时，因为x需要从1~k枚举，还可以使用二分法进一步优化。</p><h2 id="代码">2.2 代码</h2><p>动态规划：（超时）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">superEggDrop</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Integer min <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> div <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>div<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>div<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> count <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>div<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">==</span>null<span class="token operator">||</span>count<span class="token operator">&lt;</span>min<span class="token punctuation">)</span> min <span class="token operator">=</span> count<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>动态规划+二分：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">superEggDrop</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//dp[k-1][div-1]从小递增，dp[k][n-div]从大递减，只需找到一处刚好使得dp[k-1][div-1]>=dp[k][n-div]</span>                <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> high <span class="token operator">=</span> n<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> div <span class="token operator">=</span> low<span class="token operator">+</span><span class="token punctuation">(</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>div<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        low <span class="token operator">=</span> div<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>div<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> low <span class="token operator">=</span> div<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>low<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;你将获得 &lt;code&gt;K&lt;/code&gt; 个鸡蛋，并可以使用一栋从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;N&lt;/code&gt;  共有 &lt;code&gt;N&lt;/code&gt; 层楼的建筑。&lt;/p&gt;
&lt;p&gt;每个蛋的功能都是一样的，如果一个蛋碎
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计网复习04-网络层</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A004-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://www.codetool.top/article/计网复习04-网络层/</id>
    <published>2020-04-10T03:55:29.000Z</published>
    <updated>2020-04-11T15:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里的网络层指的是原理体系结构的网络层，对应OSI七层体系结构中的网络层，对应TCP/IP四层体系结构中的网际层。它为应用层提供服务，主要功能：</p><ol><li>路由选择与分组转发</li><li>异构网络互联</li><li>拥塞控制<ul><li>若<strong>所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态</strong>。因此要采取一定措施，缓解这种拥塞。</li><li>解决方案：开环控制、闭环控制</li></ul></li></ol><h1 id="提供的两种服务">1 提供的两种服务</h1><p><img src="https://api.codetool.top/img/15864909591668.png" alt></p><p>数据报方式为网络层提供无连接服务，虚电路方式为网络层提供连接服务。</p><p>无连接服务:不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p><p>连接服务:首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p><p>网络层的最小数据单元是数据包（在TCP/IP体系结构里称为IP数据报）或分组。</p><h2 id="数据报">1.1 数据报</h2><p>每个分组携带源和目的地址。</p><p>路由器根据分组的目的地址转发分组:</p><ul><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路。</li></ul><h2 id="虚电路">1.2 虚电路</h2><p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p><p>虚电路:<strong>一条源主机到目的主机类似于电路的路径(逻辑连接)</strong>，路径上所有结点都要维持这条虚电路的建立，都维持一张<strong>虚电路表</strong>，每一项记录了一个打开的虚电路的信息。</p><p>虚电路的通信过程</p><ol><li>建立连接</li><li>数据传输</li><li>释放连接</li></ol><p>建立连接时携带目的地址，通信时每个分组携带虚电路号，而非目的地址。</p><h1 id="网际协议IP">2 网际协议IP</h1><p><img src="https://api.codetool.top/img/15864910288465.png" alt></p><p><img src="https://api.codetool.top/img/15865001638495.png" alt="TCP/IP协议栈"></p><h2 id="IP数据报格式">2.1 IP数据报格式</h2><p>IP数据报分为首部和数据部分，数据部分是传输层下发的内容。</p><p>首部格式：</p><ul><li>20字节固定部分</li><li>可变部分</li></ul><p><img src="https://api.codetool.top/img/15865012168301.png" alt></p><ul><li>版本：区分IPv4/IPv6</li><li>首部长度：单位为4B，最小为5。</li><li>区分服务：指示期望获得哪种类型的服务。</li><li>总长度：首部+数据，单位是1B。</li><li>生存时间(TTL)：IP分组的保质期。经过一个路由器-1，变成0则丢弃。</li><li>协议：数据部分的协议</li><li>首部检验和：只检验首部</li></ul><p>可变部分的填充必须把首部填充为4字节的整数倍。</p><h2 id="IP数据报的分片">2.2 IP数据报的分片</h2><p>因为IP数据报经过链路层需要作为数据部分装配为数据帧，数据帧的数据部分具有最大长度，即MTU，通常是1500字节。如果IP数据报大于这个长度，需要分片。</p><p>首部中，有三个字段和分片有联系：</p><ul><li>标识：同一数据报的分片使用同一标识。</li><li>标志：三位，只有最后两位有意义<ul><li>中间位DF=1代表禁止分片，DF=0代表允许分片。</li><li>最低位MF=1代表后面还有分片，MF=0代表最后一片/没有分片</li></ul></li><li>片偏移：指出较长分组分片后,某片在原分组中的相对位置，<strong>以8B为单位</strong>。</li></ul><h2 id="IP地址">2.3 IP地址</h2><p>32位，分为网络号和主机号，通常表示为点分十进制。</p><h3 id="分类的IP地址">2.3.1 分类的IP地址</h3><p><img src="https://api.codetool.top/img/15865150045553.png" alt></p><p><strong>特殊的IP地址：</strong></p><table><thead><tr><th>NetID网络号</th><th>HostID主机号</th><th>作为IP分组源地址</th><th>作为IP分组目的地址</th><th>用途</th></tr></thead><tbody><tr><td>全0</td><td>全0</td><td>可以</td><td>不可以</td><td>本网范围内表示主机，路由表中用于表示默认路由(表示整个Internet网络)</td></tr><tr><td>全0</td><td>特定值</td><td>不可以</td><td>可以</td><td>表示本网内某个特定主机</td></tr><tr><td>全1</td><td>全1</td><td>不可以</td><td>可以</td><td>本网广播地址(路由器不转发)</td></tr><tr><td>特定值</td><td>全0</td><td>不可以</td><td>不可以</td><td>网络地址，表示一个网络</td></tr><tr><td>特定值</td><td>全1</td><td>不可以</td><td>可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td>127</td><td>任何数(非全0/1)</td><td>可以</td><td>可以</td><td>用于本地软件换回测试，称为环回地址</td></tr></tbody></table><p><strong>私有IP地址：</strong></p><table><thead><tr><th>地址类别</th><th>地址范围</th><th>网段个数</th></tr></thead><tbody><tr><td>A类</td><td>10.0.0.0~10.255.255.255</td><td>1</td></tr><tr><td>B类</td><td>172.16.0.0~172.31.255.255</td><td>16</td></tr><tr><td>C类</td><td>192.168.0.0~192.168.255.255</td><td>256</td></tr></tbody></table><p><strong>A、B、C三类地址范围：</strong></p><table><thead><tr><th>网络类别</th><th>最大可用网络数</th><th>第一个可用的网络号</th><th>最后一个可用的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2<sup>7</sup>-2</td><td>1</td><td>126</td><td>2<sup>24</sup>-2</td></tr><tr><td>B</td><td>2<sup>14</sup>-1</td><td>128.1</td><td>191.255</td><td>2<sup>16</sup>-2</td></tr><tr><td>C</td><td>2<sup>21</sup>-1</td><td>192.0.1</td><td>223.255.255</td><td>2<sup>8</sup>-2</td></tr></tbody></table><p>路由器对目的地址是私有IP地址的数据报一律不进行转发。</p><h2 id="网络地址转换NAT">2.4 网络地址转换NAT</h2><p>网络地址转换NAT(Network Address Translation) :在<strong>专用网连接到因特网</strong>的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。</p><p>NAT路由器有一个NAT转换表。</p><h2 id="IP组播-多播">2.5 IP组播/多播</h2><p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</p><p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有组播路由器的支持)。</p><p>IP组播地址让源设备能够将分组发送给一组设备。 属于多播组的设备将被分配一个组播组IP地址（一群共同需求主机的相同标识）</p><p>组播地址范围为224.0.0.0~239.255.255.255 (D类地址)，一个D类地址表示一个组播组。只能用作分组的目标地址。源地址总是为单播地址。</p><p>特点：</p><ol><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</li><li>对组播数据报不产生ICMP差错报文。</li><li>并非所有D类地址都可以作为组播地址。</li></ol><p>同单播地址一样，<strong>组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧</strong>。组播MAC地址以十六进制值<code>01-00-5E</code>打头，余下的6个十六进制位是根据IP组播组地址的最后23位转换得到的。</p><h2 id="ARP协议">2.6 ARP协议</h2><p>ARP协议将IP地址解析为硬件（mac）地址，属于数据链路层协议。</p><p>对于每个主机，都有一份ARP高速缓存，里面存的是已知主机IP地址到硬件地址的映射表。ARP缓存是有一定过期时间的。</p><p>如何获取这个映射表的数据？假设当前主机缺少一个IP地址对mac地址的映射数据，它首先会检查这个IP是否是同一个网段内的，如果是则它会向当前局域网广播一个ARP请求分组，目的mac地址可以填写<code>FF-FF-FF-FF-FF-FF</code>。目标主机（发现自己的IP吻合）收到该分组之后，会响应一个单播ARP响应分组，附带自己的mac地址。</p><p>如果目的主机不在当前局域网，首先查询默认网关的IP地址，将该分组发往默认网关，目的mac地址填写默认网关的mac地址，路由器再帮忙转发该分组。</p><p>ARP协议4种典型情况:</p><ol><li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器(网关)的硬件地址</li><li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</li></ol><p><img src="https://api.codetool.top/img/15866029383187.png" alt="ARP报文的格式"></p><h2 id="DHCP协议">2.7 DHCP协议</h2><p>主机如何获得IP地址？</p><ol><li>静态配置</li><li>动态配置</li></ol><p>动态主机配置协议DHCP是<strong>应用层</strong>协议，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于UDP。</p><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><p>主机从DHCP服务器获取IP流程：</p><ol><li>主机广播DHCP发现报文</li><li>DHCP服务器广播DHCP提供报文</li><li>主机广播DHCP请求报文</li><li>DHCP服务器广播DHCP确认报文</li></ol><p>为什么第二步、第三步、第四步还是广播？因为第一步中可能有多台DHCP服务器收到发现报文并提前准备好一个可用的IP。第二步中发送提供报文给目标主机，然而目标主机此时还没有IP地址，于是仍使用广播地址，第三步中主机通常会选择第一个收到的提供报文对应的DHCP服务器，并广播一个请求报文，广播该请求报文的意义在于，其他DHCP服务器接收到该报文后，便知道对应的主机已经有了IP提供者，可以收回自己准备的IP地址了。第四步原因同第二步。</p><h2 id="ICMP协议">2.8 ICMP协议</h2><p>ICMP协议支持主机或路由器，功能：</p><ul><li>差错(或异常)报告，对应ICMP差错报告报文</li><li>网络探询，对应ICMP询问报文，重要的应用是ping</li></ul><p>ICMP报文格式：</p><p><img src="https://api.codetool.top/img/15865297661616.png" alt></p><p>类型又分两大类：</p><ul><li>ICMP差错报告报文：<ul><li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。（该类型不再使用）</li><li>时间超过：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。</li></ul></li><li>ICMP询问报文：<ul><li>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。（PING的原理）</li><li>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。</li></ul></li></ul><p>不应发送ICMP差错报文的情况：</p><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文。</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</li></ol><h2 id="IGMP协议">2.9 IGMP协议</h2><p>互联网组管理协议（IGMP）是因特网协议家族中的一个组播协议，TCP/IP协议族的一个子协议，用于<strong>IP主机向任一个直接相邻的路由器报告他们的组成员情况</strong>。允许Internet主机参加多播，也是IP主机用作向相邻多目路由器报告多目组成员的协议。多目路由器是支持组播的路由器，向本地网络发送IGMP查询。主机通过发送IGMP报告来应答查询。组播路由器负责将组播包转发到所有网络中组播成员。　</p><p>IGMP协议让路由器知道本局域网上是否有主机(的进程)参加或退出了某个组播组。</p><p><strong>IGMP工作的两个阶段</strong></p><ul><li>某主机要加入组播组时，该主机向组播组的组播地址发送一- 个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</li><li>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的:如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</li></ul><h2 id="IPv6">2.10 IPv6</h2><p>IPv6使用128位二进制数表示，通常使用冒号十六进制记法: <code>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</code>，可以将连续的0压缩省略。</p><h3 id="IPv6数据报">2.10.1 IPv6数据报</h3><p>IPv6数据报格式：</p><ul><li>40字节基本首部</li><li>有效载荷，其中包括拓展首部</li></ul><p><img src="https://api.codetool.top/img/15865314027415.png" alt></p><h3 id="Ipv6的改进">2.10.2 Ipv6的改进</h3><ol><li>IPv6将地址从32位(4B) 扩大到128位(16B) ，更大的地址空间。</li><li>IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间。</li><li>IPv6将IPv4的可选字段移出首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6支持即插即用(即自动配置)，不需要DHCP协议。</li><li>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍。</li><li>IPv6只能在主机处分片，IPv4可以在路由器和主机处分片。</li><li><code>ICMPv6</code>：附加报文类型“分组过大”。</li><li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用。</li><li>IPv6取消了协议字段，改成下一个首部字段。</li><li>IPv6取消了总长度字段，改用有效载荷长度字段。</li><li>IPv6取消了服务类型字段。</li></ol><p>IPv6基本地址类型：</p><ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul><h3 id="IPv6向IPv4过渡的策略">2.10.3 IPv6向IPv4过渡的策略</h3><p>双栈协议：</p><p>双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</p><p>隧道技术：</p><p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。</p><h1 id="转发分组的流程">3 转发分组的流程</h1><p><img src="https://api.codetool.top/img/15864910448779.png" alt></p><h1 id="划分子网和构造超网">4 划分子网和构造超网</h1><p><img src="https://api.codetool.top/img/15864910696407.png" alt></p><h2 id="子网划分">4.1 子网划分</h2><p>子网划分又将IP地址中的主机号划分为子网号和主机号，这里的主机号仍不能是全0或全1。<strong>某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。</strong></p><p>如何确定子网号和主机号的位数就需要通过子网掩码。它是个类IP地址的形式，<strong>网络号和子网号对应的位全为1，主机号对应的位全为0。</strong></p><h2 id="构造超网">4.2 构造超网</h2><h3 id="无分类编址CIDR">4.2.1 无分类编址CIDR</h3><p>CIDR消除了传统的A类，B类和C类地址以及划分子网的概念，将IP地址划分为网络前缀和主机号，网络前缀的位数是任意的，在IP地址后加上<code>/</code>，然后写上网络前缀的位数。</p><p>CIDR把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”。</p><p>CIDR也可以有子网掩码的概念，网络前缀有多少位，子网掩码中就有多少位连续的1。</p><h3 id="构成超网">4.2.2 构成超网</h3><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>方法:将网络前缀缩短。</p><p>使用CIDR时，查找路由表可能得到几个匹配结果，<strong>应选择具有最长网络前缀的路由</strong>。前缀越长，地址块越小，路由越具体。</p><h1 id="路由选择协议">5 路由选择协议</h1><p><img src="https://api.codetool.top/img/15864910953755.png" alt></p><h2 id="RIP协议">5.1 RIP协议</h2><p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是简单。</p><p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离)。</p><p>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达。</strong></p><p>RIP协议让<strong>相邻路由器之间交换自己的路由表</strong>，每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</p><p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</p><p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即 <strong>“收敛”</strong>。</p><p>RIP协议也是应用层协议，使用UDP传输数据，RIP协议只适用于小互联网。</p><p><strong>RIP协议好消息传得快，坏消息传得慢</strong>：当网络出现故障时，要经过比较长的时间(例如数分钟)才能将此信息传送到所有的路由器，这种特点称为 <strong>“慢收敛”</strong>。</p><h2 id="OSPF协议（简介）">5.2 OSPF协议（简介）</h2><p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了Djkstra提出的最短路径算法SPF。</p><p>特点：</p><ol><li>使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器（相当于广播）。最终整个区域内所有路由器都得到了这个信息的一个副本。</li><li>发送的信息就是<strong>与本路由器相邻的所有路由器的链路状态</strong>（本路由器和哪些路由器相邻，以及该链路的度量/代价——费用、距离、时延、带宽等）。</li><li><strong>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</strong></li></ol><p>最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。然后使用Djkstra算法确定最短路径。</p><p>其他特点：</p><ol><li>每隔30min,要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。</li><li>OSPF不存在坏消息传的慢的问题，它的收敛速度很快。</li></ol><p>OSPF基于IP协议，归为传输层协议。</p><h2 id="BGP协议（简介）">5.3 BGP协议（简介）</h2><p>BGP属于外部网关协议，在不同的自治系统（AS）间进行路由，相邻的自治系统通过<strong>BGP发言人</strong>（一台边界路由器）交换网络可达性的信息，即要到达某个网络所要经过的一系列AS。</p><p>BGP所交换的网络可达性的信息就是要<strong>到达某个网络所要经过的一系列AS</strong>。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。首次交换的是整个路由表，其他时候交换的是有变换的部分。</p><p>BGP是应用层协议，通过TCP传送。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的网络层指的是原理体系结构的网络层，对应OSI七层体系结构中的网络层，对应TCP/IP四层体系结构中的网际层。它为应用层提供服务，主要功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由选择与分组转发&lt;/li&gt;
&lt;li&gt;异构网络互联&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;ul&gt;
&lt;li&gt;若&lt;s
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer06-从尾到头打印链表</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/剑指offer06-从尾到头打印链表/</id>
    <published>2020-04-10T03:47:37.000Z</published>
    <updated>2020-04-10T16:42:31.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> head = [1,3,2]<br><strong>输出：</strong> [2,3,1]  </p></blockquote><p><strong>限制：</strong></p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>栈</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈StringBuffer、StringBuilder及String在JDK9中的变化</title>
    <link href="https://www.codetool.top/article/%E8%B0%88%E4%B8%80%E8%B0%88StringBuffer%E3%80%81StringBuilder%E5%8F%8AString%E5%9C%A8JDK9%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>https://www.codetool.top/article/谈一谈StringBuffer、StringBuilder及String在JDK9中的变化/</id>
    <published>2020-04-09T05:49:25.000Z</published>
    <updated>2020-04-09T06:53:36.498Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://blog.csdn.net/qq_41376740/article/details/80143215" target="_blank" rel="noopener">JAVA9 String新特性，说说你不知道的东西_Java_人在江湖-CSDN博客</a></p><h1 id="StringBuffer和StringBuilder的区别">1 StringBuffer和StringBuilder的区别</h1><p>这里谈的是JDK8中StringBuffer和StringBuilder的实现，JDK9后随着String的变化，这两个类的实现也有了些许变化。</p><ol><li>String是不可变的，String类和它的内部value数组都被声明为final。因此通常对字符串进行拼接操作总是会生成一个新的String对象，效率较低。</li><li>为了改进字符串拼接的效率，出现了StringBuffer和StringBuilder，<strong>StringBuffer是线程安全的，因为它在主要方法上加了synchronized关键字</strong>，不过也因此会有加锁解锁的开销，性能会收到影响，而StringBuilder就是StringBuffer的线程不安全版本，它没有使用synchronized关键字，性能最好。</li><li>StringBuffer和StringBuilder都继承自AbstractStringBuilder，主要方法也都由这个父类实现了，基本的原理是它内部有一个字符数组，append的时候通过<code>System.arraycopy</code>将String中的字符数组拷贝至该builder的数组末尾，如果数组空间不足，则扩容为两倍大小，toString的时候通过这个字符数组来构造字符串。</li><li>StringBuffer和StringBuider都可以在构造函数中自定义初始化时内部字符数组的大小，如果知道要拼接字符串最后的大致大小，<strong>建议给它一个初始容量，避免数组扩容带来的开销</strong>，这点就和ArrayList差不多。</li></ol><p><img src="https://api.codetool.top/img/15864128585274.png" alt="StringBuffer和StringBuilder的关系"></p><p>AbstractStringBuilder中append的实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>String中getChars的实现：（由String负责将自己内部数组内容附加到builder中的数组末尾）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChars</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> srcEnd<span class="token punctuation">,</span> <span class="token keyword">char</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcEnd <span class="token operator">></span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">></span> srcEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> srcBegin<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="JDK9-String解读">2 JDK9 String解读</h1><p>很久之前，我在<a href="../详解java中的unicode编码（码点）">详解java中的unicode编码（码点）</a>中提到，java使用的char编码就是UTF-16，并且String的底层也是一个char数组。</p><p>UTF-16的编码规则是什么，这里复习一下：</p><ul><li>BMP（基本多语言平面）内的字符，统一使用2个字节表示，我们称其为一个码点，它已经可以表示大多数常见文字。</li><li>辅助平面内的字符，使用高代理码点和低代理码点联合表示，共四个字节，可以表示完所有unicode中的字符。</li></ul><p>但是，UTF-16存在的问题是，对于大多数拉丁语系中的字符（例如ASCII码中的字符），都可以使用1个字节表示，然而UTF-16必须使用两个字节来表示它，就会导致空间浪费。</p><p>于是JDK9中，大刀阔斧地对String及相关方法进行了重构。</p><p><img src="https://api.codetool.top/img/15864132876511.png" alt="图为String内部字段的变化，左为JDK8，右为JDK9"></p><p>需要注意的是，JDK9中的value数组变为了byte数组，意味着最小允许单字节的存在。并且多了一个coder字段，javadoc中是这样描述的：</p><blockquote><p>The identifier of the encoding used to encode the bytes in value. The supported values in this implementation are LATIN1 UTF16</p></blockquote><p>说明<code>coder</code>用于标识这个bytes数组的编码是utf-16还是latin1。（根据测试1代表UTF16，0代表latin1）</p><p><img src="https://api.codetool.top/img/15864140086085.png" alt="JDK8中的&quot;123abc&quot;"></p><p><img src="https://api.codetool.top/img/15864140321197.png" alt="JDK9中的&quot;123abc&quot;"></p><p>可以看到占用空间直接减少了1/2。</p><p>由于byte数组的使用方式，引申出了两个类StringLatin1和StringUTF16两个类，分担String类的操作。</p><p>我们来看看JDK9中String几个方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">codePointCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beginIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> beginIndex <span class="token operator">></span> endIndex <span class="token operator">||</span>        endIndex <span class="token operator">></span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLatin1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> endIndex <span class="token operator">-</span> beginIndex<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> StringUTF16<span class="token punctuation">.</span><span class="token function">codePointCount</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> beginIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法用于计算码点数，对于latin1编码，自然就是byte数组的长度。对于UTF16，和JDK8中的思想类似：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">codePointCount</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">,</span> <span class="token keyword">boolean</span> checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> beginIndex <span class="token operator">&lt;=</span> endIndex<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> endIndex <span class="token operator">-</span> beginIndex<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> beginIndex<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>checked <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkBoundsBeginEnd</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> endIndex<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> endIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isHighSurrogate</span><span class="token punctuation">(</span><span class="token function">getChar</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            Character<span class="token punctuation">.</span><span class="token function">isLowSurrogate</span><span class="token punctuation">(</span><span class="token function">getChar</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再来看<code>length()</code>:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> value<span class="token punctuation">.</span>length <span class="token operator">>></span> <span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> COMPACT_STRINGS<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    COMPACT_STRINGS <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">byte</span> <span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> COMPACT_STRINGS <span class="token operator">?</span> coder <span class="token operator">:</span> UTF16<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>javadoc对<code>COMPACT_STRINGS</code>的解释是：</p><blockquote><p>If String compaction is disabled, the bytes in value are always encoded in UTF16</p></blockquote><p>即COMPACT_STRINGS默认是开启的，即同时支持UTF16和LATIN1，但具体的编译器可以将其关闭，使其只支持UTF16。</p><p>这里计算长度的方法依然很简单，对于LATIN1就是byte数组的长度，对于UTF16则是byte数组长度除以2。</p><p>JDK9中对字符串的改动带来的问题是什么呢？可能有人知道，java中数组的大小是有上限的，许多集合类都有下面这个字段：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** The maximum size of array to allocate.* Some VMs reserve some header words in an array.* Attempts to allocate larger arrays may result in* OutOfMemoryError: Requested array size exceeds VM limit*/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>即数组的大小上限不应该超过<code>Integer.MAX_VALUE - 8</code>，那么大小相等的情况下，JDK9中byte数组自然也就比JDK8中的char数组能存储的信息少了1/2。</p><h1 id="JDK9带来的StringBuffer-StringBuilder变化">3 JDK9带来的StringBuffer/StringBuilder变化</h1><p>JDK9中String的改版，使得StringBuffer/StringBuilder的实现也有了小变化。如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The value is used for character storage.     */</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The id of the encoding used to encode the bytes in {@code value}.     */</span>    <span class="token keyword">byte</span> coder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p>AbstractStringBuilder中的内部数组也变为了byte数组，并且增加了coder字段。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putStringAt</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putStringAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getCoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> str<span class="token punctuation">.</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">,</span> coder<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">,</span> <span class="token keyword">byte</span> coder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> coder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin <span class="token operator">&lt;&lt;</span> coder<span class="token punctuation">,</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// this.coder == LATIN &amp;&amp; coder == UTF16</span>        StringLatin1<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到加入了一些对coder的判断，Builder和String必须维持相同的coder。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41376740/article/details/80143215&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAVA9 String新特性，说说你不知道
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码分析" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22-括号生成</title>
    <link href="https://www.codetool.top/article/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://www.codetool.top/article/leetcode22-括号生成/</id>
    <published>2020-04-09T04:46:43.000Z</published>
    <updated>2020-04-09T14:46:19.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p><strong>示例:</strong></p><pre style="color:#e8eaf6"><strong style="color:#e8eaf6">输入：</strong>n = 3<strong style="color:#e8eaf6">输出：</strong>[       "((()))",       "(()())",       "(())()",       "()(())",       "()()()"     ]</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我是使用的dfs，递归太爽了。其他的思路如动态规划也可以。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addToAns</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//left：当前左括号数，right：当前右括号数。</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addToAns</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span>String s<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> n<span class="token operator">&amp;&amp;</span>right <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>n<span class="token punctuation">)</span> <span class="token function">addToAns</span><span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//仅当右括号数小于左括号数才能添加右括号</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>left<span class="token punctuation">)</span> <span class="token function">addToAns</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre style=&quot;color:#e8eaf6&quot;&gt;&lt;strong s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>try-catch-finally字节码实例探究</title>
    <link href="https://www.codetool.top/article/try-catch-finally%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.codetool.top/article/try-catch-finally字节码实例探究/</id>
    <published>2020-04-08T15:20:32.000Z</published>
    <updated>2020-04-08T17:34:00.389Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用Idea的jclasslib插件查看字节码。本文全程自言自语，请勿自行代入。</p><h1 id="概述">1 概述</h1><p>java是怎么处理try-catch-finally的？</p><p>我们在<a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a>学习过，在class字节码中的属性表中，存在<code>code</code>属性，它用于存放各方法的字节码、属性等。其中就包括<code>exception_info</code>，即异常表，它记录了当一个异常发生后，应跳转到哪一行继续执行，而finally里面的代码块编译成字节码后则是被复制成许多份分别附在try和各catch块的后面。这篇文章，我们就通过一些实例来看看，java中的try-catch-finally引申出的一些问题。</p><h1 id="普通的例子">2 普通的例子</h1><h2 id="普通中的普通例子">2.1 普通中的普通例子</h2><p>我们先来一个普通的例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"try-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"finally"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个相信大家都知道是输出try-finally，因为没有异常出现，那么它的字节码是：</p><pre><code> 0 getstatic #4 &lt;java/lang/System.out&gt; 3 ldc #5 &lt;try-&gt; 5 invokevirtual #6 &lt;java/io/PrintStream.print&gt;---------------- 上面这部分输出&quot;try-&quot;----------------- 8 getstatic #4 &lt;java/lang/System.out&gt;11 ldc #7 &lt;finally&gt;13 invokevirtual #6 &lt;java/io/PrintStream.print&gt;---------------- 上面这部分输出&quot;finally&quot;--------------16 goto 50 (+34)-----------正常流程，跳转到50行直接return--------------19 astore_020 getstatic #4 &lt;java/lang/System.out&gt;23 ldc #8 &lt;catch&gt;25 invokevirtual #6 &lt;java/io/PrintStream.print&gt;-----上面这部分输出&quot;catch&quot;,astore_0存入的是异常信息-----28 getstatic #4 &lt;java/lang/System.out&gt;31 ldc #7 &lt;finally&gt;33 invokevirtual #6 &lt;java/io/PrintStream.print&gt;36 goto 50 (+14)-----注意上面这部分也是输出&quot;finally&quot;，和之前某部分一样----39 astore_140 getstatic #4 &lt;java/lang/System.out&gt;43 ldc #7 &lt;finally&gt;45 invokevirtual #6 &lt;java/io/PrintStream.print&gt;48 aload_149 athrow-----注意上面这部分也是输出&quot;finally&quot;，但抛出了一个异常----50 return</code></pre><p>我们看看异常表：</p><p><img src="https://api.codetool.top/img/15863605314214.png" alt></p><p>如何解读：</p><ul><li>0-8行（不包括8）的语句出现异常（类型为Exception，是我们catch的异常类型），交由19行处理（catch代码块），我们注意到28行执行完catch代码块后，就执行finally代码块。</li><li>0-8行的语句出现异常（类型为any，代表任何异常），交由39行处理，为什么这里会有这一项呢？<strong>是因为我们定义了finally</strong>，如果在try中出现了我们没有catch的异常类型，就可能会出现finally中的代码没有执行的情况，所以<strong>为了防止finally中的代码不执行，编译器会自动为我们暂时store这个异常信息（对应39行），执行完finally语句块后再抛出（对应49行）</strong></li><li>19-28行的语句出现异常（类型为any，代表任何异常），交由39行处理。为什么这里会有这一项呢？原因和上面一样，<strong>如果执行catch代码块又出现了异常，也要保证finally代码块的执行。</strong></li></ul><h2 id="普通例子举一反三">2.2 普通例子举一反三</h2><p>有了上面这个例子，我们就来思考一下，如果没有finally代码块，字节码会是什么样子的呢？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"try-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>首先能想到的是，正常流程执行完try中的内容就应该直接返回。而出现异常就应该跳转至中间一段用于处理异常的代码块。因为没有finally代码块，应该也不会有那么多冗余代码块被复制。</p><p>验证：</p><pre><code> 0 getstatic #4 &lt;java/lang/System.out&gt; 3 ldc #5 &lt;try-&gt; 5 invokevirtual #6 &lt;java/io/PrintStream.print&gt;----------上面输出&quot;try-&quot;------------------------- 8 goto 20 (+12)----------正常流程跳转至20行之间返回--------------11 astore_012 getstatic #4 &lt;java/lang/System.out&gt;15 ldc #7 &lt;catch&gt;17 invokevirtual #6 &lt;java/io/PrintStream.print&gt;------上面输出&quot;catch&quot;，是catch代码块的内容---------20 return</code></pre><p>这么一看确实清爽多了，再看看异常表：</p><p><img src="https://api.codetool.top/img/15863612854501.png" alt></p><p>确实异常表也清爽多了，因为不必保证finally代码块的执行，这里只有我们显式catch的一种异常。</p><h1 id="没事自己抛出异常玩玩，会发生什么？">3 没事自己抛出异常玩玩，会发生什么？</h1><h2 id="try抛出异常">3.1 try抛出异常</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwAndCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"骚一下"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抓住了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在外面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码的原型来自牛客网一道题，输出是什么？</p><p>答案应该是<code>抓住了</code>和<code>我在外面</code>，catch是可以捕获在try中手动抛出的异常的，但因为部分编译器优化程度过高知道<code>System.out.println(&quot;骚一下&quot;);</code>是不可达语句，会报编译错误。我没找到怎么关闭这个异常检查 TT_TT</p><h2 id="catch抛出异常">3.2 catch抛出异常</h2><p>catch中抛出异常的情况，我们把上面那段代码改成：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwAndCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出现异常了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抓住了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在外面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>为什么要抛RuntimeException？因为RuntimeException是非受查异常，可以不用catch，否则即使是在catch中抛出异常还是需要再嵌套一层catch。</p><p>那么这段代码会输出什么？我相信这里可能就有人猜不准了，正确答案应该是<code>抓住了</code>，并接着抛出运行时异常。</p><p>来看一下字节码：</p><pre><code> 0 iconst_1 1 iconst_0 2 idiv 3 istore_0---------上面这段代码做1/0的除法-------------------- 4 getstatic #4 &lt;java/lang/System.out&gt; 7 ldc #8 &lt;出现异常了&gt; 9 invokevirtual #9 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;出现异常了&quot;----------------------12 goto 32 (+20)-------正常流程跳转32行，执行外面的代码--------------15 astore_016 getstatic #4 &lt;java/lang/System.out&gt;19 ldc #10 &lt;抓住了&gt;21 invokevirtual #9 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;抓住了&quot;----------------------24 new #11 &lt;java/lang/RuntimeException&gt;27 dup28 invokespecial #12 &lt;java/lang/RuntimeException.&lt;init&gt;&gt;31 athrow----------上面抛出运行时异常----------------------32 getstatic #4 &lt;java/lang/System.out&gt;35 ldc #13 &lt;我在外面&gt;37 invokevirtual #9 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;我在外面&quot;----------------------40 return</code></pre><p>来看看异常表：</p><p><img src="https://api.codetool.top/img/1586362944559.png" alt></p><p>显然这里也只有我们显式catch的Exception处理。那我们来分析一下执行流程：</p><ul><li>0-3行，执行<code>1/0</code>的除法，出现了除以零的异常，因为此时行号处于0-12之间，就交给15行继续处理，所以”出现异常了”没有输出。</li><li>15-21行，输出”抓住了”，继续执行。</li><li>24-31行，new了一个<code>RuntimeException</code>，并抛出，因为没有该异常没有对应的处理，程序终止，后面的”我在外面”也不会输出。</li></ul><h2 id="举一反三">3.3 举一反三</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwAndCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出现异常了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抓住了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"必须执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在外面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>来看看这段代码，增加了一个finally语句块会输出什么呢？这里就不研究字节码了，因为原因之前在普通例子的时候就提到过了，如果catch代码块中出现异常，并且存在finally代码块，会先把异常信息存起来，执行完finally之后再抛出异常。</p><p>那么相信你也知道了，这里的输出应该是：<code>抓住了</code>和<code>必须执行</code>。</p><h1 id="我都要return了，finally还会执行吗？">4 我都要return了，finally还会执行吗？</h1><h2 id="普通例子">4.1 普通例子</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成10了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成20了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成30了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子开始有一点难度了，你能告诉我它会输出什么吗？</p><p>首先catch内的代码是不会执行的，因为没有异常抛出，你觉得finally中的代码会执行吗？</p><p>答案是会的，看看输出：</p><pre><code>修改成10了哦修改成30了哦10</code></pre><p>是否会大吃一惊？finally中的代码执行了，应该也将i修改为30了，怎么输出的还是10？</p><p>看看字节码：</p><pre><code> 0 bipush 10 2 istore_0----------上面将10存储到局部变量表---------------- 3 getstatic #2 &lt;java/lang/System.out&gt; 6 ldc #16 &lt;修改成10了哦&gt; 8 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;修改成10了哦&quot;------------------11 iload_012 istore_1-----上面将10先读出，又存储到局部变量表的1号槽位-----13 bipush 3015 istore_0------上面将30存储到局部变量表的0号槽位------------16 getstatic #2 &lt;java/lang/System.out&gt;19 ldc #17 &lt;修改成30了哦&gt;21 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;修改成30了哦&quot;------------------24 iload_125 ireturn----------从一号槽位读出数据，并返回---------------26 astore_127 bipush 2029 istore_0------上面将20存储到局部变量表的0号槽位------------30 getstatic #2 &lt;java/lang/System.out&gt;33 ldc #18 &lt;修改成20了哦&gt;35 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;修改成20了哦&quot;------------------38 bipush 3040 istore_041 getstatic #2 &lt;java/lang/System.out&gt;44 ldc #17 &lt;修改成30了哦&gt;46 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----这段和之前看过的一段一样，是finally块会干的事-----49 goto 66 (+17)52 astore_253 bipush 3055 istore_056 getstatic #2 &lt;java/lang/System.out&gt;59 ldc #17 &lt;修改成30了哦&gt;61 invokevirtual #10 &lt;java/io/PrintStream.println&gt;64 aload_265 athrow----这段和之前看过的一段一样，是finally块会干的事-----66 iload_067 ireturn----------从零号槽位读出数据，并返回---------------</code></pre><p>这段字节码是不是看着头疼，其实只需要注意到它在频繁地操作局部变量表就行了。其他流程和我们在普通例子里介绍的差不多。</p><p>看看异常表：</p><p><img src="https://api.codetool.top/img/15863642246448.png" alt></p><p>嗯。。确实跟我们之前介绍的普通例子差不多，那么为什么会出现这种奇异输出呢？我们来分析一下执行流程：</p><ul><li>0-2行，将10存储于局部变量表0号槽。</li><li>3-8行输出”修改成10了哦”</li><li>11-15行，将10转移到局部变量表1号槽，将30存入0号槽</li><li>19-21行，输出”修改成30了哦”</li><li>24-25行，从1号槽中读出10，并返回。</li></ul><p>牛的！其实执行的流程就这么点，注意到finally执行前后，程序分别将10存入局部变量表和从局部变量表中取出，实现了finally中对变量的修改不影响即将return的结果。</p><p>为什么会出现这种情况，<strong>因为编译器知道try中即将return数据，但是finally还是得执行，所以为了保护即将返回的数据，会先将该数据存起来，等finally执行完再取出并返回。</strong></p><h2 id="举一反三-1">4.2 举一反三</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成10了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成20了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成30了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子稍微更复杂点了，执行到catch中去了，那么输出是什么呢？</p><p>如果你有好好得跟着我看下来，应该不难猜到，try中异常前的语句、catch和finally中得语句都会执行，实际上，finally也不会影响catch返回的结果：</p><pre><code>修改成10了哦修改成20了哦修改成30了哦20</code></pre><h1 id="抢着return，谁优先？">5 抢着return，谁优先？</h1><h2 id="普通例子-1">5.1 普通例子</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子不复杂吧，经过了这么多历练，你能猜到结果吗？</p><p>答案其实是30，注意finally中如果出现了return语句，由于finally必会执行，总是finally中的return语句生效。</p><p>字节码也不难：</p><pre><code> 0 bipush 10 2 istore_0 3 bipush 30 5 ireturn-----在此处就执行了finally并返回----- 6 astore_0 7 bipush 20 9 istore_110 bipush 3012 ireturn13 astore_214 bipush 3016 ireturn</code></pre><h2 id="举一反三-2">5.2 举一反三</h2><p>稍微修改一下上面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出是什么？如果你能很快给出答案，我觉得你对try-catch-finally的理解已经差不多了</p><p><button onclick="document.getElementById('ans').style.display='inline';">点击查看答案</button></p><p><span id="ans" style="display:none">这道题的答案依然是30，因为编译器知道catch中即将要return了，再不执行finally来不及了，于是保存现场去执行finally，结果在finally中就return掉了。所以我们一般推荐不要在finally代码块中使用return语句，因为它会覆盖掉其他地方的return语句，程序的可读性不好，如果你不是看了我这篇文章，也想不到这段代码返回30吧？</span></p><p><span style="color:gray">有人可能要问了，学习这些是为了什么呢？谁写代码会这么写呢？那不都是为了应付面试吗😀</span></p><h1 id="finally不会执行的例外情况">6 finally不会执行的例外情况</h1><p>有人看了全文就要说了，懂了！反正finally必执行，记住这个就万无一失了！</p><p>其实finally也不是那么的保险，比如我给你举个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finally执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码中，finally就不会执行了，遇到<code>System.exit</code>，程序会直接退出，相当于杀进程了。</p><p>其他情况例如你外部杀进程，断电脑电源（手动滑稽），finally也是不会执行的。</p><p>OK，那么这篇文章就写到这了，长篇原创好文希望大家支持(<em>^_^</em>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文使用Idea的jclasslib插件查看字节码。本文全程自言自语，请勿自行代入。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;java是怎么处理try-catch-finally的？&lt;/p&gt;
&lt;p&gt;我们在&lt;a href=&quot;../深入理解java虚拟机第三版读
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer13-机器人的运动范围</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://www.codetool.top/article/剑指offer13-机器人的运动范围/</id>
    <published>2020-04-08T03:31:45.000Z</published>
    <updated>2020-04-08T04:15:09.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> m = 2, n = 3, k = 1<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> m = 3, n = 1, k = 0<br><strong>输出：</strong> 1  </p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>dfs，数组中会出现一些符合条件但不可达的格子。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">numSum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">numSum</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span>k <span class="token operator">||</span> x<span class="token operator">>=</span>visited<span class="token punctuation">.</span>length<span class="token operator">||</span>y<span class="token operator">>=</span>visited<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">||</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        count <span class="token operator">++</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;地上有一个m行n列的方格，从坐标 &lt;code&gt;[0,0]&lt;/code&gt; 到坐标 &lt;code&gt;[m-1,n-1]&lt;/code&gt; 。一个机器人从坐标 &lt;code&gt;[0, 0]&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>计网复习03-数据链路层</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A003-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://www.codetool.top/article/计网复习03-数据链路层/</id>
    <published>2020-04-07T13:11:13.000Z</published>
    <updated>2020-04-11T14:20:16.544Z</updated>
    
    <content type="html"><![CDATA[<p>这里的数据链路层指的是原理体系结构的数据链路层，对应OSI七层体系结构中的数据链路层，对应TCP/IP四层体系结构中的网络接口层的一部分。它提供介质访问和链路管理，为网络层提供服务。其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p><p>功能：</p><ol><li>为网络层提供服务：<ul><li>无确认无连接服务</li><li>有确认无连接服务</li><li>有确认面向连接服务</li></ul></li><li>链路管理，即连接的建立、维持、释放(用于面向连接的服务)。</li><li>组帧。</li><li>流量控制。</li><li>差错控制(帧错/位错)。</li></ol><h1 id="两种信道">1 两种信道</h1><p><img src="https://api.codetool.top/img/15862651096504.png" alt></p><p>广播信道需要介质访问控制：采取一定的措施，使得两对节点之间的通信不会互相干扰。</p><p>有静态划分信道和动态分配信道两种方法：</p><h2 id="静态划分信道">1.1 静态划分信道</h2><p>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。</p><ul><li>频分复用 FDM<ul><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(频率带宽)资源</li></ul></li><li>时分复用 TDM <ul><li>将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。</li><li>频分复用——“并行”，时分复用——“并发”</li><li>改进版本的统计时分复用：先收集各用户的使用情况，动态分配时隙</li></ul></li><li>波分复用 WDM<ul><li>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</li></ul></li><li>码分复用 CDM<ul><li>码分多址(CDMA)是码分复用的一种方式。1个比特分为多个码片/芯片(chip)，每一个站点被指定一个唯一的m位的芯片序列。发送1时站点发送芯片序列，发送0时发送芯片序列反码(通常把0写成-1)。</li><li>如何不打架:多个站点同时发送数据的时候，要求各个站点芯片序列相互正交。</li><li>如何合并:各路数据在信道中被线性相加。</li><li>如何分离:合并的数据和源站规格化内积。</li></ul></li></ul><h2 id="动态分配信道">1.2 动态分配信道</h2><h3 id="随机接入">1.2.1 随机接入</h3><h4 id="ALOHA协议">1.2.1.1 ALOHA协议</h4><p>想发就发，冲突重发。</p><p>如何检测冲突？超时之后没有收到确认帧就认为冲突了。</p><p>超时之后<strong>等待一随机时间后重传</strong>。</p><p>如果重传也冲突了，继续等待一随机时间后重传，直到收到了确认。</p><p>改进后的时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><h4 id="CSMA协议">1.2.1.2 CSMA协议</h4><p>载波监听多路访问协议CSMA：</p><ul><li>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</li><li>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li></ul><p>如何检测：当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大( 互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p><ul><li><strong>1-坚持CSMA思想:</strong> 如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不必等待。忙则一直监听，直到空闲马上传输。如果有冲突(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。</li><li><strong>非坚持CSMA思想:</strong> 如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</li><li><strong>p-坚持CSMA思想:</strong> 如果一个主机要发送消息，那么它先监听信道。空闲则以p概率直接传输，不必等待;概率1-p等待到下一一个时间槽再传输。忙则等待一个随机时间之后再进行监听。</li></ul><h3 id="受控接入">1.2.2 受控接入</h3><h4 id="令牌环局域网">1.2.2.1 令牌环局域网</h4><p>令牌：一个特殊格式的MAC控制帧，不含任何信息。控制信道的使用，<strong>确保同一时刻只有一个结点独占信道。</strong></p><p>每个结点都可以在一定的时间内(令牌持有时间)获得发送数据的权利，并不是无限制地持有令牌。</p><p>令牌环网<strong>物理星型拓扑，逻辑环形拓扑</strong>。</p><p>问题:</p><ol><li>令牌开销</li><li>等待延迟</li><li>单点故障</li></ol><h4 id="多点线路探询">1.2.2.2 多点线路探询</h4><p>主结点轮流“邀请”从属结点发送数据。</p><p>问题:</p><ol><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ol><h1 id="链路和数据链路">2 链路和数据链路</h1><p><img src="https://api.codetool.top/img/15862651334233.png" alt></p><h1 id="协议的三个基本问题">3 协议的三个基本问题</h1><p><img src="https://api.codetool.top/img/15862651514581.png" alt></p><h2 id="封装成帧">3.1 封装成帧</h2><p>封装成帧就是<strong>在一段数据的前后部分添加首部和尾部，这样就构成了一个帧</strong>。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p><p><strong>首部和尾部包含许多的控制信息，他们的一个重要作用是帧定界</strong>(确定帧的界限)。</p><p>一个帧分为首部、数据部分、尾部，为了传输效率一般是数据部分占比越大越好。但如果帧过长可能会导致一些传输问题（报文传输没有很好的效果）。所以规定了<strong>最大传输单元MTU，即数据部分不能超过这个长度。</strong></p><p>组帧的四种方法: </p><ol><li>字符计数法：帧首部使用一个计数字段(第一个字节，八位)来标明帧内字符数。容易出错。</li><li>字符(节)填充法：使用SOH和EOT。</li><li>零比特填充法：SOH和EOT都使用<code>01111110</code>，信息字段只要有连续5个1，就立即填入一个0。</li><li>违规编码法。使用违规表示的码元来表示SOH和EOT。</li></ol><p><img src="https://api.codetool.top/img/15862683419459.png" alt></p><h2 id="透明传输">3.2 透明传输</h2><p>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。</p><p><strong>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。</strong> 这样才能保证数据链路层的传输是透明的。</p><h2 id="差错控制">3.3 差错控制</h2><p>概括来说，传输中的差错都是由于噪声引起的。</p><p>全局性: 1. 由于线路本身电气特性所产生的<strong>随机噪声</strong>(热噪声)，是信道固有的，随机存在的。<br>解决办法:提高信噪比来减少或避免干扰。(对传感器下手)</p><p>局部性: 2. 外界特定的短暂原因所造成的<strong>冲击噪声</strong>，是产生差错的主要原因。<br>解决办法：通常利用编码技术来解决。</p><p>差错通常分为位错和帧错，假设发来一个<code>[#1]-[#2]-[#3]</code>的帧，帧错又分为：</p><ul><li>帧丢失：<code>[#1]-[#3]</code></li><li>帧重复：<code>[#1]-[#2]-[#2]-[#3]</code></li><li>帧失序：<code>[#1]-[#3]-[#2]</code></li></ul><p>差错控制技术分为差错检测和差错纠正。</p><h3 id="差错检测">3.3.1 差错检测</h3><ul><li><p>奇偶校验码，假设一个信息元共n位，用n-1位来表示数据，剩下一位用于满足整个位串中1个数的奇偶性，<strong>奇校验码要求1的个数为奇数，偶校验码要求1的个数为偶数</strong>。奇偶校验码的检错能力只能说一般，如果偶数个比特同时出现错误，就不能检测出。</p></li><li><p>循环冗余码CRC，发送端将数据划分为组，每组n（约定好的）位冗余码附在数据的最后，和接收端约定一个生成多项式P，这个P必须为n+1位。冗余码的计算方法为<code>M*n/P</code>得到的余数。接收端将得到的组除以R，如果余数为0（除尽），则说明无误，否则有误。</p></li></ul><p>差错检测检测出差错帧就会将其丢弃，保证接收端数据链路层接收的帧均无差错，但这还不是可靠传输。</p><h3 id="差错纠正">3.3.2 差错纠正</h3><p>海明码：能发现双比特错，只能纠正单比特错。</p><p>工作流程：</p><ol><li>确定校验码的位数r</li></ol><p>如何确定r？</p><p><strong>海明不等式：</strong> 2<sup>r</sup>≥k+r+1，k为信息位。例如要发送的数据的位数为6，则满足不等式的最小r为4，也就是校验码应有4位。</p><ol start="2"><li>确定校验码和数据的位置</li></ol><p>校验码只能填在2的几次方的位置，例如这4位校验码只能分别填在第1、2、4、8位。其他位置用于填写数据位。</p><ol start="3"><li>求出校验码的值</li></ol><p><img src="https://api.codetool.top/img/15862739568780.png" alt></p><p>对于任一校验码位，它的位置的二进制表示中有某一位为1，它负责校验的是数据位中位置的二进制表示中该位也为1的数据位。它的任务是令所有要校验的位（包括它本身）异或等于0。</p><p>例如对于校验位P1，它负责校验D1,D2,D4,D5。其中1⊕0⊕1⊕0=1，则它需要为0才能满足加上它后异或的结果等于0。</p><ol start="4"><li>检错并纠错</li></ol><h1 id="局域网">4 局域网</h1><p><img src="https://api.codetool.top/img/15862651714852.png" alt></p><h2 id="局域网拓扑结构">4.1 局域网拓扑结构</h2><ul><li>星型拓扑</li><li>总线型拓扑</li><li>环形拓扑</li><li>树形拓扑</li></ul><p>其中总线型拓扑不容易出现单点故障问题，比较常用。</p><h2 id="局域网介质访问控制方法">4.2 局域网介质访问控制方法</h2><ol><li>CSMA/CD：常用于总线型局域网，也用于树型网络。</li><li>令牌总线：常用于总线型局域网，也用于树型网络。它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</li><li>令牌环：用于环形局域网，如令牌环网。</li></ol><h2 id="局域网的分类">4.3 局域网的分类</h2><ol><li>以太网：以太网是应用最为广泛的局域网，包括标准以太网(10Mbps) 、快速以太网(100Mbps) 、千兆以太网(1000 Mbps)和10G以太网，它们都符合IEEE802.3系列标准规范。逻辑拓扑总线<br>型，物理拓扑是星型或拓展星型。使用CSMA/CD协议。</li><li>令牌环网：物理上采用了星形拓扑结构，逻辑上是环形拓扑结构。已是“明日黄花”。IEEE802.5</li><li>FDDI网：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构。</li><li>ATM网：较新型的单元交换技术，使用53字节固定长度的单元进行交换。</li><li>无线局域网(WLAN)：采用IEEE802.11标准。</li></ol><h2 id="MAC子层和LLC子层">4.4 MAC子层和LLC子层</h2><p>IEEE802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p><p>LLC：LLC<strong>负责识别网络层协议，然后对它们进行封装</strong>。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。<strong>为网络层提供服务</strong>:无确认无连接、面向连接、带确认无连接、高速传送。</p><p>MAC子层的主要功能包括<strong>数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制</strong>等。MAC子层的存在屏蔽了不同物理链路种类的差异性。</p><h3 id="MAC地址">4.4.1 MAC地址</h3><p>前三个字节为组织唯一标识符OUI，后三个字节为拓展标识符，由厂家自行指派。 </p><h3 id="MAC帧">4.4.2 MAC帧</h3><ul><li>6字节长目的地址</li><li>6字节长源地址</li><li>2字节长类型字段</li><li>46到1500字节之间的数据字段</li><li>4字节长帧检验序列FCS，是发送和接收都要使用循环冗余校验码（CRC）算法所产生的FCS字段的CRC码。</li></ul><p><img src="https://api.codetool.top/img/15866028161799.png" alt></p><p>MAC帧被物理层包装之后通常还会在前面插入一个八字节的前导码。</p><h2 id="以太网">4.5 以太网</h2><p>使用DIX Ethernet V2或IEEE 802.3就称为以太网，以太网提供无连接、不可靠的服务</p><ul><li>无连接：发送方和接收方之间无“握手过程”。</li><li>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</li></ul><h2 id="CSMA-CD协议">4.6 CSMA/CD协议</h2><p>CD：碰撞检测(冲突检测)，“边发送边监听” ，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</p><p>以太网端到端的往返时间2t称为争用期（碰撞窗口），最大不会超过这个时间就能监听到碰撞。</p><p><img src="https://api.codetool.top/img/1586355649295.png" alt></p><p>了解：截断二进制指数退避算法</p><h2 id="拓展的以太网">4.7 拓展的以太网</h2><h3 id="物理层拓展以太网">4.7.1 物理层拓展以太网</h3><p>光纤代替铜线，使用集线器</p><p><img src="https://api.codetool.top/img/15863560046212.png" alt></p><h3 id="链路层拓展以太网">4.7.2 链路层拓展以太网</h3><p>通过网桥、交换式集线器或是第二层交换机</p><p>网桥是交换机的前身，交换机又称为多端口网桥。</p><p>交换机根据MAC帧的目的地址对帧进行转发和过滤。当交换机收到一个帧时，并不向所有接口转发此帧，而是<strong>先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口</strong>，或者是把它丢弃(即过滤)。</p><p>自学习：动态填充转发表。交换机在<strong>收到一个MAC帧的时候，就知道对应的设备与哪个端口相连，从而动态扩充转发表。</strong></p><p><strong>交换机、网桥的每一个端口隔离一个冲突域，但不能隔离广播域。</strong></p><p><strong>集线器中的设备是共享带宽的，交换机中的设备是独占带宽的。</strong></p><p>交换机类型：</p><ul><li>直通式交换机：查完目的地址就立刻转发。延迟小，可靠性低，无法支持具有不同速率的端口的交换。</li><li>存储转发式交换机：将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。延迟大，可靠性高，可以支持具有不同速率的端口的交换。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的数据链路层指的是原理体系结构的数据链路层，对应OSI七层体系结构中的数据链路层，对应TCP/IP四层体系结构中的网络接口层的一部分。它提供介质访问和链路管理，为网络层提供服务。其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是&lt;str
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典01.07-旋转矩阵</title>
    <link href="https://www.codetool.top/article/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.codetool.top/article/程序员面试金典01-07-旋转矩阵/</id>
    <published>2020-04-07T06:12:39.000Z</published>
    <updated>2020-04-07T06:18:02.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><p>不占用额外内存空间能否做到？</p><p><strong>示例 1:</strong></p><pre><code>给定 matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],原地旋转输入矩阵，使其变为:[  [7,4,1],  [8,5,2],  [9,6,3]]</code></pre><p><strong>示例 2:</strong></p><pre><code>给定 matrix =[  [ 5, 1, 9,11],  [ 2, 4, 8,10],  [13, 3, 6, 7],  [15,14,12,16]], 原地旋转输入矩阵，使其变为:[  [15,13, 2, 5],  [14, 3, 4, 1],  [12, 6, 8, 9],  [16, 7,10,11]]</code></pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>用翻转代替旋转（先对角线翻转，再水平翻转）</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;给你一幅由 &lt;code&gt;N × N&lt;/code&gt; 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;/p&gt;
&lt;p&gt;不占用额外内存空间能否做到？&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git上传到仓库之后大写变小写的问题</title>
    <link href="https://www.codetool.top/article/git%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BB%93%E5%BA%93%E4%B9%8B%E5%90%8E%E5%A4%A7%E5%86%99%E5%8F%98%E5%B0%8F%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/git上传到仓库之后大写变小写的问题/</id>
    <published>2020-04-07T05:46:14.000Z</published>
    <updated>2020-04-08T04:15:09.791Z</updated>
    
    <content type="html"><![CDATA[<p>最近在翻之前的博客的时候发现有几篇博客打开是404状态，不知道怎么回事，以为hexo出bug了。就仔细研究了一下，首先在本地生成的静态文件中是存在的，然后就到远程git仓库里看了一眼，发现对应的文件夹的名字首字母是小写，而本地文件是大写，导致网页文件无法定位。</p><p>具体的原因是我之前将该文件从小写改为了大写，而<strong>git默认是不区分文件名或文件夹名的大小写的</strong>，也就没有同步成大写。</p><p>解决方案：</p><p>查看是否忽略大小写：</p><p><code>git config core.ignorecase</code>，默认是true</p><p>通过 <code>git config core.ignorecase false</code> 设置为区分大小写</p><p>注意在hexo的<code>/.deploy_git</code>下进行该设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在翻之前的博客的时候发现有几篇博客打开是404状态，不知道怎么回事，以为hexo出bug了。就仔细研究了一下，首先在本地生成的静态文件中是存在的，然后就到远程git仓库里看了一眼，发现对应的文件夹的名字首字母是小写，而本地文件是大写，导致网页文件无法定位。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="网站日志" scheme="https://www.codetool.top/tags/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>计网复习02-物理层</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A002-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://www.codetool.top/article/计网复习02-物理层/</id>
    <published>2020-04-06T14:23:21.000Z</published>
    <updated>2020-04-06T16:14:58.980Z</updated>
    
    <content type="html"><![CDATA[<p>这里的物理层指的是原理体系结构的物理层，对应OSI七层模型的物理层，对应TCP/IP四层模型中的网络接口层中的一部分。它为数据链路层提供服务，为数据传输提供可靠环境。</p><h1 id="基本概念">1 基本概念</h1><p><img src="https://api.codetool.top/img/15861830461240.png" alt></p><p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。</p><p>物理层的协议是非常多的，因为这一层是一些硬件设备，不同的硬件设备、不同的品牌之间可能存在着不同的协议。</p><p>物理层的主要任务就是确定与传输媒体接口有关的一些特性：</p><ul><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li><li>工程特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</li><li>规程特性(过程特性)：定义各条物理线路的工作规程和时序关系。</li></ul><h1 id="数据通信的基础知识">2 数据通信的基础知识</h1><p><img src="https://api.codetool.top/img/15861831088122.png" alt></p><h2 id="数据通信系统模型">2.1 数据通信系统模型</h2><p>在传统的电话线（ASDL）上网中，数据需要进行调制解调，数据通信系统模型：</p><ul><li>源系统<ul><li>源点（信源）：产生要传输的数据</li><li>发送器：调制传输的数据从数字信号转换为模拟信号</li></ul></li><li>传输系统：传送模拟信号</li><li>目的系统<ul><li>接收器：接收模拟信号，并解调为数字信号</li><li>终点（信宿）：从接收器获取比特流</li></ul></li></ul><h3 id="基带信号与宽带信号">2.1.1 基带信号与宽带信号</h3><p>基带信号：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)。来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。</p><p>宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输(宽带传输)。把基带信号经过<strong>载波调制</strong>后，<strong>把信号的频率范围搬移到较高的频段以便在信道中传输</strong>(即仅在一段频率范围内能够通过信道)。</p><h3 id="调制">2.1.2 调制</h3><p>基带调制：（信息-&gt;数字信号）</p><ul><li>不归零制：高1低0，编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。</li><li>归零制：信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</li><li>曼彻斯特编码：信号周期内会发生跳变，向上跳为0，向下跳为1。也可以采用相反的规定。</li><li>差分曼彻斯特编码：首先位中心必跳变，如果该位的前半段（和上一个位的后半段）相反，则为0，相同则为1。</li></ul><p><img src="https://api.codetool.top/img/15861879851932.png" alt></p><p>带通调制：（数字信号-&gt;模拟信号）</p><p><img src="https://api.codetool.top/img/15861883565831.png" alt></p><p>分别对应调幅、调频、调相。</p><p>正交振幅调制QAM：调幅+调相。</p><h2 id="相关概念">2.2 相关概念</h2><h3 id="信道">2.2.1 信道</h3><p><strong>信道:</strong> 信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。 </p><h3 id="三种通信方式">2.2.2 三种通信方式</h3><ol><li>单工通信（单向通信）只有一个方向的通信而没有反方向的交互，仅需要一条信道。</li><li>半双工通信（双向交替通信）通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。</li><li>全双工通信（双向同时通信）：通信双方可以同时发送和接受信息，也需要两条信道。</li></ol><h3 id="码元">2.2.3 码元</h3><p><strong>码元</strong>是指用一个<strong>固定时长的信号波形(数字脉冲)</strong>，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，<strong>这个时长内的信号称为k进制码元</strong>，而<strong>该时长称为码元宽度</strong>。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。</p><p>1码元可以携带多个比特的信息量。例如，<strong>在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</strong></p><h3 id="两种速率表示方式">2.2.4 两种速率表示方式</h3><p><strong>速率</strong>也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用<strong>码元传输速率和信息传输速率</strong>表示。</p><p><strong>码元传输速率:</strong> 别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是波特(Baud) 。<strong>1波特表示数字通信系统每秒传输一个码元</strong>。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</p><p><strong>信息传输速率:</strong> 别名信息速率、比特率等，表示<strong>单位时间内数字通信系统传输的二进制码元个数(即比特数)</strong>，单位是比特/秒(b/s) 。</p><p><strong>对于二进制码元，波特和比特/秒的含义是一样的，因为二进制码元携带的比特量就是1比特</strong></p><h3 id="失真">2.2.5 失真</h3><p>信号在传输过程中，由于实际信道有噪声、干扰、带宽的限制，导致接收端接收的信号和发送端发送的信号不一致，这就是失真现象。所谓失真就是失去了真实性。</p><p>影响失真程度的因素：码元传输速率、信号的传输距离、噪声干扰、传输媒体的质量。</p><p>码元传输速率越大、信号传输距离越远、噪声干扰越大、或传输媒体质量越差，波形失真越严重。</p><h3 id="码间串扰">2.2.6 码间串扰</h3><p>具体的信道所能通过的频率范围是有限的。对于信号带宽小的信号，由于实际信道的干扰等，会使信号衰减导致失真严重。而对于信号带宽过大的信号，如果信号中的<strong>高频分量在传输过程受到衰减</strong>，那么在接收端收到的波形前沿和后沿变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的。这样，在<strong>接收端接收到的信号波形就失去了码元之间清晰的界限（可以类比一排密集的点快速的移动，点与点之间的界限就会变得很模糊</strong>，就很难分辨有多少个点了，如果点分布的疏，移动慢速，就可以很清晰的分辨每一个点）。</p><p><img src="https://api.codetool.top/img/15861868115257.webp" alt></p><h3 id="奈氏准则">2.2.7 奈氏准则</h3><p>奈氏准则：<strong>在理想低通（无噪声、带宽受限）条件下，为了避免码间串扰，极限码元传输速率为<code>2W Baud</code>，W是信道带宽，单位是HZ。</strong></p><p>通过奈氏准则可知，如果信道的频带越宽，能够通过的信号高频分量越多，那么就可以用更高速率传送码元而不出现码间串扰。由于码元的传输速率受奈氏准则的制约，所以<strong>要提高数据的传输速率，就必须设法使每个码元能携带更多的个比特量的信息，这就需要多元制的调制方法。</strong></p><h3 id="信噪比">2.2.8 信噪比</h3><p>信噪比就是信号的平均功率和噪声的平均功率之比，常记于S/N，并用分贝（dB）作为度量单位。即</p><p><code>信噪比（dB） = 10 lg(S/N) (dB)</code></p><h3 id="香农公式">2.2.9 香农公式</h3><p><strong>在带宽受限且有噪声的信道中</strong>，为了不产生误差，信息的数据传输率有上限值。</p><p>信道的极限数据传输速率 = W log<sub>2</sub>(1+S/N) (b/s)</p><p>总结：</p><ol><li>信道的带宽越大或信道的信噪比越大，则信息的极限传输速率就越高。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错传输。</li><li>香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低很多。</li></ol><h1 id="传输媒体">3 传输媒体</h1><p><img src="https://api.codetool.top/img/15861831231734.png" alt></p><h1 id="信道复用技术">4 信道复用技术</h1><p><img src="https://api.codetool.top/img/15861831413598.png" alt></p><h1 id="数字传输系统">5 数字传输系统</h1><p><img src="https://api.codetool.top/img/15861831529164.png" alt></p><h1 id="宽带接入技术">6 宽带接入技术</h1><p><img src="https://api.codetool.top/img/15861831894871.png" alt></p><h1 id="物理层常见设备">7 物理层常见设备</h1><h2 id="中继器">7.1 中继器</h2><p><strong>诞生原因:</strong> 由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p><strong>中继器的功能:</strong> 对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p><p><strong>中继器的两端:</strong> 两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</p><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是<br>否有错误数据或不适于网段的数据。两端可连相同媒体，也可连不同媒体。但是两端的网段一定要是同一个协议。</p><h2 id="集线器">7.2 集线器</h2><p>集线器是一种多口中继器。它也可以对信号进行再生和还原，对衰减的信号进行放大。接着<strong>转发到其他所有(除输入端口外)处于工作状态的端口上</strong>，以增加信号传输的距离，延长网络的长度。<strong>不具备信号的定向传送能力，是一个共享式设备。</strong></p><p><strong>集线器不隔离冲突域，同一集线器下的主机属于同一个冲突域</strong>，所以通过集线器互联的局域网内的主机数到达一定数量之后通信效率会急剧降低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的物理层指的是原理体系结构的物理层，对应OSI七层模型的物理层，对应TCP/IP四层模型中的网络接口层中的一部分。它为数据链路层提供服务，为数据传输提供可靠环境。&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;1 基本概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用数据类型使用的数据结构</title>
    <link href="https://www.codetool.top/article/Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://www.codetool.top/article/Redis常用数据类型使用的数据结构/</id>
    <published>2020-04-06T11:00:07.000Z</published>
    <updated>2020-04-06T12:20:32.018Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p>[Redis数据结构——压缩列表 - 老於` - 博客园](<a href="https://www.cnblogs.com/hunternet/p/11306690.html" target="_blank" rel="noopener">https://www.cnblogs.com/hunternet/p/11306690.html</a>)</p><p>极客时间《数据结构与算法之美》</p><p>总体来说，Redis的key-value数据存储是通过哈希表实现的，那么具体到某一数据类型，又是使用了什么数据结构呢？这里我们着重看Redis中的五大数据类型：String、Hash、List、Set、Sorted_set。其中String类型非常简单，就是字符串。</p><h1 id="List">1 List</h1><p>我们先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是压缩列表（ziplist），另一种是双向循环链表。</p><h2 id="压缩列表（ZipList）">1.1 压缩列表（ZipList）</h2><p>当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ul><li>列表中保存的单个数据（有可能是字符串类型的）小于 64 字节。</li><li>列表中数据个数少于 512 个。</li></ul><p>它不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同（可以混合存储不同类型，不同大小的数据）。</p><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存,是相较于数组的存储思路而言的。我们知道,数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是20个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。</p><p><img src="https://api.codetool.top/img/15861719516161.png" alt></p><p>数组的优势是占用一片连续的空间可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。</p><p><img src="https://api.codetool.top/img/158617199613.png" alt></p><p>但是这样有一个问题，我们在遍历它的时候由于不知道每个元素的大小是多少，因此也就无法计算出下一个节点的具体位置。这个时候我们可以给每个节点增加一个length的属性。</p><p><img src="https://api.codetool.top/img/15861720704814.png" alt></p><p>这种设计思想并不少见，java的class文件字节码中涉及到字段表、方法表、属性表，都会先给一个数据项数，然后紧跟的是数据项的列表，每一个数据项开头都会记录数据项的长度。这部分相关内容见<a href="../Java字节码实例探究">Java字节码实例探究</a></p><p>Redis中的压缩列表，构成如下图：</p><p><img src="https://api.codetool.top/img/15861721358278.png" alt></p><p>一个压缩列表可以包含任意多个节点(entry),<strong>每个节点可以保存一个字节数组或者一个整数值</strong>。除了存储节点外，头部还存储了额外的信息：</p><ul><li>zlbytes：列表总长度</li><li>zltail：最后一个节点地址据列表起始地址的偏移量</li><li>zllen：节点个数</li></ul><p>尾部附加了一个<code>zlend</code>作为结束的标识。</p><p>压缩列表相较于数组，虽然节省了空间，但失去了数组的随机访问性，由于每个数据项的大小都可能不同，不能通过计算偏移量来获取某一中间元素的地址，只能顺序访问，这一点就跟链表一样，比链表好的是物理上的存储还是连续的，不必多次寻址。所以数据项较多时压缩列表就不适用了，进而使用双向循环链表。</p><h2 id="双向循环链表">1.2 双向循环链表</h2><p>当不满足压缩列表的使用条件时，就使用双向循环链表，这部分较简单。</p><p><img src="https://api.codetool.top/img/15861730113811.png" alt></p><h1 id="Hash">2 Hash</h1><p>Hash类型又称字典类型，也有两种实现方式。一种是我们刚刚讲到的压缩列表，另一种是散列表。</p><p>同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p><ul><li>字典中保存的键和值的大小都要小于 64 字节；</li><li>字典中键值对的个数要小于 512 个。</li></ul><p>当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用<code>MurmurHash2</code> 这种运行速度快、随机性好的哈希算法作为哈希函数。<strong>对于哈希冲突问题，Redis 使用链表法（拉链法）来解决。</strong>除此之外，Redis 还支持散列表的动态扩容、缩容。</p><p>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，<strong>当装载因子大于 1 的时候（对于使用拉链法解决哈希冲突的哈希表装载因子是有可能大于1的），Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右。</strong></p><p>当数据动态减少之后，为了节省内存，<strong>当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小。</strong></p><p>由于扩容缩容要做大量的数据搬移和哈希值的重新计算，比较耗时。针对这个问题，Redis 使用了渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。</p><h1 id="Set">3 Set</h1><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。</p><p>当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。</p><ul><li>存储的数据都是整数。</li><li>存储的数据元素个数不超过 512 个。</li></ul><p>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p><h1 id="Sorted-set">4 Sorted_set</h1><p>Sorted_set又称有序集合，它用来存储一组数据，并且每个数据会附带一个得分（权重）。根据得分实现对个数据进行排序。</p><p>它的底层通过跳表实现，相关内容参考<a href="../跳表-披着链表外衣的伪搜索树">跳表-披着链表外衣的伪搜索树</a>。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><p>实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。当数据量比较小的时候，Redis 会用压缩列表来实现有序集合。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：</p><ul><li>所有数据的大小都要小于 64 字节。</li><li>元素个数要小于 128 个。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;[Redis数据结构——压缩列表 - 老於` - 博客园](&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/11306690.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode72-编辑距离</title>
    <link href="https://www.codetool.top/article/leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>https://www.codetool.top/article/leetcode72-编辑距离/</id>
    <published>2020-04-06T05:23:46.000Z</published>
    <updated>2020-04-09T14:46:13.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你两个单词 <em>word1</em> 和 <em>word2*，请你计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> word1 = “horse”, word2 = “ros”<br><strong>输出：</strong> 3<br><strong>解释：</strong><br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)      </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong> word1 = “intention”, word2 = “execution”<br><strong>输出：</strong> 5<br><strong>解释:</strong><br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)   </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>编辑距离算法，和KMP算法一样，属于字符串处理里面的经典算法了，KMP算法属于精准模式匹配，而编辑距离算法用于处理两个字符串之间的相似度，也属于一种匹配方式。</p><p>一般来说,编辑距离越小,两个字符串的相似度越大。 并且编辑距离算法广泛运用于生产中，例如搜索引擎通过编辑距离算法来智能识错，word软件通过编辑距离算法做拼写检查。</p><p>思想就是动态规划：</p><p><img src="https://api.codetool.top/img/1586151429724.png" alt></p><p>画一个矩阵，中间的格子代表从一个字符串到另一个字符串的编辑距离。</p><p>对于第一行、第一列，我们提前赋值1~n，代表仅通过插入的方式计算的编辑距离。</p><p>然后，对于任意一个格子，例如图中的红色格子<code>dp[m][n]</code>，它可能由字符串A插入一个字符、字符串B插入一个字符，字符串A修改一个字符得到，对于修改字符，如果两个字符串在该位置上的字符相同，则不用修改，对应的最小编辑距离就是<code>min(dp[m][n-1],dp[m-1][n],dp[m-1][n-1]-1)+1</code>，实际上最小的必是<code>dp[m-1][n-1]-1</code>，即此时编辑距离为<code>dp[m-1][n-1]</code>，如果两个字符串在该位置上的字符不同，则需要修改最后一个字符，此时最小编辑距离为<code>min(dp[m][n-1],dp[m-1][n],dp[m-1][n-1])+1</code></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n1 <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n2 <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你两个单词 &lt;em&gt;word1&lt;/em&gt; 和 &lt;em&gt;word2*，请你计算出将 *word1&lt;/em&gt; 转换成 &lt;em&gt;word2&lt;/em&gt; 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;o
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合模板引擎Thymeleaf</title>
    <link href="https://www.codetool.top/article/SpringBoot%E6%95%B4%E5%90%88%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EThymeleaf/"/>
    <id>https://www.codetool.top/article/SpringBoot整合模板引擎Thymeleaf/</id>
    <published>2020-04-05T14:48:21.000Z</published>
    <updated>2020-04-05T14:49:09.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-对静态资源的映射规则">1 SpringBoot 对静态资源的映射规则</h1><p>所有 <code>/webjars/**</code>的请求 ，都去 classpath:/META-INF/resources/webjars/ 找资源；</p><p>resources-&gt;webjars引入静态资源</p><p><a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--引入jquery-webjar--></span>在访问的时候只需要写webjars下面资源的名称即可<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.webjars<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jquery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>所有”/**” 请求，会去以下文件夹查找：</p><ul><li><code>&quot;classpath:/META-INF/resources/&quot;</code></li><li><code>&quot;classpath:/resources/&quot;</code></li><li><code>&quot;classpath:/static/&quot;</code></li><li><code>&quot;classpath:/public/&quot;</code> </li><li><code>&quot;/&quot;</code>：当前项目的根路径</li></ul><h1 id="Thymeleaf">2 Thymeleaf</h1><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。</p><p>Thymeleaf是SpringBoot官方推荐使用的模板引擎。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="springboot相关配置">2.1 springboot相关配置</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#thymeleaf start</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">thymeleaf</span><span class="token punctuation">:</span>        <span class="token key atrule">mode</span><span class="token punctuation">:</span> HTML5        <span class="token key atrule">encoding</span><span class="token punctuation">:</span> UTF<span class="token punctuation">-</span><span class="token number">8</span>        <span class="token comment" spellcheck="true"># 开发时关闭缓存,不然没办法实现热刷新</span>        <span class="token key atrule">cache</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>        <span class="token comment" spellcheck="true"># prefix和suffix都是默认的，可不用配置</span>        <span class="token key atrule">prefix</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>/templates/ <span class="token comment" spellcheck="true"># 模版存放路径</span>        <span class="token key atrule">suffix</span><span class="token punctuation">:</span> .html <span class="token comment" spellcheck="true"># 模版后缀</span>        <span class="token key atrule">servlet</span><span class="token punctuation">:</span>            <span class="token key atrule">content-type</span><span class="token punctuation">:</span> text/html<span class="token comment" spellcheck="true">#thymeleaf end</span></code></pre><h2 id="简单案例">2.2 简单案例</h2><p>创建springboot工程，配置如上所示</p><p>在<code>/template</code>下新建<code>demo1.html</code>:</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>thymeleaf入门案例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${message}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>新建controller类<code>com.rhett.controller.TestController</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span><span class="token punctuation">{</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span><span class="token string">"hello thymeleaf!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"demo1"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>启动程序，访问<code>/hello</code>资源，看到页面正确输出。</p><h2 id="基本语法">2.3 基本语法</h2><p>Thymeleaf语法可以参考 <a href="https://www.cnblogs.com/itdragon/archive/2018/04/13/8724291.html" target="_blank" rel="noopener">https://www.cnblogs.com/itdragon/archive/2018/04/13/8724291.html</a></p><p>基本语法就是在html标签中使用<code>th:**</code>属性，里面使用表达式。</p><h3 id="表达式">2.3.1 表达式</h3><p>Variable Expressions: <code>${...}</code></p><p>Selection Variable Expressions: <code>*{...}</code></p><p>Message Expressions: <code>#{...}</code></p><p>Link URL Expressions: <code>@{...}</code></p><p>Fragment Expressions: <code>~{...}</code></p><h3 id="th-action">2.3.2 th:action</h3><p>定义后台控制器路径，类似<form>标签的action属性。</form></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>login-form<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{/test/hello}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><p>表示提交的请求地址为/test/hello</p><h3 id="th-each">2.3.3 th:each</h3><p>对象遍历，功能类似jstl中的<code>&lt;c:forEach&gt;</code>标签。</p><p>实体类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//..get..set</span><span class="token punctuation">}</span></code></pre><p>Controller添加数据</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** * 访问/test/hello  跳转到demo1页面 * @param model * @return */</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span><span class="token punctuation">{</span>    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"hello welcome"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//集合数据</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token string">"深圳"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"李四"</span><span class="token punctuation">,</span><span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"王五"</span><span class="token punctuation">,</span><span class="token string">"武汉"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"users"</span><span class="token punctuation">,</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"demo1"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>thymeleaf页面：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>下标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>编号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>住址<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name"><span class="token namespace">th:</span>each</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user,userStat:${users}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            下标:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${userStat.index}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>,        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${user.id}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${user.name}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${user.address}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span></code></pre><p>其中<code>user</code>代表当前遍历到的对象，<code>userStat</code>存储了一些遍历的相关信息，例如当前下标。</p><p><code>th:each</code>还可用于遍历Map、数组。</p><h3 id="th-if">2.3.4 th:if</h3><p>后台添加年龄</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//if条件</span>model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>页面输出</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${(age<span class="token punctuation">></span><span class="token punctuation">=</span>18)}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>终于长大了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h3 id="Date输出">2.3.5 Date输出</h3><p>后台添加日期</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//日期</span>model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"now"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>页面输出</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${#dates.format(now,<span class="token punctuation">'</span>yyyy-MM-dd hh:ss:mm<span class="token punctuation">'</span>)}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot-对静态资源的映射规则&quot;&gt;1 SpringBoot 对静态资源的映射规则&lt;/h1&gt;&lt;p&gt;所有 &lt;code&gt;/webjars/**&lt;/code&gt;的请求 ，都去 classpath:/META-INF/resources/webjars/ 找资源；
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="https://www.codetool.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer05-替换空格</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://www.codetool.top/article/剑指offer05-替换空格/</id>
    <published>2020-04-05T04:32:06.000Z</published>
    <updated>2020-04-05T04:33:43.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> s = “We are happy.”<br><strong>输出：</strong> “We%20are%20happy.”</p></blockquote><p><strong>限制：</strong></p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>简单题打卡，没有思想</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">replaceSpace</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"%20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;请实现一个函数，把字符串 &lt;code&gt;s&lt;/code&gt; 中的每个空格替换成”%20”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法的介绍</title>
    <link href="https://www.codetool.top/article/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/一致性哈希算法的介绍/</id>
    <published>2020-04-04T15:13:19.000Z</published>
    <updated>2020-04-04T15:41:18.002Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://zhuanlan.zhihu.com/p/98030096" target="_blank" rel="noopener">一致性Hash算法详解 - 知乎</a></p><h1 id="一致性哈希算法概述">1 一致性哈希算法概述</h1><p>分布式系统中，常常听到一种算法叫<strong>一致性哈希算法</strong>，而最常用的领域相信大家也有所耳闻——负载均衡。负载均衡有许多算法，例如轮询、随机、加权轮询/随机、最小连接数。但是假如我们需要会话粘滞（session sticky）呢？</p><p>什么是会话粘滞：给同一个客户提供服务的服务器永远是同一台，就能实现每次连接都是上次的session。例如我去银行办手续，谈到一半发现自己身份证忘带了，需要回家拿身份证，那么我拿完身份证回来之后希望还是同一个业务员来接待我。</p><p>一致性哈希算法就保证了分布式系统中每次给同一台客户机服务的主机都是同一台，而分辨是否是同一台客户机的依据就是客户机的IP。那么如何根据这个IP来选取同一台服务器来服务呢，如果使用哈希算法获取同一个哈希值，则这个哈希值的生成必须不能和服务器的个数相关，否则一旦服务器增加或者减少，最终生成的哈希值都会变化。</p><h1 id="一致性哈希算法原理">2 一致性哈希算法原理</h1><h2 id="环形hash空间">2.1 环形hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。</p><p><img src="https://api.codetool.top/img/15860140974532.jpg" alt></p><h2 id="映射服务器节点">2.2 映射服务器节点</h2><p><strong>将各个服务器进行一个哈希</strong>，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样<strong>每台机器就能确定其在哈希环上的位置</strong>。假设我们将四台服务器使用ip地址哈希后在环空间的位置如下：</p><p><img src="https://api.codetool.top/img/15860141686747.jpg" alt></p><h2 id="映射数据">2.3 映射数据</h2><p>现在我们将objectA、objectB、objectC、objectD四个对象（代表客户机的IP）通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p><p><img src="https://api.codetool.top/img/15860142379243.jpg" alt></p><h2 id="服务器的删除与添加">2.4 服务器的删除与添加</h2><p>如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化。</p><p>这时可能就有问题了，不是说能保证每次给同一个客户服务的都是同一台服务器吗？那现在把C重新分配给Node D是怎么回事？</p><p>我们只能尽可能地保证每次给同一个客户服务的都是同一台服务器，但是Node C宕机了也没办法啊😂而且影响到的只有之前分配给Node C的客户机，对于A、B、D都没有影响到。</p><p>如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。</p><h2 id="虚拟节点">2.5 虚拟节点</h2><p>前面部分讲述到的都是节点较多和节点分布较为均衡的情况，当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。</p><p><img src="https://api.codetool.top/img/15860147726736.jpg" alt></p><p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即<strong>对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点</strong>，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://api.codetool.top/img/1586014722278.jpg" alt></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。每个物理节点关联的虚拟节点数量就根据具体的生产环境情况在确定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/98030096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一致性Hash算法详解 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一致性哈希算法概述&quot;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="https://www.codetool.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>海量数据-两种方法解决top k问题</title>
    <link href="https://www.codetool.top/article/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE-%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3top%20k%E9%97%AE%E9%A2%98/"/>
    <id>https://www.codetool.top/article/海量数据-两种方法解决top k问题/</id>
    <published>2020-04-04T11:55:19.000Z</published>
    <updated>2020-04-04T14:33:09.376Z</updated>
    
    <content type="html"><![CDATA[<p>假如提供一百万个数据（甚至更大）的无序数组，如何从中获取最大的k个元素？</p><p>最容易想到的是先降序排序然后获取前k个元素，那假设我们用最常用的<code>O(nlogn)</code>级别的排序算法，要获取top k，时间成本也就是排序成本了，为<code>O(nlogn)</code>，而这里的n是百万级别的，那能不能更快一点呢？</p><h1 id="最小堆">1 最小堆</h1><p>假设我们设定一个最小堆，并固定这个最小堆的最大大小为k，那么任何一时刻堆顶元素都是这个堆中的第k大的数据（也是最小的数据）。来一个数据就和堆顶元素比较，如果比堆顶元素大就替换堆顶元素，并堆化。最后当所有数据都走一遍后，堆内的元素就是所有数据中最大的k个元素，而堆顶元素就是第k大的元素。</p><p>那么我们来分析一下它在时间复杂度上优化了多少吧。首先所有数据都要走一遍比较，就是n，其次维护了一个大小为k的堆，也就是说堆化的时间复杂度为<code>O(log k)</code>，那么总的时间复杂度就是<code>O(nlogk)</code> ，乍一看和先排序的时间复杂度<code>O(nlogn)</code>也没差多少，甚至说是一个衡量级别的，但毕竟这里说的是海量数据，n可能很大，k可能比较小，那么时间上就快很多了。</p><p>它的另一个好处是空间复杂度也仅为<code>O(k)</code>，不需要额外维护一个<code>O(n)</code>级别的海量数据存储。</p><p>代码实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKByHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>minHeap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="快排思想">2 快排思想</h1><p><img src="https://api.codetool.top/img/15860045819866.jpg" alt></p><p><code>O(nlogk)</code>好像还是有点不够看，能不能直接优化成<code>O(n)</code>呢？</p><p>我们知道快排的思想是每次随机选取一个pivot把数组划分成相对有序的两部分，那假设第一次随机选取pivot并分区之后，后面这部分的元素数量就正好为k，不就说明后面这部分数据就是最大的k个元素，那最好时间复杂度岂不是<code>O(logn)</code>？</p><p><img src="https://api.codetool.top/img/15860048484250.jpg" alt></p><p>那么问题就成为了选中一个pivot，将数组分为前后两部分，后面部分元素的数量为k的问题。</p><p>虽然很难一次就中，但我们在一次分区后，通过比较k和后面部分元素的数量就知道了，后面部分的元素是分多了还是分少了。</p><p>如果后面的元素数量分多了，就继续在后面这部分数据中随机选取pivot，重复步骤。如果后面的元素分少了，则往前选取pivot，就形成了一种类似二分查找的步骤。</p><p>那么我们来分析一下它的时间复杂度，我们知道快速排序每次分区的时间复杂度就是<code>log(n)</code>，那么我们假设每次分区前后两部分的数量相近，那么时间复杂度就是<code>log(n)+log(n/2)+log(n/4)+...</code>，取极限为<code>log(2n)</code>，即<code>log(n)</code>级别，是不是比一开始的<code>log(nlogn)</code>快很多？特别是在海量数据的情况下。</p><p>代码实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topK</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果是 BottomK 的话就不需要单独处理 k==n 情况了，因为划分是小于等于放在左</span>    <span class="token comment" spellcheck="true">// topK 的话如果是将大于的 k 个放在右边，那么 pivot 就变成了-1，会形成死循环。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> IntStream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> QuickSort<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> QuickSort<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> QuickSort<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的Quicksort得自己实现了，这里不作为重点，可以参考<a href="../十大排序算法与Java实现">十大排序算法与Java实现</a></p><h1 id="如果是找第K大的元素呢？">3 如果是找第K大的元素呢？</h1><p>作为拓展，讨论一下如果要找第K大的数据，仍然可以用这两个方法：</p><ul><li>对于最小堆则是操作一遍之后直接取堆顶元素。</li><li>对于快排思想，则是找一个pivot，使得分区之后它正好处于第<code>arr.length-k+1</code>的位置上。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如提供一百万个数据（甚至更大）的无序数组，如何从中获取最大的k个元素？&lt;/p&gt;
&lt;p&gt;最容易想到的是先降序排序然后获取前k个元素，那假设我们用最常用的&lt;code&gt;O(nlogn)&lt;/code&gt;级别的排序算法，要获取top k，时间成本也就是排序成本了，为&lt;code&gt;O(n
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="海量数据" scheme="https://www.codetool.top/tags/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer04-二维数组中的查找</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.codetool.top/article/剑指offer04-二维数组中的查找/</id>
    <published>2020-04-04T06:53:21.000Z</published>
    <updated>2020-04-09T14:46:30.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><blockquote><p>[<br>&nbsp;&nbsp;[1,&nbsp;&nbsp;&nbsp;4,&nbsp;&nbsp;7,&nbsp;11,&nbsp;15],<br>&nbsp;&nbsp;[2,&nbsp;&nbsp;&nbsp;5,&nbsp;&nbsp;8,&nbsp;12,&nbsp;19],<br>&nbsp;&nbsp;[3,&nbsp;&nbsp;&nbsp;6,&nbsp;&nbsp;9,&nbsp;16,&nbsp;22],<br>&nbsp;&nbsp;[10,&nbsp;13,&nbsp;14,&nbsp;17,&nbsp;24],<br>&nbsp;&nbsp;[18,&nbsp;21,&nbsp;23,&nbsp;26,&nbsp;30]<br>]</p></blockquote><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><p><strong>限制：</strong></p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>0 &lt;= m &lt;= 1000</code></p><p><strong>注意：</strong> 本题与主站 240 题相同：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我用的dfs..思路比较清晰点。（不推荐）</p><p>官方给的题解思想（减而治之，标识数法）非常巧妙：可以从右上角或左下角开始线性搜索，因为右上角的元素为列开始的最大值，而左下角的元素为行开始的最大值。一旦这个数比要查找的数大，就可以排除这一行/这一列。</p><h2 id="代码">2.2 代码</h2><p>dfs：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrixGlo<span class="token punctuation">;</span>    Boolean<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dfs<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        dfs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">[</span>matrix<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        matrixGlo <span class="token operator">=</span> matrix<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">>=</span>matrixGlo<span class="token punctuation">.</span>length<span class="token operator">||</span>y<span class="token operator">>=</span>matrixGlo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dfs<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> dfs<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrixGlo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrixGlo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        dfs<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>标识数法:（作者：liweiwei1419）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rows <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cols <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cols <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 从左下角开始查找</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> rows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> cols <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                y<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> cols <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            x<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
