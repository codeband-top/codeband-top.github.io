<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-03-08T16:22:43.537Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode121-买卖股票的最佳时机</title>
    <link href="https://www.codetool.top/article/leetcode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://www.codetool.top/article/leetcode121-买卖股票的最佳时机/</id>
    <published>2020-03-08T16:12:45.000Z</published>
    <updated>2020-03-08T16:22:43.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [7,1,5,3,6,4]<br><strong>输出:</strong> 5<br><strong>解释:</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [7,6,4,3,1]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>从左往右记录最低点，记录下当前价格与最低点的差值的最大值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minprice <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span> maxprofit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minprice<span class="token punctuation">)</span>                minprice <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minprice <span class="token operator">></span> maxprofit<span class="token punctuation">)</span>                maxprofit <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minprice<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxprofit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理与自定义配置介绍</title>
    <link href="https://www.codetool.top/article/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/SpringBoot自动配置原理与自定义配置介绍/</id>
    <published>2020-03-08T13:34:46.000Z</published>
    <updated>2020-03-08T13:36:31.395Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot配置与自动配置原理</p><h1 id="自动配置原理">1 自动配置原理</h1><p>SpringBoot启动的时候加载主配置类，开启了自动配置功能 <code>@EnableAutoConfiguration</code>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span> <span class="token annotation punctuation">@EnableAutoConfiguration</span> <span class="token comment" spellcheck="true">//!!!</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span></code></pre><p><code>@EnableAutoConfiguration</code> 的作用：</p><ul><li>利用<code>EnableAutoConfigurationImportSelector</code>给容器中导入一些组件</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//!!!</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span></code></pre><ul><li>可以查看<code>AutoConfigurationImportSelector.selectImports()</code>方法的内容；</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> NO_IMPORTS<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AutoConfigurationMetadata autoConfigurationMetadata <span class="token operator">=</span> AutoConfigurationMetadataLoader            <span class="token punctuation">.</span><span class="token function">loadMetadata</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>    AutoConfigurationEntry autoConfigurationEntry <span class="token operator">=</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>autoConfigurationMetadata<span class="token punctuation">,</span>            annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//!!!</span>    <span class="token keyword">return</span> StringUtils<span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><code>getAutoConfigurationEntry()</code>方法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> AutoConfigurationEntry <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>AutoConfigurationMetadata autoConfigurationMetadata<span class="token punctuation">,</span>        AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> EMPTY_ENTRY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    AnnotationAttributes attributes <span class="token operator">=</span> <span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//!!!</span>    configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    configurations <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><code>getCandidateConfigurations()</code>方法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span> AnnotationAttributes attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> SpringFactoriesLoader<span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> <span class="token string">"No auto configuration classes found in META-INF/spring.factories. If you "</span>            <span class="token operator">+</span> <span class="token string">"are using a custom packaging, make sure that file is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从META-INF下面找<code>spring.factories</code>文件，将里面配置的所有EnableAutoConfiguration的值加入到了容器中</p><p><img src="https://api.codetool.top/img/15836660223144.png" alt></p><p>每一个这样的<code>xxxAutoConfiguration</code>类都是容器中的一个组件，都加入到容器中；用他们来做自动配置。</p><p>例如：自动配置类<code>DispatcherServletAutoConfiguration</code></p><p>（节选内部类DispatcherServletConfiguration）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//配置文件</span><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//配置条件满足类DefaultDispatcherServletCondition的验证</span><span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span>DefaultDispatcherServletCondition<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果存在ServletRegistration类则进行配置</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>ServletRegistration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果存在对应的属性配置（WebMvcProperties对应的是spring.mvc.*）则启用配置</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span> HttpProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> WebMvcProperties<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DispatcherServletConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> DEFAULT_DISPATCHER_SERVLET_BEAN_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> DispatcherServlet <span class="token function">dispatcherServlet</span><span class="token punctuation">(</span>HttpProperties httpProperties<span class="token punctuation">,</span> WebMvcProperties webMvcProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DispatcherServlet dispatcherServlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">setDispatchOptionsRequest</span><span class="token punctuation">(</span>webMvcProperties<span class="token punctuation">.</span><span class="token function">isDispatchOptionsRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">setDispatchTraceRequest</span><span class="token punctuation">(</span>webMvcProperties<span class="token punctuation">.</span><span class="token function">isDispatchTraceRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">setThrowExceptionIfNoHandlerFound</span><span class="token punctuation">(</span>webMvcProperties<span class="token punctuation">.</span><span class="token function">isThrowExceptionIfNoHandlerFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">setPublishEvents</span><span class="token punctuation">(</span>webMvcProperties<span class="token punctuation">.</span><span class="token function">isPublishRequestHandledEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">setEnableLoggingRequestDetails</span><span class="token punctuation">(</span>httpProperties<span class="token punctuation">.</span><span class="token function">isLogRequestDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dispatcherServlet<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token comment" spellcheck="true">//如果存在类定义则配置</span>    <span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>MultipartResolver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//判断如果不存在bean名称为DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME，则配置 bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> DispatcherServlet<span class="token punctuation">.</span>MULTIPART_RESOLVER_BEAN_NAME<span class="token punctuation">)</span>    <span class="token keyword">public</span> MultipartResolver <span class="token function">multipartResolver</span><span class="token punctuation">(</span>MultipartResolver resolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Detect if the user has created a MultipartResolver but named it incorrectly</span>        <span class="token keyword">return</span> resolver<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过上面的代码,可以看到Spring Boot内部已经自动为我们做了很多关于DispatcherServlet的配置,其中的<code>@EnableConfigurationProperties</code>还能够在读取配置内容的情况下自动生成Spring MVC所需的类。到这里,应该明白为什么几乎在没有任何配置下就能用Spring Boot启动 Spring MVC项目,这些都是<strong>Spring Boot通过Maven依赖找到对应的jar包和嵌入的服务器,然后使用默认自动配置类来创建默认的开发环境。</strong>但是有时候,我们需要对这些默认的环境进行修改以适应个性化的要求,这些在 Spring Boot中也是非常简单的,正如<code>@EnableConfigurationProperties</code>注解那样，它允许读入配置文件的内容来自定义自动初始化所需的内容。</p><h1 id="Spring-Boot配置文件">2 Spring Boot配置文件</h1><p>Spring Boot的所有的AutoConfiguration属性项可以在 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties</a> 看到。这一节我们主要介绍自定义配置。</p><h2 id="yaml语法">2.1 yaml语法</h2><p>配置文件推荐使用yaml语法来写，通过缩进来表达数据关系。</p><h2 id="字符串">2.2 字符串</h2><p>字符串​可以不加引号，如果加引号：</p><ul><li><code>&quot;&quot;</code>：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思<ul><li><code>name: &quot;zhangsan \n lisi&quot;</code>：<code>\n</code>会解析为回车</li></ul></li><li><code>&#39;&#39;</code>：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据<ul><li><code>name: &#39;zhangsan \n lisi&#39;</code>：<code>\n</code>不会解析为回车</li></ul></li></ul><h2 id="对象、Map">2.3 对象、Map</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">friends</span><span class="token punctuation">:</span>    <span class="token key atrule">lastName</span><span class="token punctuation">:</span> zhangsan    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">20</span></code></pre><p>行内写法：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">friends</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">lastName</span><span class="token punctuation">:</span> zhangsan<span class="token punctuation">,</span><span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span></code></pre><h3 id="数组（List、Set）">2.3.1 数组（List、Set）</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">pets</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> cat    <span class="token punctuation">-</span> dog    <span class="token punctuation">-</span> pig</code></pre><p>行内写法：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">pets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cat<span class="token punctuation">,</span>dog<span class="token punctuation">,</span>pig<span class="token punctuation">]</span></code></pre><h2 id="自定义属性配置">2.4 自定义属性配置</h2><p>可以在类上加上<code>@ConfigurationProperties(prefix=&quot;&quot;)</code>注解，把本类中所有属性和配置文件中相关的配置进行绑定。</p><p>只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能。</p><p>例：</p><p>JavaBean</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean boss<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birth<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> lists<span class="token punctuation">;</span>    <span class="token keyword">private</span> Dog dog<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//getter and setter...</span><span class="token punctuation">}</span></code></pre><p>配置：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>    <span class="token key atrule">lastName</span><span class="token punctuation">:</span> hello    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span>    <span class="token key atrule">boss</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token key atrule">birth</span><span class="token punctuation">:</span> 2000/01/01    <span class="token key atrule">maps</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">k1</span><span class="token punctuation">:</span> v1<span class="token punctuation">,</span><span class="token key atrule">k2</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">}</span>    <span class="token key atrule">lists</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> lisi      <span class="token punctuation">-</span> zhaoliu    <span class="token key atrule">dog</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> 小狗      <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">7</span></code></pre><p>它默认从全局配置中获取值，可以使用<code>@PropertySource(value={})</code>来指定配置文件。</p><h2 id="配置文件占位符">2.5 配置文件占位符</h2><h3 id="随机数">2.5.1 随机数</h3><ul><li><code>${random.value}</code></li><li><code>${random.int}</code></li><li><code>${random.long}</code></li><li><code>${random.int(10)}</code></li><li><code>${random.int[1024,65536]}</code></li></ul><h3 id="占位符获取之前配置的值，如果没有可以是用-指定默认值">2.5.2 占位符获取之前配置的值，如果没有可以是用:指定默认值</h3><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">person.last-name</span><span class="token punctuation">=</span><span class="token attr-value">张三${random.uuid}</span><span class="token attr-name">person.age</span><span class="token punctuation">=</span><span class="token attr-value">${random.int}</span><span class="token attr-name">person.birth</span><span class="token punctuation">=</span><span class="token attr-value">2017/12/15</span><span class="token attr-name">person.boss</span><span class="token punctuation">=</span><span class="token attr-value">false</span><span class="token attr-name">person.maps.k1</span><span class="token punctuation">=</span><span class="token attr-value">v1</span><span class="token attr-name">person.maps.k2</span><span class="token punctuation">=</span><span class="token attr-value">14</span><span class="token attr-name">person.lists</span><span class="token punctuation">=</span><span class="token attr-value">a,b,c</span><span class="token attr-name">person.dog.name</span><span class="token punctuation">=</span><span class="token attr-value">${person.hello:hello}_dog</span><span class="token attr-name">person.dog.age</span><span class="token punctuation">=</span><span class="token attr-value">15</span></code></pre><h2 id="配置文件加载位置">2.6 配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><ul><li><code>file:./config/</code></li><li><code>file:./</code></li><li><code>classpath:/config/</code></li><li><code>classpath:/</code></li></ul><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置</p><p>SpringBoot会从这四个位置全部加载主配置文件，<strong>互补配置</strong></p><p>我们还可以通过<code>spring.config.location</code>来改变默认的配置文件位置。</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p><pre class=" language-shell"><code class="language-shell">java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties</code></pre><p>SpringBoot支持的所有的外部配置文件加载方法见：</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config</a></p><h2 id="ImportResource注解">2.7 @ImportResource注解</h2><p><code>@ImportResource</code>可以帮助导入传统xml类型的配置，例如springcontext配置，直接将它写在启动类上就行了。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//导入Spring的配置文件让其生效</span><span class="token annotation punctuation">@ImportResource</span><span class="token punctuation">(</span>locations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"classpath:beans.xml"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BootHelloworldApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>BootHelloworldApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="多环境化配置Profile">2.8 多环境化配置Profile</h2><h3 id="properties">2.8.1 properties</h3><p>在真实的应用中，常常会有多个环境（如：开发，测试，生产等），不同的环境数据库连接都不一样，这个时候就需要用到spring.profile.active的强大功能了，它的格式为 <code>application-{profile}.properties</code>，这里的 application 为前缀不能改，<code>{profile}</code>是我们自己定义的。</p><p>application.properties就是默认的配置文件。</p><p>在 <code>application.properties</code> 配置文件中写入 <code>spring.profiles.active=dev</code>，就可以指定使用profile为dev的配置文件。</p><p>也可以使用虚拟机参数<code>-Dspring.profiles.active=dev</code>指定</p><h3 id="yaml文档块">2.8.2 yaml文档块</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># document 1</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> prod<span class="token punctuation">---</span><span class="token comment" spellcheck="true"># document 2</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8083</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span> dev<span class="token punctuation">---</span><span class="token comment" spellcheck="true"># document 3</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8084</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span> prod  <span class="token comment" spellcheck="true">#指定属于哪个环境</span></code></pre><p>文档块之间使用<code>---</code>分隔，第一个文档块为默认使用的配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringBoot配置与自动配置原理&lt;/p&gt;
&lt;h1 id=&quot;自动配置原理&quot;&gt;1 自动配置原理&lt;/h1&gt;&lt;p&gt;SpringBoot启动的时候加载主配置类，开启了自动配置功能 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;：&lt;/p&gt;
&lt;pre c
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="https://www.codetool.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>leetcode322-零钱兑换</title>
    <link href="https://www.codetool.top/article/leetcode322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>https://www.codetool.top/article/leetcode322-零钱兑换/</id>
    <published>2020-03-08T09:53:09.000Z</published>
    <updated>2020-03-08T09:55:34.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> coins = [1, 2, 5], amount = 11<br><strong>输出:</strong> 3<br><strong>解释:</strong> 11 = 5 + 5 + 1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> coins = [1, 2, 5], amount = 11<br><strong>输出:</strong> 3<br><strong>解释:</strong> 11 = 5 + 5 + 1</p></blockquote><p><strong>说明:</strong></p><p>你可以认为每种硬币的数量是无限的。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode279-完全平方数">leetcode279-完全平方数</a>类似，可以使用BFS+剪枝的方法来做。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Integer num <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                depth<span class="token operator">++</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> left <span class="token operator">=</span> num<span class="token operator">-</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                visited<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot介绍和HelloWorld入门程序</title>
    <link href="https://www.codetool.top/article/SpringBoot%E4%BB%8B%E7%BB%8D%E5%92%8CHelloWorld%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.codetool.top/article/SpringBoot介绍和HelloWorld入门程序/</id>
    <published>2020-03-08T08:47:27.000Z</published>
    <updated>2020-03-08T13:35:14.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-简介">1 Spring Boot 简介</h1><ul><li>简化Spring应用开发的一个框架；</li><li>整个Spring技术栈的一个大整合；</li><li>J2EE开发的一站式解决方案；</li></ul><p>Spring Boot用来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用</p><h2 id="优点">1.1 优点</h2><ul><li>快速创建独立运行的Spring项目以及与主流框架集成</li><li>使用嵌入式的Servlet容器，应用无需打成WAR包</li><li>starters自动依赖与版本控制</li><li>大量的自动配置，简化开发，也可修改默认值</li><li>无需配置XML，无代码生成，开箱即用</li><li>准生产环境的运行时应用监控</li><li>与云计算的天然集成</li></ul><h2 id="starter概念">1.2 starter概念</h2><p>Spring Boot Starter是一组被依赖第三方类库的集合。</p><p>如果你要开发一个web应用程序，就通过包管理工具(如maven)引入<code>spring-boot-starter-web</code>就可以了，而不用分别引入下面这么多依赖类库，spring-boot-starter-web一次性帮你引入下面的这些常用类库。</p><ul><li>Spring — spring 核心, beans, context上下文, AOP面向切面</li><li>Web MVC — Spring MVC</li><li>Jackson — JSON数据的序列化与反序列化</li><li>Validation — Hibernate参数校验及校验API</li><li>嵌入式 Servlet Container — Tomcat</li><li>日志框架Logging — logback, slf4j</li></ul><p>Spring Boot 默认支持的starter见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter</a></p><h2 id="Spring-Boot-Starter-Parent">1.3 Spring Boot Starter Parent</h2><p>所有的Spring Boot项目默认使用spring-boot-starter-parent作为应用程序的父项目。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.0.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>继承父项目的好处在于： 统一java版本配置和其他的一些依赖类库的版本。也就是说，你引入的第三方类库不要加版本号，父项目替你管理版本，而且是经过兼容性测试的。比你自己随便引入一个版本兼容性更好。</p><h2 id="Spring-Boot集成第三方类库的步骤">1.4 Spring Boot集成第三方类库的步骤</h2><ol><li>通过maven引入springboot-XXXX-starter</li><li>修改ymal或properties全局统一配置文件</li><li>加入一个Java Config。这个属于个性化配置，如果使用通用配置，这一步不需要。</li></ol><h2 id="Spring-Boot2-x新特性">1.5 Spring Boot2.x新特性</h2><h3 id="基础环境升级">1.5.1 基础环境升级</h3><ul><li><p>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7。Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。<br>例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。</p></li><li><p>如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。</p></li></ul><h3 id="依赖组件升级">1.5.2 依赖组件升级</h3><ul><li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li><li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li><li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li><li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li><li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li><li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升</li></ul><h3 id="默认软件替换">1.5.3 默认软件替换</h3><ul><li>默认数据库连接池已从 Tomcat 切换到 HikariCP，HikariCP 是一个高性能的 JDBC 连接池，Hikari 是日语“光”的意思。</li><li>Redis客户端默认使用 Lettuce，替换掉Jedis。Lettuce 是一个可伸缩的线程安全的 Redis 客户端，用于同步、异步和反应使用。多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接，支持先进的 Redis 功能，如 Sentinel、集群、流水线、自动重新连接和 Redis 数据模型。</li></ul><h3 id="新技术的引入">1.5.4 新技术的引入</h3><ul><li>响应式编程WebFlux，重要的变革</li><li>支持 <code>Quartz</code>,Spring Boot 1.0 并没有提供对 Quartz 的支持，之前出现了各种集成方案，Spring Boot 2.0 给出了最简单的集成方式。</li><li>对Kotlin 的支持</li><li>JOOQ 的支持,JOOQ 是基于 Java 访问关系型数据库的工具包。JOOQ 既吸取了传统 ORM 操作数据的简单性和安全性，又保留了原生 SQL 的灵活性，它更像是介于 ORMS 和 JDBC 的中间层。</li></ul><h1 id="Spring-Boot-HelloWorld">2 Spring Boot HelloWorld</h1><p>使用Spring Boot来做一个Hello World入门程序：</p><p>1) 在idea中创建Spring Initializr项目</p><p><img src="https://api.codetool.top/img/15836538134655.png" alt></p><p>2) 添加maven依赖</p><p>Idea会自动为我们生成如下pom文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.rhett<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>boot-helloworld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>boot-helloworld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>添加web-starter进去：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>可以移除相关maven管理的文件，使用idea管理：</p><p><img src="https://api.codetool.top/img/15836538608240.png" alt></p><p>resources文件夹中目录结构</p><ul><li><code>static</code>：保存所有的静态资源； js css  images；</li><li><code>templates</code>：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li><code>application.properties</code>：Spring Boot应用的配置文件；可以修改一些默认设置，可以使用yml语法进行配置。</li></ul><p>3) 查看启动类</p><p>idea默认为我们生成了启动类：</p><p><img src="https://api.codetool.top/img/15836540733254.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @SpringBootApplication来标记一个主程序类，说明这是一个Spring Boot应用 */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BootHelloworldApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>BootHelloworldApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4) 编写Controller</p><p>springboot只会扫描启动类当前包和以下的包，创建以下包层次，编写一个HelloController：</p><p><img src="https://api.codetool.top/img/15836542358252.png" alt></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>@RestController</code>相当于<code>@ResponseBody</code>+<code>@Controller</code>，返回的内容直接写入响应体，不会解析到视图。</p><p>5) 启动程序</p><p>运行启动类中的main方法，程序就启动起来了，在浏览器中输入<code>localhost:8080/hello</code>来观察运行结果：</p><p><img src="https://api.codetool.top/img/1583654442364.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot-简介&quot;&gt;1 Spring Boot 简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简化Spring应用开发的一个框架；&lt;/li&gt;
&lt;li&gt;整个Spring技术栈的一个大整合；&lt;/li&gt;
&lt;li&gt;J2EE开发的一站式解决方案；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="https://www.codetool.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之分区表介绍</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B9%8B%E5%88%86%E5%8C%BA%E8%A1%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/MySQL之分区表介绍/</id>
    <published>2020-03-07T14:10:45.000Z</published>
    <updated>2020-03-07T14:22:04.547Z</updated>
    
    <content type="html"><![CDATA[<p>本文大部分参考自《MySQL技术内幕：InnoDB存储引擎》</p><h1 id="概述">1 概述</h1><p>对于InnoDB，分区就是把一个数据表的物理存储拆分为多个ibd文件（相当于独立表空间再拆分成了多个表空间）。分区后的MyISAM，则是每个分区有一个myi文件（表的索引信息）和一个myd文件（表的数据信息）。每一个分区，在MySQL看来都是一张独立的表。</p><h1 id="分区类型">2 分区类型</h1><h2 id="水平分区">2.1 水平分区</h2><p>这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</p><h2 id="垂直分区">2.2 垂直分区</h2><p>这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p><p><strong>MySQL在5.1时添加了对水平分区的支持。并不支持垂直分区。</strong></p><p>MySQL数据库的分区是局部分区索引，一个分区中既存了数据，又放了索引。也就是说，<strong>每个区的聚集索引和非聚集索引都放在各自区的</strong>（不同的物理文件）。目前MySQL数据库还不支持全局分区（数据存放在各个分区中，但是所有数据的索引放在一个对象中）。</p><h1 id="分区算法">3 分区算法</h1><p>当前MySQL支持以下几种类型的分区：</p><ul><li>RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区，MySQL5.5开始支持。</li><li>LIST分区：和RANGE类似，只是LIST分区面向的是离散的值。MySQL5.5开始支持。</li><li>HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li><li>KEY分区：根据MySQL数据库提供的哈希函数来进行分区。</li></ul><p>无论哪种类型的分区，如果表中存在主键或唯一索引时，分区列（用来判断该分往哪个分区）必须是唯一索引的一个组成部分。</p><h2 id="RANGE分区">3.1 RANGE分区</h2><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tbl_new<span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    title <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> t0 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> t1 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> t2 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个表会把以id列作为分区依据，当id：</p><ul><li>0~10 放在 t0</li><li>10~20 放在 t1</li><li>&gt;20 放在 t2</li></ul><p>当插入一个不在分区范围内的值的时候，MySQL会报异常。</p><h2 id="LIST分区">3.2 LIST分区</h2><p>示例</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>    uid <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    userName <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    gender <span class="token keyword">tinyint</span><span class="token punctuation">)</span><span class="token keyword">partition</span> <span class="token keyword">by</span> list<span class="token punctuation">(</span>gender<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">partition</span> male <span class="token keyword">values</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">partition</span> female <span class="token keyword">values</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">partition</span> unknown <span class="token keyword">values</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个表会把以gender列（性别）作为分区依据，当gender：</p><ul><li>= 1 放在 male</li><li>= 2 放在 female</li><li>= 3 放在 unknown</li></ul><p>当插入一个不在分区范围内的值的时候，MySQL同样会报异常。</p><p>当一条Insert语句插入多个值的时候，而其中有一些值是在分区范围内的，MyISAM引擎会把第一个不满足范围的数据前面的数据全部插入，而后面的不处理。而InnoDB则把它当成一个事务，都不会处理。</p><h2 id="HASH分区">3.3 HASH分区</h2><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t_hash<span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">DATETIME</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>YEAR<span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span></code></pre><p>用户给数据库提供分区的依据，<code>YEAR(b)</code>，必须是一个正整数，然后需要通过<code>PARTITIONS num</code>告知数据库分区的数量，然后数据库自动根据<code>YEAR(b)</code>将数据均匀分到这些分区中。如果没有<code>PARTITIONS num</code>语句，分区的数量默认为1。</p><h2 id="KEY分区">3.4 KEY分区</h2><p>KEY分区和HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行分区。对于大多数存储引擎，MySQL数据库使用其内部的哈希函数，这些函数基于与PASSWORD()一样的运算法则。</p><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t_key<span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">DATETIME</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span></code></pre><h2 id="其他">3.5 其他</h2><p>COLUMNS分区、子分区</p><h1 id="分区的应用场景">4 分区的应用场景</h1><ol><li>表非常大以至于无法全部放在内存中，或者只在表的最后部分有热点数据，其他均为历史数据（可以将热点数据提取出来，加快热点数据的查询、访问效率）</li><li>分区表的数据更容易维护。（批量删除数据-&gt;清除整个分区）</li><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>可以使用分区表来避免某些特殊的瓶颈。比如 InnoDB 的单个索引的互斥访问，ext3 文件系统的 inode 锁竞争。</li><li>还可以备份和恢复独立的分区</li></ol><h1 id="分区的限制">5 分区的限制</h1><ol><li>一个表最多只能有 1024 个分区</li><li>如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。</li><li>分区表中无法使用外键索引</li></ol><h1 id="分区的陷阱">6 分区的陷阱</h1><h2 id="NULL值会使分区过滤无效">6.1 NULL值会使分区过滤无效</h2><p>分区的表达式的值可以是 NULL；第一个分区是一个特殊分区，如果表达式的值为 NULL 或非法值，记录都会被存放到第一个分区。WHERE 查询时即使看起来可以过滤到只有一个分区，但实际会检查两个分区，即第一个分区。最好是设置分区的列为NOT NULL。</p><h2 id="分区列和索引列不匹配">6.2 分区列和索引列不匹配</h2><p>如果定义的索引列和分区列不匹配，会导致索引无法进行分区过滤。</p><p>假设在列 a 上定义了索引，而在列 b 上进行分区。因为每个分区都有其独立的索引，所以扫描 b 上的索引就需要扫描每一个分区内对应的索引。</p><h2 id="选择分区的成本可能很高">6.3 选择分区的成本可能很高</h2><p>尤其是范围分区，对于回答“这一行属于哪个分区”、“这些符合查询条件的行在哪些分区”这样的问题的成本可能会非常高。其他的分区类型，比如KEY分区和HASH分区，就没有这样的问题。在批量插入时问题尤其严重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文大部分参考自《MySQL技术内幕：InnoDB存储引擎》&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;对于InnoDB，分区就是把一个数据表的物理存储拆分为多个ibd文件（相当于独立表空间再拆分成了多个表空间）。分区后的MyISAM，则是每个分区有一个myi
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制简介</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.codetool.top/article/MySQL主从复制简介/</id>
    <published>2020-03-07T11:30:48.000Z</published>
    <updated>2020-03-07T11:34:26.870Z</updated>
    
    <content type="html"><![CDATA[<p>该文不谈及良好的主从复制拓扑结构和主从复制中可能出现的问题，以后有时间再写。</p><h1 id="概述">1 概述</h1><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。</p><p>MySQL 支持两种复制方式：基于行的复制和基于语句的复制。这两种方式都是通过在主库上记录 binlog，在备库重放日志的方式来实现异步的数据复制。这意味着，在同一时间点备库上的数据可能与主库存在不一致，并且保证主备之间的延迟。</p><p>复制通常不会增加主库的开销，主要是启用 binlog 带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。除此之外，每个备库也会对主库增加一些负载（网络IO），尤其当备库请求从主库读取旧的 binlog 时，可能会造成更高的 IO 开销。</p><p>通过复制可以将读操作指向备库来获得更好的读扩展，但对于写操作，除非设计得当，否则并不适合通过复制来扩展写操作。</p><h2 id="复制解决的问题">1.1 复制解决的问题</h2><ul><li>数据分布</li><li>负载均衡，读写分离</li><li>备份</li><li>高可用和故障切换</li></ul><h1 id="复制原理">2 复制原理</h1><h2 id="复制如何工作">2.1 复制如何工作</h2><p><img src="https://api.codetool.top/img/15835759827402.png" alt></p><ol><li>在主库上把数据更改记录在 <code>binlog</code> 中（这些记录称为二进制日志事件）</li><li>备库将主库上的日志<strong>复制到自己的中继日志中</strong></li><li>备库读取中继日志中的事件，将其重放到备库数据之上</li></ol><h2 id="基于语句的复制">2.2 基于语句的复制</h2><p>主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是<strong>把主库上执行过的 SQL 再执行一遍。</strong> 即binlog的statement模式</p><p>优点：</p><ol><li>实现简单 </li><li>binlog 中的事件更加紧凑</li></ol><p>问题：</p><ol><li>同一条 SQL 在主库和备库上执行的时间可能稍微或很不相同，因此在传输的 binlog 中，<br>除了 SQL，还有一些元数据，比如时间戳</li><li>一些无法被正确复制的 SQL，存储过程、触发器</li><li>更新必须是串行的，这需要更多的锁</li></ol><h2 id="基于行的复制">2.3 基于行的复制</h2><p>会将实际数据记录在 binlog 中。即binlog的row模式</p><p>好处：</p><ol><li>可以正确地复制每一行，一些语句可以被更加有效地复制</li><li>复制更加高效（但也视情况而定）</li></ol><h1 id="搭建步骤">3 搭建步骤</h1><h2 id="master">3.1 master</h2><ol><li>在master的配置文件中，配置如下内容：</li></ol><pre class=" language-conf"><code class="language-conf">#mysql 服务ID,保证整个集群环境中唯一server-id=1#mysql binlog 日志的存储路径和文件名，主从复制是基于binlog的log-bin=/var/lib/mysql/mysqlbin#错误日志,默认已经开启#log-err#mysql的安装目录#basedir#mysql的临时目录#tmpdir#mysql的数据存放目录#datadir#是否只读,1 代表只读, 0 代表读写read-only=0#忽略的数据, 指不需要同步的数据库binlog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01</code></pre><ol start="2"><li>在客户端中建同步数据的账户，并且进行授权操作：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">replication</span> slave <span class="token keyword">on</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">to</span> <span class="token string">'slave1'</span>@'slave_host<span class="token string">' identified by '</span>password'<span class="token punctuation">;</span>    flush <span class="token keyword">privileges</span><span class="token punctuation">;</span></code></pre><p>如果需要配置多个从机就创建多个账户，<code>&#39;slave_host&#39;</code>代表从机的ip地址。</p><ol start="3"><li>查看master状态：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> master <span class="token keyword">status</span><span class="token punctuation">;</span></code></pre><ul><li>File : 从哪个日志文件开始推送日志文件 </li><li>Position ： 从哪个位置开始推送日志</li><li>Binlog_Ignore_DB : 指定不需要同步的数据库</li></ul><h2 id="slave">3.2 slave</h2><ol><li>在 slave 端配置文件中，配置如下内容：</li></ol><pre class=" language-conf"><code class="language-conf">#mysql服务端ID,唯一server-id=2#指定binlog日志log-bin=/var/lib/mysql/mysqlbin</code></pre><ol start="2"><li>在客户端内执行如下指令 ：</li></ol><pre class=" language-sql"><code class="language-sql">change master <span class="token keyword">to</span> master_host<span class="token operator">=</span> <span class="token string">'master_host'</span><span class="token punctuation">,</span> master_user<span class="token operator">=</span><span class="token string">'slave1'</span><span class="token punctuation">,</span> master_password<span class="token operator">=</span><span class="token string">'password'</span><span class="token punctuation">,</span> master_log_file<span class="token operator">=</span><span class="token string">'mysqlbin.000001'</span><span class="token punctuation">,</span> master_log_pos<span class="token operator">=</span><span class="token number">413</span><span class="token punctuation">;</span></code></pre><p>指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。（这些都是在master status中看到的）</p><ol start="3"><li>开启同步操作</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">start</span> slave<span class="token punctuation">;</span><span class="token keyword">show</span> slave <span class="token keyword">status</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>停止同步操作</li></ol><pre class=" language-sql"><code class="language-sql">stop slave<span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该文不谈及良好的主从复制拓扑结构和主从复制中可能出现的问题，以后有时间再写。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之日志配置全解</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B9%8B%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%85%A8%E8%A7%A3/"/>
    <id>https://www.codetool.top/article/MySQL之日志配置全解/</id>
    <published>2020-03-07T09:43:59.000Z</published>
    <updated>2020-03-07T09:44:31.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误日志">1 错误日志</h1><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p><p>该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var/lib/mysql）, 默认的日志文件名为 <code>hostname.err</code>（hostname是主机名）。</p><h2 id="相关配置">1.1 相关配置</h2><ul><li><code>log-error</code>：错误日志存放路径</li><li><code>log-warnings</code>：是否将警告信息也输入错误日志，1代表是（5.7后废弃）</li><li><code>log_error_verbosity</code>：（代替log-warnings）错误日志级别<ul><li>1：errors only</li><li>2：errors and warnings</li><li>3：errors，warnings and notes</li></ul></li></ul><h1 id="二进制日志">2 二进制日志</h1><p>二进制日志包含了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句的事件信息，但是不包括数据查询语句。语句以”事件”的形式保存，所以包含了时间、事件开始和结束位置等信息。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</p><p>二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 </p><p>mysqld还创建一个二进制日志<strong>索引文件</strong>，当二进制日志文件滚动的时候会向该文件中写入对应的信息。所以该文件<strong>包含所有使用的二进制日志文件的文件名</strong>。默认情况下该文件与二进制日志文件的文件名相同，扩展名为’.index’。</p><h2 id="相关配置-1">2.1 相关配置</h2><ul><li><code>log_bin=[on|off|file_name]</code>：开启binlog，如果没有给定file_name，则默认为datadir下的主机名加”-bin”，并在后面跟上一串数字表示日志序列号。</li><li><code>binlog_format=[STATEMENT|ROW|MIXED]</code>：指定二进制日志的格式。<ul><li>STATEMENT：该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</li><li>ROW：该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</li><li>MIXED：这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</li></ul></li><li><code>log_bin_index = file_name</code>：配置索引文件的名字</li><li><code>expire_logs_days</code>：指定自动删除二进制日志的时间，即日志过期时间</li><li><code>binlog_do_db</code> ：明确指定要记录日志的数据库</li><li><code>binlog_ignore_db</code> ：指定不记录二进制日志的数据库</li><li><code>binlog_cache_size = 32768</code> : 基于事务类型的日志会先记录在缓冲区，当达到该缓冲大小时这些日志会写入磁盘</li><li><code>max_binlog_size</code> ：指定二进制日志文件最大值，超出指定值将自动滚动。但由于事务不会跨文件，所以并不一定总是精确。</li><li><code>sync_binlog = { 0 | n }</code> ：日志何时刷到磁盘<ul><li>0:不同步，日志何时刷到磁盘由FileSystem决定，这个性能最好。</li><li>n:每写n次二进制日志事件(不是事务)，MySQL将执行一次磁盘同步指令fdatasync()将缓存日志刷新到磁盘日志文件中。Mysql中默认的设置是sync_binlog=0，即不同步，这时性能最好，但风险最大。一旦系统奔溃，缓存中的日志都会丢失。</li><li>在Innodb的主从复制结构中，如果启用了二进制日志(几乎都会启用)，要保证事务的一致性和持久性的时候，必须将sync_binlog的值设置为1，因为每次事务提交都会写入二进制日志，设置为1就保证了每次事务提交时二进制日志都会写入到磁盘中，从而立即被从服务器复制过去。</li></ul></li></ul><h2 id="日志查看">2.2 日志查看</h2><p>由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：</p><p><code>mysqlbinlog log-file</code></p><h2 id="日志删除">2.3 日志删除</h2><p>对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清除，将会占用大量的磁盘空间。下面介绍几种删除日志的常见方法 ：</p><p>1) 通过 <code>Reset Master</code> 指令删除全部 binlog 日志，删除之后，日志编号将从 xxxx.000001重新开始。</p><p>2) 执行指令 <code>purge master logs to &#39;mysqlbin.******&#39;</code> ，该命令将删除 <code>******</code> 编号之前的所有日志。 </p><p>3) 执行指令 <code>purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code> ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志。</p><p>4) 设置参数 <code>--expire_logs_days=#</code> ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。</p><h1 id="查询日志">3 查询日志</h1><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。</p><p>默认情况下， 查询日志是未开启的。如果需要开启查询日志，需要手动配置。通常不需要开启此日志。</p><h2 id="相关配置-2">3.1 相关配置</h2><ul><li><code>general_log = {0 | 1}</code> ： 是否开启查询日志</li><li><code>general_log_file</code> ： 查询日志存放路径，不给定路径时默认的文件名以 <code>hostname.log</code> 命名。</li></ul><h1 id="慢查询日志">4 慢查询日志</h1><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p><p><code>long_query_time</code> 的默认值为 10，意思是运行 10s 以上的语句。<strong>默认情况下，Mysql 数据库并不启动慢查询日志，需要我们手动来设置这个参数</strong>，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>格式大致如下：</p><pre><code># Time: 180118 14:58:37# User@Host: root[root] @ localhost []  Id:   150# Query_time: 0.000270  Lock_time: 0.000109 Rows_sent: 0  Rows_examined: 6SET timestamp=1516258717;delete from user where User=&#39;app&#39;;</code></pre><p>是哪条语句导致慢查询（sql_text），该慢查询语句的查询时间（query_time），锁表时间（Lock_time），以及扫描过的行数（rows_examined）</p><h2 id="相关配置-3">4.1 相关配置</h2><ul><li><code>slow_query_log</code> ：是否开启慢查询日志，1 表示开启，0 表示关闭。</li><li><code>slow-query-log-file</code>：新版（5.6 及以上版本）：MySQL 数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件 host_name-slow.log</li><li><code>long_query_time</code> ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</li><li><code>log_queries_not_using_indexes</code>：未使用索引的查询也被记录到慢查询日志中（可选项）。</li><li><code>log_output</code>：日志存储方式。默认值是<code>&#39;FILE&#39;</code>，表示将日志存入文件。<code>&#39;TABLE&#39;</code>表示将日志存入数据库，这样日志信息就会被写入到 <code>mysql.slow_log</code> 表中，支持同时记录到文件和数据库，配置的时候以逗号隔开即可。</li></ul><h2 id="慢日志分析工具-mysqldumpslow">4.2 慢日志分析工具 mysqldumpslow</h2><p>在实际生产环境中，如果要手工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</p><p>参数：</p><ul><li><code>-s</code> 按照那种方式排序<ul><li><code>c</code>：访问计数</li><li><code>l</code>：锁定时间</li><li><code>r</code>:返回记录</li><li><code>al</code>：平均锁定时间</li><li><code>ar</code>：平均访问记录数</li><li><code>at</code>：平均查询时间</li></ul></li><li><code>-t</code> 是top n的意思，返回多少条数据。</li><li><code>-g</code> 可以跟上正则匹配模式，大小写不敏感。</li></ul><p><strong>例：</strong></p><p>得到返回记录集最多的 10 个 SQL。</p><p><code>mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log</code></p><p>得到访问次数最多的 10 个 SQL</p><p><code>mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log</code></p><p>得到按照时间排序的前 10 条里面含有左连接的查询语句。</p><p><code>mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log</code></p><p>另外建议在使用这些命令时结合 | 和 more 使用 ，否则有可能出现刷屏的情况。</p><p><code>mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误日志&quot;&gt;1 错误日志&lt;/h1&gt;&lt;p&gt;错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。&lt;/p&gt;
&lt;p&gt;该日志是默认
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构的演变过程</title>
    <link href="https://www.codetool.top/article/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
    <id>https://www.codetool.top/article/大型网站架构的演变过程/</id>
    <published>2020-03-07T02:41:31.000Z</published>
    <updated>2020-03-07T02:45:15.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单机时代">1 单机时代</h1><p>大型网站都是从小型网站发展而来,网站架构也是一样,是从小型网站架构逐步演化而来。小型网站最开始时没有太多人访问,只需要一台服务器就绰绰有余,最典型的是在小型网站上称霸的LAMP（Linux+Apache+MySQL+PHP）。此时的网站架构如图所示：</p><p><img src="https://api.codetool.top/img/15835099733096.png" alt></p><h1 id="应用服务和数据服务分离">2 应用服务和数据服务分离</h1><p>随着网站业务的发展,一台服务器逐渐不能满足需求:越来越多的用户访问导致性能越来越差,越来越多的数据导致存储空间不足。这时就需要将应用和数据分离。应用和数据分离后整个网站使用三台服务器:应用服务器、文件服务器和数据库服务器，如图所示：</p><p><img src="https://api.codetool.top/img/15835100957354.png" alt></p><p>这三台服务器对硬件资源的要求各不相同,应用服务器需要处理大量的业务逻辑,因此需要更快更强大的CPU;数据库服务器需要快速磁盘检索和数据缓存,因此需要更快的硬盘和更大的内存;文件服务器需要存储大量用户上传的文件,因此需要更大的硬盘。</p><p>随着用户数增多，网站又一次面临挑战：数据库压力太大导致访问延迟，进而影响整个网站的性能。</p><h1 id="使用缓存改善网站性能">3 使用缓存改善网站性能</h1><p>网站访问特点和现实世界的财富分配一样遵循二八定律:80%的业务访问集中在20%的数据上。淘宝买家浏览的商品集中在少部分成交数多、评价良好的商品上;百度搜索关键词集中在少部分热门词汇上;只有经常登录的用户才会发微博、看微博,而这部分用户也只占总用户数目的一小部分。</p><p>既然大部分的业务访问集中在一小部分数据上,那么如果把这一小部分数据缓存在内存中,是不是就可以减少数据库的访问压力,提高整个网站的数据访问速度,改善数据库的写入性能了呢?</p><p>网站使用的缓存可以分为两种:缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。<strong>本地缓存的访问速度更快一些,但是受应用服务器内存限制</strong>,其缓存数据量有限,而且会出现和应用程序争用内存的情况。远程分布式缓存可以使用集群的方式,部署大内存的服务器作为专门的缓存服务器,可以在理论上做到不受内存容量限制的缓存服务,如图所示：</p><p><img src="https://api.codetool.top/img/15835104734486.png" alt></p><p>使用缓存后,数据访问压力得到有效缓解,但是单一应用服务器能够处理的请求连接有限,在网站访问高峰期,应用服务器成为整个网站的瓶颈。</p><h1 id="使用应用服务器集群改善网站的并发处理能力">4 使用应用服务器集群改善网站的并发处理能力</h1><p>这也被称为负载均衡：</p><p><img src="https://api.codetool.top/img/15835105892447.png" alt></p><h1 id="数据库读写分离">5 数据库读写分离</h1><p>网站在使用缓存后,使绝大部分数据读操作访问都可以不通过数据库就能完成,但是仍有一部分读操作(缓存访问不命中、缓存过期)和全部的写操作需要访问数据库,在网站的用户达到一定规模后,数据库因为负载压力过高而成为网站的瓶颈。</p><p>通常使用主从复制技术，只<strong>在主机上写数据，在从机上读数据</strong>。</p><p><img src="https://api.codetool.top/img/15835107374315.png" alt></p><h1 id="使用反向代理和CDN加速网站响应">6 使用反向代理和CDN加速网站响应</h1><p>随着网站业务不断发展,用户规模越来越大,由于中国复杂的网络环境,不同地区的用户访问网站时,速度差别也极大。有研究表明,网站访问延迟和用户流失率正相关,</p><p>网站访问越慢,用户越容易失去耐心而离开。为了提供更好的用户体验,留住用户,网站需要加速网站访问速度。主要手段有使用CDN和反向代理,如图所示：</p><p><img src="https://api.codetool.top/img/15835450828492.png" alt></p><p><strong>CDN和反向代理的基本原理都是缓存</strong>,区别在于CDN部署在网络提供商的机房,使用户在请求网站服务时,可以从距离自己最近的网络提供商机房获取数据;而反向代理则部署在网站的中心机房,当用户请求到达中心机房后,首先访问的服务器是反向代理服务器,如果反向代理服务器中缓存着用户请求的资源,就将其直接返回给用户。</p><h1 id="使用分布式文件系统和分布式数据库系统">7 使用分布式文件系统和分布式数据库系统</h1><p>任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库经过读写分离后,从一台服务器拆分成两台服务器,但是随着网站业务的发展依然不能满足需求,这时需要使用分布式数据库。文件系统也是一样,需要使用分布式文件系统,如图所示:</p><p><img src="https://api.codetool.top/img/15835452178957.png" alt></p><p><strong>分布式数据库是网站数据库拆分的最后手段</strong>，只有在单表数据规模非常庞大的时候才使用。不到不得已时,网站更常用的数据库拆分手段是<strong>业务分库</strong>,将不同业务的数据库部署在不同的物理服务器上。</p><h1 id="使用NoSQL和搜索引擎">8 使用NoSQL和搜索引擎</h1><p>随着网站业务越来越复杂,对数据存储和检索的需求也越来越复杂,网站需要采用一些非关系数据库技术如 NoSQL和非数据库查询技术如搜索引擎,如图所示：</p><p><img src="https://api.codetool.top/img/15835453037260.png" alt></p><p>NoSQL和搜索引擎都是源自互联网的技术手段,对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据,减轻应用程序管理诸多数据源的麻烦。</p><h1 id="业务拆分">9 业务拆分</h1><p>大型网站为了应对日益复杂的业务场景,通过使用分而治之的手段将整个网站业务分成不同的产品线,如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线,分归不同的业务团队负责。</p><p>具体到技术上,也会根据产品线划分,<strong>将一个网站拆分成许多不同的应用,每个应用独立部署维护。</strong>应用之间可以通过一个超链接建立关系(在首页上的导航链接每个都指向不同的应用地址),也可以通过消息队列进行数据分发,当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统,如图所示。</p><p><img src="https://api.codetool.top/img/1583545568710.png" alt></p><h1 id="分布式服务">10 分布式服务</h1><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中,这些连接的数目是服务器规模的平方,导致存数据库接资源不足,拒绝服务。</p><p>既然每一个应用系统都需要执行许多相同的业务操作,比如用户管理、商品管理等,那么可以将这些共用的业务提取出来,独立部署。由这些可复用的业务连接数据库,提供共用业务服务,而应用系统只需要管理用户界面,通过分布式服务调用共用业务服务完成具体业务操作,如图所示：</p><p><img src="https://api.codetool.top/img/15835457289108.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单机时代&quot;&gt;1 单机时代&lt;/h1&gt;&lt;p&gt;大型网站都是从小型网站发展而来,网站架构也是一样,是从小型网站架构逐步演化而来。小型网站最开始时没有太多人访问,只需要一台服务器就绰绰有余,最典型的是在小型网站上称霸的LAMP（Linux+Apache+MySQL+PHP）
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="架构" scheme="https://www.codetool.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer59-队列的最大值</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer59-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://www.codetool.top/article/剑指offer59-队列的最大值/</id>
    <published>2020-03-06T16:53:23.000Z</published>
    <updated>2020-03-06T16:58:05.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的时间复杂度都是O(1)。</p><p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong><br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br><strong>输出:</strong> [null,null,null,2,1,2]</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong><br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br><strong>输出:</strong> [null,-1,-1] </p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li><li><code>1 &lt;= value &lt;= 10^5</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我一开始以为是要手写个堆。。。写完了之后发现自己理解错了题意 : )</p><p>就是另外使用一个双向队列维护一个单调递减的队列，如果要弹出的元素也是递减队列的头元素，就把它也弹出。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MaxQueue</span> <span class="token punctuation">{</span>    Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MaxQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">max_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>            deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        deque<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pop <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pop <span class="token operator">==</span> deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            deque<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pop<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;请定义一个队列并实现函数 &lt;code&gt;max_value&lt;/code&gt; 得到队列里的最大值，要求函数&lt;code&gt;max_value&lt;/code&gt;、&lt;code&gt;push_back&lt;/code&gt; 和 &lt;code&gt;pop_front&lt;/c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之表锁、行锁、MVCC详解</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B9%8B%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81%E3%80%81MVCC%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.codetool.top/article/MySQL之表锁、行锁、MVCC详解/</id>
    <published>2020-03-06T14:10:34.000Z</published>
    <updated>2020-03-06T14:24:03.550Z</updated>
    
    <content type="html"><![CDATA[<p>该文建议配合<a href="../数据库理论之并发控制/">数据库理论之并发控制</a>阅读。</p><h1 id="概述">1 概述</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p><p>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="锁分类">1.1 锁分类</h2><p>从对数据操作的粒度分 ： </p><ol><li>表锁：操作时，会锁定整个表。</li><li>行锁：操作时，会锁定当前操作行。</li></ol><p>从对数据操作的类型分：</p><ol><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</li></ol><h2 id="MySQL中的锁">1.2 MySQL中的锁</h2><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页面锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适。</p><p>仅从锁的角度来说：</p><ul><li>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用</li><li>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</li></ul><p><strong>所有的存储引擎都以自己的方式实现了锁机制</strong>，服务器层完全不了解存储引擎中的锁实现。但服务器层也会使用各种有效的表锁来实现不同的目的。</p><p>对于 MySQL 而言，事务机制更多是靠底层的存储引擎实现的，<strong>在服务器层面只有表锁。支持事务的 InnoDB 存储引擎实现了行锁。</strong></p><h1 id="MyISAM-表锁">2 MyISAM 表锁</h1><p>偏向 MyISAM 存储引擎，开销小，加锁快，无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p>在特定的场景中，表锁也可能有良好的性能。比如，READ LOCAL 表锁支持某些类型的并发写操作；另外，写锁也比读锁有更高的优先级，因此一个写锁请求可以会被插入到读锁队列的前面。</p><p>尽管存储引擎可以管理自己的锁，服务器还是会使用各种有效的表锁来实现不同的目的。比如<strong>服务器在 ALTER TABLE 时使用表锁，而忽略存储引擎的锁机制。MyISAM 在读表前自动对表加读锁，在写表前自动对表加写锁。</strong></p><h2 id="SQL语法">2.1 SQL语法</h2><p>添加表锁：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">table</span> table1 <span class="token keyword">read</span><span class="token operator">/</span><span class="token keyword">write</span> <span class="token punctuation">,</span> table2 <span class="token keyword">read</span><span class="token operator">/</span><span class="token keyword">write</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>read为读锁，共享锁；write为写锁，独占锁。</p><p>显示加过锁的表：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span><span class="token punctuation">;</span></code></pre><ul><li><code>In_use</code> : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。为1代表已加锁。</li><li><code>Name_locked</code>：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</li></ul><p>释放表锁：</p><pre class=" language-sql"><code class="language-sql">unlock <span class="token keyword">tables</span><span class="token punctuation">;</span></code></pre><h2 id="总结">2.2 总结</h2><ol><li>对 MyISAM 表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li><li>对 MyISAM 表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li></ol><p>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。这也是MyISAM不适合做写为主表的引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h1 id="InnoDB-行锁">3 InnoDB 行锁</h1><p><strong>特点：</strong></p><ul><li>锁粒度小，并发度高；开销大，加锁慢，会出现死锁</li><li>支持事务</li></ul><p>InnoDB也实现了共享锁和排他锁两种类型的行锁。</p><p>InnoDB也支持意向锁，可以对表级别上意向锁。</p><p><strong>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，InnoDB会自动给涉及的数据集加排他锁</strong></p><p><strong>对于普通<code>SELECT</code>语句，InnoDB不会加任何锁，使用一致性非锁定读</strong></p><h2 id="了解：一致性非锁定读">3.1 了解：一致性非锁定读</h2><p>一致性非锁定读是指InnoDB存储引擎通过行多版本控制（MVCC）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE，这时读取操作不会因此去等待行上锁的释放，而是去读取行的一个快照数据。</p><p><img src="https://api.codetool.top/img/15835025427688.png" alt></p><p>快照数据是该行的之前版本的数据，实现是通过undo段来完成（即为了回滚事务而产生的重做日志）。</p><p>通过读取不同的快照版本实现不同的事务隔离级别：</p><ul><li>读已提交：一致性非锁定读总是读取被锁定行的最新一份快照数据。产生了不可重复读的问题。</li><li>重复读：一致性非锁定读总是读取事务开始时的行数据版本. 解决不可重复读的问题。</li></ul><p>一致性非锁定读是InnoDB默认的读取方式，不会占用和等待表上的锁。</p><h2 id="一致性锁定读">3.2 一致性锁定读</h2><p>某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。可以通过以下语句显示给记录集加共享锁或排他锁（一致性锁定读）。</p><pre class=" language-sql"><code class="language-sql">共享锁（S）：<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE MODE</span>排他锁（X<span class="token punctuation">)</span> ：<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span></code></pre><p>当事务提交了，锁就释放了。</p><p>可以使用<code>show status like &#39;innodb_row_lock%&#39;;</code>查看innodb行锁的争用情况</p><ul><li><p><code>Innodb_row_lock_current_waits</code>: 当前正在等待锁定的数量</p></li><li><p><code>Innodb_row_lock_time</code>: 从系统启动到现在锁定总时间长度</p></li><li><p><code>Innodb_row_lock_time_avg</code>:每次等待所花平均时长</p></li><li><p><code>Innodb_row_lock_time_max</code>:从系统启动到现在等待最长的一次所花的时间</p></li><li><p><code>Innodb_row_lock_waits</code>: 系统启动后到现在总共等待的次数</p></li></ul><h2 id="行锁的三种算法">3.3 行锁的三种算法</h2><h3 id="record-lock">3.3.1 record lock</h3><p>InnoDB 里的行锁（record lock）是索引记录的锁。</p><p>record lock 锁住的是索引记录，即使该表上没有任何索引，那么 innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说<strong>当一条 sql 没有走任何索引时，那么将会在每一条聚簇索引后面加 X 锁，这个类似于表锁</strong>，但原理上和表锁应该是完全不同的。</p><h3 id="gap-lock">3.3.2 gap lock</h3><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）”，InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的间隙锁（gap lock），它<strong>锁定一个范围的记录,但不包括记录本身</strong>。锁加在未使用的空闲空间上,可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。间隙锁针对事务隔离级别为可重复读或以上级别。</p><h3 id="next-key-lock">3.3.3 next-key lock</h3><p>行锁与间隙锁组合起来用就叫做 Next-Key Lock。<strong>锁定一个范围，并且锁定记录本身</strong>。对于行的查询，都是采用该方法，主要目的是阻止多个事务将记录插入到同一范围内，解决幻读的问题。</p><p>InnoDB 工作在可重复读隔离级别下，并且会以 Next-Key Lock 的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock 是行锁和间隙锁的组合，当 InnoDB 扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><p>如果一个索引有10，11，13和20这四个值，那么该索引可能被Next-key Locking的区间为：</p><pre><code>(-∞,10](10,11](11,13](13,20](20,＋∞]</code></pre><p>若事务T1已经锁定了如下范围：</p><p><code>(10,11]</code>，<code>(11,13]</code></p><p>则插入新的记录12时，锁定的范围会变成：</p><p><code>(10,11]</code>，<code>(11,12]</code>，<code>(12,13]</code></p><p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-key Lock进行优化，将其降级为Record lock，即仅锁住索引本身，而不是范围。</p><h3 id="如何理解三种算法">3.3.4 如何理解三种算法</h3><p>我这里谈谈我自己的理解：</p><p>对于唯一索引（比如主键），只要保证锁住该索引记录，就不可能出现幻读，这对应的就是Record Lock</p><p>比如对于sql查询</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></code></pre><p>这种情况就只会加一个Record Lock，第一次查询数据之后锁住了该记录，此后在同一事务内一直到第二次查询不可能会出现其他事务也将其他记录插入到id = 5这个位置。</p><p>而如果不是唯一索引，第一次查询数据之后即使所住了该记录，但可能还会有记录被插到id = 5这个位置，所以此时需要范围索引，锁住索引为5这个值，对于范围查询，范围索引更重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该文建议配合&lt;a href=&quot;../数据库理论之并发控制/&quot;&gt;数据库理论之并发控制&lt;/a&gt;阅读。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。&lt;/p&gt;
&lt;p&gt;在数据库中，除传统的计算资源（如 CPU
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之并发参数调整</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/"/>
    <id>https://www.codetool.top/article/MySQL之并发参数调整/</id>
    <published>2020-03-06T08:56:08.000Z</published>
    <updated>2020-03-06T09:23:45.404Z</updated>
    
    <content type="html"><![CDATA[<p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 <code>max_connections</code>、<code>back_log</code>、<code>thread_cache_size</code>、<code>table_open_cahce</code>。</p><h1 id="max-connections">1 max_connections</h1><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。<strong>如果状态变量 <code>connection_errors_max_connections</code> 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败</strong>，这时可以考虑增大<code>max_connections</code> 的值。</p><p>Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><h1 id="back-log">2 back_log</h1><p><code>back_log</code> 参数控制MySQL监听TCP端口时设置的积压请求栈大小。<strong>如果MySql的连接数达到<code>max_connections</code>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code></strong>，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 <code>50 + （max_connections / 5）</code>， 但最大不超过900。</p><p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><h1 id="table-open-cache">3 table_open_cache</h1><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p><p>​<code>max_connections x N</code></p><h1 id="thread-cache-size">4 thread_cache_size</h1><p>为了加快连接数据库的速度，MySQL 会<strong>缓存一定数量的客户服务线程</strong>以备重用，通过参数 <code>thread_cache_size</code> 可控制 MySQL 缓存客户服务线程的数量。</p><h1 id="innodb-lock-wait-timeout">5 innodb_lock_wait_timeout</h1><p>该参数是用来设置InnoDB 事务<strong>等待行锁的时间</strong>，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 &lt;code&gt;max_connections&lt;/code&gt;、&lt;code&gt;back_log&lt;/
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之内存管理和优化</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>https://www.codetool.top/article/MySQL之内存管理和优化/</id>
    <published>2020-03-06T08:55:28.000Z</published>
    <updated>2020-03-06T09:26:59.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存优化原则">1 内存优化原则</h1><ol><li><p>将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p></li><li><p>MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p></li><li><p>排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p></li></ol><h1 id="MyISAM-内存优化">2 MyISAM 内存优化</h1><p>MyISAM存储引擎使用 <code>key_buffer</code> 缓存<strong>索引块</strong>，加速MyISAM索引的读写速度。<strong>对于MyISAM表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</strong></p><h2 id="key-buffer-size">2.1 key_buffer_size</h2><p><strong><code>key_buffer_size</code>决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。</strong>可以在MySQL参数文件中设置<code>key_buffer_size</code>的值，对于一般MyISAM数据库，建议至少将<code>1/4</code>可用内存分配给<code>key_buffer_size</code>。</p><p>在配置文件中做如下配置：</p><pre><code>key_buffer_size=512M</code></pre><h2 id="read-buffer-size">2.2 read_buffer_size</h2><p>为需要全表扫描的MYISAM数据表线程指定缓存。</p><p>如果需要经常顺序扫描MyISAM表，可以通过增大<code>read_buffer_size</code>的值来改善性能。但需要注意的是<code>read_buffer_size</code>是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h2 id="read-rnd-buffer-size">2.3 read_rnd_buffer_size</h2><p>对于需要做排序的MyISAM表的查询，如带有order by子句的sql，适当增加 <code>read_rnd_buffer_size</code> 的值，可以改善此类的sql性能。但需要注意的是 <code>read_rnd_buffer_size</code> 是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h1 id="InnoDB-内存优化">3 InnoDB 内存优化</h1><p>InnoDB用一块内存区做IO缓存池，该缓存池不仅用来缓存InnoDB的索引块，而且也用来缓存InnoDB的数据块。</p><h2 id="innodb-buffer-pool-size">3.1 innodb_buffer_pool_size</h2><p>该变量决定了 <strong>InnoDB 存储引擎表数据和索引数据的最大缓存区大小</strong>。在保证操作系统及其他程序有足够内存可用的情况下，<code>innodb_buffer_pool_size</code> 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。</p><pre><code>innodb_buffer_pool_size=512M</code></pre><h2 id="innodb-log-buffer-size">3.2 innodb_log_buffer_size</h2><p>决定了<strong>InnoDB重做日志缓存的大小</strong>，对于可能产生大量更新记录的大事务，增加<code>innodb_log_buffer_size</code> 的大小，可以避免InnoDB在事务提交前就执行不必要的日志写入磁盘操作。</p><pre><code>innodb_log_buffer_size=10M</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存优化原则&quot;&gt;1 内存优化原则&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyIS
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之查询缓存优化</title>
    <link href="https://www.codetool.top/article/MySQL%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>https://www.codetool.top/article/MySQL之查询缓存优化/</id>
    <published>2020-03-06T08:53:20.000Z</published>
    <updated>2020-03-06T09:27:09.142Z</updated>
    
    <content type="html"><![CDATA[<p>开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p><p><img src="https://api.codetool.top/img/1583475530312.png" alt></p><h1 id="查询缓存配置">1 查询缓存配置</h1><p>查看当前的MySQL数据库是否支持查询缓存：</p><pre><code>mysql&gt; SHOW VARIABLES LIKE &#39;have_query_cache&#39;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| have_query_cache | YES   |+------------------+-------+1 row in set (0.01 sec)</code></pre><p>查看当前MySQL是否开启了查询缓存 ：</p><pre><code>mysql&gt; SHOW VARIABLES LIKE &#39;query_cache_type&#39;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| query_cache_type | OFF   |+------------------+-------+1 row in set (0.01 sec)</code></pre><p>查看查询缓存的占用大小 ：</p><pre><code>mysql&gt; SHOW VARIABLES LIKE &#39;query_cache_size&#39;;+------------------+----------+| Variable_name    | Value    |+------------------+----------+| query_cache_size | 16777216 |+------------------+----------+1 row in set (0.00 sec)</code></pre><p>查看查询缓存的状态变量：</p><pre><code>mysql&gt; SHOW STATUS LIKE &#39;Qcache%&#39;;+-------------------------+----------+| Variable_name           | Value    |+-------------------------+----------+| Qcache_free_blocks      | 1        || Qcache_free_memory      | 16760152 || Qcache_hits             | 0        || Qcache_inserts          | 0        || Qcache_lowmem_prunes    | 0        || Qcache_not_cached       | 1        || Qcache_queries_in_cache | 0        || Qcache_total_blocks     | 1        |+-------------------------+----------+8 rows in set (0.00 sec)</code></pre><p>各个变量的含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>查询缓存中的可用内存块数</td></tr><tr><td>Qcache_free_memory</td><td>查询缓存的可用内存量</td></tr><tr><td>Qcache_hits</td><td>查询缓存命中数</td></tr><tr><td>Qcache_inserts</td><td>添加到查询缓存的查询数</td></tr><tr><td>Qcache_lowmen_prunes</td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td>Qcache_not_cached</td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td>Qcache_queries_in_cache</td><td>查询缓存中注册的查询数</td></tr><tr><td>Qcache_total_blocks</td><td>查询缓存中的块总数</td></tr></tbody></table><h1 id="开启查询缓存">2 开启查询缓存</h1><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>OFF 或 0</td><td>查询缓存功能关闭</td></tr><tr><td>ON 或 1</td><td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td></tr><tr><td>DEMAND 或 2</td><td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td></tr></tbody></table><p><img src="https://api.codetool.top/img/15834798798264.png" alt="配置缓存相关参数"></p><p>配置完毕之后，重启服务既可生效 ；</p><p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p><h1 id="查询缓存SELECT选项">3 查询缓存SELECT选项</h1><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p><p><code>SQL_CACHE</code> : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p><p><code>SQL_NO_CACHE</code> : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p><p>例子：</p><pre class=" language-SQL"><code class="language-SQL">SELECT SQL_CACHE id, name FROM customer;SELECT SQL_NO_CACHE id, name FROM customer;</code></pre><h1 id="查询缓存失效的情况">4 查询缓存失效的情况</h1><h2 id="SQL-语句不一致">4.1 SQL 语句不一致</h2><p>要想命中查询缓存，查询的SQL语句必须一致。</p><pre class=" language-SQL"><code class="language-SQL">SQL1 : select count(*) from tb_item;SQL2 : Select count(*) from tb_item;</code></pre><p>区分大小写</p><h2 id="当查询语句中用到了函数">4.2 当查询语句中用到了函数</h2><pre class=" language-SQL"><code class="language-SQL">SQL1 : select * from tb_item where updatetime < now() limit 1;SQL2 : select user();SQL3 : select database();</code></pre><p>这些自带函数每次查询都是不确定的，不会使用缓存。</p><h2 id="不使用任何表查询语句">4.3 不使用任何表查询语句</h2><pre class=" language-SQL"><code class="language-SQL">select 'A';</code></pre><h2 id="查询系统数据库">4.4 查询系统数据库</h2><p>查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。</p><pre class=" language-SQL"><code class="language-SQL">select * from information_schema.engines;</code></pre><h2 id="在存储的函数，触发器或事件的主体内执行的查询">4.5 在存储的函数，触发器或事件的主体内执行的查询</h2><h2 id="表更改">4.6 表更改</h2><p>如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句改变, 如 <code>INSERT</code>， <code>UPDATE</code>， <code>DELETE</code>， <code>TRUNCATE TABLE</code>， <code>ALTER TABLE</code>， <code>DROP TABLE</code>，或 <code>DROP DATABASE</code> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15834755303
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer57-和为s的连续正数序列</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>https://www.codetool.top/article/剑指offer57-和为s的连续正数序列/</id>
    <published>2020-03-05T17:01:12.000Z</published>
    <updated>2020-03-05T17:04:48.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> target = 9<br><strong>输出:</strong> [[2,3,4],[4,5]] </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> target = 15<br><strong>输出:</strong> [[1,2,3,4,5],[4,5,6],[7,8]]  </p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题最大的坑就是用二维数组做返回值吧。。确实语法上挺麻烦的，解法就是滑动窗口，一个prev一个next，如果当前区间内的所有值的和小于目标值，next后移一位，如果大于目标值，prev后移一位，如果等于目标值，把当前区间内的所有数放入数组中再放入一个list中。</p><p>这样下去直到prev大于目标值的一半，就可以结束循环了，然后将list中所有的数组再搞进一个数组里去。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findContinuousSequence</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>next<span class="token operator">&lt;=</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                sum <span class="token operator">=</span> sum<span class="token operator">-</span>prev<span class="token punctuation">;</span>                prev<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>next<span class="token operator">-</span>prev<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>next<span class="token operator">-</span>prev<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span>prev<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                next<span class="token operator">++</span><span class="token punctuation">;</span>                sum <span class="token operator">=</span> sum<span class="token operator">+</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;输入一个正整数 &lt;code&gt;target&lt;/code&gt; ，输出所有和为 &lt;code&gt;target&lt;/code&gt; 的连续正整数序列（至少含有两个数）。&lt;/p&gt;
&lt;p&gt;序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化-从执行策略上提高数据库性能</title>
    <link href="https://www.codetool.top/article/SQL%E4%BC%98%E5%8C%96-%E4%BB%8E%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5%E4%B8%8A%E6%8F%90%E9%AB%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD/"/>
    <id>https://www.codetool.top/article/SQL优化-从执行策略上提高数据库性能/</id>
    <published>2020-03-05T15:17:38.000Z</published>
    <updated>2020-03-05T15:42:55.808Z</updated>
    
    <content type="html"><![CDATA[<p>该文前置知识：</p><ul><li><a href="../SQL优化前置知识之优化前分析/">SQL优化前置知识之优化前分析</a></li><li><a href="../SQL优化前置知识之索引的正确使用姿势/">SQL优化前置知识之索引的正确使用姿势</a></li></ul><p>数据库的性能在系统中非常重要，在前面了解了Redis高可用的背景下也了解到了许多问题都会给数据库施加非常大的压力，一旦数据库崩溃会带来非常严重的后果乃至整个系统崩溃，对数据库性能的优化主要方法是：</p><ol><li>SQL 语句及索引的优化</li><li>数据库表结构的优化</li><li>系统配置的优化</li><li>硬件的优化</li></ol><p>从效果上第一条影响最大，后面越来越小。这篇文章就主要来阐述SQL的优化方法。</p><p>注：在本篇文章的编写过程中，我发现mysql5.7版本对某些sql语句已经有了自动优化机制，但还是建议了解sql语句的优化，毕竟版本的事总不如脑子里的东西稳。</p><h1 id="优化load-data">1 优化load data</h1><p>当使用load data infile命令导入数据的时候，适当的设置可以提高导入的效率。</p><p><img src="https://api.codetool.top/img/15834130168834.png" alt="load data infile"></p><h2 id="主键顺序插入">1.1 主键顺序插入</h2><p>因为聚簇索引的关系，如果主键的值是顺序的，那么 InnoDB 会把每一条记录都存储在上一条记录的后面，填充的是同一个页，减少了IO页的次数。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p><h2 id="关闭唯一性校验">1.2 关闭唯一性校验</h2><p>如果可以确定插入的数据满足唯一性约束，可以在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行<code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p><h2 id="手动提交事务">1.3 手动提交事务</h2><p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><h1 id="优化insert语句">2 优化insert语句</h1><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p><h2 id="合并insert语句">2.1 合并insert语句</h2><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p><p>示例， 原始方式为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>优化后的方案为 ： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="在事务中进行数据插入">2.2 在事务中进行数据插入</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span></code></pre><h2 id="数据有序插入">2.3 数据有序插入</h2><p>和load data一样的原理</p><h1 id="优化join">3 优化join</h1><p>这部分的内容在<a href="../数据库理论之查询处理和查询优化/">数据库理论之查询处理和查询优化</a>谈得比较详细，总的来说是要先选择再连接。</p><h1 id="小表驱动大表">4 小表驱动大表</h1><p>如果有两张表连接，类似于二重循环</p><p>外层的表应该是小表，内层的应该是大表。</p><p>虽然总的遍历次数是一样的，但是频繁切换数据表是影响效率的（IO 次数），应该尽可能减少切换表的次数。</p><p>这方面内容可以参考：<a href="https://www.cnblogs.com/chafanbusi/p/10647471.html" target="_blank" rel="noopener">MySql 小表驱动大表 - 茶饭不撕 - 博客园</a></p><h1 id="优化order-by语句">5 优化order by语句</h1><h2 id="了解：两种排序方式">5.1 了解：两种排序方式</h2><p>第一种是通过<strong>对返回数据进行排序</strong>，也就是通常说的 <code>filesort</code> 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p>第二种<strong>通过有序索引顺序扫描</strong>直接返回有序数据，这种情况即为 <code>using index</code>，不需要额外排序，操作效率高。</p><p>可以在explain中看到sql语句使用的是哪种排序方法。</p><p>优化目标：尽量减少额外的排序，通过索引直接返回有序数据。</p><p>对于索引<code>(a,b,c)</code>，不能使用索引进行排序的情况：（应避免）</p><ul><li><code>ORDER BY a ASC, b DESC, c DESC</code>   /<em>排序不一致</em>/</li><li><code>WHERE g = const ORDER BY b, c</code>    /<em>不满足最左前缀</em>/</li><li><code>WHERE a in (...) ORDER BY b, c</code>   /<em>对于排序来说，范围in也不能满足最左前缀</em>/</li></ul><h2 id="了解：filesort的算法">5.2 了解：filesort的算法</h2><p>有的时候并不能避免filesort，该如何优化filesort就得了解它的底层实现。</p><p><strong>双路排序：</strong> </p><p>MySQL4.1之前是使用双路排序,字面意思就是两次扫描磁盘,最终得到数据。</p><p>它的工作过程：读取行指针和 orderby列,对他们进行排序,然后扫描已经排序好的列表,按照列表中的值重新从列表中读取对应的数据输出</p><p><strong>概括：</strong> 从磁盘取排序字段,在 buffer进行排序,再从磁盘取其他字段。</p><p>然而取一批数据,要对磁盘进行了两次扫描,众所周知,IO是很耗时的,所以在mysql4.1之后,出现了第二种改进的算法,就是<strong>单路排序</strong>：</p><p><strong>单路排序的工作过程：</strong> 从磁盘读取查询需要的所有列,按照 order by列在 buffer对它们进行排序,然后扫描排序后的列表进行输出,它的效率更快一些,避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间,因为它把每一行都保存在内存中了。</p><p><strong>单路排序问题：</strong></p><p>在 sort_buffer 中单路排序比双路排序要多占用很多空间，因为单路排序是把所有字段都取出, 所以<strong>有可能取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer容量大小的数据，进行排序（创建 tmp 文件，多路合并），排完再取 sort_buffer 容量大小，再排……从而多次 I/O。本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。</p><h2 id="优化方式">5.3 优化方式</h2><p><strong>1)  尽量使用 index 方式排序，遵照索引的最佳左前缀</strong></p><p>排序时使用的字段的顺序最好与 index 建立的顺序相同</p><p>ORDER BY满足两种情况，会使用Index方法排序：</p><ol><li>ORDER BY语句使用索引最左前缀列</li><li>使用WHERE子句与ORDER BY子句条件列组合满足索引最左前缀列</li></ol><p>例：<code>WHERE a = const AND b = const ORDER BY c</code>是允许的</p><p><strong>2)  select * 是一个大忌</strong></p><p>只取出需要的字段， 这点非常重要。在这里的影响是：</p><ol><li>尽量使用覆盖索引，可以直接从索引树中读取数据，避免二次查询聚簇索引，进而导致filesort。</li><li>当Query的字段大小总和小于 <code>max_length_for_sort_data</code> 而且排序字段不是<code>TEXT|BLOB</code> 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</li><li>避免取出太多数据使得占用内存超过 <code>sort_buffer_size</code> 而采用多路排序。</li></ol><p><strong>3)  尝试提高 sort_buffer_size 和 max_length_for_sort_data</strong></p><p>提高这两个参数，会增加用改进算法的概率。两个参数最好达成一种平衡，否则如果<code>max_length_for_sort_data</code>设的太高，数据总容量超出<code>sort_buffer_size</code> 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率。</p><h1 id="优化GROUP-BY语句">6 优化GROUP BY语句</h1><p>group by实质是先排序后进行分组,遵照索引的最佳左前缀规则，所以也尽量满足该规则。</p><p>当无法使用索引时，GROUP BY 使用两种策略来完成：使用临时表和filesort来做分组。表现为<code>use temporary</code>和<code>use filesort</code>。</p><p>当无法使用索引列：</p><ul><li>可以优化filesort，即增大<code>sort_buffer_size</code>参数和<code>max_length_for_sort_data</code>参数。</li><li>可以只使用临时表，不进行filesort，这样返回的结果是无序的，想要加上<code>ORDER BY null</code></li></ul><p>另，避免使用having，where高于having，能写在where限定的条件就不要去having限定了。</p><h1 id="优化嵌套查询">7 优化嵌套查询</h1><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p><p>事实上，MySQL5.7已经会自动优化一些可以被转成join的sql语句了，临时表开始被避免使用。</p><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> user_id <span class="token keyword">from</span> user_role <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>优化为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user u <span class="token punctuation">,</span> user_role ur <span class="token keyword">where</span> u<span class="token punctuation">.</span>id <span class="token operator">=</span> ur<span class="token punctuation">.</span>user_id<span class="token punctuation">;</span></code></pre><h1 id="优化OR条件">8 优化OR条件</h1><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引，而且不能使用到复合索引；如果没有索引，则应该考虑增加索引。（避免索引失效）</p><p>如果无法增加索引，还可以考虑使用union合并有索引的那些查询出来的和没索引查询出来的结果集代替or。（在数据量小的情况下不推荐，用到临时表有的时候效率更低）</p><h1 id="优化limit语句">9 优化limit语句</h1><p>当偏移量非常大的时候，比如 limit 100000,20 这样的查询，这时 MySQL 需要查询 100020 条记录然后只返回最后 20 条，这样的代价非常高。要优化这种查询，要么在页面中限制分页数量，要么优化大偏移的性能。</p><p>一个简单的办法是使用覆盖索引（延迟关联）</p><p>意思就是先把索引排序，取出100000-20的索引值，然后用这些数据再回表查询对应行的所有列的值。使用子查询的写法就是：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_item t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> tb_item <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token number">a</span> <span class="token keyword">where</span> t<span class="token punctuation">.</span>id<span class="token operator">=</span><span class="token number">a</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><p>另一种方法，如果使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描。假设主键递增，那么当查询<code>limit 100000,20</code>返回的最后一条数据是<code>id= 1000102</code>，那么下一次查询可以使用<code>where id&gt;1000102</code>来限定范围。</p><h1 id="使用SQL提示">10 使用SQL提示</h1><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>但是除非你的优化经验很好，否则不建议使用hint强制要求使用某个索引，因为至今MySQL本身对sql的优化程度已经很高了 : )</p><h2 id="USE-INDEX">10.1 USE INDEX</h2><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p><h2 id="IGNORE-INDEX">10.2 IGNORE INDEX</h2><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint。</p><h2 id="FORCE-INDEX">10.3 FORCE INDEX</h2><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该文前置知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;../SQL优化前置知识之优化前分析/&quot;&gt;SQL优化前置知识之优化前分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;../SQL优化前置知识之索引的正确使用姿势/&quot;&gt;SQL优化前置知识之索引的正确使用姿势&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化前置知识之索引的正确使用姿势</title>
    <link href="https://www.codetool.top/article/SQL%E4%BC%98%E5%8C%96%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>https://www.codetool.top/article/SQL优化前置知识之索引的正确使用姿势/</id>
    <published>2020-03-05T12:15:33.000Z</published>
    <updated>2020-03-06T12:11:12.513Z</updated>
    
    <content type="html"><![CDATA[<p>该文的前置知识：<a href="../SQL优化前置知识之优化前分析">SQL优化前置知识之优化前分析</a></p><h1 id="索引失效">1 索引失效</h1><p>有的sql语句会不使用索引？在编写sql语句的时候应避免这些情况，一起来看看这些情况吧：</p><h2 id="不遵从最左前缀规则">1.1 不遵从最左前缀规则</h2><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p><p>最左前缀的原理来自于B+树对节点的排序规则：</p><p>摘自<a href="../MySQL索引概述及索引的分类/">MySQL索引概述及索引的分类</a></p><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引</li><li>不能跳过索引中的列</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li></ul><p>验证最左前缀规则：</p><ol><li>建立索引</li></ol><pre><code>create index idx_uname_pw_name on t_user(username,password,name);Query OK, 0 rows affected (0.05 sec)Records: 0  Duplicates: 0  Warnings: 0</code></pre><ol start="2"><li>以最左前缀规则查询</li></ol><pre><code>mysql&gt; explain select * from t_user where username = &#39;super&#39;;+----+-------------+--------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+| id | select_type | table  | partitions | type | possible_keys     | key               | key_len | ref   | rows | filtered | Extra       |+----+-------------+--------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | t_user | NULL       | ref  | idx_uname_pw_name | idx_uname_pw_name | 137     | const |    1 |   100.00 | Using index |+----+-------------+--------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>可见使用了索引</p><ol start="3"><li>不以最左前缀规则查询</li></ol><pre><code>mysql&gt; explain select * from t_user where name = &#39;学生1&#39;;+----+-------------+--------+------------+-------+---------------+-------------------+---------+------+------+----------+--------------------------+| id | select_type | table  | partitions | type  | possible_keys | key               | key_len | ref  | rows | filtered | Extra                    |+----+-------------+--------+------------+-------+---------------+-------------------+---------+------+------+----------+--------------------------+|  1 | SIMPLE      | t_user | NULL       | index | NULL          | idx_uname_pw_name | 564     | NULL |    6 |    16.67 | Using where; Using index |+----+-------------+--------+------------+-------+---------------+-------------------+---------+------+------+----------+--------------------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>可见此时type变为了”index”，扫描索引树。</p><h2 id="在索引上使用表达式">1.2 在索引上使用表达式</h2><p>索引列上使用了表达式，如 where substr(a, 1, 3) = ‘hhh’，where a = a + 1，表达式是一大忌讳，再简单 MySQL 也不认。</p><p>有时数据量不是大到严重影响速度时，一般可以先查出来，比如先查所有有订单记录的数据，再在程序中去筛选</p><p>哪怕是该字段没有建立索引，但不能保证以后不在这个字段上建立索引，所以可以这么说：不要在任何字段上进行操作。</p><pre><code>mysql&gt; explain select * from t_user where left(username,2) = &#39;ad&#39;;+----+-------------+--------+------------+-------+---------------+-------------------+---------+------+------+----------+--------------------------+| id | select_type | table  | partitions | type  | possible_keys | key               | key_len | ref  | rows | filtered | Extra                    |+----+-------------+--------+------------+-------+---------------+-------------------+---------+------+------+----------+--------------------------+|  1 | SIMPLE      | t_user | NULL       | index | NULL          | idx_uname_pw_name | 564     | NULL |    6 |   100.00 | Using where; Using index |+----+-------------+--------+------------+-------+---------------+-------------------+---------+------+------+----------+--------------------------+1 row in set, 1 warning (0.00 sec)Note (Code 1003): /* select#1 */ select `test`.`t_user`.`id` AS `id`,`test`.`t_user`.`username` AS `username`,`test`.`t_user`.`password` AS `password`,`test`.`t_user`.`name` AS `name` from `test`.`t_user` where (left(`test`.`t_user`.`username`,2) = &#39;ad&#39;)</code></pre><h2 id="range-类型查询字段后面的索引无效">1.3 range 类型查询字段后面的索引无效</h2><p><img src="https://api.codetool.top/img/15834021284440.png" alt></p><p>最后一次只用到了两个索引<br>此时可以建一个只含前两个字段的索引<br>对<code>in()</code>无效，in仍可以使用索引。</p><h2 id="varchar类型不加单引号，造成索引失效">1.4 varchar类型不加单引号，造成索引失效</h2><p><img src="https://api.codetool.top/img/15834024132813.png" alt></p><p>由于在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p><h2 id="尽量使用覆盖索引，避免select">1.5 尽量使用覆盖索引，避免select *</h2><p>覆盖索引的概念，往下翻，<code>索引的特殊应用-&gt;覆盖索引</code></p><p><img src="https://api.codetool.top/img/15834026032099.png" alt></p><p>如果查询列，超出索引列，也会降低性能。</p><blockquote><p><strong>TIP:</strong><br>using index ：使用覆盖索引的时候就会出现<br>using where：在查找使用索引的情况下，需要回表去查询所需的数据<br>using index condition：查找使用了索引，但是需要回表查询数据​<br>using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p></blockquote><h2 id="使用不等于时索引失效">1.6 使用不等于时索引失效</h2><p><img src="https://api.codetool.top/img/1583403565859.png" alt></p><h2 id="is-not-null-时有时索引失效">1.7 is (not) null 时有时索引失效</h2><p><img src="https://api.codetool.top/img/15834033385073.png" alt></p><p>失效的情况其实是MySQL评估使用索引比全表更慢，见最后一点。</p><h2 id="like-以通配符开头会导致全表扫描">1.8 like 以通配符开头会导致全表扫描</h2><p><img src="https://api.codetool.top/img/15834035806892.png" alt></p><h2 id="使用-or-时索引失效">1.9 使用 or 时索引失效</h2><p><img src="https://api.codetool.top/img/1583403593215.png" alt></p><p>如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><p>其实还蛮好理解的，因为没有索引的列符合条件也满足or，自然要全表扫描。</p><h2 id="in-走索引，-not-in-索引失效">1.10 in 走索引， not in 索引失效</h2><p><img src="https://api.codetool.top/img/15834034738616.png" alt></p><h2 id="如果MySQL评估使用索引比全表更慢，则不使用索引。">1.11 如果MySQL评估使用索引比全表更慢，则不使用索引。</h2><p>这个东西就很玄学了，典型情况是查询的情况占了整表大多数。</p><h1 id="索引的特殊应用">2 索引的特殊应用</h1><h2 id="InnoDB-AUTO-INCREMENT">2.1 InnoDB AUTO_INCREMENT</h2><h3 id="概述">2.1.1 概述</h3><p>如果正在使用 InnoDB 表并且没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该与应用无关，最简单的方法是使用 AUTO_INCREMENT 自增列。这样可以保证数据行是按顺序写入的，对于根据主键做关联操作的性能也会更好。</p><p>最好避免随机的聚簇索引，特别是对于 IO 密集型应用，比如 UUID，它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</p><p><strong>顺序主键的优点：</strong></p><p>如果主键的值是顺序的，那么 InnoDB 会把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果。</p><p><strong>顺序主键的缺点：</strong></p><p>对于高并发工作负载，在 InnoDB 中按主键顺序插入可能会造成明显的争用。主键的上界会成为热点。因为所有的插入都在这里，所以并发插入可能导致锁竞争。另一个热点可能是AUTO_INCREMENT 锁机制，可能需要重新设计表或应用。</p><h3 id="AUTO-INC锁机制">2.1.2 AUTO-INC锁机制</h3><p>AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁。</p><p>在最简单的情况下，如果一个事务正在向表中插入值，则任何其他事务必须等待对该表执行自己的插入操作，以便第一个事务插入的行的值是连续的。</p><p>InnoDB 会在内存里保存一个计数器用来记录 AUTO_INCREMENT 的值，当插入一个新行数据时，就会用一个表锁来锁住这个计数器，直到插入结束。如果一行一行的插入数据则没有什么问题，但是如果大量的并发插入就废了，表锁会引起 SQL 堵塞，不但影响效率，而且可能会瞬间达到 MAX_CONNECTION 而崩溃。</p><p><strong>插入类型：</strong></p><ol><li>simple inserts<br>simple inserts 指的是那种能够事先确定插入行数的语句，比如 INSERT/REPLACE INTO 等插入单行或者多行的语句，语句中不包括嵌套子查询。此外，INSERT INTO … ON DUPLICATE KEY UPDATE 这类语句也要除外。  </li><li>bulk inserts<br>bulk inserts 指的是事先无法确定插入行数的语句，比如 INSERT/REPLACE INTO … SELECT,<br>LOAD DATA 等。</li><li>mixed-mode inserts<br>指的是 simple inserts 类型中有些行指定了 auto_increment 列的值，有些行没有指定，比如：INSERT INTO t1 (c1,c2) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’);另外一种 mixed-mode inserts 是 INSERT … ON DUPLICATE KEY UPDATE 这种语句，可能导致分配的 auto_increment 值没有被使用。</li></ol><p><code>innodb_autoinc_lock_mode</code> 配置选项控制用于自动增量锁定的算法。 它允许您选择如何在<br>可预测的自动递增值序列和插入操作的最大并发性之间进行权衡，配置语法：</p><p><code>innodb_autoinc_lock_mode=x</code>，x可取值：</p><ul><li>0，传统的 auto_increment 机制。这种模式下所有<strong>针对 auto_increment 列的插入操作都会加AUTO-INC 锁</strong>，分配的值也是一个个分配，是连续的，正常情况下也<strong>不会有间隙</strong>（当然如果事务 rollback 了这个 auto_increment 值就会浪费掉，从而造成间隙）。</li><li>1，这种情况下<ul><li><strong>针对 bulk inserts 才会采用 AUTO-INC 锁这种方式</strong></li><li>针对 simple inserts，则直接通过分析语句，获得要插入的数量，然后<strong>一次性分配足够的 auto_increment id</strong>，只会将整个分配的过程锁住。。当然，如果其他事务已经持有了AUTO-INC锁，则simple inserts需要等待.   </li><li><strong>针对 Mixed-mode inserts：直接分析语句，获得最坏情况下需要插入的数量，然后一次性分配足够的 auto_increment id</strong>，只会将整个分配的过程锁住。保证同一条 insert 语句中新插入的 auto_increment id 都是连续的，语句之间是<strong>可能出现auto_increment 值的空隙</strong>的。比如 mixed-mode inserts 以及 bulk inserts 中都有可能导致一些分配的 auto_increment 值被浪费掉从而导致间隙。</li></ul></li><li>2，这种模式下<strong>任何类型的 inserts 都不会采用 AUTO-INC 锁</strong>，性能最好。这种模式是<strong>来一个分配一个</strong>，而不会锁表，只会锁住分配 id 的过程，和 innodb_autoinc_lock_mode = 1 的区别在于，不会预分配多个。但是在 replication 中当 binlog_format 为 statement-based 时（简称 SBR statement-based replication）存在问题，因为是来一个分配一个，这样当并发执行时，“Bulk inserts”在分配时会同时向其他的 INSERT 分配，<strong>会出现主从不一致</strong>（从库执行结果和主库执行结果不一样），因为 binlog 只会记录开始的 insert id。<strong>可能会在同一条语句内部产生 auto_increment 值间隙。</strong></li></ul><h2 id="覆盖索引">2.2 覆盖索引</h2><p>如果<strong>一个索引包含了所有需要查询字段的值</strong>，就称为覆盖索引。</p><p>覆盖索引的优点：</p><ol><li>索引条目远少于数据行大小，如果只需要读取索引，则 MySQL 就会极大地<strong>减少数据访问</strong>了，这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对 IO 密集型应用也有帮助，因为索引比数据更小，更容易全部放入内存中。</li><li>因为索引是按照列值顺序存储的，<strong>对于 IO 密集型的范围查询会比随机从磁盘读取每一行数据的 IO 次数会少得多</strong>。</li><li>InnoDB 的二级索引在叶节点中保存了行的主键值，如果二级索引是覆盖索引，则可以<strong>避免对主键聚簇索引的二次查询</strong>。  </li></ol><p>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引都不存储索引列的值，所以 MySQL 只能使用 B 树索引做覆盖索引。当发起一个索引覆盖查询时，在 EXPLAIN 的 Extra 列可以看到 Using index 的信息。InnoDB 的二级索引的叶子节点都包含了主键的值，这意味着 InnoDB 的二级索引可以有效利用这些额外的主键列来覆盖查询。</p><h2 id="使用索引进行排序">2.3 使用索引进行排序</h2><p>MySQL 有两种可以生成有序的结果：通过排序操作；按索引顺序扫描。<strong>如果 EXPLAIN 出来的 type 列的值为 index，则说明 MySQL 使用了索引顺序扫描来做排序。</strong></p><p>扫描索引本身是很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机 IO，因此按索引顺序读取数据的速度通常要比顺序地全表扫描要慢，尤其是在 IO 密集型的工作负载时。只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（降序或升序，索引默认是升序）都一样时，MySQL 才可以使用索引来对结果做排序。如果查询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY 子句和查找型索引的限制是一样的，都需要满足索引的最左前缀的要求。<strong>有一种情况下 ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。</strong></p><h2 id="前缀压缩索引">2.4 前缀压缩索引</h2><p>MyISAM 通过前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中。默认只压缩字符串，但通过参数调整也能对整数进行压缩。</p><p>MyISAM 压缩每个索引块的方法时，先完全保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。压缩块使用更少的情况，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以 <strong>MyISAM 查找时无法在索引块使用二分查找而只能从头开始扫描。</strong></p><h2 id="冗余和重复索引">2.5 冗余和重复索引</h2><p>冗余索引：MySQL 允许<strong>在相同列上创建多个索引</strong>。MySQL 需要单独维护重复的索引，并且优化器在优化查询时也需要逐个地进行考虑，这会影响性能。</p><p>重复索引是指<strong>在相同的列上按照相同的顺序创建的相同类型的索引（完全相同）</strong>，应该避免这样创建重复索引，发现以后也应该立即移除。</p><p>冗余索引和重复索引有一些不同。如果创建了索引(A,B)，又创建了索引(A)就是冗余索引，索引(A,B)也可以当做索引(A)来使用。但是如果再创建索引(B,A)，就不是冗余索引。另外，其他不同类型的索引也不会是 B 树索引的冗余索引。</p><p>冗余索引通常发生在为表添加新索引的时候。例如，有人可能会增加一个新的索引(A,B)而不是扩展已有的索引(A)，还有一种情况是将一个索引扩展为(A,PK)，对于 InnoDB 而言 PK 已经包含在二级索引中了，所以这也是冗余的。</p><p><strong>大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。</strong>但也<strong>有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大</strong>，从而影响其他使用该索引的查询的性能。</p><p>例如，现在在整数列上有一个索引，需要额外增加一个很长的 VARCHAR 列来扩展该索引，那性能可能会急剧下降。可以使用一些工具来找出冗余和重复的索引。</p><h2 id="索引重用">2.6 索引重用</h2><p>现有索引(A,B,C)，如果要使用索引，那么 where 中必须写为 A=a and B = b and C = c。如果没有对 B 的筛选，还想使用索引，怎么绕过最左前缀匹配呢？</p><p>假设 B 是一个选择性很低的列，只有 b1 和 b2 两种取值，那么查询可以写为 <code>A = a and Bin(b1,b2) and C = c</code>。</p><h2 id="避免多个范围条件">2.7 避免多个范围条件</h2><p>对于范围条件查询，MySQL 无法再使用范围列后面的其他索引列了，但是<strong>对于多个等值条件查询（in …）则没有这个限制。</strong></p><p>假设有索引(A,B)，查询条件为 A &gt; a and B &lt; b，那么此时无法同时使用 A 和 B 的复合索引，只能用到 A 的索引。一定要用的话可以考虑将 A 转为 in(a1,a2…)。</p><h1 id="查看索引使用情况">3 查看索引使用情况</h1><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'Handler_read%'</span><span class="token punctuation">;</span>    <span class="token keyword">show</span> <span class="token keyword">global</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'Handler_read%'</span><span class="token punctuation">;</span>    </code></pre><p>这两条语句可以查看mysql索引的使用情况：</p><pre><code>mysql&gt; show status like &#39;Handler_read%&#39;;+-----------------------+-------+| Variable_name         | Value |+-----------------------+-------+| Handler_read_first    | 40    || Handler_read_key      | 43    || Handler_read_last     | 0     || Handler_read_next     | 306   || Handler_read_prev     | 0     || Handler_read_rnd      | 0     || Handler_read_rnd_next | 18832 |+-----------------------+-------+7 rows in set (0.00 sec)</code></pre><p>Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。</p><p>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。</p><p>Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</p><p>Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</p><p>Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。</p><p>Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该文的前置知识：&lt;a href=&quot;../SQL优化前置知识之优化前分析&quot;&gt;SQL优化前置知识之优化前分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;索引失效&quot;&gt;1 索引失效&lt;/h1&gt;&lt;p&gt;有的sql语句会不使用索引？在编写sql语句的时候应避免这些情况，一起来看看这些情况吧：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化前置知识之优化前分析</title>
    <link href="https://www.codetool.top/article/SQL%E4%BC%98%E5%8C%96%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E4%B9%8B%E4%BC%98%E5%8C%96%E5%89%8D%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/SQL优化前置知识之优化前分析/</id>
    <published>2020-03-05T07:41:38.000Z</published>
    <updated>2020-03-07T09:45:15.111Z</updated>
    
    <content type="html"><![CDATA[<p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</p><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p><h1 id="查看SQL执行频率">1 查看SQL执行频率</h1><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p><p>下面的命令显示了当前 session 中所有统计参数的值：</p><pre><code>mysql&gt; show status like &#39;Com_______&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| Com_binlog    | 0     || Com_commit    | 4     || Com_delete    | 4     || Com_insert    | 35    || Com_repair    | 0     || Com_revoke    | 0     || Com_select    | 291   || Com_signal    | 0     || Com_update    | 11    || Com_xa_end    | 0     |+---------------+-------+10 rows in set (0.00 sec)</code></pre><p>global:</p><pre><code>mysql&gt; show global status like &#39;Com_______&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| Com_binlog    | 0     || Com_commit    | 0     || Com_delete    | 0     || Com_insert    | 0     || Com_repair    | 0     || Com_revoke    | 0     || Com_select    | 1     || Com_signal    | 0     || Com_update    | 0     || Com_xa_end    | 0     |+---------------+-------+10 rows in set (0.00 sec)</code></pre><p>下面这条语句则只会查看使用innodb引擎表的操作次数：</p><pre><code>mysql&gt; show status like &#39;Innodb_rows_%&#39;;+----------------------+-------+| Variable_name        | Value |+----------------------+-------+| Innodb_rows_deleted  | 2     || Innodb_rows_inserted | 49    || Innodb_rows_read     | 382   || Innodb_rows_updated  | 17    |+----------------------+-------+4 rows in set (0.00 sec)</code></pre><table><thead><tr><th align="left">参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">Com_select</td><td>执行 select 操作的次数，一次查询只累加 1。</td></tr><tr><td align="left">Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td></tr><tr><td align="left">Com_update</td><td>执行 UPDATE 操作的次数。</td></tr><tr><td align="left">Com_delete</td><td>执行 DELETE 操作的次数。</td></tr><tr><td align="left">Innodb_rows_read</td><td>select 查询返回的行数。</td></tr><tr><td align="left">Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数。</td></tr><tr><td align="left">Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数。</td></tr><tr><td align="left">Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数。</td></tr></tbody></table><h1 id="定位低效SQL">2 定位低效SQL</h1><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。这方面的配置见<a href="../MySQL之日志配置全解">MySQL之日志配置全解</a></li><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><p>show processlist的结果：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>用户登录mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看</td></tr><tr><td>user</td><td>显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</td></tr><tr><td>host</td><td>显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</td></tr><tr><td>db</td><td>显示这个进程目前连接的是哪个数据库</td></tr><tr><td>command</td><td>显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</td></tr><tr><td>time</td><td>显示这个状态持续的时间，单位是秒</td></tr><tr><td>state</td><td>显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</td></tr><tr><td>info</td><td>显示这个sql语句，是判断问题语句的一个重要依据</td></tr></tbody></table><h1 id="explain分析执行计划">3 explain分析执行计划</h1><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>查询SQL语句的执行计划 ： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">explain</span>  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_item <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p><img src="https://api.codetool.top/img/15833935425677.png" alt></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">explain</span>  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_item <span class="token keyword">where</span> title <span class="token operator">=</span> <span class="token string">'阿尔卡特 (OT-979) 冰川白 联通3G手机3'</span><span class="token punctuation">;</span></code></pre><p><img src="https://api.codetool.top/img/15833935895541.png" alt></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><p>准备三张如图所示的表：</p><p><img src="https://api.codetool.top/img/15833941692933.png" alt></p><h2 id="explain-之-id">3.1 explain 之 id</h2><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： </p><p>1） id相同表示加载表的顺序是从上到下。</p><pre><code>mysql&gt; explain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ;+----+-------------+-------+------------+--------+-----------------------------+---------+---------+-----------------+------+----------+----------------------------------------------------+    | id | select_type | table | partitions | type   | possible_keys               | key     | key_len | ref             | rows | filtered | Extra                                              |+----+-------------+-------+------------+--------+-----------------------------+---------+---------+-----------------+------+----------+----------------------------------------------------+|  1 | SIMPLE      | r     | NULL       | ALL    | PRIMARY                     | NULL    | NULL    | NULL            |    5 |   100.00 | NULL                                               ||  1 | SIMPLE      | ur    | NULL       | ALL    | fk_ur_user_id,fk_ur_role_id | NULL    | NULL    | NULL            |    6 |    20.00 | Using where; Using join buffer (Block Nested Loop) ||  1 | SIMPLE      | u     | NULL       | eq_ref | PRIMARY                     | PRIMARY | 98      | test.ur.user_id |    1 |   100.00 | NULL                                               |+----+-------------+-------+------------+--------+-----------------------------+---------+---------+-----------------+------+----------+----------------------------------------------------+3 rows in set, 1 warning (0.01 sec)</code></pre><p>2） id 不同id值越大，优先级越高，越先被执行。 </p><pre><code>mysql&gt; EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#39;stu1&#39;));+----+-------------+-----------+------------+-------+----------------------+----------------------+---------+-------+------+----------+-------------+| id | select_type | table     | partitions | type  | possible_keys        | key                  | key_len | ref   | rows | filtered | Extra       |+----+-------------+-----------+------------+-------+----------------------+----------------------+---------+-------+------+----------+-------------+|  1 | PRIMARY     | t_role    | NULL       | const | PRIMARY              | PRIMARY              | 98      | const |    1 |   100.00 | NULL        ||  2 | SUBQUERY    | user_role | NULL       | ref   | fk_ur_user_id        | fk_ur_user_id        | 99      | const |    1 |   100.00 | Using where ||  3 | SUBQUERY    | t_user    | NULL       | const | unique_user_username | unique_user_username | 137     | const |    1 |   100.00 | Using index |+----+-------------+-----------+------------+-------+----------------------+----------------------+---------+-------+------+----------+-------------+3 rows in set, 1 warning (0.00 sec)</code></pre><p>3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p><h2 id="explain-之-select-type">3.2 explain 之 select_type</h2><p>表示 SELECT 的类型，常见的取值，如下表所示：</p><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td></tr><tr><td>SUBQUERY</td><td>在SELECT 或 WHERE 列表中包含了子查询</td></tr><tr><td>DERIVED</td><td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><pre><code>mysql&gt; explain select * from t_user where id = (select id from user_role where role_id = &#39;9&#39;);+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+| id | select_type | table     | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra       |+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+|  1 | PRIMARY     | t_user    | NULL       | ALL  | PRIMARY       | NULL          | NULL    | NULL  |    6 |    16.67 | Using where ||  2 | SUBQUERY    | user_role | NULL       | ref  | fk_ur_role_id | fk_ur_role_id | 99      | const |    1 |   100.00 | Using index |+----+-------------+-----------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+2 rows in set, 3 warnings (0.00 sec)</code></pre><pre><code>mysql&gt; explain select * from t_user where id = &#39;1&#39; union select * from t_user where id = &#39;2&#39;;+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra           |+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+|  1 | PRIMARY      | t_user     | NULL       | const | PRIMARY       | PRIMARY | 98      | const |    1 |   100.00 | NULL            ||  2 | UNION        | t_user     | NULL       | const | PRIMARY       | PRIMARY | 98      | const |    1 |   100.00 | NULL            || NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Using temporary |+----+--------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+3 rows in set, 1 warning (0.01 sec)</code></pre><p><strong>注：</strong> MySQL5.7中对Derived table做了一个新特性。该特性允许将符合条件的Derived table中的子表与父查询的表合并进行直接JOIN。<strong>体现为simple查询</strong></p><h2 id="explain-之-table">3.3 explain 之 table</h2><p>展示这一行的数据是关于哪一张表的 </p><h2 id="explain-之-type">3.4 explain 之 type</h2><p>type 显示的是访问类型，是较为重要的一个指标，可取值为： </p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>MySQL不访问任何表，索引，直接返回结果</td></tr><tr><td>system</td><td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td></tr><tr><td>const</td><td>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td></tr><tr><td>eq_ref</td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>ref_or_null</td><td>类似ref，但是可以搜索值为NULL的行。</td></tr><tr><td>index_merge</td><td>表示使用了索引合并的优化方法。</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td></tr><tr><td>index</td><td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行</td></tr></tbody></table><p>结果值从最好到最坏以此是：</p><pre><code>NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALLsystem &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></pre><p>==一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。==</p><h2 id="explain-之-key">3.5 explain 之 key</h2><p>possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </p><p>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</p><p>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</p><h2 id="explain-之-rows">3.6 explain 之 rows</h2><p>扫描行的数量。</p><h2 id="explain-之-extra">3.7 explain 之 extra</h2><p>其他的额外的执行计划信息，在该列展示 。</p><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td>using  filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。</td></tr><tr><td>using  temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td></tr><tr><td>using  index</td><td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td></tr></tbody></table><h1 id="show-profile分析SQL">4 show profile分析SQL</h1><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>(5.7版本后推荐使用performance_schema工具)</p><p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p><pre><code>mysql&gt; select @@have_profiling;+------------------+| @@have_profiling |+------------------+| YES              |+------------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p><pre><code>mysql&gt; set profiling=1;Query OK, 0 rows affected, 1 warning (0.00 sec)</code></pre><p>查看是否开启：</p><pre><code>mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+|           1 |+-------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>通过profile，我们能够更清楚地了解SQL执行的过程。</p><p>首先，我们可以执行一系列的操作，如：</p><pre><code>show databases;use db01;show tables;select * from tb_item where id &lt; 5;select count(*) from tb_item;</code></pre><p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p><p><img src="https://api.codetool.top/img/15833986524423.png" alt></p><p>通过<code>show profile for query query_id</code>语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p><p><img src="https://api.codetool.top/img/15833987009481.png" alt></p><p>Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。</p><p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间：</p><p><img src="https://api.codetool.top/img/15833987633054.png" alt></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Status</td><td>sql 语句执行的状态</td></tr><tr><td>Duration</td><td>sql 执行过程中每一个步骤的耗时</td></tr><tr><td>CPU_user</td><td>当前用户占有的cpu</td></tr><tr><td>CPU_system</td><td>系统占有的cpu</td></tr></tbody></table><h1 id="trace分析优化器执行计划">5 trace分析优化器执行计划</h1><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p><p>打开trace ，设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SET</span> optimizer_trace<span class="token operator">=</span><span class="token string">"enabled=on"</span><span class="token punctuation">,</span>end_markers_in_json<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span><span class="token keyword">set</span> optimizer_trace_max_mem_size<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">;</span></code></pre><p>执行SQL语句 ：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_item <span class="token keyword">where</span> id <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span></code></pre><p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>optimizer_trace\G<span class="token punctuation">;</span></code></pre><pre class=" language-json"><code class="language-json">*************************** <span class="token number">1</span>. row ***************************QUERY<span class="token operator">:</span> select * from tb_item where id &lt; <span class="token number">4</span>TRACE<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"join_preparation"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"select#"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"expanded_query"</span><span class="token operator">:</span> <span class="token string">"/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span> /* steps */      <span class="token punctuation">}</span> /* join_preparation */    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"join_optimization"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"select#"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"condition_processing"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token property">"condition"</span><span class="token operator">:</span> <span class="token string">"WHERE"</span><span class="token punctuation">,</span>              <span class="token property">"original_condition"</span><span class="token operator">:</span> <span class="token string">"(`tb_item`.`id` &lt; 4)"</span><span class="token punctuation">,</span>              <span class="token property">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                  <span class="token property">"transformation"</span><span class="token operator">:</span> <span class="token string">"equality_propagation"</span><span class="token punctuation">,</span>                  <span class="token property">"resulting_condition"</span><span class="token operator">:</span> <span class="token string">"(`tb_item`.`id` &lt; 4)"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>                  <span class="token property">"transformation"</span><span class="token operator">:</span> <span class="token string">"constant_propagation"</span><span class="token punctuation">,</span>                  <span class="token property">"resulting_condition"</span><span class="token operator">:</span> <span class="token string">"(`tb_item`.`id` &lt; 4)"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>                  <span class="token property">"transformation"</span><span class="token operator">:</span> <span class="token string">"trivial_condition_removal"</span><span class="token punctuation">,</span>                  <span class="token property">"resulting_condition"</span><span class="token operator">:</span> <span class="token string">"(`tb_item`.`id` &lt; 4)"</span>                <span class="token punctuation">}</span>              <span class="token punctuation">]</span> /* steps */            <span class="token punctuation">}</span> /* condition_processing */          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"table_dependencies"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token property">"table"</span><span class="token operator">:</span> <span class="token string">"`tb_item`"</span><span class="token punctuation">,</span>                <span class="token property">"row_may_be_null"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                <span class="token property">"map_bit"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token property">"depends_on_map_bits"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">]</span> /* depends_on_map_bits */              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> /* table_dependencies */          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"ref_optimizer_key_uses"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">]</span> /* ref_optimizer_key_uses */          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"rows_estimation"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token property">"table"</span><span class="token operator">:</span> <span class="token string">"`tb_item`"</span><span class="token punctuation">,</span>                <span class="token property">"range_analysis"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                  <span class="token property">"table_scan"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"rows"</span><span class="token operator">:</span> <span class="token number">9816098</span><span class="token punctuation">,</span>                    <span class="token property">"cost"</span><span class="token operator">:</span> <span class="token number">2.04e6</span>                  <span class="token punctuation">}</span> /* table_scan */<span class="token punctuation">,</span>                  <span class="token property">"potential_range_indices"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                      <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"PRIMARY"</span><span class="token punctuation">,</span>                      <span class="token property">"usable"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                      <span class="token property">"key_parts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                        <span class="token string">"id"</span>                      <span class="token punctuation">]</span> /* key_parts */                    <span class="token punctuation">}</span>                  <span class="token punctuation">]</span> /* potential_range_indices */<span class="token punctuation">,</span>                  <span class="token property">"setup_range_conditions"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                  <span class="token punctuation">]</span> /* setup_range_conditions */<span class="token punctuation">,</span>                  <span class="token property">"group_index_range"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"chosen"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                    <span class="token property">"cause"</span><span class="token operator">:</span> <span class="token string">"not_group_by_or_distinct"</span>                  <span class="token punctuation">}</span> /* group_index_range */<span class="token punctuation">,</span>                  <span class="token property">"analyzing_range_alternatives"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"range_scan_alternatives"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                      <span class="token punctuation">{</span>                        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"PRIMARY"</span><span class="token punctuation">,</span>                        <span class="token property">"ranges"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                          <span class="token string">"id &lt; 4"</span>                        <span class="token punctuation">]</span> /* ranges */<span class="token punctuation">,</span>                        <span class="token property">"index_dives_for_eq_ranges"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token property">"rowid_ordered"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token property">"using_mrr"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                        <span class="token property">"index_only"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                        <span class="token property">"rows"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>                        <span class="token property">"cost"</span><span class="token operator">:</span> <span class="token number">1.6154</span><span class="token punctuation">,</span>                        <span class="token property">"chosen"</span><span class="token operator">:</span> <span class="token boolean">true</span>                      <span class="token punctuation">}</span>                    <span class="token punctuation">]</span> /* range_scan_alternatives */<span class="token punctuation">,</span>                    <span class="token property">"analyzing_roworder_intersect"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                      <span class="token property">"usable"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                      <span class="token property">"cause"</span><span class="token operator">:</span> <span class="token string">"too_few_roworder_scans"</span>                    <span class="token punctuation">}</span> /* analyzing_roworder_intersect */                  <span class="token punctuation">}</span> /* analyzing_range_alternatives */<span class="token punctuation">,</span>                  <span class="token property">"chosen_range_access_summary"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token property">"range_access_plan"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"range_scan"</span><span class="token punctuation">,</span>                      <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"PRIMARY"</span><span class="token punctuation">,</span>                      <span class="token property">"rows"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>                      <span class="token property">"ranges"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                        <span class="token string">"id &lt; 4"</span>                      <span class="token punctuation">]</span> /* ranges */                    <span class="token punctuation">}</span> /* range_access_plan */<span class="token punctuation">,</span>                    <span class="token property">"rows_for_plan"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>                    <span class="token property">"cost_for_plan"</span><span class="token operator">:</span> <span class="token number">1.6154</span><span class="token punctuation">,</span>                    <span class="token property">"chosen"</span><span class="token operator">:</span> <span class="token boolean">true</span>                  <span class="token punctuation">}</span> /* chosen_range_access_summary */                <span class="token punctuation">}</span> /* range_analysis */              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> /* rows_estimation */          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"considered_execution_plans"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token property">"plan_prefix"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">]</span> /* plan_prefix */<span class="token punctuation">,</span>                <span class="token property">"table"</span><span class="token operator">:</span> <span class="token string">"`tb_item`"</span><span class="token punctuation">,</span>                <span class="token property">"best_access_path"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                  <span class="token property">"considered_access_paths"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                    <span class="token punctuation">{</span>                      <span class="token property">"access_type"</span><span class="token operator">:</span> <span class="token string">"range"</span><span class="token punctuation">,</span>                      <span class="token property">"rows"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>                      <span class="token property">"cost"</span><span class="token operator">:</span> <span class="token number">2.2154</span><span class="token punctuation">,</span>                      <span class="token property">"chosen"</span><span class="token operator">:</span> <span class="token boolean">true</span>                    <span class="token punctuation">}</span>                  <span class="token punctuation">]</span> /* considered_access_paths */                <span class="token punctuation">}</span> /* best_access_path */<span class="token punctuation">,</span>                <span class="token property">"cost_for_plan"</span><span class="token operator">:</span> <span class="token number">2.2154</span><span class="token punctuation">,</span>                <span class="token property">"rows_for_plan"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>                <span class="token property">"chosen"</span><span class="token operator">:</span> <span class="token boolean">true</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> /* considered_execution_plans */          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"attaching_conditions_to_tables"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token property">"original_condition"</span><span class="token operator">:</span> <span class="token string">"(`tb_item`.`id` &lt; 4)"</span><span class="token punctuation">,</span>              <span class="token property">"attached_conditions_computation"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">]</span> /* attached_conditions_computation */<span class="token punctuation">,</span>              <span class="token property">"attached_conditions_summary"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                  <span class="token property">"table"</span><span class="token operator">:</span> <span class="token string">"`tb_item`"</span><span class="token punctuation">,</span>                  <span class="token property">"attached"</span><span class="token operator">:</span> <span class="token string">"(`tb_item`.`id` &lt; 4)"</span>                <span class="token punctuation">}</span>              <span class="token punctuation">]</span> /* attached_conditions_summary */            <span class="token punctuation">}</span> /* attaching_conditions_to_tables */          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"refine_plan"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token property">"table"</span><span class="token operator">:</span> <span class="token string">"`tb_item`"</span><span class="token punctuation">,</span>                <span class="token property">"access_type"</span><span class="token operator">:</span> <span class="token string">"range"</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span> /* refine_plan */          <span class="token punctuation">}</span>        <span class="token punctuation">]</span> /* steps */      <span class="token punctuation">}</span> /* join_optimization */    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"join_execution"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"select#"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"steps"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">]</span> /* steps */      <span class="token punctuation">}</span> /* join_execution */    <span class="token punctuation">}</span>  <span class="token punctuation">]</span> /* steps */<span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1103-分糖果II</title>
    <link href="https://www.codetool.top/article/leetcode1103-%E5%88%86%E7%B3%96%E6%9E%9CII/"/>
    <id>https://www.codetool.top/article/leetcode1103-分糖果II/</id>
    <published>2020-03-05T05:12:17.000Z</published>
    <updated>2020-03-05T06:29:53.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>排排坐，分糖果。</p><p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code> 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n + 1</code> 颗糖果，第二个小朋友 <code>n + 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code> 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> candies = 7, num_people = 4<br><strong>输出：</strong> [1,2,3,1]<br><strong>解释：</strong><br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> candies = 10, num_people = 3<br><strong>输出：</strong> [5,2,3]<br><strong>解释：</strong><br>第一次，ans[0] += 1，数组变为 [1,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3]。<br>第四次，ans[0] += 4，最终数组变为 [5,2,3]。   </p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candies &lt;= 10^9</code></li><li>. <code>1 &lt;= num_people &lt;= 1000</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>模拟过程</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">distributeCandies</span><span class="token punctuation">(</span><span class="token keyword">int</span> candies<span class="token punctuation">,</span> <span class="token keyword">int</span> num_people<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>num_people<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>candies<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>candies <span class="token operator">-</span> cur_count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                candie<span class="token punctuation">[</span>cur_index<span class="token punctuation">]</span><span class="token operator">+=</span>candies<span class="token punctuation">;</span>                candies <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            candie<span class="token punctuation">[</span>cur_index<span class="token punctuation">]</span><span class="token operator">+=</span>cur_count<span class="token punctuation">;</span>            candies <span class="token operator">-=</span> cur_count<span class="token punctuation">;</span>            cur_index<span class="token operator">++</span><span class="token punctuation">;</span>            cur_count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_index <span class="token operator">==</span> num_people<span class="token punctuation">)</span> cur_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">return</span> candie<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 &lt;code&gt;candies&lt;/code&gt;，打算把它们分给排好队的 &lt;strong&gt;&lt;code&gt;n = num_people&lt;/code&gt;&lt;/strong&gt; 个小朋友。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引概述及索引的分类</title>
    <link href="https://www.codetool.top/article/MySQL%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>https://www.codetool.top/article/MySQL索引概述及索引的分类/</id>
    <published>2020-03-04T12:44:22.000Z</published>
    <updated>2020-03-06T05:39:07.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><img src="https://api.codetool.top/img/15833118439934.png" alt></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。（在有聚簇索引的概念时指向聚簇索引的值）</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><p><strong>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong></p><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h1 id="索引分类——从逻辑角度">2 索引分类——从逻辑角度</h1><ol><li>主键索引<br>索引列的值必须唯一，并且不允许有空值</li><li>唯一索引<br>索引列的值必须唯一，但允许有空值</li><li>单值索引<br>一个索引只包含单个列，一个表可以有多个单列索引</li><li>复合索引<br>一个索引包含多个列</li></ol><p>尽量使用复合索引，而少使用单列索引 。</p><p>创建复合索引 </p><pre><code>create index idx_name_sta_address on tb_seller(name, status, address);</code></pre><p>就相当于创建了三个索引 ： </p><ul><li>name</li><li>name + status</li><li>name + status + address</li></ul><h1 id="索引分类——从数据结构角度">3 索引分类——从数据结构角度</h1><h2 id="B树-B-树">3.1 B树,B+树</h2><p>之前的博客有介绍<a href="../多叉平衡查找树-B树与B-树/">多叉平衡查找树-B树与B-树</a></p><p>通常在 B+树上有两个头指针，一个指向根结点（进行随机搜索），一个指向关键字最小的叶<br>结点（进行顺序搜索）。</p><h3 id="B-树与B树的比较">3.1.1 B+树与B树的比较</h3><p><strong>组织方式不一样</strong></p><p>B+树：所有有效的索引关键字值都必须存储在叶结点中，其内部结点中的键值只用于索引<br>项的查找定位。<br>B树：有效的索引关键字值可以出现在B树的任意一个结点中。</p><p>因此：<br>B+树：所有关键字的查找速度基本一致<br>B树：依赖于查找关键字所在结点的层次</p><p><strong>叶结点不同</strong></p><p>B+树中叶节点间增加链表指针，提供对索引关键字的顺序扫描功能；叶节点的个数未必符<br>合 m 叉查找树的要求，它依赖于键值字节数和指针字节数，为 m1 阶。</p><h3 id="MySQL中的B-树适用场景">3.1.2 MySQL中的B+树适用场景</h3><p>InnoDB 存储引擎使用的是 B+树。</p><p>B+树为对如下类型的查询有效：</p><ol><li>全值匹配：和索引中的所有列进行匹配（复合索引）</li><li>匹配最左前缀：只使用索引的第一列或前几列</li><li>匹配列前缀：只匹配某一列的值的开头部分</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>覆盖索引/只访问索引的查询</li></ol><p>一般来说，如果 B+树可以按照某种方式查找到值，那么也可以按照这种方式用于排序。如果 ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。</p><p>下面是一些关于B+树索引的限制：</p><ol><li>如果不是按照索引的最左列开始查找，则无法使用索引</li><li>不能跳过索引中的列</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li></ol><h2 id="Hash-索引">3.2 Hash 索引</h2><p>Hash树我在博客<a href="../高效查找的数据结构-HashTree（哈希树）/">高效查找的数据结构-HashTree（哈希树）</a>也提到过了。</p><p>只有精确匹配索引所有列的查询才有效，<br>在 MySQL 中，只有 Memory 引擎显式支持 Hash 索引。</p><p><strong>限制：</strong></p><ol><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读<br>取行（无法使用覆盖索引）。不过，访问内存中的行的速度很快。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li><li>哈希索引不支持部分索引列匹配查找。比如建立复合哈希索引(A,B)，无法仅使用 A 使用<br>哈希索引去查询</li><li>不支持范围查询，仅支持等值查询</li><li>哈希冲突严重时，索引维护的代码很高。</li></ol><h2 id="B树索引与Hash索引比较">3.3 B树索引与Hash索引比较</h2><ol><li>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相<br>应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该<br>键所在位置，然后再根据链表往后扫描，直到找到相应的数据；<br>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈<br>希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li><li>哈希索引也没办法利用索引完成排序，以及 <code>like ‘xxx%’</code> 这样的部分模糊查询（这种部分<br>模糊查询，其实本质上也是范围查询）；</li><li>哈希索引也不支持多列联合索引的最左匹配规则；</li><li>B+树索引的关键字检索效率比较平均，在有大量重复键值情况下，哈希索引的效率是极<br>低的，因为存在所谓的哈希碰撞问题。</li></ol><h1 id="索引分类——从物理存储角度">4 索引分类——从物理存储角度</h1><h2 id="聚簇索引（聚集索引）">4.1 聚簇索引（聚集索引）</h2><p>InnoDB 的聚簇索引实际上<strong>在同一个结构中保存了B+树索引和数据行。</strong></p><p><strong>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。</strong>聚簇表示数据行和相邻的键值紧紧地存储在一起。因为无法同时把数据行存储在两个不同的地方，所以<strong>一个表只能有一个聚簇索引。</strong></p><p>InnoDB 通过主键聚簇数据。</p><p>每张表都会有一个聚簇索引。聚簇索引是一级索引。</p><p>聚簇索引一般是主键；没有主键，就是第一个唯一键；没有唯一键，就是隐藏ID。<strong>聚簇索引以外的所有索引都称为二级索引（即非聚簇索引）。</strong> 在 InnoDB 中，二级索引中的每条记录都包含该行的主键列，以及为二级索引指定的列。 InnoDB 使用这个主键值来搜索聚簇索引中的行。</p><p><strong>聚簇索引的优点：</strong></p><ol><li>可以将相关数据保存在一起，<strong>只需一次 IO 就可以取出相邻的数据</strong></li><li>数据访问更快，因为索引和数据保存在同一个 B+树中</li><li>使用覆盖索引扫描的查询可以直接使用叶节点中的主键值</li></ol><p><strong>缺点：</strong></p><ol><li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE命令重新组织一下表</li><li><strong>更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置</strong></li><li>插入新行或者更新主键导致需要移动行的时候，可能面临页分裂的问题。<strong>当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行</strong>，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li><li><strong>可能导致全表扫描变慢</strong>，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li><li>二级索引（非聚簇索引）可能会更大， 因为在<strong>二级索引的叶子节点包含了引用行的主键值</strong>。这样的策略减少了当出现行移动或者页分裂时二级索引的维护工作。</li><li><strong>二级索引访问需要两次 B 树索引查找</strong>，而不是一次。因为二级索引中叶子节点保存的是行的主键值，要找到数据行，还需要拿主键值到聚簇索引中进行一次查找。</li></ol><p>对于 InnoDB，自适应哈希索引能够减少这样的重复工作。</p><h2 id="非聚簇索引（辅助索引）">4.2 非聚簇索引（辅助索引）</h2><p>就是不是聚簇索引。</p><h1 id="索引使用的基本原则">5 索引使用的基本原则</h1><ul><li>最经常查询的列上建立聚簇索引以提高查询效率</li><li>一个基本表最多只建立一个聚簇索引</li><li>经常更新的列不宜建立聚簇索引</li><li>主键和唯一键会自动创建索引</li></ul><h1 id="SQL索引语法">6 SQL索引语法</h1><h2 id="创建索引">6.1 创建索引</h2><pre><code>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type]ON tbl_name(index_col_name,...)index_col_name : column_name[(length)][ASC | DESC]</code></pre><ul><li>unique:唯一索引</li><li>fulltext:全文索引</li><li>spatial：空间索引</li></ul><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> PersonIndex<span class="token keyword">ON</span> Person <span class="token punctuation">(</span>LastName<span class="token punctuation">)</span> </code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> PersonIndex<span class="token keyword">ON</span> Person <span class="token punctuation">(</span>LastName <span class="token keyword">DESC</span><span class="token punctuation">)</span> </code></pre><p>复合索引：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> PersonIndex<span class="token keyword">ON</span> Person <span class="token punctuation">(</span>LastName<span class="token punctuation">,</span> FirstName<span class="token punctuation">)</span></code></pre><h2 id="查看索引">6.2 查看索引</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span></code></pre><p>会显示所有建在该表上的索引信息</p><h2 id="删除索引">6.3 删除索引</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> tbl_name<span class="token punctuation">;</span></code></pre><p>老版本好像是</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span></code></pre><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> idx_city_name <span class="token keyword">on</span> city<span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>常用开源数据库连接池C3P0、Druid介绍</title>
    <link href="https://www.codetool.top/article/%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0C3P0%E3%80%81Druid%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/常用开源数据库连接池C3P0、Druid介绍/</id>
    <published>2020-03-04T08:44:11.000Z</published>
    <updated>2020-03-04T08:45:25.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>很多时候，连接的混乱管理所造成的系统资源开销过大成为制约大型企业级应用效率的瓶颈。因为每一次WEB请求都要建立一次数据库连接，建立连接是一个耗费资源的活动，每次都得花费0.05-1s的时间，而且系统还要分配内存资源。</p><p>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。于现在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从缓冲池中取出一个，使用完毕以后再放回去即可。</p><h1 id="C3P0">2 C3P0</h1><p>C3P0是一款优秀的开源数据库连接池，被广泛使用。</p><h2 id="使用">2.1 使用</h2><p>maven依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>基本配置：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c3p0-config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 默认配置，如果没有指定则使用这个配置 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>default-config</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://192.168.91.1:3306/test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>default-config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 命名的配置,可以通过方法调用实现 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>named-config</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- ... --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>named-config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c3p0-config</span><span class="token punctuation">></span></span></code></pre><p>其他配置：</p><table><thead><tr><th>参数</th><th>默认值</th><th>解释</th></tr></thead><tbody><tr><td>initialPoolSize</td><td>3</td><td>连接池初始化时创建的连接数（介于maxPoolSize和minPoolSize之间）</td></tr><tr><td>maxPoolSize</td><td>15</td><td>连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大</td></tr><tr><td>minPoolSize</td><td>3</td><td>连接池保持的最小连接数，后面的maxIdleTimeExcessConnections跟这个配合使用来减轻连接池的负载</td></tr><tr><td>acquireIncrement</td><td>3</td><td>连接池在无空闲连接可用时一次性创建的新数据库连接数</td></tr><tr><td>maxIdleTime</td><td>0</td><td>连接的最大空闲时间，如果超过这个时间，某个数据库连接还没有被使用，则会断开掉这个连接如果为0，则永远不会断开连接</td></tr><tr><td>maxConnectorAge</td><td>0</td><td>连接的最大绝对年龄，单位是秒，0表示绝对年龄无限大</td></tr><tr><td>maxIdleTimeExcessConnection</td><td>0</td><td>单位秒，为了减轻连接池的负载，当连接池经过数据访问高峰创建了很多连接，但是后面连接池不需要维护这么多连接，必须小于maxIdleTime.配置不为0，则将连接池的数量保持到minPoolSize</td></tr><tr><td>automaticTestTable</td><td>null</td><td>如果不为null，c3p0将生成指定名称的空表，使用该表来测试连接</td></tr><tr><td>connectionTesterClassName</td><td>com.mchange.v2.c3p0.impl.<br>DefaultConnectionTester</td><td>通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。</td></tr><tr><td>idleConnectionTestPeriod</td><td>0</td><td>每个几秒检查所有连接池中的空闲连接</td></tr><tr><td>preferredTestQuery</td><td>null</td><td>定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意： 测试的表必须在初始数据源的时候就存在</td></tr><tr><td>testConnectionOnCheckin</td><td>FALSE</td><td>如果设为true那么在取得连接的同时将校验连接的有效性</td></tr><tr><td>testConnectionOnCheckout</td><td>FALSE</td><td>如果为true，在连接释放的同事将校验连接的有效性。</td></tr><tr><td>maxStatements</td><td>0</td><td>JDBC的标准参数，用以控制数据源内加载d的PreparedStatements数量</td></tr><tr><td>maxStatementsPerConnection</td><td>0</td><td>maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数</td></tr><tr><td>statementCacheNum-<br>DeferredCloseThreads</td><td>0</td><td>如果大于零，则语句池将延迟物理close()缓存语句直到其父连接未被任何客户端使用，或者在其内部（例如在测试中）由池本身使用。</td></tr><tr><td>acquireRetryAttempts</td><td>30</td><td>定义在从数据库获取新连接失败后重复尝试的次数</td></tr><tr><td>acquireRetryDelay</td><td>1000</td><td>两次连接间隔时间，单位毫秒</td></tr><tr><td>breakAfterAcquireFailure</td><td>FALSE</td><td>获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效  保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 获取连接失败后该数据源将申明已断开并永久关闭</td></tr><tr><td>autoCommitOnClose</td><td>FALSE</td><td>连接关闭时默认将所有未提交的操作回滚。如果为true，则未提交设置为待提交而不是回滚。</td></tr><tr><td>forceIgnoreUnresolvedTransactions</td><td>FALSE</td><td>官方文档建议这个不要设置为true</td></tr><tr><td>checkoutTimeout</td><td>0</td><td>当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException,如设为0则无限期等待。单位毫秒。</td></tr><tr><td>factoryClassLocation</td><td>0</td><td>指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可</td></tr><tr><td>numHelperThreads</td><td>3</td><td>c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能通过多线程实现多个操作同时被执行</td></tr></tbody></table><p>使用：</p><pre class=" language-java"><code class="language-java">DataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>它会自动去类路径下查找名为<code>c3p0-config.xml</code>配置文件并加载。</p><p>可以使用命名的配置：</p><pre class=" language-java"><code class="language-java">DataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用的就是<code>name=&quot;test&quot;</code>的<code>named-config</code></p><h1 id="Druid">3 Druid</h1><p>Druid是阿里开源的一个数据库连接池，借鉴了C3P0等成熟连接池的思想，具有诸多优点</p><h2 id="使用-1">3.1 使用</h2><p>maven依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>基本配置：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">driverClassName</span> <span class="token punctuation">=</span> <span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">url</span> <span class="token punctuation">=</span> <span class="token attr-value">jdbc:mysql://192.168.91.1:3306/test</span><span class="token attr-name">username</span> <span class="token punctuation">=</span> <span class="token attr-value">root</span><span class="token attr-name">password</span> <span class="token punctuation">=</span> <span class="token attr-value">123456</span></code></pre><p>其他配置：</p><table><thead><tr><th>配置</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显式调用 init  方法，或者第一次getConnection 时</td></tr><tr><td>maxActive</td><td>8</td><td>最大允许的连接数</td></tr><tr><td>maxIdle</td><td></td><td>已过期</td></tr><tr><td>minIdle</td><td></td><td>最小的空闲连接数</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了 maxWait 之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置  useUnfairLock 属性为 true 使用非公平锁。</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的 sql，要求是一个查询语句。</td></tr><tr><td>testOnBorrow</td><td>TRUE</td><td>申请连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>FALSE</td><td>归还连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>FALSE</td><td>设置空闲时是否检测连接可用性。建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于  timeBetweenEvictionRunsMillis，执行 validationQuery 检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>检测需要关闭的空闲连接的间隔时间</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接在池中的最小生存时间</td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><p>使用：</p><pre class=" language-java"><code class="language-java">Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>InputStream in <span class="token operator">=</span> Demo1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>DataSource dataSource <span class="token operator">=</span> DruidDataSourceFactory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用连接池</span>conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="源码">3.2 源码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> DruidPooledConnection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token keyword">long</span> maxWaitMillis<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FilterChainImpl filterChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterChainImpl</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filterChain<span class="token punctuation">.</span><span class="token function">dataSource_connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> maxWaitMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getConnectionDirect</span><span class="token punctuation">(</span>maxWaitMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>DruidPooledConnection内部包装了一个Connection，增强了close等方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>disable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DruidConnectionHolder holder <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>holder<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>holder <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dupCloseLogEnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LOG<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"dup close"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DruidAbstractDataSource dataSource <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isSameThread <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSameThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dataSource<span class="token punctuation">.</span><span class="token function">setAsyncCloseConnectionEnable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dataSource<span class="token punctuation">.</span><span class="token function">isAsyncCloseConnectionEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">syncClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ConnectionEventListener listener <span class="token operator">:</span> holder<span class="token punctuation">.</span><span class="token function">getConnectionEventListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        listener<span class="token punctuation">.</span><span class="token function">connectionClosed</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConnectionEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Filter<span class="token operator">></span> filters <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getProxyFilters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FilterChainImpl filterChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterChainImpl</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChain<span class="token punctuation">.</span><span class="token function">dataSource_recycle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>disable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【附】了解：DBUtils的使用</p><p>QueryRunner、DbUtils、ResultSetHandler。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;很多时候，连接的混乱管理所造成的系统资源开销过大成为制约大型企业级应用效率的瓶颈。因为每一次WEB请求都要建立一次数据库连接，建立连接是一个耗费资源的活动，每次都得花费0.05-1s的时间，而且系统还要分配内存资源。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="javaweb" scheme="https://www.codetool.top/tags/javaweb/"/>
    
  </entry>
  
</feed>
