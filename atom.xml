<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-06-08T05:03:23.854Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode990-等式方程的可满足性</title>
    <link href="https://www.codetool.top/article/leetcode990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/"/>
    <id>https://www.codetool.top/article/leetcode990-等式方程的可满足性/</id>
    <published>2020-06-08T04:47:47.000Z</published>
    <updated>2020-06-08T05:03:23.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> [“a==b”,”b!=a”]<br><strong>输出：</strong> false<br><strong>解释：</strong> 如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> [“b==a”,”a==b”]<br><strong>输出：</strong> true<br><strong>说明：</strong> 我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> [“a==b”,”b==c”,”a==c”]<br><strong>输出：</strong> true</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> [“a==b”,”b!=c”,”c==a”]<br><strong>输出：</strong> false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong> [“c==c”,”b==d”,”x!=z”]<br><strong>输出：</strong> true</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol><h1 id="解法">2 解法</h1><p>本题解同步发于leetcode题解：<a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/jian-ji-de-javabing-cha-ji-by-codetool/" target="_blank" rel="noopener">简洁的Java并查集</a></p><h2 id="思想">2.1 思想</h2><p>见代码部分</p><h2 id="代码">2.2 代码</h2><p>我写的这个代码没有任何优化但是很简洁，使用的HashMap实现的并查集（如果不了解并查集建议先去学习一下哦，还是蛮实用的一个数据结构的）</p><p>比较重要的思路是一定要<strong>先将字符串方程按相等到不等来排序，相等的方程用于建立并查集，不等的方程用于判断是否出错（即不等的两个代数是否出现在了同一个集合中）。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equationsPossible</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> equations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 并查集</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Character<span class="token operator">></span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 先将字符串方程从相等到不等排序</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>equations<span class="token punctuation">,</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span>s2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'='</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String s<span class="token operator">:</span>equations<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> first <span class="token operator">=</span> chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> second <span class="token operator">=</span> chars<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取根代表</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">)</span> first <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span> second <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果是不等，但根代表相同，说明出错</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> second<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果是相等，跳过根代表相同的情况，把一个根代表连接到另一个根代表上（合并集合）</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> second<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>刚看了下官方的题解并没有先排序，而是进行了两次遍历，第一次处理相等的，第二次处理不等的，确实比我写的时间复杂度要好，那么按这个思路修改之后就是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equationsPossible</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> equations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Character<span class="token operator">></span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//建立并查集</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String s<span class="token operator">:</span>equations<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">char</span> first <span class="token operator">=</span> chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">char</span> second <span class="token operator">=</span> chars<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">)</span> first <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span> second <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> second<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//检查是否有错</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String s<span class="token operator">:</span>equations<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">char</span> first <span class="token operator">=</span> chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">char</span> second <span class="token operator">=</span> chars<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">)</span> first <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span> second <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> second<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以发现有一些重复代码，如果抽取成一个函数会更简洁，还有哈希集可以写成数组，时间成本会更低一些，感兴趣的小伙伴自己试试优化啦(<em>^_^</em>)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 &lt;code&gt;equations[i]&lt;/code&gt; 的长度为 &lt;code&gt;4&lt;/code&gt;，并采用两种不同的形式之一：&lt;code&gt;&amp;quot;a==b&amp;quot;&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode453-最小移动次数使数组元素相等</title>
    <link href="https://www.codetool.top/article/leetcode453-%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/"/>
    <id>https://www.codetool.top/article/leetcode453-最小移动次数使数组元素相等/</id>
    <published>2020-06-07T05:51:25.000Z</published>
    <updated>2020-06-07T05:58:41.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个长度为 n 的<strong>非空</strong>整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。</p><p><strong>示例:</strong></p><pre><strong>输入:</strong>[1,2,3]<strong>输出:</strong>3<strong>解释:</strong>只需要3次移动（注意每次移动会增加两个元素的值）：[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>根据峡谷相对论，给n-1个数加一，相当于给剩下的那个数减一</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMoves</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer min <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum <span class="token operator">-</span> min<span class="token operator">*</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个长度为 n 的&lt;strong&gt;非空&lt;/strong&gt;整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode128-最长连续序列</title>
    <link href="https://www.codetool.top/article/leetcode128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode128-最长连续序列/</id>
    <published>2020-06-06T06:02:06.000Z</published>
    <updated>2020-06-06T06:44:23.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 O(n)。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [100, 4, 200, 1, 3, 2]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>哈希集，记录出现过的数（我感觉不是严格的<code>O(n)</code>）</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> curNum <span class="token operator">=</span> num<span class="token punctuation">;</span>                <span class="token keyword">int</span> curLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>curNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    curNum <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    curLen <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                maxLen <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxLen<span class="token punctuation">,</span>curLen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxLen<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;要求算法的时间复杂度为 O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/stro
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1144-递减元素使数组呈锯齿状</title>
    <link href="https://www.codetool.top/article/leetcode1144-%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%91%88%E9%94%AF%E9%BD%BF%E7%8A%B6/"/>
    <id>https://www.codetool.top/article/leetcode1144-递减元素使数组呈锯齿状/</id>
    <published>2020-06-05T06:10:51.000Z</published>
    <updated>2020-06-05T13:44:36.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p><p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p><ul><li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li><li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li></ul><p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> nums = [1,2,3]<br><strong>输出：</strong> 2<br><strong>解释：</strong> 我们可以把 2 递减到 0，或把 3 递减到 1。  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [9,6,1,6,2]<br><strong>输出：</strong> 4</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>分成奇、偶两种情况进行遍历，找到满足条件的最小值</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">movesToMakeZigzag</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> diff <span class="token operator">=</span> cur <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">1001</span><span class="token operator">:</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>i <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">1001</span><span class="token operator">:</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> count1<span class="token operator">+=</span>diff<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> count2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> diff <span class="token operator">=</span> cur <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>i <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">?</span><span class="token number">1001</span><span class="token operator">:</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>diff <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> count2<span class="token operator">+=</span>diff<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>count1<span class="token punctuation">,</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，每次 &lt;strong&gt;操作&lt;/strong&gt; 会从中选择一个元素并 &lt;strong&gt;将该元素的值减少 1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果符合下列情况之一，则数组 &lt;cod
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode238-除自身以外数组的乘积</title>
    <link href="https://www.codetool.top/article/leetcode238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>https://www.codetool.top/article/leetcode238-除自身以外数组的乘积/</id>
    <published>2020-06-04T00:17:45.000Z</published>
    <updated>2020-06-04T00:20:16.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个长度为 n 的整数数组 <code>nums</code>，其中 n &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入：</strong> [1,2,3,4]<br><strong>输出：</strong> [24,12,8,6]  </p></blockquote><p><strong>提示：</strong> 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p><p><strong>说明:</strong> 请<strong>不要使用除法</strong>，且在 O(n) 时间复杂度内完成此题。</p><p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>顺序相反的两次遍历</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> prev <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prev<span class="token operator">*</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            prev <span class="token operator">=</span> prev<span class="token operator">*</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个长度为 n 的整数数组 &lt;code&gt;nums&lt;/code&gt;，其中 n &amp;gt; 1，返回输出数组 &lt;code&gt;output&lt;/code&gt; ，其中 &lt;code&gt;output[i]&lt;/code&gt; 等于 &lt;code&gt;nums&lt;/c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java8避免空指针异常Optional类的使用</title>
    <link href="https://www.codetool.top/article/Java8%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8Optional%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.codetool.top/article/Java8避免空指针异常Optional类的使用/</id>
    <published>2020-06-03T13:49:56.000Z</published>
    <updated>2020-06-03T14:38:59.694Z</updated>
    
    <content type="html"><![CDATA[<p>最近都是一天写一篇算法题解，好久没有写过博客了，不知道写啥了而且快到期末考试了。。</p><p>今天介绍一个Java8的特性：Optional类，这个类我平时也不咋用，今天来研究一下。</p><h1 id="Optional的介绍与创建">1 Optional的介绍与创建</h1><p>Optional可以看作一个对象的容器，内部可以有一个对象，也可以没有（为空）。</p><p>通过下面的API可以创建一个Optional对象：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 将传入的参数包装为一个Optional容器，不允许是null，否则报NullPointerException</span>Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> optional <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果参数是null，返回一个空容器，否则返回一个包装着该对象的容器</span>Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> optional <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获得了一个Optional对象之后，就有很多有意思的操作了：</p><h1 id="Optional的操作方法">2 Optional的操作方法</h1><h2 id="get">2.1 get</h2><p>最简单的取出容器内的元素，就是get方法，注意<strong>如果容器为空，抛出<code>NoSuchElementException</code>异常</strong>：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> optional <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取容器中的值，如果容器为空，抛出NoSuchElementException异常</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="isPresent">2.2 isPresent</h2><p>判断容器中是否有值（不为空），返回一个布尔值：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 容器中是否有值（不为空）</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="ifPresent">2.3 ifPresent</h2><p>ifPresent就要配合同是Java8特性的函数式接口来使用了，如果容器中存在值，就调用传入的一个Consumer来消耗它，例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果容器中存在值，则消费，不存在则不做任何事</span>optional<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也可以使用方法引用来改写这行代码：</p><pre class=" language-java"><code class="language-java">optional<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="orElse">2.4 orElse</h2><p>如果容器为空，直接调用get方法会报异常，那么可以使用<code>orElse</code>方法获取一个值，它类似于HashMap的<code>getOrDefault</code>，如果容器为空，则返回传入的参数对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果容器为空，返回"123"，否则返回容器中的对象</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="orElseGet">2.5 orElseGet</h2><p>orElseGet和orElse很像，只是若容器为空<code>orElse</code>返回的对象是传入的参数，而<code>orElseGet</code>是通过传入的一个<code>Supplier</code>获取返回的对象：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果容器为空，返回"123"，否则返回容器中的对象</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="orElseThrow">2.6 orElseThrow</h2><p>orElseThrow要求提供一个异常的<code>Supplier</code>，如果容器为空，则抛出通过<code>Supplier</code>获取的异常。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果容器为空，抛出RuntimeException异常</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>optional<span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="filter">2.7 filter</h2><p>配合函数式接口来使用，传入一个Predicate用于过滤容器中的值，如果满足给定的条件，则保留容器中的值，否则返回一个空容器：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> optional <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    optional<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span>e<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="map">2.8 map</h2><p>map这个方法很有用，也是配合函数式接口来使用，传入一个Function，用返回的元素替换容器中的元素，注意如果容器原来为空的，则替换后也为空，如果返回的元素是null，也会包装为一个空容器。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> optional <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    optional<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span>e<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>比较实用的做法是，获取一个对象内部字段，可以通过这个方法，避免空指针异常</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span>e<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="flatMap">2.9 flatMap</h2><p>flatMap和map很像，区别在于，flatMap不允许替换的元素是null，否则会报<code>NullPointerException</code>异常</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近都是一天写一篇算法题解，好久没有写过博客了，不知道写啥了而且快到期末考试了。。&lt;/p&gt;
&lt;p&gt;今天介绍一个Java8的特性：Optional类，这个类我平时也不咋用，今天来研究一下。&lt;/p&gt;
&lt;h1 id=&quot;Optional的介绍与创建&quot;&gt;1 Optional的介绍与创
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode837-新21点</title>
    <link href="https://www.codetool.top/article/leetcode837-%E6%96%B021%E7%82%B9/"/>
    <id>https://www.codetool.top/article/leetcode837-新21点/</id>
    <published>2020-06-03T05:11:45.000Z</published>
    <updated>2020-06-03T06:18:08.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> N = 10, K = 1, W = 10<br><strong>输出：</strong> 1.00000<br><strong>说明：</strong> 爱丽丝得到一张卡，然后停止。  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong> N = 6, K = 1, W = 10<br><strong>输出：</strong> 0.60000<br><strong>说明：</strong> 爱丽丝得到一张卡，然后停止。<br>在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> N = 21, K = 17, W = 10<br><strong>输出：</strong> 0.73278</p></blockquote><p><strong>提示：</strong></p><ol><li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li><li><code>1 &lt;= W &lt;= 10000</code></li><li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li><li>此问题的判断限制时间已经减少。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>可以从dfs的角度入手，这是自顶向下的解法，但比较耗时，</p><p>于是可以转换为动态规划。</p><h2 id="代码">2.2 代码</h2><p>未经优化的DFS，计算了很多重复单元：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> K<span class="token punctuation">;</span>    <span class="token keyword">int</span> W<span class="token punctuation">;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">new21Game</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>K <span class="token operator">=</span> K<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>W <span class="token operator">=</span> W<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>N <span class="token operator">=</span> N<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span><span class="token keyword">double</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">>=</span>K<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">&lt;=</span>N<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">double</span> ans <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>W<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token operator">+</span>i<span class="token punctuation">,</span>p<span class="token operator">/</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>加入记忆化后的DFS，仍然超时：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> K<span class="token punctuation">;</span>    <span class="token keyword">int</span> W<span class="token punctuation">;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    Double<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">new21Game</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>K <span class="token operator">=</span> K<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>W <span class="token operator">=</span> W<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>N <span class="token operator">=</span> N<span class="token punctuation">;</span>        memory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">>=</span>K<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">&lt;=</span>N<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">/</span>W<span class="token punctuation">,</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memory<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> memory<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> ans <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>W<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token operator">+</span>i<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        memory<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>那么需要进一步优化，通过分析发现，这里的概率其实仅和<code>cur</code>有关，即<code>memory[cur][depth] == Math.pow(1.0/W,depth) * memory[cur][0]</code>，因此只需要计算出<code>memory[0][0],memory[1][0],memory[2][0]...</code>就能完成大部分计算。</p><p>于是可以使用动态规划来做（用dfs会特别麻烦）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">new21Game</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>K <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span>K <span class="token operator">+</span> W<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> K<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> K <span class="token operator">+</span> W<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span>K <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>N <span class="token operator">-</span> K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> W<span class="token punctuation">)</span> <span class="token operator">/</span> W<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> K <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> W <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> W<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：&lt;/p&gt;
&lt;p&gt;爱丽丝以 &lt;code&gt;0&lt;/code&gt; 分开始，并在她的得分少于 &lt;code&gt;K&lt;/code&gt; 分时抽取数字。 抽取时，她从 &lt;code&gt;[1, W]
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer64-求1+2+…+n</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer64-%E6%B1%821-2-%E2%80%A6-n/"/>
    <id>https://www.codetool.top/article/剑指offer64-求1-2-…-n/</id>
    <published>2020-06-02T05:20:54.000Z</published>
    <updated>2020-06-02T12:52:20.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> n = 3<br><strong>输出：</strong> 6  </p></blockquote><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> n = 3<br><strong>输出：</strong> 6  </p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题有比较多的限制，因此需要些技巧。</p><p>通常能想到几个方法：</p><ol><li>递归，但不能使用条件判断语句</li><li>数学公式，但不能使用乘法</li></ol><p>这里利用短路逻辑运算，从而终止递归。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumNums</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> n <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">+=</span> <span class="token function">sumNums</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;求 &lt;code&gt;1+2+...+n&lt;/code&gt; ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1431-拥有最多糖果的孩子（儿童节快乐！）</title>
    <link href="https://www.codetool.top/article/leetcode1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%88%E5%84%BF%E7%AB%A5%E8%8A%82%E5%BF%AB%E4%B9%90%EF%BC%81%EF%BC%89/"/>
    <id>https://www.codetool.top/article/leetcode1431-拥有最多糖果的孩子（儿童节快乐！）/</id>
    <published>2020-06-01T04:11:47.000Z</published>
    <updated>2020-06-01T04:16:15.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p><p><strong>示例 1:</strong></p><pre><strong>输入：</strong>candies = [2,3,5,1,3], extraCandies = 3<strong>输出：</strong>[true,true,true,false,true] <strong>解释：</strong>孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</pre><p><strong>示例 2:</strong></p><pre><strong>输入：</strong>candies = [4,2,1,1,2], extraCandies = 1<strong>输出：</strong>[true,false,false,false,false] <strong>解释：</strong>只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>candies = [12,1,12], extraCandies = 10<strong>输出：</strong>[true,false,true]</pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= candies.length &lt;= 100</code></li><li><code>1 &lt;= candies[i] &lt;= 100</code></li><li><code>1 &lt;= extraCandies &lt;= 50</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>越长大越想过六一嘻嘻，力扣儿童节每日一题选这个也是有心了，好久没有写过这么简单的题了。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">kidsWithCandies</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candies<span class="token punctuation">,</span> <span class="token keyword">int</span> extraCandies<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>candies<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>candies<span class="token punctuation">)</span><span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token operator">+</span>extraCandies<span class="token operator">>=</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你一个数组 &lt;code&gt;candies&lt;/code&gt; 和一个整数 &lt;code&gt;extraCandies&lt;/code&gt; ，其中 &lt;code&gt;candies[i]&lt;/code&gt; 代表第 &lt;code&gt;i&lt;/code&gt; 个孩子拥有的糖果数
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode82-删除排序链表中的重复元素II</title>
    <link href="https://www.codetool.top/article/leetcode82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>https://www.codetool.top/article/leetcode82-删除排序链表中的重复元素II/</id>
    <published>2020-05-31T06:02:52.000Z</published>
    <updated>2020-05-31T06:04:21.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br><strong>输出:</strong> 1-&gt;2-&gt;5  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3<br><strong>输出:</strong> 2-&gt;3</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>双指针吧</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode sentinel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> sentinel<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">do</span><span class="token punctuation">{</span>                    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                cur <span class="token operator">=</span> node<span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sentinel<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 1
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode81-搜索旋转排序数组II</title>
    <link href="https://www.codetool.top/article/leetcode81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <id>https://www.codetool.top/article/leetcode81-搜索旋转排序数组II/</id>
    <published>2020-05-30T05:50:08.000Z</published>
    <updated>2020-05-30T06:36:18.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> nums = [2,5,6,0,0,1,2], target = 0<br><strong>输出:</strong> true</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> nums = [2,5,6,0,0,1,2], target = 3<br><strong>输出:</strong> false</p></blockquote><p><strong>进阶:</strong></p><ul><li>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code>  可能包含重复元素。 </li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找，如果遇到重复的数字就顺序缩窄范围（也可以继续二分查找，但比较麻烦）。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//前半部分有序</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//target在前半部分</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    end <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//否则，去后半部分找</span>                    start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//后半部分有序</span>                <span class="token comment" spellcheck="true">//target在后半部分</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    start <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//否则，去后半部分找</span>                    end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//一直没找到，返回false</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,0,1,2,2,5,6]&lt;/code&gt; 可能变为 &lt;code&gt;[2,5,6,0,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏05</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F05/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏05/</id>
    <published>2020-05-29T14:39:18.000Z</published>
    <updated>2020-05-30T13:27:39.141Z</updated>
    
    <content type="html"><![CDATA[<p>继续我的复习刷题</p><h1 id="可以有和类名同名的函数">1 可以有和类名同名的函数</h1><p>题目：</p><p>JAVA中，下列语句哪一个正确（）</p><p>A. class中的constructor不可省略<br>B. constructor必须与class同名，但方法不能与class同名<br>C. constructor在一个对象被new时执行<br>D. 一个class只能定义一个constructor  </p><p>正确答案: C   你的答案: C (正确)</p><hr><p>虽然选对了，不过这个知识点得补上：</p><p>除了构造函数，可以声明和类名同名的函数，但是要带上返回类型，如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConstructor3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">TestConstructor3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">TestConstructor3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>只是通常不这么写罢了</p><h1 id="a—b怎么理解？">2 a—b怎么理解？</h1><p>题目：</p><p>以下程序会输出什么</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span>c<span class="token operator">=</span>a<span class="token operator">--</span><span class="token operator">-</span>b<span class="token punctuation">,</span>d<span class="token operator">=</span>a<span class="token operator">--</span><span class="token operator">-</span>b<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>A. 100 48 48 49<br>B. 100 49 48 52<br>C. 98 50 50 49<br>D. 98 50 50 48  </p><p>正确答案: C   你的答案: C (正确)</p><hr><p>还蛮有意思的这个，（虽然没什么价值），主要问题是<code>a---b</code>到底应该断句为<code>a-- -b</code>还是<code>a- --b</code>，通过排除法可以知道如果理解为<code>a- --b</code>这里也没得选了，所以应该是<code>a-- -b</code>，主要的知识点就是 <strong><code>--</code>的优先级比<code>-</code>要高些</strong> ，不过这个知识点没什么营养，实际100%不会这么写。</p><h1 id="接口可以定义静态成员常量">3 接口可以定义静态成员常量</h1><p>题目：</p><p>下列描述正确的是（ ）？</p><p>A. 类不可以多继承而接口可以多实现<br>B. 抽象类自身可以定义成员而接口不可以<br>C. 抽象类和接口都不能被实例化<br>D. 一个类可以有多个基类和多个基接口  </p><p>正确答案: A C   你的答案: A B C (错误)</p><hr><p>如题：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TestInterface2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而且<code>public static final</code>是可以省略的，即接口里面的字段默认是静态常量。</p><p>这样的接口有数据共享的作用，不过通常不这样用。</p><h1 id="String-valueOf是存在char类型参数的重载版本的">4 String.valueOf是存在char类型参数的重载版本的</h1><p>题目：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharToString</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">char</span> myChar <span class="token operator">=</span> <span class="token string">'g'</span><span class="token punctuation">;</span>        String myStr <span class="token operator">=</span> Character<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>myChar<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String is: "</span><span class="token operator">+</span>myStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        myStr <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>myChar<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String is: "</span><span class="token operator">+</span>myStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此代码片段输出正确的值是（）</p><p>A.<br>String is: g<br>String is: g  </p><p>B.<br>String is: 103<br>String is: g  </p><p>C.<br>String is: g<br>String is: 103  </p><p>D.<br>String is: 103<br>String is: 103  </p><p>正确答案: A   你的答案: C (错误)</p><hr><p>这道题目也太会误导了吧。。</p><p>通过查找可以发现String类是存在这个方法的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="static变量不能定义在方法中">5 static变量不能定义在方法中</h1><p>题目：</p><p>如下代码的输出结果是什么？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    test<span class="token punctuation">.</span><span class="token function">aMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token function">aMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>A. 0<br>B. 1<br>C. 2<br>D. 编译失败 </p><p>正确答案: D   你的答案: C (错误)</p><hr><p>Java是不允许在方法中定义静态变量的（我记得C++好像可以定义，Java确实不太确定）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续我的复习刷题&lt;/p&gt;
&lt;h1 id=&quot;可以有和类名同名的函数&quot;&gt;1 可以有和类名同名的函数&lt;/h1&gt;&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;JAVA中，下列语句哪一个正确（）&lt;/p&gt;
&lt;p&gt;A. class中的constructor不可省略&lt;br&gt;B. constructor必须与
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode198-打家劫舍</title>
    <link href="https://www.codetool.top/article/leetcode198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://www.codetool.top/article/leetcode198-打家劫舍/</id>
    <published>2020-05-29T04:01:14.000Z</published>
    <updated>2020-05-29T04:18:08.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [2,7,9,3,1]<br><strong>输出:</strong> 12<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划，到第n间偷取的最高金额是<code>n-2间偷取的最高金额+该间金额</code>和<code>n-1间偷取的最高金额</code>的最大值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> second <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> second<span class="token punctuation">;</span>            second <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>first <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>            first <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏04</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F04/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏04/</id>
    <published>2020-05-28T06:48:37.000Z</published>
    <updated>2020-05-29T14:44:43.377Z</updated>
    
    <content type="html"><![CDATA[<p>继续我的复习刷题</p><h1 id="接口方法可以使用abstract修饰">1 接口方法可以使用abstract修饰</h1><p>问题：</p><p>java接口的方法修饰符可以为？(忽略内部接口)</p><p>A. private<br>B. protected<br>C. final<br>D. abstract  </p><p>正确答案: D   你的答案: D (正确)</p><hr><p>虽然说接口中的方法都是抽象的，平时不写abstract，但是是可以使用abstract修饰的，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TestInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码没有任何问题，但Idea会好心提示：<code>Modifier &#39;abstract&#39; is redundant for interface methods</code>（即这个修饰符是多余的）</p><h1 id="lt-init-gt-方法是怎么组成的">2 &lt;init&gt;方法是怎么组成的</h1><p>问题：</p><p>在创建派生类对象，构造函数的执行顺序（）</p><p>A. 基类构造函数，派生类对象成员构造函数，派生类本身的构造函数<br>B. 派生类本身的构造函数，基类构造函数，对象成员构造函数<br>C. 基类构造函数，派生类本身的构造函数，派生类对象成员构造函数<br>D. 对象成员构造函数，基类构造函数，派生类本身的构造函数  </p><p>正确答案: A   你的答案: C (错误)</p><hr><p>这道题我不太理解所谓的<code>对象成员构造函数</code>是什么，后面想了一下应该是指如果成员字段是一个对象的话，调用的构造函数吧。</p><p>那么这其实就涉及<code>&lt;init&gt;</code>这个方法的知识点了。</p><p><code>&lt;cinit&gt;</code>这个方法的组成特别好记：就是静态字段赋值和静态代码块从上到下连接构成的。</p><p>然而<code>&lt;init&gt;</code>这个方法呢？</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 成员字段的类别</span><span class="token keyword">class</span> <span class="token class-name">ChildrenClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ChildrenClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成员字段的赋值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BaseClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">BaseClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类的非静态域"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConstructor2</span> <span class="token keyword">extends</span> <span class="token class-name">BaseClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">TestConstructor2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自身的构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自身的非静态域"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ChildrenClass childrenClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChildrenClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TestConstructor2 constructor2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestConstructor2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先看一下这段代码，输出是什么？</p><pre><code>父类的非静态域父类的构造函数自身的非静态域成员字段的赋值自身的构造函数</code></pre><p>再看一下字节码：</p><pre><code>---------调用父类的init方法------------- 0 aload_0 1 invokespecial #1 &lt;com/rhett/javafoundation/BaseClass.&lt;init&gt;&gt;---------非静态域方法------------------ 4 getstatic #2 &lt;java/lang/System.out&gt; 7 ldc #3 &lt;自身的非静态域&gt; 9 invokevirtual #4 &lt;java/io/PrintStream.println&gt;---------成员字段的赋值-----------------12 aload_013 new #5 &lt;com/rhett/javafoundation/ChildrenClass&gt;16 dup17 invokespecial #6 &lt;com/rhett/javafoundation/ChildrenClass.&lt;init&gt;&gt;20 putfield #7 &lt;com/rhett/javafoundation/TestConstructor2.childrenClass&gt;---------自身的构造函数-----------------23 getstatic #2 &lt;java/lang/System.out&gt;26 ldc #8 &lt;自身的构造函数&gt;28 invokevirtual #4 &lt;java/io/PrintStream.println&gt;31 return</code></pre><p>可以看到，顺序是这样的：</p><ol><li>调用父类的<init>方法</init></li><li>非静态域方法+成员字段的赋值（经实测，这两个的顺序就是代码中书写的顺序从上到下构成的）</li><li>自身的构造函数</li></ol><h1 id="字符串相加会触发从字符串常量池中取值吗">3 字符串相加会触发从字符串常量池中取值吗</h1><p>题目：</p><p>有以下代码片段：</p><pre class=" language-java"><code class="language-java">String str1<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>String str2<span class="token operator">=</span><span class="token string">"he"</span><span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"llo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>请问输出的结果是：</p><p>A. true<br>B. 都不对<br>C. null<br>D. false  </p><p>正确答案: D   你的答案: A (错误)</p><hr><p>字符串字面量的机制，我已经在<a href="../String-s-new-String-123-创建了几个String对象？">String s = new String(“123”);创建了几个String对象？</a>中谈过了，然而这道题目我还是选错了，主要是没有认真思考，像这样的字符串加法，是不存在编译时优化的，<strong>内部机制还是通过使用StringBuilder去实现的字符串拼接，最终结果和字符串常量池中的对象肯定是不同的。</strong></p><p>那什么情况下会出现编译时优化呢？就是修改为下面这段代码：</p><pre class=" language-java"><code class="language-java">String str1<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>String str2<span class="token operator">=</span><span class="token string">"he"</span><span class="token operator">+</span><span class="token string">"llo"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>就会输出为true了。</p><h1 id="Java的自动转型规则">4 Java的自动转型规则</h1><p>题目：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span> b1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b2<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b3<span class="token punctuation">,</span>b6<span class="token punctuation">,</span>b8<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">byte</span> b4<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>b5<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>b7<span class="token punctuation">;</span>b3<span class="token operator">=</span><span class="token punctuation">(</span>b1<span class="token operator">+</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*语句1*/</span>b6<span class="token operator">=</span>b4<span class="token operator">+</span>b5<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*语句2*/</span>b8<span class="token operator">=</span><span class="token punctuation">(</span>b1<span class="token operator">+</span>b4<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*语句3*/</span>b7<span class="token operator">=</span><span class="token punctuation">(</span>b2<span class="token operator">+</span>b5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*语句4*/</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b3<span class="token operator">+</span>b6<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下列代码片段中，存在编译错误的语句是()</p><p>A. 语句2<br>B. 语句1<br>C. 语句3<br>D. 语句4</p><p>正确答案: B C D   你的答案: D (错误)</p><hr><p>这道题涉及一个知识点，我之前确实不知道：（来自牛客网用户：Pandora）</p><p>Java表达式转型规则由低到高转换：</p><ol><li><strong>所有的byte,short,char型的值将被提升为int型</strong>；</li><li>如果有一个操作数是long型，计算结果是long型；</li><li>如果有一个操作数是float型，计算结果是float型；</li><li>如果有一个操作数是double型，计算结果是double型；</li><li><strong>被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化</strong>。</li></ol><p>第一点这个规则大概是因为没有对应的字节码操作指令，但我确实不知道会自动转为int。</p><p>因此：</p><ul><li>语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；</li><li>语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；</li><li>语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);</li><li>语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续我的复习刷题&lt;/p&gt;
&lt;h1 id=&quot;接口方法可以使用abstract修饰&quot;&gt;1 接口方法可以使用abstract修饰&lt;/h1&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;java接口的方法修饰符可以为？(忽略内部接口)&lt;/p&gt;
&lt;p&gt;A. private&lt;br&gt;B. protecte
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode443-压缩字符串</title>
    <link href="https://www.codetool.top/article/leetcode443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/leetcode443-压缩字符串/</id>
    <published>2020-05-28T02:56:31.000Z</published>
    <updated>2020-05-28T03:08:54.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一组字符，使用原地算法将其压缩。</p><p>压缩后的长度必须始终小于或等于原数组长度。</p><p>数组的每个元素应该是长度为1 的<strong>字符</strong>（不是 int 整数类型）。</p><p>在完成原地<strong>修改输入数组</strong>后，返回数组的新长度。</p><p><strong>进阶：</strong><br>你能否仅使用O(1) 空间解决问题？</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>["a","a","b","b","c","c","c"]<strong>输出：</strong>返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]<strong>说明：</strong>"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>["a"]<strong>输出：</strong>返回1，输入数组的前1个字符应该是：["a"]<strong>说明：</strong>没有任何字符串被替代。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>["a","b","b","b","b","b","b","b","b","b","b","b","b"]<strong>输出：</strong>返回4，输入数组的前4个字符应该是：["a","b","1","2"]。<strong>说明：</strong>由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。注意每个数字在数组中都有它自己的位置。</pre><p><strong>注意：</strong></p><ol><li>所有字符都有一个ASCII值在<code>[35, 126]</code>区间内。</li><li><code>1 &lt;= len(chars) &lt;= 1000</code>。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>看到这种原地修改字符串，且修改后的字符串比原来要短的题目，基本就是双指针</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compress</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            p2<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">==</span> chars<span class="token punctuation">.</span>length <span class="token operator">||</span> chars<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token operator">!=</span>chars<span class="token punctuation">[</span>p2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                chars<span class="token punctuation">[</span><span class="token operator">++</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>p2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                String num <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        chars<span class="token punctuation">[</span><span class="token operator">++</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一组字符，使用原地算法将其压缩。&lt;/p&gt;
&lt;p&gt;压缩后的长度必须始终小于或等于原数组长度。&lt;/p&gt;
&lt;p&gt;数组的每个元素应该是长度为1 的&lt;strong&gt;字符&lt;/strong&gt;（不是 int 整数类型）。&lt;/p&gt;
&lt;p&gt;在完成原
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏03（附赠哈夫曼树&amp;哈夫曼编码）</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F03/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏03/</id>
    <published>2020-05-27T13:43:13.000Z</published>
    <updated>2020-05-29T14:44:57.981Z</updated>
    
    <content type="html"><![CDATA[<p>继续我的复习刷题</p><h1 id="构造器显式调用父类构造方法的规则">1 构造器显式调用父类构造方法的规则</h1><p>题目：</p><p>以下程序的输出结果为</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Derived</span> <span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Derived</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>A. BD<br>B. DB<br>C. C<br>D. 编译错误   </p><p>正确答案: D   你的答案: A (错误)</p><hr><p>这道题其实没什么特别的，就是之前对这个规则不熟悉：</p><p>在子类的构造方法中，必须调用父类的构造方法，如果没有显示地调用，编译器会在第一行添加一个父类的无参构造方法，但是如果父类重载了构造方法导致没有无参的构造方法，子类就必须在构造方法中显示地调用父类的构造方法，否则就会报错。</p><h1 id="IO流分为节点流和处理流">2 IO流分为节点流和处理流</h1><p>题目：</p><p>下列流当中，属于处理流的是：（）     </p><p>A. FileInputStream<br>B. InputStream<br>C. DataInputStream<br>D. BufferedInputStream</p><p>正确答案: C D   你的答案: A C (错误)</p><hr><p>这道题选错是不知道节点流和处理流是什么。原来IO流可以这样分类：（来自牛客网用户：无情的AC机器）</p><p><strong>按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。</strong></p><ul><li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li><li>处理流：<strong>是对一个已存在的流的连接和封装</strong>，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul><p>JAVA常用的节点流：</p><ul><li>文 件 <code>FileInputStream</code>、<code>FileOutputStrean</code>、<code>FileReader</code>、<code>FileWriter</code>。文件进行处理的节点流。</li><li>字符串 <code>StringReader</code>、<code>StringWriter</code>。对字符串进行处理的节点流。</li><li>数 组：<code>ByteArrayInputStream</code>、<code>ByteArrayOutputStreamCharArrayReader</code>、<code>CharArrayWriter</code>。对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li><li>管 道：<code>PipedInputStream</code>、<code>PipedOutputStream</code>、<code>PipedReaderPipedWriter</code>。对管道进行处理的节点流。</li></ul><p>常用处理流（关闭处理流使用关闭里面的节点流）</p><ul><li>缓冲流：<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code>。增加缓冲功能，避免频繁读写硬盘。</li><li>转换流：<code>InputStreamReader</code>、<code>OutputStreamReader</code>。实现字节流和字符流之间的转换。</li><li>数据流：<code>DataInputStream</code>、<code>DataOutputStream</code>等。提供<strong>将基础数据类型写入到文件中，或者读取出来</strong>.</li></ul><h1 id="如何通过反射获取和设置对象私有字段的值">3 如何通过反射获取和设置对象私有字段的值</h1><p>这个倒不是刷题刷出来的，就是整理知识点的时候对这个API有点不太熟练，这里复习一下：</p><p><img src="https://api.codetool.top/img/15905882124003.png" alt></p><p>我相信这个思维导图已经概括得很详细了（这只是我复习中整理的一小部分，等我把整个java体系复习完了把整个思维导图分享出来）</p><p>下面上代码说明：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Security</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestReflect</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Security security <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Security</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取字段</span>        Field num <span class="token operator">=</span> security<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置访问权限</span>        num<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修改值</span>        num<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>security<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method getNum <span class="token operator">=</span> security<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"getNum"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        getNum<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object invoke <span class="token operator">=</span> getNum<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>security<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>invoke<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码中还有一个知识点：<code>getNum</code>方法返回的是基本类型int，但<strong>invoke只能返回一个Object对象，它会自动把int类型装箱，即变成Integer类型返回</strong>，因此是可以输出的。</p><h1 id="哈夫曼树-amp-哈夫曼编码">4 哈夫曼树&amp;哈夫曼编码</h1><p>哈哈越扯越偏了，这里顺便放一个数据结构的知识点上来，这个不太想单独写一篇博客。</p><p>哈夫曼树，就是使<strong>带权外部路径长度最小</strong>（课本上这样说的）的一种二叉树。</p><p>至于如何计算这个带权外部路径：</p><ol><li>所有外部节点（叶子节点）带有一个权值</li><li><strong>每个外部节点乘以其到根节点的路径长之和</strong>，就是该树的带权外部路径长度。</li></ol><p>如何构造一个哈夫曼树：</p><ol><li>将所有外部节点按权值大小从小到大排序，组成一个有序链表</li><li>取出前两个节点，将它们的值相加，得到一个新的权值，用它构造一个新的节点，同时是这两个节点的父节点，然后把这个新的节点按值的大小插入链表中</li><li>重复第二步，直到组成一棵树</li></ol><p>我不太想画图，累了0v0（复习哪有时间认真写博客）</p><p>注意哈夫曼树是一种满二叉树（满二叉树这个定义有争议，我这里的定义就是除了叶子节点所有的节点的度都为2），即不包含度为1的节点。</p><p>然后哈夫曼树有一个应用就是哈夫曼编码，左边的出度取0，右边的出度取1。从根节点到叶子节点路径上的0、1值组成的就是哈夫曼编码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续我的复习刷题&lt;/p&gt;
&lt;h1 id=&quot;构造器显式调用父类构造方法的规则&quot;&gt;1 构造器显式调用父类构造方法的规则&lt;/h1&gt;&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;以下程序的输出结果为&lt;/p&gt;
&lt;pre class=&quot; language-java&quot;&gt;&lt;code class=&quot;langu
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode974-和可被K整除的子数组</title>
    <link href="https://www.codetool.top/article/leetcode974-%E5%92%8C%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode974-和可被K整除的子数组/</id>
    <published>2020-05-27T03:53:22.000Z</published>
    <updated>2020-05-27T03:55:15.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p><p><strong>示例:</strong>  </p><blockquote><p><strong>输入：</strong> A = [4,5,0,-2,-3,1], K = 5<br><strong>输出：</strong> 7<br><strong>解释：</strong><br>有 7 个子数组满足其元素之和可被 K = 5 整除：<br>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>2 &lt;= K &lt;= 10000</code></li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>看到连续的子数组的和就要想到前缀和</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraysDivByK</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> remainder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">;</span>        remainder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> remain <span class="token operator">=</span> sum<span class="token operator">%</span>K<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>remain<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> remain <span class="token operator">+=</span> K<span class="token punctuation">;</span>            count <span class="token operator">+=</span> remainder<span class="token punctuation">[</span>remain<span class="token punctuation">]</span><span class="token punctuation">;</span>            remainder<span class="token punctuation">[</span>remain<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;A&lt;/code&gt;，返回其中元素之和可被 &lt;code&gt;K&lt;/code&gt; 整除的（连续、非空）子数组的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM常用参数整理</title>
    <link href="https://www.codetool.top/article/JVM%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <id>https://www.codetool.top/article/JVM常用参数整理/</id>
    <published>2020-05-26T14:12:43.000Z</published>
    <updated>2020-05-29T14:23:09.955Z</updated>
    
    <content type="html"><![CDATA[<p>这里不保证完全准确，可以到官方文档上面去验证：</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><h1 id="GC常用参数">1 GC常用参数</h1><ul><li><code>-Xmn</code>：年轻代大小</li><li><code>-Xms</code>：初始堆大小</li><li><code>-Xmx</code>：最大堆大小</li><li><code>-Xss</code>：每个线程的栈大小</li><li><code>-XX:+UseTLAB</code>：使用TLAB，默认打开</li><li><code>-XX:+PrintTLAB</code>：打印TLAB的使用情况</li><li><code>-XX:+TLABSize</code>：设置TLAB大小</li><li><code>-XX:+DisableExplictGC</code>：禁用显式的垃圾回收，即<code>System.gc()</code></li><li><code>-XX:+PrintGC</code>：打印GC信息</li><li><code>-XX:+PrintGCDetails</code>：GC详细信息</li><li><code>-XX:+PrintHeapAtGC</code>：GC打印堆栈情况</li><li><code>-XX:+PrintGCTimeStamps</code>：发生GC系统的时间</li><li><code>-XX:+PrintGCApplicationConcurrentTime</code>：打印自上次GC暂停以来经过的时间</li><li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印GC的暂停时长</li><li><code>-XX:+PrintReferenceGC</code>：记录回收了多少种不同引用类型的引用</li><li><code>-verbose:class</code>：类加载详细过程</li><li><code>-XX:+PrintVMOptions</code>：打印JVM的参数</li><li><code>-XX:+PrintFlagsFinal</code>/<code>-XX:+PrintFlagsInitial</code>：打印最终的/初始化默认的参数</li><li><code>-Xloggc:opt/log/gc.log</code></li><li><code>-XX:MaxTenuringThreshold</code>：新生代晋升年龄,最大值15</li><li>锁自旋次数 <code>-XX:PreBlockSpin</code> 热点代码检测参数 <code>-XX:CompileThreshold</code> 逃逸分析 标量替换…这些不建议设置</li></ul><h1 id="Parallel常用参数">2 Parallel常用参数</h1><ul><li><code>-XX:SurvivorRatio</code>：新生代Eden:Survivor1:Survivor2的比例，默认<code>8:1:1</code></li><li><code>-XX:PreTenureSizeThreshold</code>：多大对象直接放入老年代</li><li><code>-XX:MaxTenuringThreshold</code>：新生代晋升年龄,最大值15</li><li><code>-XX:+ParallelGCThreads</code>：并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：自适应Eden:Survivor1:Survivor2大小比例</li></ul><h1 id="CMS常用参数">3 CMS常用参数</h1><ul><li><code>-XX:+UseConcMarkSweepGC</code>：启用CMS</li><li><code>-XX:ParallelCMSThreads</code>：CMS线程数量</li><li><code>-XX:CMSInitiatingOccupancyFraction</code>：使用多少比例的老年代后开始CMS收集，默认是92%</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>：在FGC时进行压缩，会导致回收耗时变长</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>：多少次FGC之后进行压缩</li><li><code>-XX:+CMSClassUnloadingEnabled</code>：永久代相关，1.8之前的</li><li><code>-XX:CMSInitiatingPermOccupancyFraction</code>：永久代相关，1.8之前的</li><li><code>-XX:GCTimeRatio</code>：建议GC时间占用程序运行时间的百分比</li><li><code>-XX:MaxGCPauseMillis</code>：期望的垃圾回收停顿时间</li></ul><h1 id="G1常用参数">4 G1常用参数</h1><ul><li><code>-XX:+UseG1GC</code>：启用G1</li><li><code>-XX:MaxGCPauseMillis</code>：建议GC停顿的最大事件，G1会尝试调整Young区的块数来达到这个值</li><li><code>-XX:GCPauseIntervalMillis</code>：GC的间隔时间</li><li><code>-XX:+G1HeapRegionSize</code>：设置Region分区大小，随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长，ZGC做了改进（动态区块大小）</li><li><code>-XX:G1NewSizePercent</code>：新生代最小比例，默认为5%</li><li><code>-XX:G1MaxNewSizePercent</code>：新生代最大比例，默认为60%</li><li><code>-XX:GCTimeRatio</code>：建议GC时间占用程序运行时间的百分比</li><li><code>-XX:ConcGCThreads</code>：用于清理的并发线程数量</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>：启动G1的堆空间占用比例</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里不保证完全准确，可以到官方文档上面去验证：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode80-删除排序数组中的重复项II</title>
    <link href="https://www.codetool.top/article/leetcode80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/"/>
    <id>https://www.codetool.top/article/leetcode80-删除排序数组中的重复项II/</id>
    <published>2020-05-26T06:01:39.000Z</published>
    <updated>2020-05-26T06:06:48.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地<strong>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre>给定 <em>nums</em> = <strong>[1,1,1,2,2,3]</strong>,函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong> <strong>3 </strong>。你不需要考虑数组中超出新长度后面的元素。</pre><p><strong>示例 2:</strong></p><pre>给定 <em>nums</em> = <strong>[0,0,1,1,1,1,2,3,3]</strong>,函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前五个元素被修改为&nbsp;<strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, <strong>3 。</strong>你不需要考虑数组中超出新长度后面的元素。</pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“<strong>引用</strong>”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。for (int i = 0; i &lt; len; i++) {&nbsp; &nbsp; print(nums[i]);}</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>和<a href="../leetcode26-删除排序数组中的重复项">leetcode26-删除排序数组中的重复项</a>类似，这里也使用双指针，但是添加一个变量用于计数。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果遇到了新的字符，计数清零</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果计数小于二，将后面那个指针指向的值赋给前面那个指针指向的值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地&lt;strong&gt;修改输入数组&lt;/strong&gt;并在使用 O(1) 额外空间的条件
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏02</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F02/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏02/</id>
    <published>2020-05-25T13:38:14.000Z</published>
    <updated>2020-05-29T14:45:27.251Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈我其实没有想到这个系列真会有续集，上次写完01以后以为不会再写下去了，没想到最近牛客网刷题有些题目还是挺纠结的，这里补一补</p><h1 id="构造器能带哪些修饰符">1 构造器能带哪些修饰符</h1><p>题目：</p><p>Which of the following can be applied to constructors:</p><p>A. final<br>B. static<br>C. synchronized<br>D. native<br>E. None of these.  </p><p>正确答案: E   你的答案: C (错误)</p><hr><p>我选的时候觉得A C有可能，然后因为是单选选了C。</p><p>经测试，类构造器不能带以上任何一个修饰符，如果要声明为最终类，直接在类上修饰为final的就行了。</p><p>而synchronized，我一开始以为因为方法上的<code>synchronized</code>默认锁住的是this对象，而还没构造的对象可能不能锁，但后来发现并不是这个原因，起码下面这段代码是能运行的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConstructor</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TestConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            name <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TestConstructor testConstructor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testConstructor<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>并且通过调试发现在进入<code>synchronized</code>代码块之前对象已经创建出来，只是还没有对name赋值。所以可能就是硬不可以吧。</p><h1 id="关于整数和字符串相加的问题">2 关于整数和字符串相加的问题</h1><p>题目：</p><p>如果int x=20, y=5，则语句System.out.println(x+y +””+(x+y)+y);  的输出结果是（）</p><p>A. 2530<br>B. 55<br>C. 2052055<br>D. 25255  </p><p>正确答案: D   你的答案: D (正确)</p><hr><p>这道题虽然选对了，但是是根据排除法做出来的，因为空字符串后面那部分<code>(x+y)+y</code>必是<code>255</code>，但是空字符串前面的那个<code>x+y</code>我不确定是<code>25</code>还是<code>205</code>。</p><p>经测试，运行结果是25255，那就说明在遇到字符串之前还是做正常的整数加法，而遇到字符串之后都是做字符串拼接。如果思考一下原因，也很好解释，大概就是因为加法是单步执行的（JVM字节码执行的时候一条指令最多操作两个操作数栈中的操作数），那么遇到字符串之前，都不知道后面会有字符串，也就会做正常的整数加法了。</p><h1 id="重载静态多分派">3 重载静态多分派</h1><p>题目：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> collections <span class="token operator">=</span>                <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Super subToSuper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection <span class="token operator">:</span> collections<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subToSuper<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:collection"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:list"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getType</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:arrayList"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:set"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getType</span><span class="token punctuation">(</span>HashSet<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Super:hashSet"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getType</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 我猜这一行应该是想返回"Sub:collection"</span>            <span class="token keyword">return</span> <span class="token string">"Sub"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>A.<br>Sub:collection<br>Sub:collection<br>Sub:collection  </p><p>B.<br>Sub:hashSet<br>Sub:arrayList<br>Sub:collection  </p><p>C.<br>Super:collection<br>Super:collection<br>Super:collection   </p><p>D.<br>Super:hashSet<br>Super:arrayList<br>Super:collection </p><p>正确答案: C   你的答案: A (错误)</p><hr><p>这道题目做错了真的不怪我啊，牛客网上的排版太乱了，代码又长，很难读完的。</p><p>这道题目其实涉及多个知识点：</p><p>首先它是通过了一个实例对象去调用静态方法，注意两个类中的方法都是静态的，而静态方法是不会被覆写的。</p><p>然后下面这部分代码，要确定到底调用的是哪个类中的getType方法：</p><pre class=" language-java"><code class="language-java">Super subToSuper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> collection <span class="token operator">:</span> collections<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subToSuper<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一行就属于静态分派，new了一个<code>Sub</code>对象，但将其声明为<code>Super</code>类型的引用，这就属于编译期间确定好的类型，也称为“静态分派”。那么可以确定，后面调用的<code>getType</code>方法，实际上是调用了<code>Super</code>类型的静态方法，但到底是哪个重载版本呢？</p><p>其实后面这个也是静态分派，因为第二行代码中<code>Collection&lt;?&gt; collection : collections</code>也显式地将从集合中取出来的对象声明为了<code>Collection</code>类型的引用，所以调用的重载方法版本就是参数为Collection类型的。</p><h1 id="布尔型居然可以用位运算？">4 布尔型居然可以用位运算？</h1><p>我一直以为布尔型位运算只存在于C语言这种语言中，直到我遇见了这道题：</p><p>题目：</p><p>根据下面的代码，<br>String s = null;<br>会抛出NullPointerException异常的有（）。</p><p>A. if( (s!=null) &amp; (s.length()&gt;0) )<br>B. if( (s!=null) &amp;&amp; (s.length()&gt;0) )<br>C. if( (s==null) | (s.length()==0) )<br>D. if( (s==null) || (s.length()==0) )  </p><p>正确答案: A C   你的答案: A C (正确)</p><hr><p>虽然我是选对了，因为我知道根据短路原则BD必不可能嘛，但是我还真不知道布尔型可以用位运算。</p><p>然后我就试了一下这些代码：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">&amp;</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">&amp;</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">|</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">|</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token operator">|</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>发现都是可以正常执行的，并且输出依次为：</p><pre><code>truefalsefalsetruetruefalse</code></pre><p>可见和逻辑运算的结果并没有差别，那么true和false底层是通过1和0来表示吗？我在网上搜了一下，有一个人是这么说的：</p><blockquote><p>JVM虚拟机规格标准第二版规定：字节码形态的boolean的false和true，是用int(32bit整型)的0和1表示</p></blockquote><p>那么就假定这是正确的，但通过实验，布尔类型不能和整型互转，也不能参与整型的运算。不是很明白JVM这样设计的用意。</p><p>那么谈到这里，和题目一比较，大概就知道了，这样的位运算符运用在布尔类型上和逻辑运算符的区别就是没有短路原则，可以做个实验验证一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token operator">|</span><span class="token function">returnFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">returnFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>写一段这样的代码，经过调试发现，会执行到<code>returnFalse</code>这个方法中去。所以说是没有短路原则的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哈哈我其实没有想到这个系列真会有续集，上次写完01以后以为不会再写下去了，没想到最近牛客网刷题有些题目还是挺纠结的，这里补一补&lt;/p&gt;
&lt;h1 id=&quot;构造器能带哪些修饰符&quot;&gt;1 构造器能带哪些修饰符&lt;/h1&gt;&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;Which of the follo
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
