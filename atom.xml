<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-23T19:12:16.370Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode84-柱状图中最大的矩形</title>
    <link href="https://www.codetool.top/article/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode84-柱状图中最大的矩形/</id>
    <published>2020-01-23T19:01:50.000Z</published>
    <updated>2020-01-23T19:12:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://api.codetool.top/img/15798062014581.png" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://api.codetool.top/img/15798062338069.png" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [2,1,5,6,2,3]<br><strong>输出：</strong> 10</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode42-接雨水/">leetcode42-接雨水</a>较为相似。</p><p>对于每列来说，以当前列高为高的最大矩形区域的宽度区域为被左边最近较矮一列和右边最近较矮一列围起来的宽度。</p><p>如果两边有一边没有比当前列矮的一列，则左边算作-1，右边算作length。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.to
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记09</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B009/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记09/</id>
    <published>2020-01-23T13:14:13.000Z</published>
    <updated>2020-01-23T17:22:36.645Z</updated>
    
    <content type="html"><![CDATA[<p>续<a href="../深入理解java虚拟机第三版读书笔记08">深入理解java虚拟机第三版读书笔记08</a></p><h1 id="类加载器">1 类加载器</h1><p><strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>称为类加载器。类加载器可以用户自定义，是java语言流行的一项原因</p><h2 id="类与类加载器">1.1 类与类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>或者说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><h2 id="双亲委派模型">1.2 双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap<br>ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p><p>自JDK 1.2以来，Java一直保持着<strong>三层类加载器、双亲委派的类加载架构。</strong></p><p>对于JDK8及之前版本的Java，绝大多数程序都会使用到以下3个系统提供的类加载器来进行加载</p><ul><li>启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在 <code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</li><li>扩展类加载器（Extension Class Loader）：这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application Class Loader）：这个类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是<strong>程序中默认的类加载器</strong>。</li></ul><p><img src="https://api.codetool.top/img/15797991285820.png" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。（子加载器将部分动作委派给父加载器）</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有<strong>当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><p>好处是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类<code>java.lang.Object</code>都是交给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>实现双亲委派模型的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，检查请求的类是否已经被加载过了</span>    Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>            <span class="token comment" spellcheck="true">// 说明父类加载器无法完成加载请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时</span>            <span class="token comment" spellcheck="true">// 再调用本身的findClass方法来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;续&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记08&quot;&gt;深入理解java虚拟机第三版读书笔记08&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;类加载器&quot;&gt;1 类加载器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;通过一个类的全限定名来获取描述该类的二进制字节流&lt;/strong&gt;称为类加
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码实例探究</title>
    <link href="https://www.codetool.top/article/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.codetool.top/article/Java字节码实例探究/</id>
    <published>2020-01-23T10:22:05.000Z</published>
    <updated>2020-01-23T13:11:56.515Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a>中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。</p><p>java源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">40000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个类有方法有实例变量有静态变量，在JDK8环境下编译后的字节码开头部分如下图：</p><p><img src="https://api.codetool.top/img/15797791725139.png" alt="该文件开头部分"></p><p>我们来逐字节分析：</p><h1 id="魔数、次版本号、主版本号">1 魔数、次版本号、主版本号</h1><p>00~03：<code>CA FE BA BE</code>，魔数。</p><p>04~05：<code>00 00</code> Minor Version，次版本号<br>06~07：<code>00 34</code> 十进制52，Major Version，主版本号，两者对应JDK8</p><h1 id="常量池">2 常量池</h1><p>08~09：<code>00 2F</code> 十进制47，代表常量池内项的数量。</p><p>10开始为常量池中的各表：</p><p><strong>#1</strong><br>0A：<code>0A</code> 十进制10，代表<code>CONSTANT_Methodref_info</code>类型，<br>0B~0E：<code>00 0A 00 1E</code> #10，#30</p><p><strong>#2</strong><br>0F：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>10~13：<code>00 09 00 1F</code> #9，#31</p><p><strong>#3</strong><br>14：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>15~18：<code>00 20 00 21</code> #32，#33</p><p><strong>#4</strong><br>19：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>1A~1D：<code>00 09 00 22</code> #9，#34</p><p><strong>#5</strong><br>1E：<code>0A</code> 十进制9，代表<code>CONSTANT_Methodref_info</code>类型，<br>1F~22：<code>00 23 00 24</code> #35，#36</p><p><strong>#6</strong><br>1E：<code>03</code> 十进制3，代表<code>CONSTANT_Integer_info</code>类型，<br>15~18：<code>00 00 9C 40</code> 40000</p><p><strong>#7</strong><br>28：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>29~2C：<code>00 09 00 25</code> #9，#37</p><p><strong>#8</strong><br>2D：<code>08</code> 十进制8，代表<code>CONSTANT_String_info</code>类型，<br>2E~2F：<code>00 26</code> #38</p><p><strong>#9</strong><br>30：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>31~32：<code>00 27</code> #39</p><p><strong>#10</strong><br>33：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>34~35：<code>00 28</code> #40</p><p><strong>#11</strong><br>36：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>37~38：<code>00 01</code>代表长度为1，39：<code>69</code> 代表字符<code>&#39;i&#39;</code></p><p><strong>#12</strong><br>3A：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>3B~3C：<code>00 01</code>代表长度为1，3D：<code>49</code> 代表字符<code>&#39;I&#39;</code></p><p>剩余常量池的项我们用javap得到（其实累了）：</p><pre><code>#13 = Utf8               j#14 = Utf8               str#15 = Utf8               Ljava/lang/String;#16 = Utf8               &lt;init&gt;#17 = Utf8               ()V#18 = Utf8               Code#19 = Utf8               LineNumberTable#20 = Utf8               LocalVariableTable#21 = Utf8               this#22 = Utf8               LMain;#23 = Utf8               main#24 = Utf8               ([Ljava/lang/String;)V#25 = Utf8               args#26 = Utf8               [Ljava/lang/String;#27 = Utf8               &lt;clinit&gt;#28 = Utf8               SourceFile#29 = Utf8               Main.java#30 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V#31 = NameAndType        #11:#12        // i:I#32 = Class              #41            // java/lang/System#33 = NameAndType        #42:#43        // out:Ljava/io/PrintStream;#34 = NameAndType        #14:#15        // str:Ljava/lang/String;#35 = Class              #44            // java/io/PrintStream#36 = NameAndType        #45:#46        // println:(Ljava/lang/String;)V#37 = NameAndType        #13:#12        // j:I#38 = Utf8               Hello World!#39 = Utf8               Main#40 = Utf8               java/lang/Object#41 = Utf8               java/lang/System#42 = Utf8               out#43 = Utf8               Ljava/io/PrintStream;#44 = Utf8               java/io/PrintStream#45 = Utf8               println#46 = Utf8               (Ljava/lang/String;)V</code></pre><h1 id="访问标志、类索引、父类索引、接口索引集合">3 访问标志、类索引、父类索引、接口索引集合</h1><p>跳过常量池，到了<strong>访问标志：</strong></p><p>01C1~01C2：<code>00 21</code>，代表<code>ACC_SUPER</code>（0x0020）和<code>ACC_PUBLIC</code>（0x0001）。</p><p>接着是<strong>类索引：</strong></p><p>01C3~01C4：<code>00 09</code> 代表常量池中#9，#9又指向#39，可以得知是Main，即类名</p><p><strong>父类索引：</strong></p><p>01C5~01C6：<code>00 0A</code> 代表常量池中#10，#10又指向#40，可以得知是<code>java/lang/Object</code></p><p><strong>接口索引集合：</strong></p><p>01C7~01D8：<code>00 00</code> 代表接口索引集合中没有数据，长度是0</p><h1 id="字段表集合">4 字段表集合</h1><p>01C9~01CA: <code>00 03</code> 十进制3，代表字段表中有三项数据：</p><p>第一个字段：</p><p>01CB~01CC: <code>00 02</code> ，访问标志，代表<code>ACC_PRIVATE</code>（0x0002）<br>01CD~01CE：<code>00 0B</code> ，name_index，指向常量池#11，#11代表<code>&#39;i&#39;</code><br>01CF~01D0：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D1~01D2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第二个字段：</p><p>01D3~01D4: <code>00 0A</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PRIVATE</code>（0x0002）<br>01D5~01D6：<code>00 0D</code> ，name_index，指向常量池#13，#13代表<code>&#39;j&#39;</code><br>01D7~01D8：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D9~01DA：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第三个字段：</p><p>01DB~01DC: <code>00 09</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PUBLIC</code>（0x0001）<br>01DD~01DE：<code>00 0E</code> ，name_index，指向常量池#14，#14代表<code>&quot;str&quot;</code><br>01DF~01E0：<code>00 0F</code> , discriptor_index，指向常量池#15，#15代表<code>&quot;Ljava/lang/String;&quot;</code>（即String类型）<br>01E1~01E2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><h1 id="方法表集合">5 方法表集合</h1><p>01E3~01E4：<code>00 03</code> ，十进制3，代表方法表中有三项数据：</p><p><strong>第一个方法：</strong></p><p>01E5~01E6: <code>00 01</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）<br>01E7~01E8：<code>00 10</code> ，name_index，指向常量池#16，#16代表<code>&quot;&lt;init&gt;&quot;</code>（即对象构造器）<br>01E9~01EA：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参、无返回值）<br>01EB~01EC：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>01ED~01EE: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>01EF~01F2：<code>00 00 00 39</code>，代表Code内容长度为57个字节。</p><p>接下来57个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>01F3~022B</p><pre><code>Code:stack=2, locals=1, args_size=1    0: aload_0    1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V    4: aload_0    5: bipush        10    7: putfield      #2                  // Field i:I    10: returnLineNumberTable:    line 7: 0    line 8: 4LocalVariableTable:    Start  Length   Slot    Name    Signature    0      11       0       this    LMain;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>aload_0      </p></blockquote><p>将局部变量表slot 0加载到操作数栈，那么局部变量表slot 0原来存放的是什么呢？非静态方法局部变量表0位置一开始都是存放的this，即调用方法的当前对象。这句话就是把this入操作数栈。</p><blockquote><p>invokespecial #1</p></blockquote><p>this调用#1代表的方法，我们查常量表#1，#1又指向#10和#30，#10指向#40，是<code>java/lang/Object</code>，#30是<code>&quot;&lt;init&gt;&quot;:()V</code>，即调用父类Object的构造方法。</p><blockquote><p>aload_0</p></blockquote><p>再次加载this</p><blockquote><p>bipush 10</p></blockquote><p>将常量10压入操作数栈。</p><blockquote><p>putfield #2</p></blockquote><p>putfield是设置对象的字段值，通过查常量表，#2代表<code>Main</code>中的<code>i:I</code>，这句话就把栈里的两个操作数：<code>10</code>设置给<code>this.i</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第二个方法：</strong></p><p>022C~022D: <code>00 09</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）和<code>ACC_STATIC</code>（0x0008）<br>022E~022F：<code>00 17</code> ，name_index，指向常量池#23，#23代表<code>&quot;main&quot;</code><br>0230~0231：<code>00 18</code> , discriptor_index，指向常量池#24，#24代表<code>&quot;([Ljava/lang/String;)V&quot;</code>（即参数为String数组、无返回值）<br>0232~0233：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>0234~0235: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>0236~0239：<code>00 00 00 38</code>，代表Code内容长度为56个字节。</p><p>接下来56个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>023A~0271</p><pre><code>Code:stack=2, locals=1, args_size=1    0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;    3: getstatic     #4                  // Field str:Ljava/lang/String;    6: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V    9: returnLineNumberTable:    line 12: 0    line 13: 9LocalVariableTable:    Start  Length  Slot  Name   Signature        0      10     0  args   [Ljava/lang/String;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>getstatic #3      </p></blockquote><p>获取一个类的静态字段，通过查常量表可知#3是<code>java/lang/System</code>的<code>out:Ljava/io/PrintStream;</code>即获取<code>System.out</code></p><blockquote><p>getstatic #4</p></blockquote><p>获取一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>即获取str字段。</p><blockquote><p>invokevirtual #5</p></blockquote><p>调用#5方法，通过查常量表可知#5是<code>java/io/PrintStream</code>的<code>println:(Ljava/lang/String;)V</code>，即在操作栈的基础上调用<code>System.out.println(str)</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第三个方法：</strong></p><p>0272~0273: <code>00 08</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）<br>0274~0275：<code>00 1B</code> ，name_index，指向常量池#27，#27代表<code>&quot;&lt;clinit&gt;&quot;</code>（即类构造器）<br>0276~0277：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参无返回值）<br>0278~0279：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>027A~027B: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>027C~027F：<code>00 00 00 27</code>，代表Code内容长度为39个字节。</p><p>接下来39个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>0280~02A6</p><pre><code>Code:stack=1, locals=0, args_size=0    0: ldc           #6                  // int 40000    2: putstatic     #7                  // Field j:I    5: ldc           #8                  // String Hello World!    7: putstatic     #4                  // Field str:Ljava/lang/String;    10: returnLineNumberTable:    line 9: 0    line 10: 5</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>ldc #6     </p></blockquote><p>把一个常量#6加载到操作数栈，通过查常量表可知#6是40000。</p><blockquote><p>putstatic #7</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#7是<code>Main</code>的<code>j:I</code>，即设置j的值为40000。（注意这里与第一个方法不同的是，设置小于等于short最大值的值的时候常数放在字节码中，而大于short最大值的常量放在常量表中）</p><blockquote><p>ldc #8</p></blockquote><p>把一个常量#8加载到操作数栈，通过查常量表可知#8是<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>putstatic #4</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>，即将str的值设置为<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>return</p></blockquote><p>返回</p><h1 id="属性表">6 属性表</h1><p>02A7~02A8：<code>00 01</code> attributes_count，代表属性表中有一项数据<br>02A9~02AA：<code>00 1C</code> attribute_name_index，指向常量池#28，#28代表<code>&quot;SourceFile&quot;</code>（记录源文件名称）<br>02AB~02AE: <code>00 00 00 02</code> 代表属性内容长度为2个字节。<br>02AF~02B0: <code>00 1D</code> 代表属性的值，指向常量池#29，#29代表<code>&quot;Main.java&quot;</code>  </p><p>到此，该class文件的字节码全部分析完</p><p><img src="https://api.codetool.top/img/15797822431714.png" alt="该文件结尾部分"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记06&quot;&gt;深入理解java虚拟机第三版读书笔记06&lt;/a&gt;中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。&lt;/p&gt;
&lt;p&gt;java源码：&lt;/p&gt;
&lt;pre class=&quot; language
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="Class文件" scheme="https://www.codetool.top/tags/Class%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode71-简化路径</title>
    <link href="https://www.codetool.top/article/leetcode71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.codetool.top/article/leetcode71-简化路径/</id>
    <published>2020-01-23T06:40:01.000Z</published>
    <updated>2020-01-23T07:10:01.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> “/home/“<br><strong>输出：</strong> “/home”<br><strong>解释：</strong> 注意，最后一个目录名后面没有斜杠。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> “/../“<br><strong>输出：</strong> “/“<br><strong>解释：</strong> 从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> “/home//foo/“<br><strong>输出：</strong> “/home/foo”<br><strong>解释：</strong> 在规范路径中，多个连续斜杠需要用一个斜杠替换。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> “/a/./b/../../c/“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong> “/a/../../b/../c//.//“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 6：</strong></p><blockquote><p><strong>输入：</strong> “/a//b////c/d//././/..”<br><strong>输出：</strong> “/a/b/c”  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用栈的思想来解决该问题，将给定的字符串使用<code>&quot;/&quot;</code>分割，会得到由空字符串、<code>&quot;.&quot;</code>、<code>&quot;..&quot;</code>、目录名组成的字符串数组，然后根据它们的特点对元素进行入栈出栈等操作。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">simplifyPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//因为最后要遍历栈，这里用ArrayList来模拟栈</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>dirs<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//空字符串和"."都表示当前目录</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">||</span> i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//".."表示上一级目录，出栈一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>                     stack<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//其他目录名入栈</span>            <span class="token keyword">else</span> stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过"/"连接起来</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>stack<span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;以 Unix 风格给出一个文件的&lt;strong&gt;绝对路径&lt;/strong&gt;，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（&lt;code&gt;.&lt;/code&gt;）表示当前目录本身；此外
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42-接雨水</title>
    <link href="https://www.codetool.top/article/leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://www.codetool.top/article/leetcode42-接雨水/</id>
    <published>2020-01-22T17:09:42.000Z</published>
    <updated>2020-01-22T17:39:56.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://api.codetool.top/img/15797131314307.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong> 6</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一列能存下的雨水单位等于<code>左右最高两列当中的较矮一列与当前高度的高度差</code>。</p><p><img src="https://api.codetool.top/img/15797135878580.png" alt></p><p>如图，第五列的积雨水量，等于左边最高一列（第四列left）和右边最高一列（第八列right）的较矮一列（left）与当前列高度的高度差（2-1=1）</p><p>如果两边有一边没有比当前列高的列，则当前列不会积水。</p><h2 id="代码">2.2 代码</h2><p>我一开始是这样写的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新左边所有列的right</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新右边所有列的left</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null <span class="token operator">||</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>时间复杂度达到了N<sup>2</sup>级别，那么如何优化呢？</p><ol><li>不必使用null来表示没有比当前列高的列，即使两列相等，高度差也是0，相当于不积水。</li><li>利用动态规划的思想，如果前一列的left比当前列高，则当前列的left也等于前一列的left。对于right也是一样的。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从左向右更新left</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从右向左更新right</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15797131314307.png&quot; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode95-不同的二叉搜索树II</title>
    <link href="https://www.codetool.top/article/leetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://www.codetool.top/article/leetcode95-不同的二叉搜索树II/</id>
    <published>2020-01-22T15:12:01.000Z</published>
    <updated>2020-01-22T15:20:18.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong><br>[<br>&nbsp;&nbsp;[1,null,3,2],<br>&nbsp;&nbsp;[3,2,null,1],<br>&nbsp;&nbsp;[3,1,null,null,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[1,null,2,null,3]<br>]<br><strong>解释:</strong><br>以上的输出对应以下 5 种不同结构的二叉搜索树：<br>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题的思想和<a href="../leetcode96-不同的二叉搜索树">leetcode96-不同的二叉搜索树</a>类似，通过各种左右组合情况得到为一个list返回。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">></span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含null的list使得for嵌套能正常工作</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含本数字的list</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自由组合左子树和右子树的情况</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode left<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode right<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96-不同的二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode96-不同的二叉搜索树/</id>
    <published>2020-01-22T14:15:52.000Z</published>
    <updated>2020-01-22T15:16:07.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:  </p><p>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于每一个n对应的数量应该是相同的，我们从1~n中任选一个做根节点（假设是第i个），那么左右两边各有<code>F(i-1)</code>和<code>F(n-i)</code>中情况，将它们相乘就是此时第i个元素做根节点的情况。如此递归计算总数量。</p><h2 id="代码">2.2 代码</h2><p>我一开始的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是发现这样写消耗非常多时间，leetcode执行用时<code>1700 ms</code>。</p><p>优化的思路主要是：</p><ol><li>end和start并不关键，只要start-end（即范围内的数字数量,用n表示）相同，对应的值就相同。</li><li>假如优化上条，很多<code>F(n)</code>单元会被重复计算，可以使用数组做缓存。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记08</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B008/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记08/</id>
    <published>2020-01-22T08:54:44.000Z</published>
    <updated>2020-01-22T19:37:45.581Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第七章 虚拟机类加载机制</strong>的内容</p><h1 id="概述">1 概述</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。在Java语言里面，<strong>类型的加载、连接和初始化过程都是在程序运行期间完成的</strong>，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性。</p><h1 id="类加载的时机">2 类加载的时机</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载<br>（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://api.codetool.top/img/15796958251344.png" alt></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而<strong>解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始</strong>，这是为了支持Java语言的运行时绑定特性。</p><p>加载阶段并没有严格规定开始的时机，而有且只有六种情况必须立即对类进行“初始化”：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>使用java.lang.reflect包的方法对类型进行反射调用</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p>这六种操作称为主动引用，其他引用称为被动引用，不会触发初始化。</p><p>接口的初始化稍有不同：对于第三点，接口只有真正用到父接口的时候才会使父接口初始化。</p><h1 id="类加载的过程">3 类加载的过程</h1><h2 id="加载">3.1 加载</h2><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>其中第一步自由度就很高，从ZIP压缩包中读取、从网络中获取、运行时计算生成等等。</p><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，<strong>开发人员通过定义自己的类加载器去控制字节流的获取方式</strong>（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><p><strong>数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。</strong>但数组类与类加载器仍然有很密切的关系，因为<strong>数组类的元素类型（指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载</strong>，一个数组类（下面简称为C）创建过程遵循以下规则：</p><ul><li>如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li><li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。</li><li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li></ul><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，但加载阶段提前开始于连接阶段。</p><h2 id="验证">3.2 验证</h2><p>这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>尽管Java代码编译时会拒绝编译一些致命错误，但字节码可以被轻易修改，字节码检查也是必不可少的。</p><h3 id="文件格式验证">3.2.1 文件格式验证</h3><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>……</li></ul><p>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有<strong>通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</strong></p><h3 id="元数据验证">3.2.2 元数据验证</h3><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li><li>……</li></ul><p>第二阶段的主要目的是<strong>对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</strong></p><h3 id="字节码验证">3.2.3 字节码验证</h3><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li></ul><p>目的是通过数据流分析和控制流分析，<strong>确定程序语义是合法的、符合逻辑的</strong>，不会危害虚拟机安全。</p><h3 id="符号引用验证">3.2.4 符号引用验证</h3><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作在解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、&lt;package&gt;）是否可被当前类访问。</li><li>……</li></ul><p>符号引用验证的主要目的是<strong>确保解析行为能正常执行</strong>，如果无法通过符号引用验证，Java虚拟机将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常，典型的如：<code>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError</code>等。</p><p>验证阶段不是必需的，如果程序运行使用的所有字节码都是安全的，可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备">3.3 准备</h2><p>准备阶段是正式<strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</strong>。（初始值指的是零值，类初始化阶段中调用类构造器方法才会对类变量赋值）</p><p>特殊情况：如果字段存在ConstantValue属性（声明为final，会在字段表的属性表中增加一项ConstantValue属性），那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p><h2 id="解析">3.4 解析</h2><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>。</p><p>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><p>而符号引用只是能无歧义定位到目标的一套自定符号表述。</p><p>解析阶段发生的具体时间并未强制规定，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>对同一个符号引用可以进行多次解析请求，虚拟机也可以缓存解析的结果，但对于<code>invokedynamic</code>指令不能缓存，执行到该条指令时才能解析，它对应的引用称为“动态调用点限定符”。</p><blockquote><p>invokedynamic本是为了支持如JRuby、 Scala等动态语言，JDK8后Lambda表达式和接口的默认方法的底层也会用到invokedynamic。</p></blockquote><h3 id="类或接口的解析">3.4.1 类或接口的解析</h3><p>将符号代表的类的全限定名交给当前类的类加载器来加载，如果是数组类型，则是加载它的数组元素类型，再由虚拟机生成对应的数组类型。</p><p>之后，验证当前类是否具有对该类的访问权限，若没有抛出异常<code>java.lang.IllegalAccessError</code></p><h3 id="字段解析">3.4.2 字段解析</h3><p>要解析一个未被解析过的字段符号引用，会先找到字段表中对应的所属类并解析。</p><ol><li>如果该类本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果该类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则。如果该类不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p><p>如果一个字段具有多义性（如果不严格按照顺序可能多种方式都能找到），javac可能会拒绝编译。</p><h3 id="方法解析">3.4.3 方法解析</h3><p>方法解析也会先找到方法表中对应的所属类并解析。</p><ol><li>类的方法和接口的方法符号引用的常量类型定义是分开的，如果发现该类是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError 异常。</li><li>如果通过了第一步，在该类中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该类的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该类实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明该类是一个抽象类，这时候查找结束，抛出 <code>java.lang.AbstractMethodError</code>异常。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p><h3 id="接口方法解析">3.4.4 接口方法解析</h3><p>接口方法解析也会先找到方法表中对应的所属类并解析。</p><ol><li>与类的方法解析相反，如果发现该类是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>否则，在该接口中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该接口的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>如果多重继承多个父接口都有该方法，可能会返回其中一个方法的直接引用，在编译期间javac也可能拒绝编译。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><p>JDK9模块化之后也可能抛出<code>java.lang.IllegalAccessError</code>异常。</p><h2 id="初始化">3.5 初始化</h2><p>初始化阶段就是<strong>执行类构造器&lt;clinit&gt;()方法的过程。</strong>&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p><p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，顺序为出现的顺序。</p><p>Java虚拟机会保证在子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在Java虚拟机中第一个被执行的&lt;clinit&gt;()方法的类型肯定是java.lang.Object。</p><p>这个方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</p><p>在多线程环境下，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第七章 虚拟机类加载机制&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode779-第K个语法符号</title>
    <link href="https://www.codetool.top/article/leetcode779-%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <id>https://www.codetool.top/article/leetcode779-第K个语法符号/</id>
    <published>2020-01-21T18:06:24.000Z</published>
    <updated>2020-01-21T18:11:32.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><p>给定行数 <code>N</code> 和序数 <code>K</code>，返回第 <code>N</code> 行中第 <code>K</code>个字符。（<code>K</code>从1开始）</p><p><strong>例子：</strong></p><blockquote><p><strong>输入:</strong> N = 1, K = 1<br><strong>输出:</strong> 0  </p><p><strong>输入:</strong> N = 2, K = 1<br><strong>输出:</strong> 0</p><p><strong>输入:</strong> N = 2, K = 2<br><strong>输出:</strong> 1  </p><p><strong>输入:</strong> N = 4, K = 5<br><strong>输出:</strong> 1   </p><p><strong>解释:</strong><br>第一行: 0<br>第二行: 01<br>第三行: 0110<br>第四行: 01101001  </p></blockquote><p><strong>注意:</strong></p><ol><li><code>N</code> 的范围 <code>[1, 30]</code>.</li><li><code>K</code> 的范围 <code>[1, 2^(N-1)]</code>.</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归分析要查找的字符是上一行的哪个数字得到的，然后根据奇偶性得到目标字符</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthGrammar</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>K<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">kthGrammar</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">kthGrammar</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;在第一行我们写上一个 &lt;code&gt;0&lt;/code&gt;。接下来的每一行，将前一行中的&lt;code&gt;0&lt;/code&gt;替换为&lt;code&gt;01&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;替换为&lt;code&gt;10&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode70-爬楼梯</title>
    <link href="https://www.codetool.top/article/leetcode70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>https://www.codetool.top/article/leetcode70-爬楼梯/</id>
    <published>2020-01-21T05:58:10.000Z</published>
    <updated>2020-01-21T06:11:07.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong> 给定 n 是一个正整数。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 2<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有两种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶<br>2.  2 阶  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有三种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶 + 1 阶<br>2.  1 阶 + 2 阶<br>3.  2 阶 + 1 阶</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>实际上是斐波那契数问题：</p><p>假设现在要走三阶楼梯，那么第一次走一阶楼梯时，还有f(2)种可能性，第一次走两阶楼梯时，还有f(1)种可能性，则f(3)=f(2)+f(1)，以此类推。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode509-斐波那契数</title>
    <link href="https://www.codetool.top/article/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode509-斐波那契数/</id>
    <published>2020-01-20T18:39:37.000Z</published>
    <updated>2020-01-21T06:11:11.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p></blockquote><p>给定 <code>N</code>，计算 <code>F(N)</code>。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 2<br><strong>输出：</strong> 1<br><strong>解释：</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 4<br><strong>输出：</strong> 3<br><strong>解释：</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.</p></blockquote><p><strong>提示：</strong></p><ul><li><code>0 ≤ N ≤ 30</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，由于很多递归单元会被重复计算，需要做缓存。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为&lt;strong&gt;斐波那契数列&lt;/strong&gt;。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记07</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B007/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记07/</id>
    <published>2020-01-20T17:41:55.000Z</published>
    <updated>2020-01-23T10:17:17.175Z</updated>
    
    <content type="html"><![CDATA[<p>附：</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">Java虚拟机规范-Java虚拟机指令集：JDK8</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-6.html" target="_blank" rel="noopener">Java虚拟机规范-Java虚拟机指令集：JDK13</a></p><p>续<a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a></p><h1 id="字节码指令简介">1 字节码指令简介</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为<strong>操作数</strong>，Operand）构成。</p><h2 id="字节码数据类型">1.1 字节码数据类型</h2><p>字节码指令集中存在大量与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。</p><p>因为操作码一字节的限制，并非每种数据类型和每一种操作都有对应的指令，有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><p>下表列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作：</p><table><thead><tr><th>opcode</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th><th>char</th><th>reference</th></tr></thead><tbody><tr><td>Tipush</td><td>bipush</td><td>sipush</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Tconst</td><td></td><td></td><td>iconst</td><td>lconst</td><td>fconst</td><td>dconst</td><td></td><td>aconst</td></tr><tr><td>Tload</td><td></td><td></td><td>iload</td><td>lload</td><td>fload</td><td>dload</td><td></td><td>aload</td></tr><tr><td>Tstore</td><td></td><td></td><td>istore</td><td>lstore</td><td>fstore</td><td>dstore</td><td></td><td>astore</td></tr><tr><td>Taload</td><td>baload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>caload</td><td>aaload</td></tr><tr><td>Tastore</td><td>bastore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>castore</td><td>aastore</td></tr><tr><td>Tadd</td><td></td><td></td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td><td></td><td></td></tr><tr><td>Tsub</td><td></td><td></td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td><td></td><td></td></tr><tr><td>Tmul</td><td></td><td></td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td><td></td><td></td></tr><tr><td>Tdiv</td><td></td><td></td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td><td></td><td></td></tr><tr><td>Tneg</td><td></td><td></td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td><td></td><td></td></tr><tr><td>Tshl</td><td></td><td></td><td>ishl</td><td>lshl</td><td></td><td></td><td></td><td></td></tr><tr><td>Tshr</td><td></td><td></td><td>ishr</td><td>lshr</td><td></td><td></td><td></td><td></td></tr><tr><td>Tushr</td><td></td><td></td><td>iushr</td><td>lushr</td><td></td><td></td><td></td><td></td></tr><tr><td>Tand</td><td></td><td></td><td>iand</td><td>land</td><td></td><td></td><td></td><td></td></tr><tr><td>Tor</td><td></td><td></td><td>ior</td><td>lor</td><td></td><td></td><td></td><td></td></tr><tr><td>Txor</td><td></td><td></td><td>ixor</td><td>lxor</td><td></td><td></td><td></td><td></td></tr><tr><td>i2T</td><td>i2b</td><td>i2s</td><td></td><td>i2l</td><td>i2f</td><td>i2d</td><td></td><td></td></tr><tr><td>12T</td><td></td><td></td><td>12i</td><td></td><td>12f</td><td>12d</td><td></td><td></td></tr><tr><td>f2T</td><td></td><td></td><td>f2i</td><td>f2l</td><td></td><td>f2d</td><td></td><td></td></tr><tr><td>d2T</td><td></td><td></td><td>d2i</td><td>d2l</td><td>d2f</td><td></td><td></td><td></td></tr><tr><td>Tcmp</td><td></td><td></td><td></td><td>lcmp</td><td></td><td></td><td></td><td></td></tr><tr><td>Tcmpl</td><td></td><td></td><td></td><td></td><td>fcmpl</td><td>dcmpl</td><td></td><td></td></tr><tr><td>Tcmpg</td><td></td><td></td><td></td><td></td><td>fcmpg</td><td>dcmpg</td><td></td><td></td></tr><tr><td>if_TempOP</td><td></td><td></td><td>if_icmpOP</td><td></td><td></td><td></td><td></td><td>if_acmpOP</td></tr><tr><td>Treturn</td><td></td><td>ireturn</td><td>lreturn</td><td>fretun</td><td>dretun</td><td></td><td></td><td>areturn</td></tr></tbody></table><p><strong>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。</strong>编译器会在编译期或运行期将<strong>byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型</strong>数据，将<strong>boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型</strong>数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p><h2 id="加载和存储指令">1.2 加载和存储指令</h2><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：</p><ul><li>将一个<strong>局部变量加载到操作数栈</strong>：iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、 dload_&lt;n&gt;、aload、aload_&lt;n&gt;</li><li>将一个数值从<strong>操作数栈存储到局部变量表</strong>：istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、 fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</li><li>将一个<strong>常量加载到操作数栈</strong>：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</li><li>扩充局部变量表的访问索引的指令：wide</li></ul><p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p><p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。除了这点不同以外，它们的语义与原生的通用指令是完全一致的（<strong>例如iload_0的语义与操作数为0时的iload指令语义完全一致</strong>）。</n></n></p><h2 id="运算指令">1.3 运算指令</h2><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p><p>大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><p>非精确的结果必须舍入为可被表示的最接近的精确值；如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的，称为向最接近数舍入模式。而在把浮点数转换为整数时，使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</p><p>在对long类型数值进行比较时，Java虚拟机采用带符号的比较方式，而对浮点数值进行比较时<br>（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（Nonsignaling Comparison）方式进行。</p><p>iinc直接在局部变量槽slot上运算。</p><h2 id="类型转换指令">1.4 类型转换指令</h2><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening<br>Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p><ul><li>int类型到long、float或者double类型</li><li>long类型到float、double类型</li><li>float类型到double类型</li></ul><p>与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f</code>。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p><h2 id="对象创建与访问指令">1.5 对象创建与访问指令</h2><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、 dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><h2 id="操作数栈管理指令">1.6 操作数栈管理指令</h2><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、 dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul><h2 id="控制转移指令">1.7 控制转移指令</h2><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：<br>·条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne<br>·复合条件分支：tableswitch、lookupswitch<br>·无条件分支：goto、goto_w、jsr、jsr_w、ret</p><h2 id="方法调用和返回指令">1.8 方法调用和返回指令</h2><ul><li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic指令：用于调用类静态方法（static方法）。</li><li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</p><h2 id="异常处理指令">1.9 异常处理指令</h2><p>在Java程序中<strong>显式抛出异常的操作（throw语句）都由athrow指令来实现</strong>，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p><p>而在Java虚拟机中，<strong>处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成。</strong></p><h2 id="同步指令">1.10 同步指令</h2><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，<strong>如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。</strong>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;附：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java虚拟机规范-Java虚拟机指令集：JD
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode24-两两交换链表中的节点</title>
    <link href="https://www.codetool.top/article/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.codetool.top/article/leetcode24-两两交换链表中的节点/</id>
    <published>2020-01-20T12:55:44.000Z</published>
    <updated>2020-01-20T13:00:14.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，自底向上</p><p>终止点：</p><ol><li>head为null，返回null</li><li>head的next为null，代表此时是倒数第一个元素（链表节点是奇数个），直接返回head</li></ol><p>否则，直接交换当前节点和下一个节点，下一个节点的next使用<code>swapPairs()</code>计算</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你不能只是单纯的改变节点内部的值&lt;/strong&gt;，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode559-N叉树的最大深度</title>
    <link href="https://www.codetool.top/article/leetcode559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://www.codetool.top/article/leetcode559-N叉树的最大深度/</id>
    <published>2020-01-20T12:39:39.000Z</published>
    <updated>2020-01-20T12:42:58.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>我们应返回其最大深度，3。</p><p><strong>说明:</strong></p><ol><li>树的深度不会超过 <code>1000</code>。</li><li>树的节点总不会超过 <code>5000</code>。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>自底向上，每个节点是所有孩子节点的深度的最大值+1</li><li>自顶向下，依次更新最大高度</li></ol><h2 id="代码">2.2 代码</h2><p>自底向上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> depth<span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>level<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> level<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自顶向下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> depth<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> cur<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">></span>depth<span class="token punctuation">)</span> depth <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span>            <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，找到其最大深度。&lt;/p&gt;
&lt;p&gt;最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode429-N叉树的层序遍历</title>
    <link href="https://www.codetool.top/article/leetcode429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode429-N叉树的层序遍历/</id>
    <published>2020-01-19T18:36:06.000Z</published>
    <updated>2020-01-19T18:43:26.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其层序遍历:</p><pre><code>[     [1],     [3,2,4],     [5,6]]</code></pre><p><strong>说明:</strong> </p><ol><li>树的深度不会超过 1000。</li><li>树的节点总数不会超过 5000。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似<a href="../leetcode102-二叉树的层次遍历/">leetcode102-二叉树的层次遍历</a>，通过DFS或BFS实现。</p><h2 id="代码">2.2 代码</h2><p>迭代（BFS）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以null作为每层结束的标志符</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Node node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Node child<span class="token operator">:</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//若队首为null说明这一层的节点的子节点已经全部加入队列了，需要加入一个null</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>递归（DFS）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span>            <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> level<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>level<span class="token punctuation">)</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;层序遍历&lt;/em&gt;。 (即从左到右，逐层遍历)。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetoo
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode590-N叉树的后序遍历</title>
    <link href="https://www.codetool.top/article/leetcode590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode590-N叉树的后序遍历/</id>
    <published>2020-01-19T18:23:52.000Z</published>
    <updated>2020-01-19T18:25:30.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其前序遍历: <code>[5,6,3,2,4,1]</code>.</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似二叉树的后序遍历，递归回溯时将根节点加入集合中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;后序遍历&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1579
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode589-N叉树的前序遍历</title>
    <link href="https://www.codetool.top/article/leetcode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode589-N叉树的前序遍历/</id>
    <published>2020-01-18T18:52:50.000Z</published>
    <updated>2020-01-18T18:59:06.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似二叉树的前序遍历，递归将根节点加入集合中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;前序遍历&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1579
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记06</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B006/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记06/</id>
    <published>2020-01-18T14:12:50.000Z</published>
    <updated>2020-01-23T10:17:24.346Z</updated>
    
    <content type="html"><![CDATA[<p>附：</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">Java虚拟机规范-Class文件格式：JDK8</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-4.html" target="_blank" rel="noopener">Java虚拟机规范-Class文件格式：JDK13</a></p><p>以下是<strong>第六章 类文件结构</strong>的内容</p><h1 id="Class类文件的结构">1 Class类文件的结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项都是紧凑排列的，如果有需要占用8个字节以上的数据项时，会按照高位在前的方式分割成多个8字节进行存储。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型——“无符号数”和“表”：</p><ul><li>无符号数：基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，<strong>所有表的命名都习惯性地以“_info”结尾。</strong> </li></ul><p>Class文件由以下这些数据项组成：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h2 id="魔数与Class文件的版本">1.1 魔数与Class文件的版本</h2><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件格式标准都会用魔数来确认文件格式，使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。Class文件的魔数值为<code>0xCAFEBABE</code>（咖啡宝贝）。</p><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的主版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><p>Java1：45<br>Java4：48<br>Java5：49<br>Java8：52<br>以此类推  </p><p>关于次版本号，曾经在Java 2出现前被短暂使用过，从JDK 1.2以后，直到JDK 12之前<strong>次版本号均未使用，全部固定为零。</strong>而到了JDK 12时期，由于JDK提供的功能集已经非常庞大，有一些复杂的新特性需要以“公测”的形式放出，所以设计者重新启用了副版本号，将它用于标识“技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。</p><table><thead><tr><th>JDK版本</th><th>-target参数</th><th>-source参数</th><th>版本号</th></tr></thead><tbody><tr><td>JDK 1.1.8</td><td>不支持target参数</td><td>不支持source参数</td><td>45.3</td></tr><tr><td>JDK 1.2.2</td><td>不带（默认为-target 1.1）</td><td>1.1~1.2</td><td>45.3</td></tr><tr><td>JDK 1.2.2</td><td>-target 1.2</td><td>1.1~1.2</td><td>46.0</td></tr><tr><td>JDK 1.3.1_19</td><td>不带（默认为-target 1.1)</td><td>1.1~1.3</td><td>45.3</td></tr><tr><td>JDK 1.3.1_19</td><td>-target 1.3</td><td>1.1~1.3</td><td>47.0</td></tr><tr><td>JDK 1.4.2_10</td><td>不带（默认为-target 1.2）</td><td>1.1~1.4</td><td>46.0</td></tr><tr><td>JDK 1.4.2_10</td><td>-target 1.4</td><td>1.1~1.4</td><td>48.0</td></tr><tr><td>JDK 5.0_11</td><td>不带（默认为-target 1.5），后续版本不带target参数默认编译的Class文件均与其JDK版本相同</td><td>11～15</td><td>49.0</td></tr><tr><td>JDK 5.0_11</td><td>-target 1.4 -source 1.4</td><td>1.1~1.5</td><td>48.0</td></tr><tr><td>JDK 6</td><td>不带（默认为-target 6）</td><td>1.1~6</td><td>50.0</td></tr><tr><td>JDK 7</td><td>不带（默认为-target 7）</td><td>1.1～7</td><td>51.0</td></tr><tr><td>JDK 8</td><td>不带（默认为-target 8)</td><td>1.1~8</td><td>52.0</td></tr><tr><td>JDK 9</td><td>不带（默认为-target 9）</td><td>6～9</td><td>53.0</td></tr><tr><td>JDK 10</td><td>不带（默认为-target 10）</td><td>6~10</td><td>54.0</td></tr><tr><td>JDK 11</td><td>不带（默认为-target 11）</td><td>6~11</td><td>55.0</td></tr><tr><td>JDK 12</td><td>不带（默认为-target 12）</td><td>6~12</td><td>56.0</td></tr><tr><td>JDK 13</td><td>不带（默认为-target 13）</td><td>6~13</td><td>57.0</td></tr></tbody></table><h2 id="常量池">1.2 常量池</h2><p>8~9字节是一项u2类型的数据，代表常量池容量计数值（常量池有多少项），这个容量计数是从1而不是0开始的。</p><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul><p>最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK13，常量表中分别有17种不同类型的常量。</p><p>这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位（tag，取值见下表标志列），代表着当前常量属于哪种常量类型。17种常量类型所代表的具体含义如表所示。</p><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>表示一个动态计算常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>表示一个模块</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>表示一个模块中开放或者导出的包。</td></tr></tbody></table><p>常量池中的17种数据类型的结构总表：</p><table> <col class="xl651514" span="4"> <thead>    <tr height="19">    <th height="19" class="xl661514">常量    </th><th class="xl661514">项目    </th><th class="xl661514">类型    </th><th class="xl661514">描述    </th></tr> </thead> <tr height="19">  <td rowspan="3" height="95" class="xl671514">CONSTANT_Utf8_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为1</td> </tr> <tr height="38">  <td height="38" class="xl661514">length<span>&nbsp;</span></td>  <td class="xl661514">u2</td>  <td class="xl661514">UTF-8编码的字符串占用的字节数</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u1</td>  <td class="xl661514">长度为length的UTF-8编码的字符串</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Integer_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为3</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u4</td>  <td class="xl661514">按照高位在前存储的int值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Float_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为4</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u4</td>  <td class="xl661514">按照高位在前存储的float值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Long_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为5</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u8</td>  <td class="xl661514">按照高位在前存储的long值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Double_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为6</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u8</td>  <td class="xl661514">按照高位在前存储的double值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Class_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为7</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向全限定名常量项的索引</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_String_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为8</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向字符串字面量的索引</td> </tr> <tr height="19">  <td rowspan="3" height="152" class="xl671514">CONSTANT_Fieldref_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为9</td> </tr> <tr height="76">  <td height="76" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向字段描述符CONSTANT_NameAndType的索引项</td> </tr> <tr height="19">  <td rowspan="3" height="133" class="xl671514">CONSTANT_Methodref_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为10</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向声明方法的类描述符CONSTANT_Class_info的索引项</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向名称及类型描述符CONSTANT_NameAndType的索引项</td> </tr> <tr height="19">  <td rowspan="3" height="152" class="xl671514">CONSTANT_InterfaceMethodref_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为11</td> </tr> <tr height="76">  <td height="76" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向声明方法的接口描述符CONSTANT_Class_info的索引项</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向名称及类型描述符CONSTANT_NameAndType的索引项</td> </tr> <tr height="19">  <td rowspan="3" height="95" class="xl671514">CONSTANT_NameAndType_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为12</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向该字段或方法名称常量项的索引</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向该字段或方法描述符常量项的索引</td> </tr> <tr height="19">  <td rowspan="3" height="152" class="xl671514">CONSTANT_MethodHandle_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为15</td> </tr> <tr height="95">  <td height="95" class="xl661514">reference_kind</td>  <td class="xl661514">u1</td>  <td class="xl661514">值必须在1至9之间（包括1和9），它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</td> </tr> <tr height="38">  <td height="38" class="xl661514">reference_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引</td> </tr> <tr height="19">  <td rowspan="2" height="114" class="xl671514">CONSTANT_MethodType_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为16</td> </tr> <tr height="95">  <td height="95" class="xl661514">descriptor_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符</td> </tr> <tr height="19">  <td rowspan="3" height="209" class="xl671514">CONSTANT_Dynamic_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为17</td> </tr> <tr height="76">  <td height="76" class="xl661514">bootstrap_method_attr_ index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td> </tr> <tr height="114">  <td height="114" class="xl661514">name_and_type_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符。</td> </tr> <tr height="19">  <td rowspan="3" height="209" class="xl671514">CONSTANT_InvokeDynamic_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为18</td> </tr> <tr height="76">  <td height="76" class="xl661514">bootstrap_method_attr_ index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td> </tr> <tr height="114">  <td height="114" class="xl661514">name_and_type_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符。</td> </tr> <tr height="19">  <td rowspan="2" height="114" class="xl671514">CONSTANT_Module_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为19</td> </tr> <tr height="95">  <td height="95" class="xl661514">name_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示模块名字</td> </tr> <tr height="19">  <td rowspan="2" height="114" class="xl671514">CONSTANT_Package_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为20</td> </tr> <tr height="95">  <td height="95" class="xl661514">name_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示包名称</td> </tr></table><h2 id="访问标志">1.3 访问标志</h2><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final，只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK1.0.2之后编译出来的类的这个标志都必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0X0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0X0400</td><td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0X2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>标识这是一个模块</td></tr></tbody></table><p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一律为零。</p><h2 id="类索引、父类索引与接口索引集合">1.4 类索引、父类索引与接口索引集合</h2><p>跟在访问标志后面的，分别是类索引、父类索引和接口索引集合。类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。<strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</strong>除了<code>java.lang.Object</code>外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串。</p><p>接口索引集合的入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。</p><h2 id="字段表集合">1.5 字段表集合</h2><p>字段表（field_info）用于描述接口或者类中声明的变量，包括类级变量以及实例级变量。</p><p>字段表结构:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>discriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>其中<code>access_flags</code>代表字段修饰符，含义如下</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table><p>跟随<code>access_flags</code>标志的是两项索引值：<code>name_index</code>和<code>descriptor_index</code>。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><p>概念解析：</p><ul><li>全限定名：”org/fenixsoft/clazz/TestClass”，把类全名中的”.”替换成了”/“，最后一般会加入一个“;”号表示全限定名结束</li><li>简单名称：没有类型和参数修饰的方法或者字段名称</li><li>描述符：描述字段的数据类型、方法的参数列表和返回值，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示：</li></ul><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型byte</td></tr><tr><td>C</td><td>基本类型char</td></tr><tr><td>D</td><td>基本类型double</td></tr><tr><td>F</td><td>基本类型float</td></tr><tr><td>I</td><td>基本类型int</td></tr><tr><td>J</td><td>基本类型long</td></tr><tr><td>S</td><td>基本类型short</td></tr><tr><td>Z</td><td>基本类型boolean</td></tr><tr><td>V</td><td>特殊类型void</td></tr><tr><td>L</td><td>对象类型，如Ljava/lang/Object;</td></tr></tbody></table><p>对于数组类型，每一维度将使用一个前置的”[“字符来描述，如一个定义为”java.lang.String[][]”类型的二维数组将被记录成”<code>[[Ljava/lang/String;</code>“</p><p>用描述符来描述方法时，按照<strong>先参数列表、后返回值</strong>的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法<code>void inc()</code>的描述符为“<code>()V</code>”，方法<code>java.lang.String toString()</code>的描述符为“<code>()Ljava/lang/String;</code>”。</p><p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p><h2 id="方法表集合">1.6 方法表集合</h2><p>Class文件中方法表的结构同字段表完全一致：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>discriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>访问标志的内容有所区别：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是不是由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICT</td><td>0X0800</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生</td></tr></tbody></table><p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面</p><h2 id="属性表集合">1.7 属性表集合</h2><p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p><p>属性表不再要求各个属性表具有严格顺序，甚至只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息。</p><p>为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>Constant Value</td><td>字段表</td><td>由final关键字定义的常量值</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常列表</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标示这个类所在的外围方法</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK 6中新增的属性，供新的类型检查验证器（Type Checker)检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>JDK 5中新增的属性，用于支持范型情况下的方法签名。在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（TypeVariables)或参数化类型（Parameterized Types)，则Signature属性会为它记录泛型签名信息。由于Java的范型采用擦除法实现，为了避免类型信息被擦除后导致签名混乱，需要这个属性记录范型中的相关信息</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>JDK 5中新增的属性，用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号，JSR45提案为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以用于存储这个标准所新加入的调试信息</td></tr><tr><td>Synthetic</td><td>类、方法表、字段表</td><td>标识方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>JDK 5中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK 5中新增的属性，为动态注解提供支持。该属性用于指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK 5中新增的属性，与RuntimeVisibleAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotations</td><td>方法表</td><td>JDK 5中新增的属性，作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法参数</td></tr><tr><td>RuntimeInvisibleParameterAnnotations</td><td>方法表</td><td>JDK 5中新增的属性，作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象为方法参数</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>JDK 5中新增的属性，用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>JDK 7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符</td></tr><tr><td>RuntimeVisibleTypeAnnotations</td><td>类、方法表、字段表，Code属性</td><td>JDK 8中新增的属性，为实现JSR 308中新增的类型注解提供的支持，用于指明哪些类注解是运行时（实际上运行时就是进行反射调用）可见的</td></tr><tr><td>RuntimeInvisibleTypeAnnotations</td><td>类、方法表、字段表，Code属性</td><td>JDK 8中新增的属性，为实现JSR 308中新增的类型注解提供的支持，与RuntimeVisibleTypeAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的</td></tr><tr><td>MethodParameters</td><td>方法表</td><td>JDK 8中新增的属性，用于支持（编译时加上-parameters参数)将方法名称编译进Class文件中，并可运行时获取。此前要获取方法名称（典型的如IDE的代码提示）只能通过JavaDoc中得到</td></tr><tr><td>Module</td><td>类</td><td>JDK 9中新增的属性，用于记录一个Module的名称以及相关信息（requires、exports、opens、uses、provides)</td></tr><tr><td>ModulePackages</td><td>类</td><td>JDK 9中新增的属性，用于记录一个模块中所有被exports或者opens的包</td></tr><tr><td>ModuleMainClass</td><td>类</td><td>JDK 9中新增的属性，用于指定一个模块的主类</td></tr><tr><td>NestHost</td><td>类</td><td>JDK 11中新增的属性，用于支持嵌套类（Java中的内部类)的反射和访问控制的API，一个内部类通过该属性得知自己的宿主类</td></tr><tr><td>NestMembers</td><td>类</td><td>JDK 11中新增的属性，用于支持嵌套类（Java中的内部类)的反射和访问控制的API，一个宿主类通过该属性得知自己有哪些内部类</td></tr></tbody></table><p>对于每一个属性，它的名称都要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足下表所定义的结构：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td></tr></tbody></table><h3 id="Code属性">1.7.1 Code属性</h3><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。结构如下表：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>max_stack</td><td>1</td></tr><tr><td>u2</td><td>max_ locals</td><td>1</td></tr><tr><td>u4</td><td>code_length</td><td>1</td></tr><tr><td>u1</td><td>code</td><td>code_length</td></tr><tr><td>u2</td><td>exception_table_length</td><td>1</td></tr><tr><td>exception_info</td><td>exception_table</td><td>exception_table_length</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><ul><li><code>attribute_name_index</code>指向固定常量“Code”，它代表了该属性的属性名称</li><li><code>attribute_length</code>指示了属性值的总长度，不包括<code>attribute_name_index</code>和<code>attribute_length</code>的长度。</li><li><code>max_stack</code>代表了操作数栈深度的最大值。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。 </li><li><code>max_locals</code>代表了局部变量表所需的存储空间。单位是变量槽（Slot），对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li><li><code>code_length</code>和<code>code</code>用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。<ul><li>关于<code>code_length</code>，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即<strong>它实际只使用了u2的长度</strong>，如果超过这个限制，Javac编译器就会拒绝编译。</li><li>code中每个指令就是一个u1类型的单字节。每读取一个字节便可知道指令是什么、后面是否跟着参数。</li><li>通过javap可以查看字节码指令</li></ul></li><li>如果存在异常表，它的格式如下表所示</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>end_pc</td><td>1</td></tr><tr><td>u2</td><td>handler_pc</td><td>1</td></tr><tr><td>u2</td><td>catch_type</td><td>1</td></tr></tbody></table><p>如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第end_pc行）出现了类型为<code>catch_type</code>或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第<code>handler_pc</code>行继续处理。当<code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</p><p>尽管字节码中有最初为处理异常而设计的跳转指令，但《Java 虚拟机规范》中明确要求Java语言的编译器<strong>应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制</strong>。</p><h3 id="LineNumberTable属性">1.7.2 LineNumberTable属性</h3><p><code>LineNumberTable</code>属性用于描述<strong>Java源码行号与字节码行号（字节码的偏移量）之间的对应关系</strong>。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用<code>-g：none</code>或<code>-g：lines</code>选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>line_number_table_length</td><td>1</td></tr><tr><td>line_number_info</td><td>line_number_table</td><td>line_number_table_length</td></tr></tbody></table><p><code>line_number_table</code>是一个数量为<code>line_number_table_length</code>、类型为<code>line_number_info</code>的集合，<code>line_number_info</code>表包含<code>start_pc</code>和<code>line_number</code>两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p><h3 id="LocalVariableTable及LocalVariableTypeTable属性">1.7.3 LocalVariableTable及LocalVariableTypeTable属性</h3><p><code>LocalVariableTable</code>属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用<code>-g：none</code>或<code>-g：vars</code>选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>local variable table length</td><td>1</td></tr><tr><td>local_ variable_info</td><td>local_variable_table</td><td>local_variable_table_length</td></tr></tbody></table><p>其中<code>local_variable_info</code>项目代表了一个栈帧与源码中的局部变量的关联:</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pe</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u2</td><td>name index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>index</td><td>1</td></tr></tbody></table><p><code>start_pc</code>和<code>length</code>属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。 <code>name_index</code>和<code>descriptor_index</code>都是指向常量池中<code>CONSTANT_Utf8_info</code>型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p><p><code>index</code>是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时<br>（double和long），它占用的变量槽为index和index+1两个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;附：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java虚拟机规范-Class文件格式：JDK
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode108-将有序数组转换为二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode108-将有序数组转换为二叉搜索树/</id>
    <published>2020-01-17T16:59:42.000Z</published>
    <updated>2020-01-17T17:16:15.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><pre><code>给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：      0     / \   -3   9   /   / -10  5</code></pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似于二分查找，每次递归使用数组的中间元素作为根节点。就能最大化利用左右节点空间，使之平衡。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110-平衡二叉树</title>
    <link href="https://www.codetool.top/article/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode110-平衡二叉树/</id>
    <published>2020-01-17T15:30:21.000Z</published>
    <updated>2020-01-17T15:52:10.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><pre><code>       1      / \     2   2    / \   3   3  / \ 4   4</code></pre><p>返回 <code>false</code> 。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>自顶向下：每个节点获取左右两棵子树的高度，并比较高度差是否大于1，获取高度通过递归实现。</p><p>自底向上：回溯时比较左右节点的高度，如果有任意节点左右子树高度差大于1，则说明不是平衡树。</p><h2 id="代码">2.2 代码</h2><p>自顶向下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Height</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自底向上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BalancedBinaryTree</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
