<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-27T18:37:12.316Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode385-迷你语法分析器</title>
    <link href="https://www.codetool.top/article/leetcode385-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode385-迷你语法分析器/</id>
    <published>2020-01-27T18:14:31.000Z</published>
    <updated>2020-01-27T18:37:12.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。</p><p>列表中的每个元素只可能是整数或整数嵌套列表</p><p><strong>提示：</strong> 你可以假定这些字符串都是格式良好的：</p><ul><li>字符串非空</li><li>字符串不包含空格</li><li>字符串只包含数字<code>0-9</code>, <code>[</code>, <code>-</code> ,<code>,</code>, <code>]</code></li></ul><p><strong>示例 1：</strong></p><blockquote><p>给定 s = “324”,</p><p>你应该返回一个 NestedInteger 对象，其中只包含整数值 324。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>给定 s = “[123,[456,[789]]]”,</p><p>返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：</p><p>1. 一个 integer 包含值 123<br>2. 一个包含两个元素的嵌套列表：<br>&nbsp;&nbsp;&nbsp;&nbsp;i.  一个 integer 包含值 456<br>&nbsp;&nbsp;&nbsp;&nbsp;ii. 一个包含一个元素的嵌套列表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. 一个 integer 包含值 789</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>设定一个getNest()函数用于返回一个列表类型的NestedInteger。</p><p>相当于每个<code>[</code> <code>]</code>中都代表一次递归函数调用。</p><p>最重要的思想是通过类的全局字符数组和一个下标值让每次调用递归函数都知道要处理哪个位置。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//递归函数通过字符数组和cur下标确定要处理的位置</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> NestedInteger <span class="token function">deserialize</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//本身不是一个集合而是一个整数的情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'['</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用递归函数返回根集合</span>        <span class="token keyword">return</span> <span class="token function">getNest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> NestedInteger <span class="token function">getNest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        NestedInteger nest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//num用于缓存用逗号分割的整数类型的值</span>        <span class="token keyword">boolean</span> negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前记录的整数是不是负数</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span>chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">','</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'['</span><span class="token punctuation">)</span> nest<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getNest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遇到[递归获取子集合</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nest<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span> negative <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//是数字的情况</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>negative<span class="token punctuation">)</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>num <span class="token operator">-</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span>num <span class="token operator">+</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果下一个字符是,或者]说明当前数字已经记录完了，需要加入集合中</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">','</span><span class="token operator">||</span>chars<span class="token punctuation">[</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                     nest<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NestedInteger</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。&lt;/p&gt;
&lt;p&gt;列表中的每个元素只可能是整数或整数嵌套列表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 你可以假定这些字符串都是格式良好的：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记11</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B011/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记11/</id>
    <published>2020-01-27T12:32:40.000Z</published>
    <updated>2020-01-27T18:38:33.201Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第十一章 后端编译与优化</strong>的内容</p><p>把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码可以视为整个编译过程的后端。</p><p>最近几年提前编译也开始兴起，我们在这章把它和即时编译共称为后端编译。</p><h1 id="即时编译器">1 即时编译器</h1><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。</p><h2 id="解释器与编译器">1.1 解释器与编译器</h2><p>目前主流的商用Java虚拟机内部都同时包含解释器与编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。</p><p><img src="https://api.codetool.top/img/15801398731996.png" alt></p><p>HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称<br>为“客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和C2编译器,第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。</p><p>解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”，用户也可以使用参数<code>-Xint</code>强制虚拟机运行于“解释模式”。另外，也可以使用参数<code>-Xcomp</code>强制虚拟机运行于“编译模式”，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p><p>由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot虚拟机在编译子系统中加入了<strong>分层编译</strong>的功能。</p><p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层。程序<strong>纯解释执行</strong>，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层。使用<strong>客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化</strong>，不开启性能监控功能。</li><li>第2层。仍然<strong>使用客户端编译器执行</strong>，仅<strong>开启方法及回边次数统计等有限的性能监控功能。</strong></li><li>第3层。仍然<strong>使用客户端编译器执行，开启全部性能监控</strong>，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层。<strong>使用服务端编译器将字节码编译为本地代码</strong>，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h2 id="编译对象与触发条件">1.2 编译对象与触发条件</h2><p>热点代码：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。</p><p>要知道某段代码是不是热点代码，称为“热点探测”，有两种方法：</p><ul><li>基于采样的热点探测：周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。</li><li>基于计数器的热点探测：为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”，更精确。</li></ul><p>HotSpot使用了第二种方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，一旦溢出，就会触发即时编译。</p><p>方法调用计数器默认阈值在客户端模式下是<code>1500次</code>，在服务端模式下是<code>10000次</code>，这个阈值可以通过虚拟机参数<code>-XX： CompileThreshold</code>来人为设定。</p><p>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是<strong>一段时间之内方法被调用的次数。</strong>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被<strong>减少一半</strong>，这个过程被称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的<strong>半衰周期</strong>，进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX：-UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用<code>-XX：CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><p>回边计数器统计一个方法中循环体代码执行的次数，阈值使用<code>-XX：OnStackReplacePercentage</code>间接设置：</p><ul><li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：<br>CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：<br>OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995。</li><li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：<br>CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700。</li></ul><p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第十一章 后端编译与优化&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码可以视为整个编译过程的后端。&lt;/p&gt;
&lt;p&gt;最近几年提前编译也开始兴起，我们在这章把它和即时编译共称为后端编译
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode341-扁平化嵌套列表迭代器</title>
    <link href="https://www.codetool.top/article/leetcode341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode341-扁平化嵌套列表迭代器/</id>
    <published>2020-01-26T18:18:33.000Z</published>
    <updated>2020-01-26T18:36:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p><p>列表中的项或者为一个整数，或者是另一个列表。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> [[1,1],2,[1,1]]<br><strong>输出:</strong> [1,1,2,1,1]<br><strong>解释:</strong> 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> 14<br><strong>输出:</strong> False<br><strong>解释:</strong> 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>构造通过递归构造，获取元素就是通用迭代器的方法。    </p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIterator</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">addViaList</span><span class="token punctuation">(</span>nestedList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViaList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>NestedInteger i<span class="token operator">:</span>nestedList<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">addViaList</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cur<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/p&gt;
&lt;p&gt;列表中的项或者为一个整数，或者是另一个列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode331-验证二叉树的前序序列化</title>
    <link href="https://www.codetool.top/article/leetcode331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://www.codetool.top/article/leetcode331-验证二叉树的前序序列化/</id>
    <published>2020-01-26T15:51:46.000Z</published>
    <updated>2020-01-26T16:14:19.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><pre><code>     _9_    /   \   3     2  / \   / \ 4   1  #  6/ \ / \   / \# # # #   # #</code></pre><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> “9,3,4,#,#,1,#,#,2,#,6,#,#”<br><strong>输出:</strong> true   </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> “1,#”<br><strong>输出:</strong> false  </p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> “9,#,#,1”<br><strong>输出:</strong> false</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>可能导致前序序列化验证失败的情况有：</p><ol><li>null做空节点</li><li>子节点不完全</li></ol><pre><code>  #       1 / \     / \1   2   3</code></pre><p>假设任一状态待填充的节点数为count，第一种情况会导致在某一个时刻count小于0，第二种情况会导致最后count大于0。而这两种情况是不会同时存在的。</p><p>每次遇到一个节点count的值减一，遇到一个非null的节点count的值加二，最后看count是否为0。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidSerialization</span><span class="token punctuation">(</span>String preorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> nodes <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>nodes<span class="token punctuation">)</span><span class="token punctuation">{</span>            count<span class="token operator">-=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> count<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 &lt;code&gt;#&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     _9_
   
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode224-基本计算器</title>
    <link href="https://www.codetool.top/article/leetcode224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode224-基本计算器/</id>
    <published>2020-01-25T19:07:56.000Z</published>
    <updated>2020-01-25T19:19:58.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式可以包含左括号 <code>(</code> ，右括号 <code>)</code>，加号 <code>+</code> ，减号 <code>-</code>，<strong>非负</strong>整数和空格<code></code> 。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> “1 + 1”<br><strong>输出:</strong> 2  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> “ 2-1 + 2 “<br><strong>输出:</strong> 3</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> “(1+(4+5+2)-3)+(6+8)”<br><strong>输出:</strong> 23</p></blockquote><p><strong>说明：</strong></p><ul><li>你可以假设所给定的表达式都是有效的。</li><li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>操作数栈的思想</p><h2 id="代码">2.2 代码</h2><p>原来以为递归会很取巧，结果遇到了很多细节问题。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> hasNum <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> i<span class="token operator">:</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token string">'0'</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hasNum <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>negative<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span> num<span class="token operator">=</span><span class="token punctuation">(</span>num<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> num<span class="token operator">=</span><span class="token punctuation">(</span>num<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    hasNum <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>                    num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    negative <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>hasNum <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> negative <span class="token operator">=</span> <span class="token operator">!</span>negative<span class="token punctuation">;</span>                    <span class="token keyword">else</span> negative <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    hasNum <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>                    num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lastLeft <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastLeft<span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token operator">+</span>lastLeft<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">calculate</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>lastLeft<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">calculate</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastLeft<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>栈的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> signs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        signs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                signs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                signs<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> signs<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">+</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式的值。&lt;/p&gt;
&lt;p&gt;字符串表达式可以包含左括号 &lt;code&gt;(&lt;/code&gt; ，右括号 &lt;code&gt;)&lt;/code&gt;，加号 &lt;code&gt;+&lt;/code&gt; ，减号 &lt;code&gt;-&lt;/c
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记10.md</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B010-md/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记10-md/</id>
    <published>2020-01-25T13:15:55.000Z</published>
    <updated>2020-01-27T12:32:14.408Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第十章 前端编译与优化</strong>的内容</p><p>Java中的编译可能是指：</p><ul><li><strong>前端编译</strong>：把*.java文件转变成*.class文件的过程</li><li><strong>即时编译（JIT）</strong>：运行期把字节码转变成本地机器码的过程</li><li><strong>提前编译（AOT）</strong>：直接把程序编译成与目标机器指令集相关的二进制代码的过程</li></ul><p>这一章讲的是前端编译</p><h1 id="Javac编译器">1 Javac编译器</h1><p>javac是一个由java语言编写的程序</p><h2 id="Javac的源码与调试">1.1 Javac的源码与调试</h2><p>Java6以后，Javac的源码放在了<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code></p><p><strong>Javac的工作流程</strong></p><ol><li>准备过程：初始化插入式注解处理器。</li><li>解析与填充符号表过程，包括：<br>·词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。<br>·填充符号表。产生符号地址和符号信息。 </li><li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li><li>分析与字节码生成过程，包括：<ul><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态运行过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ol><p>执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号。</p><h1 id="Java语法糖的味道">2 Java语法糖的味道</h1><h2 id="泛型">2.1 泛型</h2><h3 id="Java与C-的泛型">2.1.1 Java与C#的泛型</h3><p>Java是 <strong>“类型擦除式泛型”</strong>，C#是 <strong>“具现化式泛型”</strong>。</p><p>Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型，并且在相应的地方插入了强制转型代码。</p><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于C#的具现化式泛型，而它的唯一优势是在于实现这种泛型的影响范围上。</p><p>Java选择类型擦除主要是因为遗留代码多，向前兼容。</p><h3 id="类型擦除">2.1.2 类型擦除</h3><p>实现：泛型类原地泛型化变成裸类型</p><p>Java是简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在元素访问、修改时自动插入一些强制类型转换和检查指令。</p><p><strong>类型擦除的缺陷：</strong></p><ol><li>不支持基本类型，例如<code>ArrayList&lt;int&gt;</code>，因为无法实现int和Object互转，只能自动装箱、拆箱使用Integer，导致执行效率低。</li><li>运行期无法取到泛型类型信息，导致不能出现下列操作：<ul><li><code>if (item instanceof E) {   // 不合法，无法对泛型进行实例判断</code></li><li><code>E newItem = new E();       // 不合法，无法使用泛型创建对象</code></li><li><code>E[] itemArray = new E[10]; // 不合法，无法使用泛型创建数组</code></li></ul></li><li>方法重载即使是不同泛型类型的参数也不能作为不一样的特征签名。但是返回值类型不同实际是可以正常运行的，虽然特征签名还是一致，但class文件支持不同描述符的方法共存，后续JVM有优化。</li></ol><h3 id="值类型和未来的泛型">2.1.3 值类型和未来的泛型</h3><p>在2014年，刚好是Java泛型出现的十年之后，Oracle建立了一个名为Valhalla的语言改进项目，希望改进Java语言留下的各种缺陷（解决泛型的缺陷就是项目主要目标其中之一）。</p><p>在Valhalla项目中规划了几种不同的新泛型实现方案，在这些新的泛型设计中，泛型类型有可能被具现化，也有可能继续维持类型擦除以保持兼容（取决于采用哪种实现方案），即使是继续采用类型擦除的方案，泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用，也可以指定编译器默认要擦除哪些类型。相对于使用不同方式实现泛型，<strong>目前比较明确的是未来的Java应该会提供“值类型”（Value Type）的语言层面的支持。</strong></p><p>值类型可以与引用类型一样，具有构造函数、方法或是属性字段，等等，而它与引用类型的区别在于它<strong>在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的。</strong>更为关键的是，值类型的实例很容易实现分配在方法的调用栈上的，这意味着<strong>值类型会随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</strong></p><p>在Valhalla项目中，Java的值类型方案被称为“内联类型”，计划通过一个新的关键字inline来定义。</p><h2 id="条件编译">2.2 条件编译</h2><p>使用条件为常量的if语句，可以在编译期间过滤掉一些代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>反编译的结果</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="可变参数">2.3 可变参数</h2><p><code>public void foo(String... args){}</code></p><p>=&gt; <code>public void foo(String[] args){}</code></p><h2 id="switch-字符串和switch-enum">2.4 switch-字符串和switch-enum</h2><h3 id="switch-字符串">2.4.1 switch-字符串</h3><p>配合字符串的哈希值使用。</p><pre class=" language-java"><code class="language-java">String i <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"hello"</span><span class="token operator">:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">"world"</span><span class="token operator">:</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>反编译后</p><pre class=" language-java"><code class="language-java">String i <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token keyword">byte</span> var3 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">99162322</span><span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">113318802</span><span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">switch</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="switch-enum">2.4.2 switch-enum</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Sex<span class="token punctuation">{</span>    MALE<span class="token punctuation">,</span>FEMALE<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Sex sex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">case</span> MALE<span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> FEMALE<span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>反编译后</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* *定义一个合成类（仅jvm使用，对我们不可见） *用来映射枚举的ordina1与数组元素的关系 *枚举的ordinal表示枚举对象的序号，从0开始 *即MALE的ordinal()=0，FEMALE的ordinal()=1 */</span><span class="token keyword">static</span> <span class="token keyword">class</span> $MAP<span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//数组大小即为枚举元素个数，里面存储case用来对比的数字 </span>    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">static</span><span class="token punctuation">{</span>         map<span class="token punctuation">[</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>         map<span class="token punctuation">[</span>Sex<span class="token punctuation">.</span>FEMALE<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Sex sex<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> x <span class="token operator">=</span> $MAP<span class="token punctuation">.</span>map<span class="token punctuation">[</span>sex<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">switch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男"</span>）<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女"</span>）<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="枚举">2.5 枚举</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Sex<span class="token punctuation">{</span>    MALE<span class="token punctuation">,</span>FEMALE<span class="token punctuation">}</span></code></pre><p>实际上是编译成了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sex</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>Sex<span class="token operator">></span><span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex MALE<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex FEMALE<span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Sex<span class="token punctuation">[</span><span class="token punctuation">]</span> $VALUES<span class="token punctuation">;</span>    <span class="token keyword">static</span><span class="token punctuation">{</span>         MALE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"MALE"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         FEMALE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">(</span><span class="token string">"FEMALE"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         $VALUES <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sex</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>MALE<span class="token punctuation">,</span>FEMALE<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Sex</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> ordinal<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>ordinal<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Sex<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> $VALUES<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Sex <span class="token function">valueOf</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> Enum<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>Sex<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="try-with-resources">2.6 try-with-resources</h2><p>JDK7开始新增了对需要关闭的资源处理的特殊语法<code>try-with-resources</code>:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>资源变量<span class="token operator">=</span>创建资源对象<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>其中资源对象需要实现<code>Autocloseable</code>接口，例如<code>InputStream、OutputStream、Connection、Statement、Resultset</code>等接口都实现了<code>Autocloseable</code>，使用<code>try-with-resources</code>可以不用写finally语句块，编译器会帮助生成关闭资源代码，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">try</span><span class="token punctuation">(</span>InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"d:\\1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span><span class="token punctuation">{</span>         e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> </code></pre><p>反编译后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    InputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"d:\\1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Throwable var2 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var12<span class="token punctuation">)</span> <span class="token punctuation">{</span>        var2 <span class="token operator">=</span> var12<span class="token punctuation">;</span>        <span class="token keyword">throw</span> var12<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var11<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    var2<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>var11<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var14<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var14<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第十章 前端编译与优化&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;Java中的编译可能是指：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端编译&lt;/strong&gt;：把*.java文件转变成*.class文件的过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时编译
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode103-二叉树的锯齿形层次遍历</title>
    <link href="https://www.codetool.top/article/leetcode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode103-二叉树的锯齿形层次遍历/</id>
    <published>2020-01-24T18:52:24.000Z</published>
    <updated>2020-01-24T19:04:58.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;/ \<br>&nbsp;&nbsp;9&nbsp;&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;7  </p></blockquote><p>返回锯齿形层次遍历如下：</p><blockquote><p>[<br>&nbsp;&nbsp;[3],<br>&nbsp;&nbsp;[20,9],<br>&nbsp;&nbsp;[15,7]<br>]  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>用两个栈来交替存储某一层和下一层的节点:</p><p>读取第一个栈的时候，从左向右的读取节点，将它们的子节点从左向右入第二个栈，能使读取第二个栈的时候是以从右向左的顺序出栈的。</p><p>读取第二个栈的时候，从右向左的读取节点，将它们的子节点从右向左入第一个栈，能使读取第一个栈的时候是以从左向右的顺序出栈的。</p><p>这样交替使用两个栈，可以实现两层之间的顺序反转。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//当前层的节点按从左向右的顺序依次出栈，子节点按从左向右的顺序入second栈，实现顺序逆转</span>            cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> second<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> second<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下一层的节点按从右向左的顺序依次出栈，子节点按从右向左的顺序入first栈，实现顺序逆转</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> second<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> first<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/cod
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>愿广大国人都能平安度过这个春节</title>
    <link href="https://www.codetool.top/article/%E6%84%BF%E5%B9%BF%E5%A4%A7%E5%9B%BD%E4%BA%BA%E9%83%BD%E8%83%BD%E5%B9%B3%E5%AE%89%E5%BA%A6%E8%BF%87%E8%BF%99%E4%B8%AA%E6%98%A5%E8%8A%82/"/>
    <id>https://www.codetool.top/article/愿广大国人都能平安度过这个春节/</id>
    <published>2020-01-24T16:30:44.000Z</published>
    <updated>2020-01-24T16:51:20.114Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2020年1月25日，农历正月初一，是咱们国家的传统佳节——春节。我一直觉得春节是中国很重要的一个文化符号，我相信对于所有华人来说，春节的特殊性已经融于血液之中，是不可替代的节日。我在这里恭祝所有华人新年快乐，鼠年大吉。</p><p>同时我也希望，大家应时刻把自己的健康安全放在第一位，在2019-nCoV（武汉肺炎）肆虐之际，要时刻注意清洁卫生，出门戴好口罩，这段时间尽量避免和别人接触。</p><p>截至目前，大多数省级行政区都启动了突发公共卫生事件一级响应，这件事的重要程度不言而喻，我也有在持续关注疫情的动态。我相信只要大家齐心协力，我们一定能打好这场攻坚战，我们也不用太过恐慌，保护好自己就是最重要的。</p><p>目前已经可以看到很多市民的防范意识都有提高，我觉得我们现在做的一切都在步入正轨。</p><p>希望这个春节所有人都平平安安！武汉加油！中国加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是2020年1月25日，农历正月初一，是咱们国家的传统佳节——春节。我一直觉得春节是中国很重要的一个文化符号，我相信对于所有华人来说，春节的特殊性已经融于血液之中，是不可替代的节日。我在这里恭祝所有华人新年快乐，鼠年大吉。&lt;/p&gt;
&lt;p&gt;同时我也希望，大家应时刻把自己的
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode85-最大矩形</title>
    <link href="https://www.codetool.top/article/leetcode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode85-最大矩形/</id>
    <published>2020-01-24T05:19:04.000Z</published>
    <updated>2020-01-24T05:53:01.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong><br>[<br>&nbsp;&nbsp;[“1”,”0”,”1”,”0”,”0”],<br>&nbsp;&nbsp;[“1”,”0”,”1”,”1”,”1”],<br>&nbsp;&nbsp;[“1”,”1”,”1”,”1”,”1”],<br>&nbsp;&nbsp;[“1”,”0”,”0”,”1”,”0”]<br>]<br><strong>输出:</strong> 6  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题可以分解成若干<a href="../leetcode84-柱状图中最大的矩形/">leetcode84-柱状图中最大的矩形</a>的子问题，可以使用相同的方法。</p><p>我们从上往下动态规划二维数组，每增加一行就会出现不同的柱状区域。</p><p><img src="https://api.codetool.top/img/15798449822257.png" alt></p><p>从每一次得到的最大矩形面积中获取最大值，就是该题的答案</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximalRectangle</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> line<span class="token operator">:</span>matrix<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//每增加一行改变height数组</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span><span class="token punctuation">)</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max<span class="token operator">=</span>area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt;&lt;br
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode84-柱状图中最大的矩形</title>
    <link href="https://www.codetool.top/article/leetcode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>https://www.codetool.top/article/leetcode84-柱状图中最大的矩形/</id>
    <published>2020-01-23T19:01:50.000Z</published>
    <updated>2020-01-23T19:12:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://api.codetool.top/img/15798062014581.png" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://api.codetool.top/img/15798062338069.png" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [2,1,5,6,2,3]<br><strong>输出：</strong> 10</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode42-接雨水/">leetcode42-接雨水</a>较为相似。</p><p>对于每列来说，以当前列高为高的最大矩形区域的宽度区域为被左边最近较矮一列和右边最近较矮一列围起来的宽度。</p><p>如果两边有一边没有比当前列矮的一列，则左边算作-1，右边算作length。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果左边一列比当前列矮，则left就等于左边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着左边这列的left一直查找过去，直到找到比当前列低的一列</span>                left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果右边一列比当前列矮，则right就等于右边一列的下标。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>heights<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//否则沿着右边这列的right一直查找过去，直到找到比当前列低的一列</span>                right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>  right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>length<span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> area<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.to
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记09</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B009/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记09/</id>
    <published>2020-01-23T13:14:13.000Z</published>
    <updated>2020-01-25T13:15:49.781Z</updated>
    
    <content type="html"><![CDATA[<p>续<a href="../深入理解java虚拟机第三版读书笔记08">深入理解java虚拟机第三版读书笔记08</a></p><h1 id="类加载器">1 类加载器</h1><p><strong>通过一个类的全限定名来获取描述该类的二进制字节流</strong>称为类加载器。类加载器可以用户自定义，是java语言流行的一项原因</p><h2 id="类与类加载器">1.1 类与类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>或者说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><h2 id="双亲委派模型">1.2 双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap<br>ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p><p>自JDK 1.2以来，Java一直保持着<strong>三层类加载器、双亲委派的类加载架构。</strong></p><p>对于JDK8及之前版本的Java，绝大多数程序都会使用到以下3个系统提供的类加载器来进行加载</p><ul><li>启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在 <code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</li><li>扩展类加载器（Extension Class Loader）：这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application Class Loader）：这个类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是<strong>程序中默认的类加载器</strong>。</li></ul><p><img src="https://api.codetool.top/img/15797991285820.png" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。（子加载器将部分动作委派给父加载器）</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是<strong>把这个请求委派给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有<strong>当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><p>好处是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类<code>java.lang.Object</code>都是交给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>实现双亲委派模型的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先，检查请求的类是否已经被加载过了</span>    Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//代表找到了启动类加载器</span>                c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果父类加载器抛出ClassNotFoundException</span>            <span class="token comment" spellcheck="true">// 说明父类加载器无法完成加载请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在父类加载器无法加载时</span>            <span class="token comment" spellcheck="true">// 再调用本身的findClass方法来进行类加载</span>            c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//findClass实现加载过程</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="破坏双亲委派模型">1.3 破坏双亲委派模型</h2><p><strong>为什么要破坏双亲委派模型？</strong></p><ol><li><p>如果基础类型要调用回用户的代码。</p><p> 实例：</p><ul><li><p>启动类加载器加载的DriverManager在<code>loadInitialDriver()</code>加载<code>com.mysql.jdbc.Driver</code>应用程序类</p></li><li><p>JNDI服务对资源进行查找和集中管理，可以通过接口名获取所有实现类，需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。</p></li></ul></li><li><p>JDK9的模块化实现热部署。</p></li></ol><p><strong>解决方案：</strong></p><p>线程上下文类加载器（Thread Context ClassLoader）。<br>这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，<br>如果创建线程时还未设置，它将会从父线程中继承一个，<br>如果在应用程序的全局范围内都没有设置过的话，那<strong>这个类加载器默认就是应用程序类加载器。</strong></p><p>使用<code>Class.forName(String name, boolean initialize,ClassLoader loader)</code>方法使用指定的类加载器加载类。</p><h2 id="自定义类加载器">1.4 自定义类加载器</h2><ol><li>继承ClassLoader父类</li><li>要遵从双亲委派模型，重写findClass方法。</li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用该类加载器的loadClass方法</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        String path <span class="token operator">=</span> <span class="token string">"e:\\mypath\\"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ByteArrayOutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Files<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="补充">1.5 补充</h2><ul><li><code>Class.getClassLoader()</code>可以获取一个类的加载器，启动类加载器是null</li><li><code>-Xbootclasspath/a:&lt;追加路径&gt;</code>可以在<code>JAVA_HOME/lib</code>的基础上追加路径让启动类加载器加载。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;续&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记08&quot;&gt;深入理解java虚拟机第三版读书笔记08&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;类加载器&quot;&gt;1 类加载器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;通过一个类的全限定名来获取描述该类的二进制字节流&lt;/strong&gt;称为类加
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码实例探究</title>
    <link href="https://www.codetool.top/article/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.codetool.top/article/Java字节码实例探究/</id>
    <published>2020-01-23T10:22:05.000Z</published>
    <updated>2020-01-23T13:11:56.515Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a>中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。</p><p>java源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">40000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个类有方法有实例变量有静态变量，在JDK8环境下编译后的字节码开头部分如下图：</p><p><img src="https://api.codetool.top/img/15797791725139.png" alt="该文件开头部分"></p><p>我们来逐字节分析：</p><h1 id="魔数、次版本号、主版本号">1 魔数、次版本号、主版本号</h1><p>00~03：<code>CA FE BA BE</code>，魔数。</p><p>04~05：<code>00 00</code> Minor Version，次版本号<br>06~07：<code>00 34</code> 十进制52，Major Version，主版本号，两者对应JDK8</p><h1 id="常量池">2 常量池</h1><p>08~09：<code>00 2F</code> 十进制47，代表常量池内项的数量。</p><p>10开始为常量池中的各表：</p><p><strong>#1</strong><br>0A：<code>0A</code> 十进制10，代表<code>CONSTANT_Methodref_info</code>类型，<br>0B~0E：<code>00 0A 00 1E</code> #10，#30</p><p><strong>#2</strong><br>0F：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>10~13：<code>00 09 00 1F</code> #9，#31</p><p><strong>#3</strong><br>14：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>15~18：<code>00 20 00 21</code> #32，#33</p><p><strong>#4</strong><br>19：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>1A~1D：<code>00 09 00 22</code> #9，#34</p><p><strong>#5</strong><br>1E：<code>0A</code> 十进制9，代表<code>CONSTANT_Methodref_info</code>类型，<br>1F~22：<code>00 23 00 24</code> #35，#36</p><p><strong>#6</strong><br>1E：<code>03</code> 十进制3，代表<code>CONSTANT_Integer_info</code>类型，<br>15~18：<code>00 00 9C 40</code> 40000</p><p><strong>#7</strong><br>28：<code>09</code> 十进制9，代表<code>CONSTANT_Fieldref_info</code>类型，<br>29~2C：<code>00 09 00 25</code> #9，#37</p><p><strong>#8</strong><br>2D：<code>08</code> 十进制8，代表<code>CONSTANT_String_info</code>类型，<br>2E~2F：<code>00 26</code> #38</p><p><strong>#9</strong><br>30：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>31~32：<code>00 27</code> #39</p><p><strong>#10</strong><br>33：<code>07</code> 十进制7，代表<code>CONSTANT_Class_info</code>类型，<br>34~35：<code>00 28</code> #40</p><p><strong>#11</strong><br>36：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>37~38：<code>00 01</code>代表长度为1，39：<code>69</code> 代表字符<code>&#39;i&#39;</code></p><p><strong>#12</strong><br>3A：<code>01</code> 十进制1，代表<code>CONSTANT_Utf8_info</code>类型，<br>3B~3C：<code>00 01</code>代表长度为1，3D：<code>49</code> 代表字符<code>&#39;I&#39;</code></p><p>剩余常量池的项我们用javap得到（其实累了）：</p><pre><code>#13 = Utf8               j#14 = Utf8               str#15 = Utf8               Ljava/lang/String;#16 = Utf8               &lt;init&gt;#17 = Utf8               ()V#18 = Utf8               Code#19 = Utf8               LineNumberTable#20 = Utf8               LocalVariableTable#21 = Utf8               this#22 = Utf8               LMain;#23 = Utf8               main#24 = Utf8               ([Ljava/lang/String;)V#25 = Utf8               args#26 = Utf8               [Ljava/lang/String;#27 = Utf8               &lt;clinit&gt;#28 = Utf8               SourceFile#29 = Utf8               Main.java#30 = NameAndType        #16:#17        // &quot;&lt;init&gt;&quot;:()V#31 = NameAndType        #11:#12        // i:I#32 = Class              #41            // java/lang/System#33 = NameAndType        #42:#43        // out:Ljava/io/PrintStream;#34 = NameAndType        #14:#15        // str:Ljava/lang/String;#35 = Class              #44            // java/io/PrintStream#36 = NameAndType        #45:#46        // println:(Ljava/lang/String;)V#37 = NameAndType        #13:#12        // j:I#38 = Utf8               Hello World!#39 = Utf8               Main#40 = Utf8               java/lang/Object#41 = Utf8               java/lang/System#42 = Utf8               out#43 = Utf8               Ljava/io/PrintStream;#44 = Utf8               java/io/PrintStream#45 = Utf8               println#46 = Utf8               (Ljava/lang/String;)V</code></pre><h1 id="访问标志、类索引、父类索引、接口索引集合">3 访问标志、类索引、父类索引、接口索引集合</h1><p>跳过常量池，到了<strong>访问标志：</strong></p><p>01C1~01C2：<code>00 21</code>，代表<code>ACC_SUPER</code>（0x0020）和<code>ACC_PUBLIC</code>（0x0001）。</p><p>接着是<strong>类索引：</strong></p><p>01C3~01C4：<code>00 09</code> 代表常量池中#9，#9又指向#39，可以得知是Main，即类名</p><p><strong>父类索引：</strong></p><p>01C5~01C6：<code>00 0A</code> 代表常量池中#10，#10又指向#40，可以得知是<code>java/lang/Object</code></p><p><strong>接口索引集合：</strong></p><p>01C7~01D8：<code>00 00</code> 代表接口索引集合中没有数据，长度是0</p><h1 id="字段表集合">4 字段表集合</h1><p>01C9~01CA: <code>00 03</code> 十进制3，代表字段表中有三项数据：</p><p>第一个字段：</p><p>01CB~01CC: <code>00 02</code> ，访问标志，代表<code>ACC_PRIVATE</code>（0x0002）<br>01CD~01CE：<code>00 0B</code> ，name_index，指向常量池#11，#11代表<code>&#39;i&#39;</code><br>01CF~01D0：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D1~01D2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第二个字段：</p><p>01D3~01D4: <code>00 0A</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PRIVATE</code>（0x0002）<br>01D5~01D6：<code>00 0D</code> ，name_index，指向常量池#13，#13代表<code>&#39;j&#39;</code><br>01D7~01D8：<code>00 0C</code> , discriptor_index，指向常量池#12，#12代表<code>&#39;I&#39;</code>（即int类型）<br>01D9~01DA：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><p>第三个字段：</p><p>01DB~01DC: <code>00 09</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）和<code>ACC_PUBLIC</code>（0x0001）<br>01DD~01DE：<code>00 0E</code> ，name_index，指向常量池#14，#14代表<code>&quot;str&quot;</code><br>01DF~01E0：<code>00 0F</code> , discriptor_index，指向常量池#15，#15代表<code>&quot;Ljava/lang/String;&quot;</code>（即String类型）<br>01E1~01E2：<code>00 00</code> , attributes_count，代表该字段无属性表。  </p><h1 id="方法表集合">5 方法表集合</h1><p>01E3~01E4：<code>00 03</code> ，十进制3，代表方法表中有三项数据：</p><p><strong>第一个方法：</strong></p><p>01E5~01E6: <code>00 01</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）<br>01E7~01E8：<code>00 10</code> ，name_index，指向常量池#16，#16代表<code>&quot;&lt;init&gt;&quot;</code>（即对象构造器）<br>01E9~01EA：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参、无返回值）<br>01EB~01EC：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>01ED~01EE: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>01EF~01F2：<code>00 00 00 39</code>，代表Code内容长度为57个字节。</p><p>接下来57个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>01F3~022B</p><pre><code>Code:stack=2, locals=1, args_size=1    0: aload_0    1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V    4: aload_0    5: bipush        10    7: putfield      #2                  // Field i:I    10: returnLineNumberTable:    line 7: 0    line 8: 4LocalVariableTable:    Start  Length   Slot    Name    Signature    0      11       0       this    LMain;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>aload_0      </p></blockquote><p>将局部变量表slot 0加载到操作数栈，那么局部变量表slot 0原来存放的是什么呢？非静态方法局部变量表0位置一开始都是存放的this，即调用方法的当前对象。这句话就是把this入操作数栈。</p><blockquote><p>invokespecial #1</p></blockquote><p>this调用#1代表的方法，我们查常量表#1，#1又指向#10和#30，#10指向#40，是<code>java/lang/Object</code>，#30是<code>&quot;&lt;init&gt;&quot;:()V</code>，即调用父类Object的构造方法。</p><blockquote><p>aload_0</p></blockquote><p>再次加载this</p><blockquote><p>bipush 10</p></blockquote><p>将常量10压入操作数栈。</p><blockquote><p>putfield #2</p></blockquote><p>putfield是设置对象的字段值，通过查常量表，#2代表<code>Main</code>中的<code>i:I</code>，这句话就把栈里的两个操作数：<code>10</code>设置给<code>this.i</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第二个方法：</strong></p><p>022C~022D: <code>00 09</code> ，访问标志，代表<code>ACC_PUBLIC</code>（0x0001）和<code>ACC_STATIC</code>（0x0008）<br>022E~022F：<code>00 17</code> ，name_index，指向常量池#23，#23代表<code>&quot;main&quot;</code><br>0230~0231：<code>00 18</code> , discriptor_index，指向常量池#24，#24代表<code>&quot;([Ljava/lang/String;)V&quot;</code>（即参数为String数组、无返回值）<br>0232~0233：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>0234~0235: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>0236~0239：<code>00 00 00 38</code>，代表Code内容长度为56个字节。</p><p>接下来56个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>023A~0271</p><pre><code>Code:stack=2, locals=1, args_size=1    0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;    3: getstatic     #4                  // Field str:Ljava/lang/String;    6: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V    9: returnLineNumberTable:    line 12: 0    line 13: 9LocalVariableTable:    Start  Length  Slot  Name   Signature        0      10     0  args   [Ljava/lang/String;</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>getstatic #3      </p></blockquote><p>获取一个类的静态字段，通过查常量表可知#3是<code>java/lang/System</code>的<code>out:Ljava/io/PrintStream;</code>即获取<code>System.out</code></p><blockquote><p>getstatic #4</p></blockquote><p>获取一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>即获取str字段。</p><blockquote><p>invokevirtual #5</p></blockquote><p>调用#5方法，通过查常量表可知#5是<code>java/io/PrintStream</code>的<code>println:(Ljava/lang/String;)V</code>，即在操作栈的基础上调用<code>System.out.println(str)</code></p><blockquote><p>return</p></blockquote><p>返回</p><p><strong>第三个方法：</strong></p><p>0272~0273: <code>00 08</code> ，访问标志，代表<code>ACC_STATIC</code>（0x0008）<br>0274~0275：<code>00 1B</code> ，name_index，指向常量池#27，#27代表<code>&quot;&lt;clinit&gt;&quot;</code>（即类构造器）<br>0276~0277：<code>00 11</code> , discriptor_index，指向常量池#17，#17代表<code>&quot;()V&quot;</code>（即无参无返回值）<br>0278~0279：<code>00 01</code> , attributes_count，代表属性表中有一项数据。<br>027A~027B: <code>00 12</code> ，attribute_name_index，指向常量池#18，#18代表<code>&quot;Code&quot;</code>（即Code属性）<br>027C~027F：<code>00 00 00 27</code>，代表Code内容长度为39个字节。</p><p>接下来39个字节我们不查表逐一翻译，查看javap提供的内容：</p><p>0280~02A6</p><pre><code>Code:stack=1, locals=0, args_size=0    0: ldc           #6                  // int 40000    2: putstatic     #7                  // Field j:I    5: ldc           #8                  // String Hello World!    7: putstatic     #4                  // Field str:Ljava/lang/String;    10: returnLineNumberTable:    line 9: 0    line 10: 5</code></pre><p>我们来解释一下它的字节码指令：</p><blockquote><p>ldc #6     </p></blockquote><p>把一个常量#6加载到操作数栈，通过查常量表可知#6是40000。</p><blockquote><p>putstatic #7</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#7是<code>Main</code>的<code>j:I</code>，即设置j的值为40000。（注意这里与第一个方法不同的是，设置小于等于short最大值的值的时候常数放在字节码中，而大于short最大值的常量放在常量表中）</p><blockquote><p>ldc #8</p></blockquote><p>把一个常量#8加载到操作数栈，通过查常量表可知#8是<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>putstatic #4</p></blockquote><p>设置一个类的静态字段，通过查常量表可知#4是<code>Main</code>的<code>str:Ljava/lang/String;</code>，即将str的值设置为<code>&quot;Hello World!&quot;</code>。</p><blockquote><p>return</p></blockquote><p>返回</p><h1 id="属性表">6 属性表</h1><p>02A7~02A8：<code>00 01</code> attributes_count，代表属性表中有一项数据<br>02A9~02AA：<code>00 1C</code> attribute_name_index，指向常量池#28，#28代表<code>&quot;SourceFile&quot;</code>（记录源文件名称）<br>02AB~02AE: <code>00 00 00 02</code> 代表属性内容长度为2个字节。<br>02AF~02B0: <code>00 1D</code> 代表属性的值，指向常量池#29，#29代表<code>&quot;Main.java&quot;</code>  </p><p>到此，该class文件的字节码全部分析完</p><p><img src="https://api.codetool.top/img/15797822431714.png" alt="该文件结尾部分"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;../深入理解java虚拟机第三版读书笔记06&quot;&gt;深入理解java虚拟机第三版读书笔记06&lt;/a&gt;中介绍了class文件结构，这里我们动手实践，编译一个类查看一下它的字节码。&lt;/p&gt;
&lt;p&gt;java源码：&lt;/p&gt;
&lt;pre class=&quot; language
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="Class文件" scheme="https://www.codetool.top/tags/Class%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode71-简化路径</title>
    <link href="https://www.codetool.top/article/leetcode71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.codetool.top/article/leetcode71-简化路径/</id>
    <published>2020-01-23T06:40:01.000Z</published>
    <updated>2020-01-23T07:10:01.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> “/home/“<br><strong>输出：</strong> “/home”<br><strong>解释：</strong> 注意，最后一个目录名后面没有斜杠。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> “/../“<br><strong>输出：</strong> “/“<br><strong>解释：</strong> 从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> “/home//foo/“<br><strong>输出：</strong> “/home/foo”<br><strong>解释：</strong> 在规范路径中，多个连续斜杠需要用一个斜杠替换。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong> “/a/./b/../../c/“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong> “/a/../../b/../c//.//“<br><strong>输出：</strong> “/c”  </p></blockquote><p><strong>示例 6：</strong></p><blockquote><p><strong>输入：</strong> “/a//b////c/d//././/..”<br><strong>输出：</strong> “/a/b/c”  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>使用栈的思想来解决该问题，将给定的字符串使用<code>&quot;/&quot;</code>分割，会得到由空字符串、<code>&quot;.&quot;</code>、<code>&quot;..&quot;</code>、目录名组成的字符串数组，然后根据它们的特点对元素进行入栈出栈等操作。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">simplifyPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//因为最后要遍历栈，这里用ArrayList来模拟栈</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>dirs<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//空字符串和"."都表示当前目录</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">||</span> i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//".."表示上一级目录，出栈一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>                     stack<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//其他目录名入栈</span>            <span class="token keyword">else</span> stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过"/"连接起来</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String i<span class="token operator">:</span>stack<span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;以 Unix 风格给出一个文件的&lt;strong&gt;绝对路径&lt;/strong&gt;，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（&lt;code&gt;.&lt;/code&gt;）表示当前目录本身；此外
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://www.codetool.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode42-接雨水</title>
    <link href="https://www.codetool.top/article/leetcode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://www.codetool.top/article/leetcode42-接雨水/</id>
    <published>2020-01-22T17:09:42.000Z</published>
    <updated>2020-01-22T17:39:56.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://api.codetool.top/img/15797131314307.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong> [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong> 6</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一列能存下的雨水单位等于<code>左右最高两列当中的较矮一列与当前高度的高度差</code>。</p><p><img src="https://api.codetool.top/img/15797135878580.png" alt></p><p>如图，第五列的积雨水量，等于左边最高一列（第四列left）和右边最高一列（第八列right）的较矮一列（left）与当前列高度的高度差（2-1=1）</p><p>如果两边有一边没有比当前列高的列，则当前列不会积水。</p><h2 id="代码">2.2 代码</h2><p>我一开始是这样写的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新左边所有列的right</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//更新右边所有列的left</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token operator">||</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null <span class="token operator">||</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>时间复杂度达到了N<sup>2</sup>级别，那么如何优化呢？</p><ol><li>不必使用null来表示没有比当前列高的列，即使两列相等，高度差也是0，相当于不积水。</li><li>利用动态规划的思想，如果前一列的left比当前列高，则当前列的left也等于前一列的left。对于right也是一样的。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        right<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从左向右更新left</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从右向左更新right</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            total <span class="token operator">+=</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15797131314307.png&quot; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode95-不同的二叉搜索树II</title>
    <link href="https://www.codetool.top/article/leetcode95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/"/>
    <id>https://www.codetool.top/article/leetcode95-不同的二叉搜索树II/</id>
    <published>2020-01-22T15:12:01.000Z</published>
    <updated>2020-01-22T15:20:18.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong><br>[<br>&nbsp;&nbsp;[1,null,3,2],<br>&nbsp;&nbsp;[3,2,null,1],<br>&nbsp;&nbsp;[3,1,null,null,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[1,null,2,null,3]<br>]<br><strong>解释:</strong><br>以上的输出对应以下 5 种不同结构的二叉搜索树：<br>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题的思想和<a href="../leetcode96-不同的二叉搜索树">leetcode96-不同的二叉搜索树</a>类似，通过各种左右组合情况得到为一个list返回。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">generateTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>TreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> <span class="token function">nodesInRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">></span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含null的list使得for嵌套能正常工作</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//返回一个包含本数字的list</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自由组合左子树和右子树的情况</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode left<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>TreeNode right<span class="token operator">:</span><span class="token function">nodesInRange</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>                    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode96-不同的二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode96-不同的二叉搜索树/</id>
    <published>2020-01-22T14:15:52.000Z</published>
    <updated>2020-01-22T15:16:07.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> 5<br><strong>解释:</strong> 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:  </p><p>&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>对于每一个n对应的数量应该是相同的，我们从1~n中任选一个做根节点（假设是第i个），那么左右两边各有<code>F(i-1)</code>和<code>F(n-i)</code>中情况，将它们相乘就是此时第i个元素做根节点的情况。如此递归计算总数量。</p><h2 id="代码">2.2 代码</h2><p>我一开始的写法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是发现这样写消耗非常多时间，leetcode执行用时<code>1700 ms</code>。</p><p>优化的思路主要是：</p><ol><li>end和start并不关键，只要start-end（即范围内的数字数量,用n表示）相同，对应的值就相同。</li><li>假如优化上条，很多<code>F(n)</code>单元会被重复计算，可以使用数组做缓存。</li></ol><p>优化后：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">+=</span> <span class="token function">kindsCount</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">kindsCount</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 3&lt;br&gt;&lt;strong
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记08</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B008/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记08/</id>
    <published>2020-01-22T08:54:44.000Z</published>
    <updated>2020-01-22T19:37:45.581Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第七章 虚拟机类加载机制</strong>的内容</p><h1 id="概述">1 概述</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。在Java语言里面，<strong>类型的加载、连接和初始化过程都是在程序运行期间完成的</strong>，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性。</p><h1 id="类加载的时机">2 类加载的时机</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载<br>（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://api.codetool.top/img/15796958251344.png" alt></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而<strong>解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始</strong>，这是为了支持Java语言的运行时绑定特性。</p><p>加载阶段并没有严格规定开始的时机，而有且只有六种情况必须立即对类进行“初始化”：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>使用java.lang.reflect包的方法对类型进行反射调用</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p>这六种操作称为主动引用，其他引用称为被动引用，不会触发初始化。</p><p>接口的初始化稍有不同：对于第三点，接口只有真正用到父接口的时候才会使父接口初始化。</p><h1 id="类加载的过程">3 类加载的过程</h1><h2 id="加载">3.1 加载</h2><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>其中第一步自由度就很高，从ZIP压缩包中读取、从网络中获取、运行时计算生成等等。</p><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，<strong>开发人员通过定义自己的类加载器去控制字节流的获取方式</strong>（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><p><strong>数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。</strong>但数组类与类加载器仍然有很密切的关系，因为<strong>数组类的元素类型（指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载</strong>，一个数组类（下面简称为C）创建过程遵循以下规则：</p><ul><li>如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li><li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。</li><li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li></ul><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，但加载阶段提前开始于连接阶段。</p><h2 id="验证">3.2 验证</h2><p>这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>尽管Java代码编译时会拒绝编译一些致命错误，但字节码可以被轻易修改，字节码检查也是必不可少的。</p><h3 id="文件格式验证">3.2.1 文件格式验证</h3><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>……</li></ul><p>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有<strong>通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</strong></p><h3 id="元数据验证">3.2.2 元数据验证</h3><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li><li>……</li></ul><p>第二阶段的主要目的是<strong>对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</strong></p><h3 id="字节码验证">3.2.3 字节码验证</h3><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li></ul><p>目的是通过数据流分析和控制流分析，<strong>确定程序语义是合法的、符合逻辑的</strong>，不会危害虚拟机安全。</p><h3 id="符号引用验证">3.2.4 符号引用验证</h3><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作在解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性（private、protected、public、&lt;package&gt;）是否可被当前类访问。</li><li>……</li></ul><p>符号引用验证的主要目的是<strong>确保解析行为能正常执行</strong>，如果无法通过符号引用验证，Java虚拟机将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常，典型的如：<code>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError</code>等。</p><p>验证阶段不是必需的，如果程序运行使用的所有字节码都是安全的，可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备">3.3 准备</h2><p>准备阶段是正式<strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</strong>。（初始值指的是零值，类初始化阶段中调用类构造器方法才会对类变量赋值）</p><p>特殊情况：如果字段存在ConstantValue属性（声明为final，会在字段表的属性表中增加一项ConstantValue属性），那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p><h2 id="解析">3.4 解析</h2><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>。</p><p>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><p>而符号引用只是能无歧义定位到目标的一套自定符号表述。</p><p>解析阶段发生的具体时间并未强制规定，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>对同一个符号引用可以进行多次解析请求，虚拟机也可以缓存解析的结果，但对于<code>invokedynamic</code>指令不能缓存，执行到该条指令时才能解析，它对应的引用称为“动态调用点限定符”。</p><blockquote><p>invokedynamic本是为了支持如JRuby、 Scala等动态语言，JDK8后Lambda表达式和接口的默认方法的底层也会用到invokedynamic。</p></blockquote><h3 id="类或接口的解析">3.4.1 类或接口的解析</h3><p>将符号代表的类的全限定名交给当前类的类加载器来加载，如果是数组类型，则是加载它的数组元素类型，再由虚拟机生成对应的数组类型。</p><p>之后，验证当前类是否具有对该类的访问权限，若没有抛出异常<code>java.lang.IllegalAccessError</code></p><h3 id="字段解析">3.4.2 字段解析</h3><p>要解析一个未被解析过的字段符号引用，会先找到字段表中对应的所属类并解析。</p><ol><li>如果该类本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，如果该类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则。如果该类不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p><p>如果一个字段具有多义性（如果不严格按照顺序可能多种方式都能找到），javac可能会拒绝编译。</p><h3 id="方法解析">3.4.3 方法解析</h3><p>方法解析也会先找到方法表中对应的所属类并解析。</p><ol><li>类的方法和接口的方法符号引用的常量类型定义是分开的，如果发现该类是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError 异常。</li><li>如果通过了第一步，在该类中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该类的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该类实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明该类是一个抽象类，这时候查找结束，抛出 <code>java.lang.AbstractMethodError</code>异常。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p><h3 id="接口方法解析">3.4.4 接口方法解析</h3><p>接口方法解析也会先找到方法表中对应的所属类并解析。</p><ol><li>与类的方法解析相反，如果发现该类是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>否则，在该接口中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>否则，在该接口的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>如果多重继承多个父接口都有该方法，可能会返回其中一个方法的直接引用，在编译期间javac也可能拒绝编译。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><p>JDK9模块化之后也可能抛出<code>java.lang.IllegalAccessError</code>异常。</p><h2 id="初始化">3.5 初始化</h2><p>初始化阶段就是<strong>执行类构造器&lt;clinit&gt;()方法的过程。</strong>&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p><p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，顺序为出现的顺序。</p><p>Java虚拟机会保证在子类的&lt;clinit&gt;()方法执行前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在Java虚拟机中第一个被执行的&lt;clinit&gt;()方法的类型肯定是java.lang.Object。</p><p>这个方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</p><p>在多线程环境下，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第七章 虚拟机类加载机制&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode779-第K个语法符号</title>
    <link href="https://www.codetool.top/article/leetcode779-%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <id>https://www.codetool.top/article/leetcode779-第K个语法符号/</id>
    <published>2020-01-21T18:06:24.000Z</published>
    <updated>2020-01-21T18:11:32.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><p>给定行数 <code>N</code> 和序数 <code>K</code>，返回第 <code>N</code> 行中第 <code>K</code>个字符。（<code>K</code>从1开始）</p><p><strong>例子：</strong></p><blockquote><p><strong>输入:</strong> N = 1, K = 1<br><strong>输出:</strong> 0  </p><p><strong>输入:</strong> N = 2, K = 1<br><strong>输出:</strong> 0</p><p><strong>输入:</strong> N = 2, K = 2<br><strong>输出:</strong> 1  </p><p><strong>输入:</strong> N = 4, K = 5<br><strong>输出:</strong> 1   </p><p><strong>解释:</strong><br>第一行: 0<br>第二行: 01<br>第三行: 0110<br>第四行: 01101001  </p></blockquote><p><strong>注意:</strong></p><ol><li><code>N</code> 的范围 <code>[1, 30]</code>.</li><li><code>K</code> 的范围 <code>[1, 2^(N-1)]</code>.</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归分析要查找的字符是上一行的哪个数字得到的，然后根据奇偶性得到目标字符</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthGrammar</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>K<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">kthGrammar</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">kthGrammar</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;在第一行我们写上一个 &lt;code&gt;0&lt;/code&gt;。接下来的每一行，将前一行中的&lt;code&gt;0&lt;/code&gt;替换为&lt;code&gt;01&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt;替换为&lt;code&gt;10&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode70-爬楼梯</title>
    <link href="https://www.codetool.top/article/leetcode70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>https://www.codetool.top/article/leetcode70-爬楼梯/</id>
    <published>2020-01-21T05:58:10.000Z</published>
    <updated>2020-01-21T06:11:07.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong> 给定 n 是一个正整数。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 2<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有两种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶<br>2.  2 阶  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> 有三种方法可以爬到楼顶。<br>1.  1 阶 + 1 阶 + 1 阶<br>2.  1 阶 + 2 阶<br>3.  2 阶 + 1 阶</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>实际上是斐波那契数问题：</p><p>假设现在要走三阶楼梯，那么第一次走一阶楼梯时，还有f(2)种可能性，第一次走两阶楼梯时，还有f(1)种可能性，则f(3)=f(2)+f(1)，以此类推。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">climbStairs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode509-斐波那契数</title>
    <link href="https://www.codetool.top/article/leetcode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode509-斐波那契数/</id>
    <published>2020-01-20T18:39:37.000Z</published>
    <updated>2020-01-21T06:11:11.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p></blockquote><p>给定 <code>N</code>，计算 <code>F(N)</code>。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 2<br><strong>输出：</strong> 1<br><strong>解释：</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 3<br><strong>输出：</strong> 2<br><strong>解释：</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 4<br><strong>输出：</strong> 3<br><strong>解释：</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.</p></blockquote><p><strong>提示：</strong></p><ul><li><code>0 ≤ N ≤ 30</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，由于很多递归单元会被重复计算，需要做缓存。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为&lt;strong&gt;斐波那契数列&lt;/strong&gt;。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
