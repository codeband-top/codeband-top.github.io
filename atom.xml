<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-10T16:01:00.702Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>StringTable性能调优</title>
    <link href="https://www.codetool.top/article/stringtable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>https://www.codetool.top/article/stringtable性能调优/</id>
    <published>2020-01-10T14:55:10.000Z</published>
    <updated>2020-01-10T16:01:00.702Z</updated>
    
    <content type="html"><![CDATA[<p>StringTable是jvm运行时常量池表中的字符串常量池，<a href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B002/#toc-heading-14">深入理解java虚拟机第三版读书笔记02</a>有相关的介绍。</p><p>无论是运行时常量表还是StringTable，他们内部都是通过哈希表来保证字符串常量的唯一性，可以通过配置jvm参数<code>-XX:+PrintStringTableStatistics</code>来查看常量表的详细信息。</p><h1 id="验证StringTable的垃圾回收">1 验证StringTable的垃圾回收</h1><p>首先我们运行下面这段代码：<br>使用虚拟机参数：<code>-XX:+PrintGCDetails -XX:+PrintStringTableStatistics</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>截取部分输出：</p><pre><code>StringTable statistics:Number of buckets       :     60013 =    480104 bytes, avg   8.000Number of entries       :     11695 =    280680 bytes, avg  24.000Number of literals      :     11695 =    635176 bytes, avg  54.312</code></pre><p>可见StringTable总共有60013个桶，10000个字符串全部进入常量池，且没有垃圾回收的信息输出。</p><p>那我们让进入堆的内存适度减小，让它有可能发生堆空间不足的情况：</p><p>使用虚拟机参数：<code>-Xmx10m -XX:+PrintGCDetails -XX:+PrintStringTableStatistics</code>再次运行上面那段代码</p><p>截取部分输出：</p><pre><code>[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;504K(2560K)] 2048K-&gt;720K(9728K), 0.0014597 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </code></pre><pre><code>Number of buckets       :     60013 =    480104 bytes, avg   8.000Number of entries       :      7981 =    191544 bytes, avg  24.000Number of literals      :      7981 =    456584 bytes, avg  57.209</code></pre><p>可以看到，这次10000个字符串并没有全部进入常量池，一部分被回收掉了。</p><h1 id="调整桶的个数">2 调整桶的个数</h1><p>我们都知道哈希表的存取效率和桶的个数是紧密相关的，桶的个数太大则空间有可能浪费，太小则可能效率过低。</p><p>我们运行这段代码：<br>使用虚拟机参数<code>-XX:+PrintStringTableStatistics</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">500000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"cost:"</span><span class="token operator">+</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000000000.0</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>截取部分输出：</p><pre><code>cost:0.0997132s</code></pre><pre><code>StringTable statistics:Number of buckets       :     60013 =    480104 bytes, avg   8.000Number of entries       :    501704 =  12040896 bytes, avg  24.000Number of literals      :    501704 =  28075720 bytes, avg  55.961</code></pre><p>我们使用虚拟机参数来调整桶的个数：<br>使用虚拟机参数<code>-XX:StringTableSize=1009 -XX:+PrintStringTableStatistics</code></p><pre><code>cost:3.1234771sNumber of buckets       :      1009 =      8072 bytes, avg   8.000Number of entries       :    503097 =  12074328 bytes, avg  24.000Number of literals      :    503097 =  28176912 bytes, avg  56.007</code></pre><p>可见消耗时间明显增大</p><p>我们再将桶的个数调至更大：<br>使用虚拟机参数<code>-XX:StringTableSize=1009 -XX:+PrintStringTableStatistics</code></p><p>截取部分输出：</p><pre><code>cost:0.0879392s</code></pre><pre><code>StringTable statistics:Number of buckets       :   1000000 =   8000000 bytes, avg   8.000Number of entries       :    501704 =  12040896 bytes, avg  24.000Number of literals      :    501704 =  28075720 bytes, avg  55.961</code></pre><p>可见消耗时间有所减少</p><h1 id="是否该使用intern方法将字符串入池">3 是否该使用intern方法将字符串入池</h1><p>我们运行下面这段代码，使用jvisualvm查看堆内存的变化情况：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//每个字符串搞出10次</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">500000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"part "</span><span class="token operator">+</span>n<span class="token operator">+</span><span class="token string">" has done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://api.codetool.top/img/15786715819102.png" alt="初始状态"></p><p><img src="https://api.codetool.top/img/1578671645159.png" alt="结束状态"></p><p>可见String和char[]占用了极高内存（接近300M）</p><p>我们在原来代码的基础上使用intern方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//每个字符串搞出10次</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">500000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"part "</span><span class="token operator">+</span>n<span class="token operator">+</span><span class="token string">" has done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再次查看运行结束后的内存占用：</p><p><img src="https://api.codetool.top/img/15786718501205.png" alt></p><p>可见这次String和char[]占用的内存接近100M，相比减少很多。</p><p>所以当java程序可能引用很多相同内容的字符串的时候，最好将字符串入池，能有效减轻内存负担，所增开销仅是intern方法内部开销。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;StringTable是jvm运行时常量池表中的字符串常量池，&lt;a href=&quot;https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="字符串常量池" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode145-二叉树的后序遍历</title>
    <link href="https://www.codetool.top/article/leetcode145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode145-二叉树的后序遍历/</id>
    <published>2020-01-10T08:03:17.000Z</published>
    <updated>2020-01-10T09:50:26.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [1,null,2,3]<br>&nbsp;1<br>&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;/<br>&nbsp;3<br><strong>输出:</strong> [3,2,1]  </p></blockquote><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>递归</li><li>迭代（不同于前序遍历和中序遍历，后序遍历迭代更麻烦）</li><li>逆转前序遍历</li></ol><h2 id="代码">2.2 代码</h2><p>递归：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                     <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>迭代：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TreeNode cur <span class="token operator">=</span> root<span class="token punctuation">;</span>    TreeNode last <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            TreeNode temp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//是否变到右子树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span>right <span class="token operator">!=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> temp<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                last <span class="token operator">=</span> temp<span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>逆转前序遍历：（来源leetcode官方）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> output<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      output<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> output<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回它的 &lt;em&gt;后序&lt;/em&gt; 遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [1,null,2,3]&lt;br&gt;&amp;n
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode144-二叉树的前序遍历</title>
    <link href="https://www.codetool.top/article/leetcode144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode144-二叉树的前序遍历/</id>
    <published>2020-01-10T07:37:59.000Z</published>
    <updated>2020-01-10T07:51:06.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [1,null,2,3]<br>&nbsp;1<br>&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;/<br>&nbsp;3<br><strong>输出:</strong> [1,2,3]  </p></blockquote><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归、迭代，类似 <a href="https://www.codetool.top/article/leetcode94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">leetcode94-二叉树的中序遍历</a></p><h2 id="代码">2.2 代码</h2><p>递归：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>迭代：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List <span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List <span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack <span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode curr <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curr <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回它的 &lt;em&gt;前序&lt;/em&gt; 遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [1,null,2,3]&lt;br&gt;&amp;n
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode410-分割数组的最大值</title>
    <link href="https://www.codetool.top/article/leetcode410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode410-分割数组的最大值/</id>
    <published>2020-01-09T13:58:22.000Z</published>
    <updated>2020-01-09T15:32:05.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br>数组长度 <em>n</em> 满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, n)</li></ul><p><strong>示例：</strong></p><blockquote><p>输入:<br>nums = [7,2,5,10,8]<br>m = 2  </p><p>输出:<br>18</p><p>解释:<br>一共有四种方法将nums分割为2个子数组。<br>其中最好的方式是将其分为[7,2,5] 和 [10,8]，<br>因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找。要分成连续子数组，子数组的和的下限和上限分别是值最大的元素和所有元素之和，根据和不大于mid的子数组个数来逼近一个值，就是分割数组的最大值。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">splitArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> i<span class="token punctuation">;</span>            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> max<span class="token punctuation">,</span> end <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">long</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                temp <span class="token operator">+=</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">></span>mid<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    temp <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token operator">++</span>count<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">></span>m<span class="token punctuation">)</span>                start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                end <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>start<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个非负整数数组和一个整数 &lt;em&gt;m&lt;/em&gt;，你需要将这个数组分成 &lt;em&gt;m&lt;/em&gt; 个非空的连续子数组。设计一个算法使得这 &lt;em&gt;m&lt;/em&gt; 个子数组各自和的最大值最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode4-寻找两个有序数组的中位数</title>
    <link href="https://www.codetool.top/article/leetcode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode4-寻找两个有序数组的中位数/</id>
    <published>2020-01-09T09:20:24.000Z</published>
    <updated>2020-01-09T15:33:57.153Z</updated>
    
    <content type="html"><![CDATA[<p>这道题我没想出符合条件的思路</p><h1 id="原题">1 原题</h1><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p><strong>示例1：</strong></p><blockquote><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p></blockquote><p><strong>示例2：</strong></p><blockquote><p>nums1 = [1, 2]<br>nums2 = [3, 4]  </p><p>则中位数是 (2 + 3)/2 = 2.5  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找合并后的数组中第k/2个数，排除法,参考 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> m <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getKth</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> start1<span class="token punctuation">,</span> <span class="token keyword">int</span> end1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> start2<span class="token punctuation">,</span> <span class="token keyword">int</span> end2<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> end1 <span class="token operator">-</span> start1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> end2 <span class="token operator">-</span> start2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len1 <span class="token operator">></span> len2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">getKth</span><span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> start2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> start1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>start2 <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>start2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> start1 <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>len1<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> start2 <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>len2<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">getKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> start1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end2<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> start2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">getKth</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> start2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> start1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道题我没想出符合条件的思路&lt;/p&gt;
&lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记04</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B004/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记04/</id>
    <published>2020-01-08T14:45:04.000Z</published>
    <updated>2020-01-08T15:51:26.709Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第三章 垃圾收集器与内存分配策略</strong>的内容</p><h1 id="概述">1 概述</h1><p>程序计数器、虚拟机栈、本地方法栈是线程独有的，栈帧更是随方法结束而消亡，不需要垃圾回收。而堆和方法区则需要经过垃圾回收的设计</p><h1 id="如何确定一个对象是否该回收了">2 如何确定一个对象是否该回收了</h1><h2 id="引用计数算法">2.1 引用计数算法</h2><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>特点：虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。<br>但是，在Java 领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><h2 id="可达性分析算法">2.2 可达性分析算法</h2><p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p><p><img src="https://api.codetool.top/img/15784962041632.jpg" alt></p><p>固定可作为GC Roots的对象包括以下几种：</p><ul><li>在<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</li><li>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。 ·在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li><strong>Java虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象（比如<br>NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有<strong>被同步锁（synchronized关键字）持有的对象</strong>。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><h2 id="再谈引用">2.3 再谈引用</h2><p>需求：有一类对象，当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用、软引用、弱引用和虚引用</strong>4种，这4种引用强度依次逐渐减弱。</p><ul><li>强引用：传统的引用关系，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li>软引用：还有用，但非必须的对象。在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，在JDK 1.2版之后提供了<code>SoftReference</code>类来实现软引用。</li><li>弱引用：非必须对象，但是它的强度比软引用更弱一些。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉<strong>只被弱引用关联的对象</strong>。在JDK 1.2版之后提供了<code>WeakReference</code>类来实现弱引用</li><li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了<code>PhantomReference</code>类来实现虚引用。</li></ul><p>##　生存还是死亡？</p><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，<strong>要真正宣告一个对象死亡，至少要经历两次标记过程</strong>：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。<strong>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过</strong>，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第三章 垃圾收集器与内存分配策略&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;程序计数器、虚拟机栈、本地方法栈是线程独有的，栈帧更是随方法结束而消亡，不需要垃圾回收。而堆和方法区则需要经过垃圾回收的设计&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode287-寻找重复数</title>
    <link href="https://www.codetool.top/article/leetcode287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode287-寻找重复数/</id>
    <published>2020-01-07T05:07:59.000Z</published>
    <updated>2020-01-07T14:05:23.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个包含 <em>n + 1</em> 个整数的数组 <em>nums</em> ，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> [1,3,4,2,2]<br><strong>输出:</strong> 2  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> [3,1,3,4,2]<br><strong>输出:</strong> 3</p></blockquote><p><strong>说明：</strong></p><ol><li><strong>不能</strong>更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n<sup>2</sup>) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>有排序和哈希集的方法，但要满足4点限制，可以使用二分查找或快慢指针：</p><ol><li>二分查找，参考 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/</a></li><li>快慢指针，将index看成有向图里的节点，将对应的value看成节点指向的节点。那么有重复元素必然会形成环。如图：</li></ol><p><img src="https://api.codetool.top/img/15784053304804.png" alt="示例1：[1,3,4,2,2]"></p><p><img src="https://api.codetool.top/img/1578405391461.png" alt="示例2：[3,1,3,4,2]"></p><p>那么入环的节点值就是重复出现的元素，可以使用<a href="https://www.codetool.top/article/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/">leetcode142-环形链表II</a>的双指针法来找出入环的元素。</p><h2 id="代码">2.2 代码</h2><p>哈希集：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>二分查找：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// int mid = left + (right - left) / 2;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    counter <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>快慢指针：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//相当于走一步</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//相当于走两步</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>slow<span class="token operator">!=</span>fast<span class="token punctuation">)</span><span class="token punctuation">;</span>        slow <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个包含 &lt;em&gt;n + 1&lt;/em&gt; 个整数的数组 &lt;em&gt;nums&lt;/em&gt; ，其数字都在 1 到 &lt;em&gt;n&lt;/em&gt; 之间（包括 1 和 &lt;em&gt;n&lt;/em&gt;），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希集" scheme="https://www.codetool.top/tags/%E5%93%88%E5%B8%8C%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode154-寻找旋转排序数组中的最小值II</title>
    <link href="https://www.codetool.top/article/leetcode154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>https://www.codetool.top/article/leetcode154-寻找旋转排序数组中的最小值II/</id>
    <published>2020-01-07T04:29:31.000Z</published>
    <updated>2020-01-07T04:46:01.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> [1,3,5]<br><strong>输出：</strong> 1   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> [2,2,2,0,1]<br><strong>输出：</strong> 0    </p></blockquote><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>线性查找</li><li>二分查找,参考 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/</a></li></ol><h2 id="代码">2.2 代码</h2><ol><li>线性查找</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{</span>                min<span class="token operator">=</span>i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>二分查找</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> right <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记03</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B003/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记03/</id>
    <published>2020-01-06T08:36:25.000Z</published>
    <updated>2020-01-06T13:36:12.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HotSpot虚拟机对象探秘">1 HotSpot虚拟机对象探秘</h1><h2 id="对象的创建">1.1 对象的创建</h2><ol><li><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数<strong>是否能在常量池中定位到一个类的符号引用</strong>，并且检查这个<strong>符号引用代表的类是否已被加载、解析和初始化过</strong>。如果没有，那必须先执行相应的<strong>类加载过程</strong></p></li><li><p>类加载检查通过后，为新生对象分配内存。有两种方法：</p><ul><li>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个<strong>指针向空闲空间方向挪动一段与对象大小相等的距离</strong>，这种分配方式称为 <strong>“指针碰撞”</strong></li><li>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须<strong>维护一个列表，记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”</li></ul></li><li><p>同步问题：仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决方法：</p><ul><li>对分配内存空间的动作进行同步处理（实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性）</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），是否启用TLAB可以通过<code>-XX：+/-UseTLAB</code>参数来设定。</li></ul></li><li><p>将分配到的内存空间（但不包括对象头）都初始化为零值</p></li><li><p>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。</p></li><li><p>执行<init> ()方法（构造函数）</init></p></li></ol><h2 id="对象的内存布局">1.2 对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h3 id="对象头">1.2.1 对象头</h3><p>Markword:存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。</p><p><img src="https://api.codetool.top/img/15783086203644.png" alt="markword"></p><p>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，如果开启指针压缩，可以在64位机上也变成32比特。</p><p>开启指针压缩：<code>-XX:+UseCompressedOops</code></p><p><img src="https://api.codetool.top/img/15783086492674.png" alt="kclass"></p><p>数组长度： 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，这部分数据的长度是32比特。</p><h3 id="实例数据">1.2.2 实例数据</h3><p>对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><p><img src="https://api.codetool.top/img/15783093332239.png" alt="实例数据"></p><p>这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。</p><h3 id="对齐填充">1.2.3 对齐填充</h3><p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位">1.3 对象的访问定位</h2><p>Java程序会<strong>通过栈上的reference数据来操作堆上的具体对象</strong>。<br>对象访问方式是由虚拟机实现而定的，主流的访问方式主要有<strong>使用句柄和直接指针</strong>两种：</p><ul><li>句柄访问：可能会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据与类型数据</strong>各自具体的地址信息，其结构如图所示：</li></ul><p><img src="https://api.codetool.top/img/1578313342112.jpg" alt></p><p>好处：好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><ul><li>直接指针访问:Java堆中对象的内存布局就必须考虑如何<strong>放置访问类型数据</strong>的相关信息，reference中存储的直接就是<strong>对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示:</li></ul><p><img src="https://api.codetool.top/img/15783134884212.jpg" alt></p><p>好处：速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，HotSpot是使用的这种方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HotSpot虚拟机对象探秘&quot;&gt;1 HotSpot虚拟机对象探秘&lt;/h1&gt;&lt;h2 id=&quot;对象的创建&quot;&gt;1.1 对象的创建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数&lt;strong&gt;是否能在常量池中定位到
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记02</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B002/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记02/</id>
    <published>2020-01-05T12:08:33.000Z</published>
    <updated>2020-01-06T13:33:59.726Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第二章 Java内存区域与内存溢出异常</strong>的内容</p><h1 id="运行时数据区域">1 运行时数据区域</h1><p><img src="https://api.codetool.top/img/15782333435215.jpg" alt></p><h2 id="程序计数器">1.1 程序计数器</h2><h3 id="特点">1.1.1 特点</h3><ul><li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li><li>程序计数器是线程私有的，线程轮换之后通过程序计数器确定要执行的指令位置。</li><li>不存在内存溢出。</li></ul><h2 id="Java虚拟机栈">1.2 Java虚拟机栈</h2><h3 id="特点-1">1.2.1 特点</h3><ul><li>Java虚拟机栈也是线程私有的,它的生命周期与线程相同。</li><li>虚拟机栈描述的是Java方法执行的<strong>线程内存模型</strong>：每个方法被执行的时候，Java虚拟机都<br>会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口等信息</strong>。栈帧的入栈出栈对应一个方法的调用。</li><li>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和返回地址。</li><li>局部变量表中的存储空间以 <strong>局部变量槽（Slot）</strong> 来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配。</li></ul><h3 id="异常">1.2.2 异常</h3><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常，可能会有这两种情况：<ul><li>栈帧过多</li><li>栈帧过大</li></ul></li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。（HotSpot虚拟机的栈容量是不可以动态扩展的，也不会导致这种异常）</li></ul><p>代码演示：通过<code>-Xss</code>参数来设定栈的大小</p><p>（无限递归导致栈帧过多）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/***    VM Args：-Xss128k*    @author zzm */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaVMStackSOF</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 stackLength<span class="token operator">++</span><span class="token punctuation">;</span>                 <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        JavaVMStackSOF oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JavaVMStackSOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">try</span> <span class="token punctuation">{</span>            oom<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack length:"</span> <span class="token operator">+</span> oom<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（栈帧太大）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author zzm */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaVMStackSOF</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> unused1<span class="token punctuation">,</span> unused2<span class="token punctuation">,</span> unused3<span class="token punctuation">,</span> unused4<span class="token punctuation">,</span> unused5<span class="token punctuation">,</span>        unused6<span class="token punctuation">,</span> unused7<span class="token punctuation">,</span> unused8<span class="token punctuation">,</span> unused9<span class="token punctuation">,</span> unused10<span class="token punctuation">,</span>                      unused11<span class="token punctuation">,</span> unused12<span class="token punctuation">,</span> unused13<span class="token punctuation">,</span> unused14<span class="token punctuation">,</span> unused15<span class="token punctuation">,</span>        unused16<span class="token punctuation">,</span> unused17<span class="token punctuation">,</span> unused18<span class="token punctuation">,</span> unused19<span class="token punctuation">,</span> unused20<span class="token punctuation">,</span>        unused21<span class="token punctuation">,</span> unused22<span class="token punctuation">,</span> unused23<span class="token punctuation">,</span> unused24<span class="token punctuation">,</span> unused25<span class="token punctuation">,</span>        unused26<span class="token punctuation">,</span> unused27<span class="token punctuation">,</span> unused28<span class="token punctuation">,</span> unused29<span class="token punctuation">,</span> unused30<span class="token punctuation">,</span>        unused31<span class="token punctuation">,</span> unused32<span class="token punctuation">,</span> unused33<span class="token punctuation">,</span> unused34<span class="token punctuation">,</span> unused35<span class="token punctuation">,</span>        unused36<span class="token punctuation">,</span> unused37<span class="token punctuation">,</span> unused38<span class="token punctuation">,</span> unused39<span class="token punctuation">,</span> unused40<span class="token punctuation">,</span>         unused41<span class="token punctuation">,</span> unused42<span class="token punctuation">,</span> unused43<span class="token punctuation">,</span> unused44<span class="token punctuation">,</span> unused45<span class="token punctuation">,</span>        unused46<span class="token punctuation">,</span> unused47<span class="token punctuation">,</span> unused48<span class="token punctuation">,</span> unused49<span class="token punctuation">,</span> unused50<span class="token punctuation">,</span>         unused51<span class="token punctuation">,</span> unused52<span class="token punctuation">,</span> unused53<span class="token punctuation">,</span> unused54<span class="token punctuation">,</span> unused55<span class="token punctuation">,</span>         unused56<span class="token punctuation">,</span> unused57<span class="token punctuation">,</span> unused58<span class="token punctuation">,</span> unused59<span class="token punctuation">,</span> unused60<span class="token punctuation">,</span>        unused61<span class="token punctuation">,</span> unused62<span class="token punctuation">,</span> unused63<span class="token punctuation">,</span> unused64<span class="token punctuation">,</span> unused65<span class="token punctuation">,</span>        unused66<span class="token punctuation">,</span> unused67<span class="token punctuation">,</span> unused68<span class="token punctuation">,</span> unused69<span class="token punctuation">,</span> unused70<span class="token punctuation">,</span>        unused71<span class="token punctuation">,</span> unused72<span class="token punctuation">,</span> unused73<span class="token punctuation">,</span> unused74<span class="token punctuation">,</span> unused75<span class="token punctuation">,</span>        unused76<span class="token punctuation">,</span> unused77<span class="token punctuation">,</span> unused78<span class="token punctuation">,</span> unused79<span class="token punctuation">,</span> unused80<span class="token punctuation">,</span>        unused81<span class="token punctuation">,</span> unused82<span class="token punctuation">,</span> unused83<span class="token punctuation">,</span> unused84<span class="token punctuation">,</span> unused85<span class="token punctuation">,</span>        unused86<span class="token punctuation">,</span> unused87<span class="token punctuation">,</span> unused88<span class="token punctuation">,</span> unused89<span class="token punctuation">,</span> unused90<span class="token punctuation">,</span>        unused91<span class="token punctuation">,</span> unused92<span class="token punctuation">,</span> unused93<span class="token punctuation">,</span> unused94<span class="token punctuation">,</span> unused95<span class="token punctuation">,</span>        unused96<span class="token punctuation">,</span> unused97<span class="token punctuation">,</span> unused98<span class="token punctuation">,</span> unused99<span class="token punctuation">,</span> unused100<span class="token punctuation">;</span>        stackLength <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unused1 <span class="token operator">=</span> unused2 <span class="token operator">=</span> unused3 <span class="token operator">=</span> unused4 <span class="token operator">=</span> unused5 <span class="token operator">=</span>        unused6 <span class="token operator">=</span> unused7 <span class="token operator">=</span> unused8 <span class="token operator">=</span> unused9 <span class="token operator">=</span> unused10 <span class="token operator">=</span>         unused11 <span class="token operator">=</span> unused12 <span class="token operator">=</span> unused13 <span class="token operator">=</span> unused14 <span class="token operator">=</span> unused15 <span class="token operator">=</span>        unused16 <span class="token operator">=</span> unused17 <span class="token operator">=</span> unused18 <span class="token operator">=</span> unused19 <span class="token operator">=</span> unused20 <span class="token operator">=</span>        unused21 <span class="token operator">=</span> unused22 <span class="token operator">=</span> unused23 <span class="token operator">=</span> unused24 <span class="token operator">=</span> unused25 <span class="token operator">=</span>        unused26 <span class="token operator">=</span> unused27 <span class="token operator">=</span> unused28 <span class="token operator">=</span> unused29 <span class="token operator">=</span> unused30 <span class="token operator">=</span>        unused31 <span class="token operator">=</span> unused32 <span class="token operator">=</span> unused33 <span class="token operator">=</span> unused34 <span class="token operator">=</span> unused35 <span class="token operator">=</span>        unused36 <span class="token operator">=</span> unused37 <span class="token operator">=</span> unused38 <span class="token operator">=</span> unused39 <span class="token operator">=</span> unused40 <span class="token operator">=</span>        unused41 <span class="token operator">=</span> unused42 <span class="token operator">=</span> unused43 <span class="token operator">=</span> unused44 <span class="token operator">=</span> unused45 <span class="token operator">=</span>         unused46 <span class="token operator">=</span> unused47 <span class="token operator">=</span> unused48 <span class="token operator">=</span> unused49 <span class="token operator">=</span> unused50 <span class="token operator">=</span>        unused51 <span class="token operator">=</span> unused52 <span class="token operator">=</span> unused53 <span class="token operator">=</span> unused54 <span class="token operator">=</span> unused55 <span class="token operator">=</span>        unused56 <span class="token operator">=</span> unused57 <span class="token operator">=</span> unused58 <span class="token operator">=</span> unused59 <span class="token operator">=</span> unused60 <span class="token operator">=</span>        unused61 <span class="token operator">=</span> unused62 <span class="token operator">=</span> unused63 <span class="token operator">=</span> unused64 <span class="token operator">=</span> unused65 <span class="token operator">=</span>        unused66 <span class="token operator">=</span> unused67 <span class="token operator">=</span> unused68 <span class="token operator">=</span> unused69 <span class="token operator">=</span> unused70 <span class="token operator">=</span>        unused71 <span class="token operator">=</span> unused72 <span class="token operator">=</span> unused73 <span class="token operator">=</span> unused74 <span class="token operator">=</span> unused75 <span class="token operator">=</span>        unused76 <span class="token operator">=</span> unused77 <span class="token operator">=</span> unused78 <span class="token operator">=</span> unused79 <span class="token operator">=</span> unused80 <span class="token operator">=</span>        unused81 <span class="token operator">=</span> unused82 <span class="token operator">=</span> unused83 <span class="token operator">=</span> unused84 <span class="token operator">=</span> unused85 <span class="token operator">=</span>        unused86 <span class="token operator">=</span> unused87 <span class="token operator">=</span> unused88 <span class="token operator">=</span> unused89 <span class="token operator">=</span> unused90 <span class="token operator">=</span>        unused91 <span class="token operator">=</span> unused92 <span class="token operator">=</span> unused93 <span class="token operator">=</span> unused94 <span class="token operator">=</span> unused95 <span class="token operator">=</span>        unused96 <span class="token operator">=</span> unused97 <span class="token operator">=</span> unused98 <span class="token operator">=</span> unused99 <span class="token operator">=</span> unused100 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>                         <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stack length:"</span> <span class="token operator">+</span> stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="本地方法栈">1.3 本地方法栈</h2><p>是java虚拟机栈的native方法版。<br>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈</p><h2 id="Java堆">1.4 Java堆</h2><h3 id="特点-2">1.4.1 特点</h3><ul><li>是各个进程共享的。</li><li>所有的对象实例以及数组都应当在堆上分配，日后可能出现值类型的支持。</li><li>Java堆中可以划分出多个线程私有的<strong>分配缓冲区</strong>，以提升对象分配时的效率。</li><li>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。</li></ul><h3 id="异常-1">1.4.2 异常</h3><p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError</code>异常。</p><p>代码演示：<br>(将堆的最小值<code>-Xms</code>参数与最大值<code>-Xmx</code>参数设置为一样即可避免堆自动扩展，通过参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**·*    VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError*    @author zzm*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>OOMObject<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>OOMObject<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="方法区">1.5 方法区</h2><h3 id="特点-3">1.5.1 特点</h3><ul><li>是各个进程共享的。</li><li>它用于存储<strong>已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</li><li>JAVA8以前HotSpot使用永久代实现方法区，把堆的垃圾回收机制延申至方法区，JAVA8开始使用位于本地内存中的<strong>元空间</strong>实现方法区。</li><li>JAVA虚拟机规范不要求实现垃圾回收。</li><li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</li><li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。</li><li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。</li></ul><h3 id="异常-2">1.5.2 异常</h3><p>如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。(由于JAVA8后方法区位于本地内存中，很少出现这种情况，一般是涉及到动态加载过多类)</p><h2 id="运行时常量池">1.6 运行时常量池</h2><ul><li>运行时常量池是方法区的一部分。</li><li>类的字节码中有一项信息是常量池表，用于存放编译期生成的<strong>类名、方法名、参数类型与字面量</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</li><li>Java语言并不要求常量一定只有编译期才能产生，String类的intern方法可以将字符串常量放进字符串常量池表。</li></ul><h3 id="异常-3">1.6.1 异常</h3><p>常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="intern方法有意思的点">1.6.2 intern方法有意思的点</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RuntimeConstantPoolOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"计算机"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"软件"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>        String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ja"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"va"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码在JDK 6中运行，会得到两个false，而在JDK 7中运行，会得到一个true和一个false。产生差异的原因是，在JDK 6中，intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在 Java堆上，所以必然不可能是同一个引用，结果将返回false。</p><p>而JDK 7（以及部分其他虚拟机，例如JRockit）的<strong>intern()方法实现就不需要再拷贝字符串的实例到永久代</strong>了，既然字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。而对str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了（sun.misc.Version类中加载），字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p><h2 id="直接内存">1.7 直接内存</h2><p>直接内存就是机器的内存，JDK1.4中的NIO可以使用Native函数库直接分配堆外内存</p><p><code>-XX：MaxDirectMemorySize</code>指定可使用的直接内存大小，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第二章 Java内存区域与内存溢出异常&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;运行时数据区域&quot;&gt;1 运行时数据区域&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15782333435215.jp
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode744-寻找比目标字母大的最小字母</title>
    <link href="https://www.codetool.top/article/leetcode744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/"/>
    <id>https://www.codetool.top/article/leetcode744-寻找比目标字母大的最小字母/</id>
    <published>2020-01-05T09:31:46.000Z</published>
    <updated>2020-01-05T09:40:41.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个只包含小写字母的有序数组<code>letters</code> 和一个目标字母 <code>target</code>，寻找有序数组里面比目标字母大的最小字母。</p><p>数组里字母的顺序是循环的。举个例子，如果目标字母<code>target = &#39;z&#39;</code> 并且有序数组为 <code>letters = [&#39;a&#39;, &#39;b&#39;]</code>，则答案返回 <code>&#39;a&#39;</code>。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “a”<br><strong>输出:</strong> “c”<br><br><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “c”<br><strong>输出:</strong> “f”<br><br><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “d”<br><strong>输出:</strong> “f”<br><br><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “g”<br><strong>输出:</strong> “j”<br><br><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “j”<br><strong>输出:</strong> “c”<br><br><br><strong>输入:</strong><br>letters = [“c”, “f”, “j”]<br>target = “k”<br><strong>输出:</strong> “c”</p></blockquote><p><strong>注:</strong></p><ol><li><code>letters</code>长度范围在<code>[2, 10000]</code>区间内。</li><li><code>letters</code> 仅由小写字母组成，最少包含两个不同的字母。</li><li>目标字母<code>target</code> 是一个小写字母。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">nextGreatestLetter</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> letters<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> letters<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>letters<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> end <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>letters<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> letters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> letters<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个只包含小写字母的有序数组&lt;code&gt;letters&lt;/code&gt; 和一个目标字母 &lt;code&gt;target&lt;/code&gt;，寻找有序数组里面比目标字母大的最小字母。&lt;/p&gt;
&lt;p&gt;数组里字母的顺序是循环的。举个例子，如果目标字
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode367-有效的完全平方数</title>
    <link href="https://www.codetool.top/article/leetcode367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode367-有效的完全平方数/</id>
    <published>2020-01-05T08:52:03.000Z</published>
    <updated>2020-01-05T08:55:48.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个正整数 <em>num*，编写一个函数，如果 *num</em> 是一个完全平方数，则返回 True，否则返回 False。</p><p><strong>说明：</strong> 不要使用任何内置的库函数，如  <code>sqrt</code>。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> 16<br><strong>输出:</strong> True  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> 14<br><strong>输出:</strong> False</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找。由于平方后可能会超出int范围要注意long的使用。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPerfectSquare</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;=</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">long</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">*</span>mid <span class="token operator">==</span> num<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">*</span>mid <span class="token operator">></span> num<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">*</span>mid <span class="token operator">&lt;</span>num<span class="token punctuation">)</span> start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;num*，编写一个函数，如果 *num&lt;/em&gt; 是一个完全平方数，则返回 True，否则返回 False。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 不要使用任何内置的库函数，如  &lt;code
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode50-Pow(x,n)</title>
    <link href="https://www.codetool.top/article/leetcode50-Pow-x-n/"/>
    <id>https://www.codetool.top/article/leetcode50-Pow-x-n/</id>
    <published>2020-01-05T08:10:49.000Z</published>
    <updated>2020-01-05T08:17:50.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>实现 <code>pow(x, n)</code> ，即计算 x 的 n 次幂函数。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> 2.00000, 10<br><strong>输出：</strong> 1024.00000   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> 2.10000, 3<br><strong>输出：</strong> 9.26100  </p></blockquote><p><strong>示例3：</strong></p><blockquote><p><strong>输入：</strong> 2.00000, -2<br><strong>输出：</strong> 0.25000<br><strong>解释：</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题使用暴力解法会超出时间限制。</p><p>自底向上，快速幂。由x<sup>n</sup> = (x<sup>n/2</sup>)<sup>2</sup>得到。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">;</span>        <span class="token keyword">double</span> half <span class="token operator">=</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> rest <span class="token operator">=</span> <span class="token function">myPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> half <span class="token operator">*</span> half <span class="token operator">*</span> rest<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;实现 &lt;code&gt;pow(x, n)&lt;/code&gt; ，即计算 x 的 n 次幂函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt; 2.0
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记01</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B001/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记01/</id>
    <published>2020-01-04T12:54:41.000Z</published>
    <updated>2020-01-06T06:43:46.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="做笔记之前的感言">1 做笔记之前的感言</h1><p>谈到《深入理解java虚拟机》，在业内可太有名了，是国内的一位大神写的一本关于java虚拟机的畅销书，基本上对java稍有深入的程序员都听说过这本书。不过遗憾的是，这本书第二版的创作背景是java7，而在过了这么多年java的更新之后，jvm内部也发生了许多变化，最近听闻这本书的第三版出来了，赶紧买了一本来看。</p><p><img src="https://api.codetool.top/img/15781428537860.png" alt></p><p>以下是<strong>第一章 走进Java</strong>的内容</p><h1 id="java技术体系">2 java技术体系</h1><p>从广义上讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员。如果仅从传统意义上来看，JCP官方所定义的Java技术体系包括了以下几个组成部分：</p><ul><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机实现</li><li>Class文件格式</li><li>Java类库API</li><li>来自商业机构和开源社区的第三方Java类库</li></ul><p><img src="https://api.codetool.top/img/157814354693.jpg" alt></p><p>JavaEE中对JavaSE中的针对性补充一般以javax.*作为包名。</p><h1 id="java发展史">3 java发展史</h1><p><img src="https://api.codetool.top/img/15781436864850.jpg" alt></p><p>1995年5月23日，<strong>Oak语言</strong>改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。Java语言第一次提出了“Write Once，Run Anywhere”的口号。</p><ul><li>JDK 1.0版本的代表技术包括：Java虚拟机、Applet、AWT等。</li><li>JDK 1.1版的技术代表有：JAR文件格式、JDBC、JavaBeans、RMI等。Java语言的语法也有了一定的增强，如内部类（Inner Class）和反射（Reflection）都是在这时候出现的。</li><li>JDK 1.4同样带来了很多新的技术特性，如<strong>正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器</strong>。</li><li>JDK 5在Java语法易用性上做出了非常大的改进。如：<strong>自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）</strong>等语法特性都是在JDK 5中加入的。在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包等。</li><li>JDK 6的改进包括：提供初步的动态语言支持（通过内置Mozilla JavaScript<br>Rhino引擎实现）、提供编译期注解处理器和微型HTTP服务器API，等等。同时，这个版本对<strong>Java虚拟机内部</strong>做了大量改进，包括<strong>锁与同步、垃圾收集、类加载</strong>等方面的实现都有相当多的改动。</li><li>JDK 7包含的改进有：提供新的<strong>G1收集器</strong>、加强对非Java语言的调用支持（JSR-292，这项特性在到JDK 11还有改动）、可并行的类加载架构等。</li><li>JDK 8提供了那些曾在JDK 7中规划过，但最终未能在JDK 7中完成的功能，主要包括：对<strong>Lambda表达式</strong>的支持，这让Java语言拥有了流畅的函数式表达能力、内置Nashorn JavaScript引擎的支持、<strong>新的时间、日期API、彻底移除HotSpot的永久代</strong>。</li><li>除了<strong>Jigsaw</strong>外，JDK 9还增强了若干工具（JS Shell、JLink、JHSDB等），整顿了<br>HotSpot各个模块各自为战的日志系统，支持HTTP 2客户单API等91个JEP。</li><li>JDK 11发布，这是一个LTS版本的JDK，包含17个JEP，其中有<strong>ZGC这样的革命性的垃圾收集器</strong>出现。</li><li>JDK 12发布，只包含8个JEP，其中主要有<strong>Switch表达式、Java微测试套件（JMH）</strong>等新功能，最引人注目的特性无疑是加入了由RedHat领导开发的Shen-andoah垃圾收集器。</li></ul><h1 id="java虚拟机家族">4 java虚拟机家族</h1><p>虚拟机始祖：Sun Classic/Exact VM</p><p><img src="https://api.codetool.top/img/15781220438809.jpg" alt></p><h1 id="java技术的未来">5 java技术的未来</h1><h2 id="无语言倾向">5.1 无语言倾向</h2><p>2018年4月，Oracle Labs新公开了一项黑科技：<strong>Graal VM</strong></p><p>Graal VM被官方称为“Universal VM”和“Polyglot VM”，这是一个在HotSpot虚拟机基础上增强而成的<strong>跨语言全栈虚拟机</strong>，可以作为“任何语言”的运行平台使用，这里“任何语言”包括了Java、Scala、Groovy、Kotlin等基于Java虚拟机之上的语言，还包括了C、C++、Rust等基于LLVM的语言，同时支持其他像JavaScript、Ruby、Python和R语言等。Graal VM可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言使用已经编写好的本地库文件。</p><h2 id="新一代即时编译器">5.2 新一代即时编译器</h2><p>HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2），通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统</p><p>自<strong>JDK 10</strong>起，HotSpot中又加入了一个全新的即时编译器：<strong>Graal编译器</strong>，看名字就可以联想到它是来自于前一节提到的Graal VM。Graal编译器是以<strong>C2编译器替代者</strong>的身份登场的。C2的历史已经非常长了，可以追溯到Cliff Click大神读博士期间的作品，这个由C++写成的编译器尽管目前依然效果拔群，但已经复杂到连Cliff Click本人都不愿意继续维护的程度。而Graal编译器本身就是由Java语言写成，实现时又刻意与C2采用了同一种名为“Sea-of-Nodes”的高级中间表示（High IR）形式，使其能够更容易借鉴C2的优点。Graal编译器比C2编译器晚了足足二十年面世，有着极其充沛的后发优势，在保持输出相近质量的编译代码的同时，开发效率和扩展性上都要显著优于C2编译器，这决定了C2编译器中优秀的代码优化技术可以轻易地移植到Graal编译器上，但是反过来Graal编译器中行之有效的优化在 C2编译器里实现起来则异常艰难。这种情况下，Graal的编译效果短短几年间迅速追平了C2，甚至某些测试项中开始逐渐反超C2编译器。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。</p><h2 id="向Native迈进">5.3 向Native迈进</h2><p>微服务架构的兴起促进java<strong>提前编译技术</strong>的发展</p><p>Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器（Native Image Generator），用于为用户程序建立基于Substrate VM 的本地运行时镜像。这个构造器采用指针分析（Points-To Analysis）技术，从用户提供的程序入口出发，搜索所有可达的代码。在搜索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样一来，Substrate VM就可以直接从目标程序开始运行，而无须重复进行Java虚拟机的初始化过程。但相应地，原理上也决定了Substrate VM必须要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。基于这个假设，Substrate VM才能探索整个编译空间，并通过静态分析推算出所有虚方法调用的目标方法。</p><h2 id="灵活的胖子">5.4 灵活的胖子</h2><p>经过一系列的重构与开放，HotSpot虚拟机逐渐从时间的侵蚀中挣脱出来，虽然代码复杂度还在增长，体积仍在变大，但其架构并未老朽，而是拥有了越来越多的开放性和扩展性，使得HotSpot成为一个能够联动外部功能，能够应对各种场景，能够学会十八般武艺的身手灵活敏捷的“胖子”。</p><h2 id="语言语法持续增强">5.5 语言语法持续增强</h2><p>随着Java每半年更新一次的节奏，新版本的Java中会出现越来越多其他语言里已有的优秀特性，相信博采众长的Java，还能继续保持现在的勃勃生机相当长时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;做笔记之前的感言&quot;&gt;1 做笔记之前的感言&lt;/h1&gt;&lt;p&gt;谈到《深入理解java虚拟机》，在业内可太有名了，是国内的一位大神写的一本关于java虚拟机的畅销书，基本上对java稍有深入的程序员都听说过这本书。不过遗憾的是，这本书第二版的创作背景是java7，而在过了
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode658-找到K个最接近的元素</title>
    <link href="https://www.codetool.top/article/leetcode658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://www.codetool.top/article/leetcode658-找到K个最接近的元素/</id>
    <published>2020-01-04T12:08:07.000Z</published>
    <updated>2020-01-04T12:44:46.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个排序好的数组，两个整数 <code>k</code> 和 <code>x</code>，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。如果有两个数与 <code>x</code> 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5], k=4, x=3<br><strong>输出:</strong> [1,2,3,4] </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5], k=4, x=-1<br><strong>输出:</strong> [1,2,3,4] </p></blockquote><p><strong>说明:</strong></p><ol><li>k 的值为正数，且总是小于给定排序数组的长度。</li><li>数组不为空，且长度不超过 104</li><li>数组里的每个元素与 x 的绝对值不超过 104</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>按照差值排序</li><li>双指针</li></ol><h2 id="代码">2.2 代码</h2><ol><li>排序</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">==</span> b <span class="token operator">?</span> a <span class="token operator">-</span> b <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token operator">-</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>b<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>     Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>双指针（作者：liweiwei1419）</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> removeNums <span class="token operator">=</span> size <span class="token operator">-</span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>removeNums <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            removeNums<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left <span class="token operator">+</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个排序好的数组，两个整数 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt;，从数组中找到最靠近 &lt;code&gt;x&lt;/code&gt;（两数之差最小）的 &lt;code&gt;k&lt;/code&gt; 个数。返回的结果必须要是按升序排好的。
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode34--在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://www.codetool.top/article/leetcode34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://www.codetool.top/article/leetcode34-在排序数组中查找元素的第一个和最后一个位置/</id>
    <published>2020-01-03T09:58:04.000Z</published>
    <updated>2020-01-03T10:00:44.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [5,7,7,8,8,10], target = 8<br><strong>输出：</strong> [3,4]   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [5,7,7,8,8,10], target = 6<br><strong>输出：</strong> [-1,-1]    </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找，找到一个目标值时向两边继续查找最初和最末出现的地方。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">!=</span>target <span class="token operator">&amp;&amp;</span>start<span class="token operator">&lt;=</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span> start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid_cache <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">int</span> end_cache <span class="token operator">=</span> end<span class="token punctuation">;</span>        end <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>        start <span class="token operator">=</span> mid_cache<span class="token punctuation">;</span>        end <span class="token operator">=</span> end_cache<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> start <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> end<span class="token punctuation">;</span>        <span class="token keyword">return</span> pos<span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个按照升序排列的整数数组 &lt;code&gt;nums&lt;/code&gt;，和一个目标值 &lt;code&gt;target&lt;/code&gt;。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode153-寻找旋转排序数组中的最小值</title>
    <link href="https://www.codetool.top/article/leetcode153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode153-寻找旋转排序数组中的最小值/</id>
    <published>2020-01-03T07:59:23.000Z</published>
    <updated>2020-01-07T04:45:58.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> [3,4,5,1,2]<br><strong>输出：</strong> 1   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> [4,5,6,7,0,1,2]<br><strong>输出：</strong> 0    </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>线性查找</li><li>二分查找，找出旋转点</li></ol><h2 id="代码">2.2 代码</h2><ol><li>线性查找</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{</span>                min<span class="token operator">=</span>i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>二分查找</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> head <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> head<span class="token punctuation">)</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> head<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">></span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode162-寻找峰值</title>
    <link href="https://www.codetool.top/article/leetcode162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>https://www.codetool.top/article/leetcode162-寻找峰值/</id>
    <published>2020-01-03T07:22:04.000Z</published>
    <updated>2020-01-03T07:34:16.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> nums = [1,2,3,1]<br><strong>输出:</strong> 2<br><strong>解释:</strong> 3 是峰值元素，你的函数应该返回其索引 2。  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> nums = [1,2,1,3,5,6,4]<br><strong>输出:</strong> 1 或 5<br><strong>解释:</strong> 你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>线性查找，从第一个元素开始，第一个打破单调递增的元素。</li><li>二分查找，看中间元素值的的趋势（斜率）</li></ol><h2 id="代码">2.2 代码</h2><ol><li>线性查找</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findPeakElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cache <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">>=</span>cache<span class="token punctuation">)</span><span class="token punctuation">{</span>            cache <span class="token operator">=</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>二分查找（来源：leetcode官方）</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findPeakElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 &lt;code&gt;nums&lt;/code&gt;，其中 &lt;code&gt;nums[i] ≠ nums[i+1]&lt;/code&gt;，找到峰值元素并返回其索引。&lt;/p&gt;
&lt;p&gt;数组可能包
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode278-第一个错误的版本</title>
    <link href="https://www.codetool.top/article/leetcode278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>https://www.codetool.top/article/leetcode278-第一个错误的版本/</id>
    <published>2020-01-02T13:17:40.000Z</published>
    <updated>2020-01-02T13:20:58.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例：</strong></p><blockquote><p>给定 n = 5，并且 version = 4 是第一个错误的版本。<br><br><br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br><br><br>所以，4 是第一个错误的版本。   </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* The isBadVersion API is defined in the parent class VersionControl.      boolean isBadVersion(int version); */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token keyword">extends</span> <span class="token class-name">VersionControl</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isBadVersion</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> start<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。&lt;/p&gt;
&lt;p&gt;假设你有 &lt;code&gt;n&lt;/code&gt; 个版本
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode33-搜索旋转排序数组</title>
    <link href="https://www.codetool.top/article/leetcode33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode33-搜索旋转排序数组/</id>
    <published>2020-01-01T14:03:54.000Z</published>
    <updated>2020-01-01T14:15:51.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p><strong>示例1：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,5,6,7,0,1,2], target = 0<br><strong>输出：</strong> 4   </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,5,6,7,0,1,2], target = 3<br><strong>输出：</strong> -1    </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找，需要注意、区分一些情况。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> head <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>start<span class="token operator">&lt;=</span>end<span class="token punctuation">)</span><span class="token punctuation">{</span>            mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//mid比target大</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">></span>head<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//target在左边</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>head<span class="token punctuation">)</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//mid在左边</span>                    <span class="token keyword">else</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//target在右边</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>head<span class="token punctuation">)</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//mid在左边</span>                    <span class="token keyword">else</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//mid比target小</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token operator">></span>head<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//target在左边</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>head<span class="token punctuation">)</span> start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//mid在左边</span>                    <span class="token keyword">else</span> end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//target在右边</span>                    start <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
