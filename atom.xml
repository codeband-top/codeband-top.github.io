<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-01-20T13:00:14.489Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode24-两两交换链表中的节点</title>
    <link href="https://www.codetool.top/article/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.codetool.top/article/leetcode24-两两交换链表中的节点/</id>
    <published>2020-01-20T12:55:44.000Z</published>
    <updated>2020-01-20T13:00:14.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，自底向上</p><p>终止点：</p><ol><li>head为null，返回null</li><li>head的next为null，代表此时是倒数第一个元素（链表节点是奇数个），直接返回head</li></ol><p>否则，直接交换当前节点和下一个节点，下一个节点的next使用<code>swapPairs()</code>计算</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你不能只是单纯的改变节点内部的值&lt;/strong&gt;，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="https://www.codetool.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode559-N叉树的最大深度</title>
    <link href="https://www.codetool.top/article/leetcode559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://www.codetool.top/article/leetcode559-N叉树的最大深度/</id>
    <published>2020-01-20T12:39:39.000Z</published>
    <updated>2020-01-20T12:42:58.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>我们应返回其最大深度，3。</p><p><strong>说明:</strong></p><ol><li>树的深度不会超过 <code>1000</code>。</li><li>树的节点总不会超过 <code>5000</code>。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><ol><li>自底向上，每个节点是所有孩子节点的深度的最大值+1</li><li>自顶向下，依次更新最大高度</li></ol><h2 id="代码">2.2 代码</h2><p>自底向上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> depth<span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>level<span class="token operator">></span>max<span class="token punctuation">)</span> max <span class="token operator">=</span> level<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自顶向下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> depth<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depth</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> cur<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">></span>depth<span class="token punctuation">)</span> depth <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span>            <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>cur<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，找到其最大深度。&lt;/p&gt;
&lt;p&gt;最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode429-N叉树的层序遍历</title>
    <link href="https://www.codetool.top/article/leetcode429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode429-N叉树的层序遍历/</id>
    <published>2020-01-19T18:36:06.000Z</published>
    <updated>2020-01-19T18:43:26.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其层序遍历:</p><pre><code>[     [1],     [3,2,4],     [5,6]]</code></pre><p><strong>说明:</strong> </p><ol><li>树的深度不会超过 1000。</li><li>树的节点总数不会超过 5000。</li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似<a href="../leetcode102-二叉树的层次遍历/">leetcode102-二叉树的层次遍历</a>，通过DFS或BFS实现。</p><h2 id="代码">2.2 代码</h2><p>迭代（BFS）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以null作为每层结束的标志符</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Node node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                cur<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Node child<span class="token operator">:</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token operator">!=</span>null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//若队首为null说明这一层的节点的子节点已经全部加入队列了，需要加入一个null</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>递归（DFS）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span>            <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> level<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>level<span class="token punctuation">)</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">!=</span>null<span class="token punctuation">)</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;层序遍历&lt;/em&gt;。 (即从左到右，逐层遍历)。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetoo
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode590-N叉树的后序遍历</title>
    <link href="https://www.codetool.top/article/leetcode590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode590-N叉树的后序遍历/</id>
    <published>2020-01-19T18:23:52.000Z</published>
    <updated>2020-01-19T18:25:30.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其前序遍历: <code>[5,6,3,2,4,1]</code>.</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似二叉树的后序遍历，递归回溯时将根节点加入集合中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;后序遍历&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1579
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode589-N叉树的前序遍历</title>
    <link href="https://www.codetool.top/article/leetcode589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://www.codetool.top/article/leetcode589-N叉树的前序遍历/</id>
    <published>2020-01-18T18:52:50.000Z</published>
    <updated>2020-01-18T18:59:06.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p><p>例如，给定一个 <code>3叉树</code> :</p><p><img src="https://api.codetool.top/img/15793736562578.png" alt></p><p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。</p><p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似二叉树的前序遍历，递归将根节点加入集合中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursion</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Node node<span class="token operator">:</span>root<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">recursion</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个 N 叉树，返回其节点值的&lt;em&gt;前序遍历&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;例如，给定一个 &lt;code&gt;3叉树&lt;/code&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/1579
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机第三版读书笔记06</title>
    <link href="https://www.codetool.top/article/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B006/"/>
    <id>https://www.codetool.top/article/深入理解java虚拟机第三版读书笔记06/</id>
    <published>2020-01-18T14:12:50.000Z</published>
    <updated>2020-01-19T19:34:07.570Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<strong>第六章 类文件结构</strong>的内容</p><h1 id="Class类文件的结构">1 Class类文件的结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项都是紧凑排列的，如果有需要占用8个字节以上的数据项时，会按照高位在前的方式分割成多个8字节进行存储。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型——“无符号数”和“表”：</p><ul><li>无符号数：基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，<strong>所有表的命名都习惯性地以“_info”结尾。</strong> </li></ul><p>Class文件由以下这些数据项组成：</p><p><img src="https://api.codetool.top/img/15793652641604.png" alt="Class文件格式"></p><h2 id="魔数与Class文件的版本">1.1 魔数与Class文件的版本</h2><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件格式标准都会用魔数来确认文件格式，使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。Class文件的魔数值为<code>0xCAFEBABE</code>（咖啡宝贝）。</p><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的主版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><p>Java1：45<br>Java4：48<br>Java5：49<br>Java8：52<br>以此类推  </p><p>关于次版本号，曾经在Java 2出现前被短暂使用过，从JDK 1.2以后，直到JDK 12之前<strong>次版本号均未使用，全部固定为零。</strong>而到了JDK 12时期，由于JDK提供的功能集已经非常庞大，有一些复杂的新特性需要以“公测”的形式放出，所以设计者重新启用了副版本号，将它用于标识“技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。</p><p><img src="https://api.codetool.top/img/15793686659279.png" alt="Class文件版本号"></p><h2 id="常量池">1.2 常量池</h2><p>8~9字节是一项u2类型的数据，代表常量池容量计数值（常量池有多少项），这个容量计数是从1而不是0开始的。</p><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul><p>最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_Module_info和CONSTANT_Package_info两个常量，所以截至JDK13，常量表中分别有17种不同类型的常量。</p><p>这17类表都有一个共同的特点，表结构起始的第一位是个u1类型的标志位（tag，取值见下表标志列），代表着当前常量属于哪种常量类型。17种常量类型所代表的具体含义如表所示。</p><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>表示一个动态计算常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>表示一个模块</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>表示一个模块中开放或者导出的包。</td></tr></tbody></table><p>常量池中的17种数据类型的结构总表：</p><table> <col class="xl651514" span="4"> <thead>    <tr height="19">    <th height="19" class="xl661514">常量    </th><th class="xl661514">项目    </th><th class="xl661514">类型    </th><th class="xl661514">描述    </th></tr> </thead> <tr height="19">  <td rowspan="3" height="95" class="xl671514">CONSTANT_Utf8_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为1</td> </tr> <tr height="38">  <td height="38" class="xl661514">length<span>&nbsp;</span></td>  <td class="xl661514">u2</td>  <td class="xl661514">UTF-8编码的字符串占用的字节数</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u1</td>  <td class="xl661514">长度为length的UTF-8编码的字符串</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Integer_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为3</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u4</td>  <td class="xl661514">按照高位在前存储的int值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Float_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为4</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u4</td>  <td class="xl661514">按照高位在前存储的float值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Long_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为5</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u8</td>  <td class="xl661514">按照高位在前存储的long值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Double_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为6</td> </tr> <tr height="38">  <td height="38" class="xl661514">bytes<span>&nbsp;</span></td>  <td class="xl661514">u8</td>  <td class="xl661514">按照高位在前存储的double值</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_Class_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为7</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向全限定名常量项的索引</td> </tr> <tr height="19">  <td rowspan="2" height="57" class="xl671514">CONSTANT_String_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为8</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向字符串字面量的索引</td> </tr> <tr height="19">  <td rowspan="3" height="152" class="xl671514">CONSTANT_Fieldref_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为9</td> </tr> <tr height="76">  <td height="76" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向字段描述符CONSTANT_NameAndType的索引项</td> </tr> <tr height="19">  <td rowspan="3" height="133" class="xl671514">CONSTANT_Methodref_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为10</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向声明方法的类描述符CONSTANT_Class_info的索引项</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向名称及类型描述符CONSTANT_NameAndType的索引项</td> </tr> <tr height="19">  <td rowspan="3" height="152" class="xl671514">CONSTANT_InterfaceMethodref_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为11</td> </tr> <tr height="76">  <td height="76" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向声明方法的接口描述符CONSTANT_Class_info的索引项</td> </tr> <tr height="57">  <td height="57" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向名称及类型描述符CONSTANT_NameAndType的索引项</td> </tr> <tr height="19">  <td rowspan="3" height="95" class="xl671514">CONSTANT_NameAndType_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为12</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向该字段或方法名称常量项的索引</td> </tr> <tr height="38">  <td height="38" class="xl661514">index</td>  <td class="xl661514">u2</td>  <td class="xl661514">指向该字段或方法描述符常量项的索引</td> </tr> <tr height="19">  <td rowspan="3" height="152" class="xl671514">CONSTANT_MethodHandle_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为15</td> </tr> <tr height="95">  <td height="95" class="xl661514">reference_kind</td>  <td class="xl661514">u1</td>  <td class="xl661514">值必须在1至9之间（包括1和9），它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</td> </tr> <tr height="38">  <td height="38" class="xl661514">reference_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引</td> </tr> <tr height="19">  <td rowspan="2" height="114" class="xl671514">CONSTANT_MethodType_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为16</td> </tr> <tr height="95">  <td height="95" class="xl661514">descriptor_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符</td> </tr> <tr height="19">  <td rowspan="3" height="209" class="xl671514">CONSTANT_Dynamic_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为17</td> </tr> <tr height="76">  <td height="76" class="xl661514">bootstrap_method_attr_ index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td> </tr> <tr height="114">  <td height="114" class="xl661514">name_and_type_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符。</td> </tr> <tr height="19">  <td rowspan="3" height="209" class="xl671514">CONSTANT_InvokeDynamic_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为18</td> </tr> <tr height="76">  <td height="76" class="xl661514">bootstrap_method_attr_ index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td> </tr> <tr height="114">  <td height="114" class="xl661514">name_and_type_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符。</td> </tr> <tr height="19">  <td rowspan="2" height="114" class="xl671514">CONSTANT_Module_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为19</td> </tr> <tr height="95">  <td height="95" class="xl661514">name_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示模块名字</td> </tr> <tr height="19">  <td rowspan="2" height="114" class="xl671514">CONSTANT_Package_info</td>  <td class="xl661514">tag</td>  <td class="xl661514">u1</td>  <td class="xl661514">值为20</td> </tr> <tr height="95">  <td height="95" class="xl661514">name_index</td>  <td class="xl661514">u2</td>  <td class="xl661514">值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示包名称</td> </tr></table><h2 id="访问标志">1.3 访问标志</h2><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final，只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令的新语义，invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK1.0.2之后编译出来的类的这个标志都必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0X0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0X0400</td><td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0X2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>标识这是一个模块</td></tr></tbody></table><p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一律为零。</p><h2 id="类索引、父类索引与接口索引集合">1.4 类索引、父类索引与接口索引集合</h2><p>跟在访问标志后面的，分别是类索引、父类索引和接口索引集合。类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。<strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</strong>除了<code>java.lang.Object</code>外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串。</p><p>接口索引集合的入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是&lt;strong&gt;第六章 类文件结构&lt;/strong&gt;的内容&lt;/p&gt;
&lt;h1 id=&quot;Class类文件的结构&quot;&gt;1 Class类文件的结构&lt;/h1&gt;&lt;p&gt;Class文件是一组以8个字节为基础单位的二进制流，各个数据项都是紧凑排列的，如果有需要占用8个字节以上的数据项时，
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="深入理解java虚拟机" scheme="https://www.codetool.top/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>leetcode108-将有序数组转换为二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode108-将有序数组转换为二叉搜索树/</id>
    <published>2020-01-17T16:59:42.000Z</published>
    <updated>2020-01-17T17:16:15.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><pre><code>给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：      0     / \   -3   9   /   / -10  5</code></pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>类似于二分查找，每次递归使用数组的中间元素作为根节点。就能最大化利用左右节点空间，使之平衡。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode110-平衡二叉树</title>
    <link href="https://www.codetool.top/article/leetcode110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode110-平衡二叉树/</id>
    <published>2020-01-17T15:30:21.000Z</published>
    <updated>2020-01-17T15:52:10.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><pre><code>       1      / \     2   2    / \   3   3  / \ 4   4</code></pre><p>返回 <code>false</code> 。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>自顶向下：每个节点获取左右两棵子树的高度，并比较高度差是否大于1，获取高度通过递归实现。</p><p>自底向上：回溯时比较左右节点的高度，如果有任意节点左右子树高度差大于1，则说明不是平衡树。</p><h2 id="代码">2.2 代码</h2><p>自顶向下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Height</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">Height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自底向上：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BalancedBinaryTree</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode235-二叉搜索树的最近公共祖先</title>
    <link href="https://www.codetool.top/article/leetcode235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://www.codetool.top/article/leetcode235-二叉搜索树的最近公共祖先/</id>
    <published>2020-01-17T13:03:36.000Z</published>
    <updated>2020-01-17T13:33:56.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://api.codetool.top/img/15792677547121.png" alt></p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br><strong>输出:</strong> 6<br><strong>解释:</strong> 节点 2 和节点 8 的最近公共祖先是 6。  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br><strong>输出:</strong> 2<br><strong>解释:</strong> 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。  </p></blockquote><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>利用二叉搜索树的性质，两个节点p、q可以有两种分布情况：</p><ol><li>分别位于公共祖先的左、右子树。</li><li>其中一个节点就是公共祖先，另一个节点位于子树上。</li></ol><p>如此递归查找。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">></span>p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val<span class="token operator">></span>q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode450-删除二叉搜索树中的节点</title>
    <link href="https://www.codetool.top/article/leetcode450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://www.codetool.top/article/leetcode450-删除二叉搜索树中的节点/</id>
    <published>2020-01-16T11:35:34.000Z</published>
    <updated>2020-01-16T12:23:07.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><blockquote><p>root = [5,3,6,2,4,null,7]<br>key = 3</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5<br>&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;6<br>&nbsp;/&nbsp;\ &nbsp;&nbsp;&nbsp;\<br>2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;7   </p><p>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。  </p><p>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;5<br>&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6<br>&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7  </p><p>另一个正确答案是 [5,2,6,null,4,null,7]。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;5<br>&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;6<br>&nbsp;&nbsp;&nbsp;\ &nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;7       </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>删除一个节点，可以有三种情况：</p><ol><li>它没有子节点，那么直接删除。</li><li>它拥有一个子节点，那么直接用子节点替换它</li><li>它有两个子节点，则可以：</li></ol><p>将它的右子节点附在左子节点的最右边：</p><p><img src="https://api.codetool.top/img/15791745014898.png" alt></p><p>或，将它的左子节点附在右子节点的最左边：</p><p><img src="https://api.codetool.top/img/15791749252282.png" alt></p><p>实际就是让搜索树线性化，这样操作会让搜索树的高度逐渐失衡，所以并不推荐作为一个数据结构这样实现。</p><p>更好的删除方法可以参考官方题解： <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian-by-l/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian-by-l/</a></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">deleteNode</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//根节点就是要删除的节点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token keyword">return</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token operator">==</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//左子节点是要删除的节点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> root<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                node<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token operator">&amp;&amp;</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token operator">==</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//右子节点是要删除的节点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token operator">==</span>null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> root<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                node<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> root<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉搜索树的根节点 &lt;strong&gt;root&lt;/strong&gt; 和一个值 &lt;strong&gt;key&lt;/strong&gt;，删除二叉搜索树中的 &lt;strong&gt;key&lt;/strong&gt; 对应的节点，并保证二叉搜索树的性质不变。返回二
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode701-二叉搜索树中的插入操作</title>
    <link href="https://www.codetool.top/article/leetcode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.codetool.top/article/leetcode701-二叉搜索树中的插入操作/</id>
    <published>2020-01-16T09:52:36.000Z</published>
    <updated>2020-01-16T10:15:50.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如, </p><blockquote><p>给定二叉搜索树:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;7<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3  </p><p>和 插入的值: 5</p></blockquote><p>你可以返回这个二叉搜索树:</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\ &nbsp;&nbsp;/<br>&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;5  </p></blockquote><p>或者这个树也是有效的:</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>与搜索操作类似，对于每个节点，我们将：</p><ol><li>根据节点值与目标节点值的关系，搜索左子树或右子树；</li><li>重复步骤 1 直到到达外部节点；</li><li>根据节点的值与目标节点的值的关系，将新节点添加为其左侧或右侧的子节点。</li></ol><p>如此递归。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">&lt;</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token operator">==</span>null<span class="token punctuation">)</span> root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>val<span class="token operator">></span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token operator">==</span>null<span class="token punctuation">)</span> root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。&lt;/p&gt;
&lt;p&gt;注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode700-二叉搜索树中的搜索</title>
    <link href="https://www.codetool.top/article/leetcode700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.codetool.top/article/leetcode700-二叉搜索树中的搜索/</id>
    <published>2020-01-16T05:45:31.000Z</published>
    <updated>2020-01-16T09:56:49.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><blockquote><p>给定二叉搜索树:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;7<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3  </p><p>和值: 2</p></blockquote><p>你应该返回如下子树:</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3</p></blockquote><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 <code>NULL</code>。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>根据BST的特性，对于每个节点：</p><ol><li>如果目标值等于节点的值，则返回节点;</li><li>如果目标值小于节点的值，则继续在左子树中搜索;</li><li>如果目标值大于节点的值，则继续在右子树中搜索。</li></ol><p>如此递归搜索。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定二叉搜索树:&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode173-二叉搜索树迭代器</title>
    <link href="https://www.codetool.top/article/leetcode173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://www.codetool.top/article/leetcode173-二叉搜索树迭代器/</id>
    <published>2020-01-15T17:05:07.000Z</published>
    <updated>2020-01-15T17:09:07.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p><p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p><p><strong>示例：</strong></p><p><img src="https://api.codetool.top/img/15791079678639.png" alt></p><blockquote><p>BSTIterator iterator = new BSTIterator(root);<br>iterator.next();    // 返回 3<br>iterator.next();    // 返回 7<br>iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 9<br>iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 15<br>iterator.hasNext(); // 返回 true<br>iterator.next();    // 返回 20<br>iterator.hasNext(); // 返回 false  </p></blockquote><p><strong>提示：</strong></p><ul><li><code>next()</code> 和 <code>hasNext()</code> 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。</li><li>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 中至少存在一个下一个最小的数。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>理解二叉搜索树的数据结构，像二叉树的中序遍历那样构造一个list。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BSTIterator</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BSTIterator</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">buildList</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildList</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">buildList</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">buildList</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** @return the next smallest number */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cur<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** @return whether we have a next smallest number */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;next()&lt;/code&gt; 将返回二叉搜索树中的下一个最小的数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>JDK8u20字符串去重</title>
    <link href="https://www.codetool.top/article/JDK8u20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D/"/>
    <id>https://www.codetool.top/article/JDK8u20字符串去重/</id>
    <published>2020-01-15T11:54:37.000Z</published>
    <updated>2020-01-15T12:54:11.995Z</updated>
    
    <content type="html"><![CDATA[<ul><li>优点：节省大量内存</li><li>缺点：略微多占用cpu时间，新生代回收时间略微增加</li></ul><p><code>-XX:+UseStringDeduplication</code></p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//char[] {'h','e','l','l','o'}</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//char[] {'h','e','l','l','o'}</span></code></pre><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1并发检查是否有字符串重复</li><li>如果它们值一样，让它们引用同一个char[]</li><li>注意，与String.intern()不一样<ul><li>String.intern()关注的是字符串对象</li><li>而字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串表</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;优点：节省大量内存&lt;/li&gt;
&lt;li&gt;缺点：略微多占用cpu时间，新生代回收时间略微增加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseStringDeduplication&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot; language-java&quot;
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
      <category term="优化" scheme="https://www.codetool.top/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>leetcode98-验证二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode98-验证二叉搜索树/</id>
    <published>2020-01-15T08:20:17.000Z</published>
    <updated>2020-01-15T09:11:16.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;2<br>&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3<br><strong>输出:</strong> true</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;5<br>&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;6<br><strong>输出:</strong> false<br><strong>解释:</strong> 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>递归，要考虑整个左子树的最大值小于根节点，整个右子树的最小值大于根节点。通过传参来获取这些信息。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">recursion</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> Integer up<span class="token punctuation">,</span> Integer low<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>up <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">>=</span> up<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> low<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> low<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recursion</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> up<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;假设一个二叉搜索树具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含&lt;strong&gt;小于&lt;/strong&gt;当前节点的数。&lt;/li&gt;
&lt;li&gt;节点的右子树只包
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode297-二叉树的序列化与反序列化</title>
    <link href="https://www.codetool.top/article/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://www.codetool.top/article/leetcode297-二叉树的序列化与反序列化/</id>
    <published>2020-01-14T18:29:14.000Z</published>
    <updated>2020-01-14T18:37:25.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>示例：</strong></p><blockquote><p>你可以将以下二叉树：    </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5  </p><p>序列化为 “[1,2,3,null,null,4,5]”  </p></blockquote><p><strong>提示:</strong> 这与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1194353/" target="_blank" rel="noopener">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>说明:</strong> 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>BFS，完全用队列实现就好，我这里会形成<code>1,2,3,null,null,4,5,null,null,null,null,</code>这样的字符串。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Codec</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Encodes a tree to a single string.</span>    <span class="token keyword">public</span> String <span class="token function">serialize</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Decodes your encoded data to tree.</span>    <span class="token keyword">public</span> TreeNode <span class="token function">deserialize</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"null,"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> datas <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>datas<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode left <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>datas<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>datas<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TreeNode right <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>datas<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>datas<span class="token punctuation">[</span>count<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            node<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>            count<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&lt;/p&gt;
&lt;p&gt;请设计一个算法来实现二叉树的序列化与反序列
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode236-二叉树的最近公共祖先</title>
    <link href="https://www.codetool.top/article/leetcode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://www.codetool.top/article/leetcode236-二叉树的最近公共祖先/</id>
    <published>2020-01-14T16:54:05.000Z</published>
    <updated>2020-01-14T17:29:55.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://api.codetool.top/img/15790215494425.png" alt></p><p><strong>示例1：</strong></p><blockquote><p><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>输出:</strong> 3<br><strong>解释:</strong> 节点 5 和节点 1 的最近公共祖先是节点 3。  </p></blockquote><p><strong>示例2：</strong></p><blockquote><p><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>输出:</strong> 5<br><strong>解释:</strong> 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我首先的思路就是要有一个reach函数，可以判断一个节点是不是指定节点的祖先，通过dfs实现，返回一个bool值。<br>那么这道题要寻找离p、q最近的祖先节点，就可以再使用一个dfs，我们都知道dfs回溯的时候是从下往上的，那么只要调用函数最早对参数p、q都返回true的节点就是要得到的答案了，然后沿着回溯返回值链传回这个节点。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        TreeNode left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>        TreeNode right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">reach</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token operator">==</span><span class="token boolean">true</span><span class="token operator">&amp;&amp;</span><span class="token function">reach</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">reach</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">reach</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">reach</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;st
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode117-填充每个节点的下一个右侧节点指针II</title>
    <link href="https://www.codetool.top/article/leetcode117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/"/>
    <id>https://www.codetool.top/article/leetcode117-填充每个节点的下一个右侧节点指针II/</id>
    <published>2020-01-14T13:45:48.000Z</published>
    <updated>2020-01-14T13:53:02.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二叉树</p><blockquote><p>struct Node {<br>&nbsp;&nbsp;int val;<br>&nbsp;&nbsp;Node *left;<br>&nbsp;&nbsp;Node *right;<br>&nbsp;&nbsp;Node *next;<br>}  </p></blockquote><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例：</strong></p><p><img src="https://api.codetool.top/img/15790096159513.png" alt></p><blockquote><p><strong>输入：</strong> root = [1,2,3,4,5,null,7]<br><strong>输出：</strong>[1,#,2,3,#,4,5,7,#]<br><strong>解释：</strong> 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p></blockquote><p><strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我在<a href="../leetcode116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/">leetcode116-填充每个节点的下一个右侧节点指针</a>用的方法仍适用于该题</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Node<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> Node <span class="token function">connect</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            Node node <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> root<span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>depth<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二叉树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;struct Node {&lt;br&gt;&amp;nbsp;&amp;nbsp;int val;&lt;br&gt;&amp;nbsp;&amp;nbsp;Node *left;&lt;br&gt;&amp;nbsp;&amp;nbsp;Node *ri
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode116-填充每个节点的下一个右侧节点指针</title>
    <link href="https://www.codetool.top/article/leetcode116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <id>https://www.codetool.top/article/leetcode116-填充每个节点的下一个右侧节点指针/</id>
    <published>2020-01-14T12:23:22.000Z</published>
    <updated>2020-01-14T13:40:55.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><blockquote><p>struct Node {<br>&nbsp;&nbsp;int val;<br>&nbsp;&nbsp;Node *left;<br>&nbsp;&nbsp;Node *right;<br>&nbsp;&nbsp;Node *next;<br>}  </p></blockquote><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例：</strong></p><p><img src="https://api.codetool.top/img/15790051044903.png" alt></p><blockquote><p><strong>输入：</strong>{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}<br><br><br><strong>输出：</strong> {“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}<br><br><br><strong>解释：</strong> 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p></blockquote><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>DFS搜索，用一个list存放每层前一个遍历的节点，再次遍历到该层的时候从list中取出上一个元素并修改next指针。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Node<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> Node <span class="token function">connect</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Node root<span class="token punctuation">,</span><span class="token keyword">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>            Node node <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> root<span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>depth<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;完美二叉树&lt;/strong&gt;，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;struct Node {&lt;br&gt;&amp;nbsp;&amp;nbsp;int v
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode105-从前序与中序遍历序列构造二叉树</title>
    <link href="https://www.codetool.top/article/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode105-从前序与中序遍历序列构造二叉树/</id>
    <published>2020-01-12T18:50:27.000Z</published>
    <updated>2020-01-14T13:40:40.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><blockquote><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p></blockquote><p>返回如下的二叉树：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;/ \<br>&nbsp;&nbsp;9&nbsp;&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;7  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>根据前序遍历第一个元素是根、中序遍历以根为中心划分左子树和右子树的特点，递归构造左子树和右子树。</p><p>算法优化过程见：<a href="https://www.codetool.top/article/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">leetcode106-从中序与后序遍历序列构造二叉树</a></p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorderGlobal<span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map<span class="token punctuation">;</span>    <span class="token keyword">public</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        preorderGlobal <span class="token operator">=</span> preorder<span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        TreeNode root <span class="token operator">=</span> <span class="token function">getUnit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>preorder<span class="token punctuation">.</span>length<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TreeNode <span class="token function">getUnit</span><span class="token punctuation">(</span><span class="token keyword">int</span> preorderStart<span class="token punctuation">,</span><span class="token keyword">int</span> preorderEnd<span class="token punctuation">,</span><span class="token keyword">int</span> inorderStart<span class="token punctuation">,</span><span class="token keyword">int</span> inorderEnd<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>preorderStart<span class="token operator">==</span>preorderEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorderGlobal<span class="token punctuation">[</span>preorderStart<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>preorderGlobal<span class="token punctuation">[</span>preorderStart<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftCount <span class="token operator">=</span> index <span class="token operator">-</span> inorderStart<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">getUnit</span><span class="token punctuation">(</span>preorderStart<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preorderStart<span class="token operator">+</span>leftCount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inorderStart<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">getUnit</span><span class="token punctuation">(</span>preorderStart<span class="token operator">+</span>leftCount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>preorderEnd<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inorderEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;你可以假设树中没有重复的元素。&lt;/p&gt;
&lt;p&gt;例如，给出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前序遍历 preorder 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="https://www.codetool.top/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
