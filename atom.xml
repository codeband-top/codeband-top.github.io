<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-04-16T17:52:16.965Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPS的原理——混合加密、数字签名、CA</title>
    <link href="https://www.codetool.top/article/HTTPS%E7%9A%84%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81CA/"/>
    <id>https://www.codetool.top/article/HTTPS的原理——混合加密、数字签名、CA/</id>
    <published>2020-04-16T17:51:52.000Z</published>
    <updated>2020-04-16T17:52:16.965Z</updated>
    
    <content type="html"><![CDATA[<p>前置知识：<a href="../谈谈对称加密、非对称加密、消息摘要以及数字签名">谈谈对称加密、非对称加密、消息摘要以及数字签名</a></p><p>本文参考资源：</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453141883&idx=2&sn=3b93d3bed05ec0094a0cae77bf1cc82c&chksm=8cf2dbf8bb8552ee286c4799b30d3847a641760142e50234b12bd042f9d238b3291c161b5996&mpshare=1&scene=23&srcid=&sharer_sharetime=1587058055254&sharer_shareid=c085eab43b9a65b398a19df04709e455#rd" target="_blank" rel="noopener">全网最透彻HTTPS（面试常问）</a></p><p><a href="https://blog.csdn.net/u014294681/article/details/86599741" target="_blank" rel="noopener">网络篇 - https协议中的数据是否需要二次加密_网络_u014294681的博客-CSDN博客</a></p><h1 id="HTTPS概述">1 HTTPS概述</h1><h2 id="HTTPS介绍">1.1 HTTPS介绍</h2><p>HTTPS是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。</p><p>HTTPS 把 HTTP 下层的传输协议由 <code>TCP/IP</code> 换成了 <code>SSL/TLS</code>，由<code>HTTP over TCP/IP</code>变成了<code>HTTP over SSL/TLS</code>，让 HTTP 运行在了安全的 <code>SSL/TLS</code> 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。</p><p><img src="https://api.codetool.top/img/15870519053306.png" alt></p><h2 id="什么是SSL-TLS">1.2 什么是SSL/TLS</h2><p>SSL 即安全套接层（Secure Sockets Layer），<strong>在 OSI 模型中处于第 5 层（会话层）</strong>，由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p><p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF <strong>在 1999 年把它改名为 TLS</strong>（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 <code>TLS1.0</code> 实际上就是 <code>SSLv3.1</code>。</p><p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和 2018 年的 1.3。</p><p>说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p><h1 id="TLS的关键技术">2 TLS的关键技术</h1><p>对于网络传输，要保证安全，必须保证：</p><ul><li>机密性：对数据进行加密，通过密文实现</li><li>完整性：指数据在传输过程中没有被窜改，服务器发的是什么，客户端接收的就是什么样的</li><li>身份认证：确认对方的真实身份，否则容易被中间人攻击</li><li>不可否认：也叫不可抵赖，意思是不能否认已经发生过的行为，如果缺了不可否认，那通信的事务真实性就得不到保证。</li></ul><p><img src="https://api.codetool.top/img/15870551057859.png" alt="实现安全要求的原理"></p><p>可以看到，TLS为保证安全，同时使用了对称加密、非对称加密和消息摘要。不了解的可以点击前置知识链接去看一下。</p><h2 id="传输加密">2.1 传输加密</h2><p>TLS保证传输加密是使用了混合加密，它同时使用了对称加密和非对称加密。</p><p>为什么要混合加密呢？我们在<a href="../谈谈对称加密、非对称加密、消息摘要以及数字签名">谈谈对称加密、非对称加密、消息摘要以及数字签名</a>中提到，非对称加密虽然安全，但加密解密速度较慢，效率较低，而对称加密又需要解决密钥的传输安全性问题。于是，我们可以结合这二者，<strong>使用非对称加密解决对称加密的密钥传输问题</strong>。</p><p>客户端用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</p><p>服务端拿到密文之后再用私钥解密，拿到“会话密钥”，<strong>作为后续对称加密使用的密钥</strong>。</p><h2 id="消息摘要">2.2 消息摘要</h2><p>TLS保证消息的完整性则是使用了消息摘要，只要双方在消息后附上它的摘要，就能够保证数据的完整性。当然摘要也得使用混合加密，否则会被黑客修改。</p><p>目前 TLS 推荐使用摘要算法的是SHA-2系列（包含SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要）。</p><h2 id="数字签名-amp-CA">2.3 数字签名&amp;CA</h2><p>数字签名实现了身份认证和不可否认，数字签名又使用了非对称加密和消息摘要技术。我们在<a href="../谈谈对称加密、非对称加密、消息摘要以及数字签名">谈谈对称加密、非对称加密、消息摘要以及数字签名</a>中介绍过。数字签名就是将消息摘要后的数据再使用私钥加密。</p><p><img src="https://api.codetool.top/img/15870581177513.png" alt></p><p>然而考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。</p><p>当服务端向客户端返回公钥A1的时候，中间人将其替换成自己的公钥B1传送给浏览器。</p><p>而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被中间人截获，中间人利用自己的私钥B2解密，得到密钥K，再使用服务端的公钥A1加密传送给服务端，完成了通信链路，而服务端和客户端毫无感知。</p><p><img src="https://api.codetool.top/img/15870559453668.jpg" alt></p><p>这个时候就需要CA证书了，<strong>CA证书证明该公钥确实是来自服务端</strong>。服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份数字证书，数字证书里包含有证书持有者、证书有效期、服务端的公钥、CA使用的消息摘要算法等信息，称为明文数据，CA还会将证书的明文数据进行消息摘要，并使用私钥生成数字签名，附在证书内。服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。（<strong>证书的构成：证书的明文信息+由证书的明文信息+CA的私钥生成的数字签名</strong>）</p><p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。<strong>小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。</strong>你必须相信，否则整个证书信任链就走不下去了。</p><p>有了这个证书体系，<strong>操作系统和浏览器都内置了各大 CA 的根证书（包含CA的公钥）</strong>，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而确定里面的公钥也是可信的。</p><p>CA机构颁发证书的过程：</p><ol><li>CA机构拥有自己的一对公钥和私钥</li><li>CA机构在颁发证书时对证书明文信息进行哈希</li><li>将哈希值用私钥进行加签，得到数字签名</li></ol><p><strong>服务端将证书明文数据和数字签名组成证书，传递给客户端。</strong> 而客户端需要验证证书中的公钥没有被篡改：</p><ol><li>客户端得到证书，分解成明文部分Text和数字签名Sig1</li><li>用CA机构的公钥进行解密，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）</li><li>用证书里声明的哈希算法对明文Text部分进行哈希得到H</li><li>当自己计算得到的哈希值H与Sig2相等，表示证书可信，没有被篡改</li></ol><p>然后客户端就可以信任明文数据中的服务端公钥了。</p><h1 id="HTTP通信过程一览">3 HTTP通信过程一览</h1><p><img src="https://api.codetool.top/img/15870544945377.png" alt="HTTPS原理一览图"></p><ol><li>用户在浏览器发起HTTPS请求（如 <a href="https://www.mogu.com/），默认使用服务端的443端口进行连接" target="_blank" rel="noopener">https://www.mogu.com/），默认使用服务端的443端口进行连接</a></li><li>HTTPS需要使用一套CA数字证书，<strong>证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开</strong></li><li>服务端收到请求，<strong>返回配置好的包含公钥Pub的证书给客户端</strong></li><li>客户端收到证书，<strong>校验合法性</strong>，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续</li><li>客户端<strong>生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端</strong></li><li>服务端收到随机Key的密文，<strong>使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key</strong></li><li>服务端<strong>使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密</strong>，将密文返回客户端；</li><li>客户端<strong>使用随机Key对称解密密文</strong>，得到HTTP数据明文</li><li>后续HTTPS请求使用之前交换好的随机Key进行对称加解密</li></ol><p>其中用了两次非对称加密，这两次非对称加密是容易把人搞懵的：</p><ul><li>第一次是客户端获取证书后，<strong>使用CA的公钥解密证书中的数字签名</strong>，然后判断证书中的服务端公钥是否可信</li><li>第二次是客户端<strong>使用服务端公钥对使用随机数生成的对称加密密钥进行加密</strong>，然后发给服务端。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前置知识：&lt;a href=&quot;../谈谈对称加密、非对称加密、消息摘要以及数字签名&quot;&gt;谈谈对称加密、非对称加密、消息摘要以及数字签名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAw
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习02-处理器管理（进程管理）</title>
    <link href="https://www.codetool.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A002-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%89/"/>
    <id>https://www.codetool.top/article/操作系统复习02-处理器管理（进程管理）/</id>
    <published>2020-04-16T09:54:01.000Z</published>
    <updated>2020-04-16T13:16:59.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理器概念">1 处理器概念</h1><p><img src="https://api.codetool.top/img/15870310461239.png" alt></p><p>特权指令和非特权指令、管态和目态已在上一篇提及。</p><p>Intel的X86处理器具有四个特权级别，分别是RING0、RING1、RING2、RING3，RING0层拥有最高权限，依此向下RING3层即拥有最低的权限。</p><p>用户态切换为核心态是通过中断实现的。并且中断是唯一途径，用户手动触发中断的指令称为陷阱指令，也称为访管指令。</p><p>核心态切换为用户态是通过执行一个特权指令，将程序状态字(PSW)的标志位设置为用户态。</p><h2 id="用户栈和核心栈">1.1 用户栈和核心栈</h2><p>用户栈：是用户进程空间中开辟的内存区域，用于保存应用程序的子程序(函数)间相互调用的参数、返回值、返回点以及子程序的局部变量。</p><p>核心栈：每个进程被创建时捆绑一个核心栈，是内存中属于OS空间的区域，用途包括：用于保存中断现场；或保存OS程序间相互调用的参数、返回值、返回点以及程序局部变量。</p><h2 id="程序状态字PSW">1.2 程序状态字PSW</h2><p>计算机如何知道当前处于管态还是目态？通常OS都引入程序状态字PSW（Program Status Word）来区别不同的处理器工作状态。</p><p>PSW用来<strong>控制指令执行顺序并保留和指示与程序有关的系统状态</strong>，主要作用是实现程序状态的保护和恢复。<strong>每个程序都有一个与其执行相关的PSW，每个处理器都设置一个PSW寄存器。</strong>程序占有处理器执行，它的PSW将占有PSW寄存器。 </p><p>PSW寄存器包括以下内容：</p><ul><li>程序基本状态：<ol><li>程序计数器；</li><li>条件码；</li><li>处理器状态位。</li></ol></li><li>中断码：保存程序执行时当前发生的中断事件。</li><li>中断屏蔽位：指明程序执行中发生中断事件时，是否响应出现的中断事件。</li></ul><p>Intel x86中，PSW由标志寄存器EFLAGS和指令指针寄存器EIP组成，均为32位。</p><p>EFLAGS的低16位称FLAGS，标志可划分为三组：状态标志、控制标志、系统标志。</p><h1 id="中断技术">2 中断技术</h1><p><img src="https://api.codetool.top/img/15870310716982.png" alt></p><p>中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程。</p><h2 id="中断源分类">2.1 中断源分类</h2><ul><li>内中断：信号的来源是CPU内部，与当前执行的指令有关<ul><li>I/O中断</li><li>访管中断：调用访管指令，是程序自愿的</li><li>硬件故障</li><li>程序性中断（和编程时的问题有关）</li></ul></li><li>外中断：信号的来源是CPU外部，与当前执行的指令无关<ul><li>外部设备请求</li><li>时钟中断</li></ul></li></ul><p>外中断又分可屏蔽中断和不可屏蔽中断，内中断完全不可屏蔽。</p><p>时钟是操作系统进行调度工作的重要工具，如让分时进程作时间片轮转、让实时进程定时发出或接收控制信号、系统定时唤醒或阻塞一个进程、对用户进程进行记账。</p><h2 id="中断优先级">2.2 中断优先级</h2><p>每个不同中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会屏蔽部分或全部低级中断。级别高的有优先获得响应的权力，中断装置预定的这个响应顺序称为中断优先级。 </p><h2 id="多重中断事件的处理">2.3 多重中断事件的处理</h2><p><strong>中断正在进行处理期间，CPU又响应新的中断事件</strong>，于是暂时停止正在运行的中断处理程序，转去执行新的中断处理程序，就叫多重中断（又称中断嵌套）。处理方法：</p><ol><li>串行处理，</li><li>嵌套处理，</li><li>即时处理。</li></ol><h1 id="进程及其实现">3 进程及其实现</h1><p><img src="https://api.codetool.top/img/15870310852352.png" alt></p><h2 id="进程概念">3.1 进程概念</h2><ul><li>进程是可并发执行的程序在某个数据集合上的一次计算活动，也是<strong>操作系统进行资源分配和保护的基本单位。</strong></li><li>进程是一个<strong>既能用来共享资源，又能描述程序并发执行过程的系统基本单位。</strong></li><li>进程是一种支持程序执行的系统机制。</li></ul><p>进程的属性：</p><ul><li>动态性</li><li>共享性</li><li>独立性：独立性会体现在虚存、程序计数器、内部状态上</li><li>制约性</li><li>并发性</li></ul><h2 id="进程状态和转换">3.2 进程状态和转换</h2><p>本节参考和图片来源：<a href="https://www.cnblogs.com/lrhya/p/10636011.html" target="_blank" rel="noopener">进程的状态转换 - LRH呀 - 博客园</a></p><h3 id="三态模型">3.2.1 三态模型</h3><p>三态模型，也是最基本的几个状态：</p><p><img src="https://api.codetool.top/img/15870345103687.png" alt></p><ul><li>就绪态意味着运行条件满足，等待系统分配处理器以便运行</li><li>运行态是已分配处理器，正在运行的状态</li><li>等待态是不具备运行条件，等待某个事件完成，如IO输入。</li></ul><h3 id="五态模型">3.2.2 五态模型</h3><p><img src="https://api.codetool.top/img/15870348059720.png" alt></p><p>五态模型在三态模型的基础上加了新建态和终止态。</p><ul><li>新建态：对应于进程被创建时的状态，尚未进入就绪队列。<blockquote><p>创建一个进程需要通过两个步骤：  </p></blockquote></li></ul><p>1.为新进程分配所需要资源和建立必要的管理信息。<br>2.设置该进程为就绪态，并等待被调度执行。  </p><ul><li>终止态：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。<blockquote><p>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。<br>终止一个进程需要两个步骤：    </p></blockquote></li></ul><p>1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。<br>2.然后回收占用的资源并被系统删除。</p><h3 id="七态模型">3.2.3 七态模型</h3><p>三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，<strong>当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。</strong> 起到平滑系统操作负荷的目的。</p><p>七态模型在五态模型的基础上增加了挂起就绪态（ready suspend）和挂起等待态（blocked suspend）。</p><ul><li>挂起就绪态：进程具备运行条件，但目前<strong>在外存中</strong>，只有它被对换到内存才能被调度执行。</li><li>挂起等待态：表明进程正在等待某一个事件发生且<strong>在外存中</strong>。</li></ul><p><img src="https://api.codetool.top/img/15870350867344.png" alt></p><h2 id="进程的描述和组成">3.3 进程的描述和组成</h2><h3 id="进程映像">3.3.1 进程映像</h3><p>进程实体(进程映像)的组成：</p><ul><li>进程控制块（<strong>PCB</strong>）</li><li>进程<strong>程序块</strong></li><li>进程核心栈</li><li>进程<strong>数据块</strong></li></ul><p>进程控制块PCB，是OS<strong>用于记录和刻划进程状态及有关信息的数据结构</strong>。也是OS掌握进程的唯一资料结构，它包括<strong>进程执行时的情况，以及进程让出处理器后所处的状态、断点等信息。</strong> PCB是进程存在的唯一标志。</p><p>进程控制块包含三类信息：</p><ul><li>标识信息，包括进程号（pid），进程组，用户标识符（uid）</li><li>现场信息，包含中断时处理器的信息</li><li>控制信息<ul><li>进程调度的相关信息，如进程优先级</li><li>进程组成信息</li><li>进程间的族系信息</li><li>进程间通信信息</li></ul></li></ul><h3 id="进程队列及其管理">3.3.2 进程队列及其管理</h3><p>处于同一状态的所有PCB链接在一起的数据结构称为进程队列。 可按先来先到的原则排成队列，也可按优先数或其它原则排队。</p><p>组织方式：</p><ul><li>线性方式</li><li>链接方式：操作系统持有指向各个队列的指针</li><li>索引方式：根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针</li></ul><h3 id="进程上下文切换">3.3.3 进程上下文切换</h3><p>进程切换是让处于运行态的进程中断运行，让出处理器，这时要做一次进程上下文切换、即保存老进程的上下文而装入被保护了的新进程的上下文，以便新进程运行。</p><p>中断运行的三种情况：</p><ul><li>被阻塞的高优先级进程变为就绪态</li><li>运行进程的时间片耗尽</li><li>运行进程执行阻塞型I/O指令（变为准备态）</li></ul><p>当然，这些情况触发也不一定就会立即进行进程调度和切换，例外情况：</p><ul><li>内核正在处理中断的过程中</li><li>进程运行在内核临界区中</li><li>内核处在需要屏蔽中断的原子操作过程中</li></ul><p>进程上下文切换的步骤：</p><ol><li>保存被中断进程的处理器现场信息</li><li>修改被中断进程的PCB有关信息，如进程状态等</li><li>把被中断进程的PSB加入有关队列</li><li>选择下一个占有处理器运行的进程</li><li>修改被选中进程的PSB的有关信息</li><li>根据被选中进程设置操作系统用到的地址转换和存储保护信息</li><li>根据被选中进程恢复处理器现场</li></ol><p>当中断/系统调用发生时，暂时中断正在执行的用户进程，把进程从用户状态转换到内核状态，去执行操作系统服务程序以获得服务，这就是一次处理器状态转换。</p><p>处理器状态转换的步骤：</p><ol><li>保存被中断进程的处理器现场信息；</li><li>处理器从用户态转换到核心态，以便执行服务程序或中断处理程序；</li><li>如果处理中断，可根据规定的中断级设置中断屏蔽位；</li><li>根据系统调用号或中断号，从系统调用表或中断入口表找到服务程序或中断处理程序地址。</li></ol><h2 id="进程管理原语">3.4 进程管理原语</h2><p>这个不属于进程上下文切换中的内容，思维导图里面是我弄错了。</p><p>进程管理原语用于进程控制，有：</p><ul><li>进程创建</li><li>进程撤销</li><li>进程阻塞</li><li>进程唤醒</li><li>进程挂起</li><li>进程激活</li></ul><p>进程创建的详细步骤：</p><ol><li>在进程列表中增加一项，从PCB池中申请一个空闲PCB，为新进程分配惟一的进程标识符</li><li>为新进程的进程映像分配地址空间，以便容纳进程实体。进程管理程序确定加载到进程地址空间中的程序</li><li>为新进程分配除主存空间外的其他各种所需资源；</li><li>初始化PCB，如进程标识符、处理器初始状态、进程优先级等；</li><li>把新进程状态置为就绪态，并移入就绪进程队列；</li><li>通知操作系统的某些模块，如记账程序、性能监控程序。</li></ol><p>linux创建进程/线程可以使用：</p><ul><li><code>fork()</code>：父子进程是独立的进程 </li><li><code>clone()</code>：父子进程允许共享资源</li><li><code>vfork()</code>：子进程租用父进程地址空间 </li></ul><p>进程撤销的详细步骤：</p><ol><li>根据撤销进程标识号，从相应队列中找到并移出它</li><li>将该进程拥有的资源归还给父进程或操作系统</li><li>若该进程拥有子进程，先撤销它的所有子进程，以防它们脱离控制</li><li>回收PCB，并归还到PCB池</li></ol><p>进程阻塞步骤：</p><ol><li>停止进程执行，保存现场信息到PCB</li><li>修改进程PCB有关内容，如进程状态由运行态改为等待态等，并把修改状态后的进程移入相应事件的等待队列中</li><li>转入进程调度程序去调度其他进程运行</li></ol><p>进程唤醒步骤：</p><ol><li>从相应的等待队列中移出进程</li><li>修改进程PCB的有关信息，如进程状态改为就绪态，并移入就绪队列</li><li>若被唤醒进程比当前运行进程优先级高，重新设置调度标志</li></ol><h1 id="线程及其实现">4 线程及其实现</h1><p><img src="https://api.codetool.top/img/15870311193616.png" alt></p><h2 id="线程概念">4.1 线程概念</h2><p>OS中引入进程的目的是为了使多个程序并发执行，以改善资源使用率和提高系统效率，OS中再引入线程，则是<strong>为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好。</strong></p><p>线程是OS进程中能够独立执行的实体（控制流），<strong>是处理器调度和分派的基本单位。线程是进程的组成部分</strong>，每个进程内允许包含多个并发执行的实体（控制流），这就是多线程。</p><h2 id="线程优点">4.2 线程优点</h2><ul><li>快速线程切换</li><li>通信易于实现</li><li>减少管理开销</li><li>并发程度提高</li></ul><p>进程作为系统资源分配和保护的独立单位，不需要频繁地切换，而线程共享进程中的数据，利于通信。</p><h2 id="多线程环境">4.3 多线程环境</h2><h3 id="线程组成">4.3.1 线程组成</h3><ol><li>线程控制块：线程<strong>唯一标识符及线程状态信息</strong>(运行态、就绪态、阻塞态和终止态)</li><li>线程是一条执行路径，<strong>有独立的程序计数器</strong>；未运行时保护线程上下文</li><li>线程有<strong>执行栈和存放局部变量的私用存储空间</strong></li><li><strong>可访问所属进程的内存和资源</strong>，并与该进程中的其他线程共享这些资源</li></ol><p>线程又称轻量进程，线程运行在进程的上下文中,并使用进程的资源和环境。系统调度的基本单位是线程而不是进程,每当创建一个进程时，至少要同时为该进程创建一个线程。</p><h3 id="线程状态">4.3.2 线程状态</h3><p>线程状态有：运行、就绪、等待和终止，状态转换也类似于进程。</p><p>挂起状态对线程是没有意义，如果进程挂起后被对换出主存，则它的所有线程因共享进程的地址空间，也必须全部对换出去。</p><h3 id="线程组织">4.3.3 线程组织</h3><p>进程中线程多种组织方式：</p><ul><li>调度员／工作者模式：一个线程担任调度员，用于分配任务并唤醒工作者，其他线程为工作者。</li><li>组模式：各个线程都可以取得并处理工作请求，对特定任务建立相应线程队列（执行不同任务）</li><li>流水线模式：线程排成某个次序，前一个线程产生的数据交给下一个线程处理 </li></ul><h2 id="线程的实现">4.4 线程的实现</h2><p>本节参考：<a href="https://blog.csdn.net/cxy19931018/article/details/81435811" target="_blank" rel="noopener">操作系统学习记录之五：多线程实现的混合策略_小小柴的博客-CSDN博客</a></p><p>从实现角度看，线程分成:</p><ul><li>用户级线程ULT(如Java ,Informix)。</li><li>内核级线程KLT(如OS/2)。</li><li>混合式线程(如Solaris)。</li></ul><p>内核级线程是内核支持的线程，线程管理工作由内核完成。优点是线程切换速度快、执行效率高。缺点是用户态运行、内核态管理导致系统开销大。</p><p>用户级线程是<strong>由应用程序所支持的线程实现</strong>, 内核意识不到用户级线程的实现。线程管理由应用程序完成。优点：</p><ul><li>节省系统模式转换开销和内核的宝贵资源</li><li>允许进程按照应用的特定需要选择调度算法</li><li>能够运行在任何操作系统上</li><li>内核无须做任何改变</li></ul><p>缺点：</p><ul><li>线程的阻塞将引起整个进程的阻塞</li><li>不可能得益于多线程的并发执行</li></ul><p>混合式线程：线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。<strong>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上。</strong>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点。</p><p><img src="https://api.codetool.top/img/15870405337015.png" alt></p><h1 id="处理器调度">5 处理器调度</h1><p><img src="https://api.codetool.top/img/15870311366136.png" alt></p><h2 id="调度层次">5.1 调度层次</h2><p>作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度：</p><p>高级调度，又称作业调度、长程调度。任务是<strong>选择作业进入内存</strong>，控制多道程序的道数。</p><p>中级调度，又称平衡调度、中程调度。任务是<strong>完成外存和内存中的进程对换工作、转换就绪态和等待态</strong>,提高内存利用率和系统吞吐率。</p><p>低级调度，又称进程调度/线程调度、短程调度。任务是<strong>决定就绪队列中的某个进程/线程获得处理器</strong>。</p><h2 id="选择调度算法原则">5.2 选择调度算法原则</h2><p>原则就是性能指标，包含：</p><ul><li>资源利用率：CPU利用率=CPU有效工作时间/CPU总的运行时间。CPU总的运行时间=CPU有效工作时间+CPU空闲等待时间。</li><li>吞吐率：单位时间内CPU处理作业的个数。</li><li>公平性：确保每个进程都能获得合理的资源份额，不会出现饥饿现象。</li><li>响应时间：交互式进程从提交一个请求(命令)到接收到响应之间的时间间隔称响应时间。</li><li>周转时间：从提交作业开始到作业完成的时间。</li></ul><h2 id="作业的管理与调度">5.3 作业的管理与调度</h2><h3 id="作业和进程的关系">5.3.1 作业和进程的关系</h3><p>作业是任务实体，进程是完成任务的执行实体;没有作业任务，进程无事可干，没有进程，作业任务没法完成。</p><p><strong>作业概念更多地用在批处理操作系统，而进程则可以用在各种多道程序设计系统。</strong></p><h3 id="作业控制块">5.3.2 作业控制块</h3><p>多道批处理操作系统具有独立的作业管理模块，必须像进程管理一样为每一个作业建立作业控制块（JCB）。</p><p>JCB通常是在批作业进入系统时，由Spooling系统建立的，它是作业存在于系统的标志，作业撤离时，JCB也被撤销。</p><p>JCB的主要内容包括：</p><ol><li>作业情况</li><li>资源需求</li><li>资源使用情况</li></ol><h3 id="批处理作业的调度">5.3.3 批处理作业的调度</h3><ol><li>选择作业：按照调度算法选择</li><li>分配资源</li><li>创建进程：被调度时，系统为作业创建进程，并生成PCB及各种进程实体</li><li>作业控制：按说明书运行</li><li>后续处理：调度程序做好作业撤离和善后工作</li></ol><h3 id="低级调度功能和类型">5.3.4 低级调度功能和类型</h3><p><strong>调度程序两项任务：</strong> 调度和分派。<strong>调度决定就绪态线程竞争使用处理器的次序，分派决定如何时分复用CPU，处理上下文切换。</strong></p><p>低级调度的基本类型：第一类称剥夺式，有两种处理器剥夺原则，其一是高优先级进程/线程可剥夺低优先级进程/线程，另一种是当运行进程/线程时间片用完后被剥夺。第二类称非剥夺式，进程/线程开始运行后不再让出处理器</p><p>作业调度和低级调度算法：</p><ul><li>先来先服务算法FCFS</li></ul><p>先来先服务是<strong>按照作业进入系统后备队列的先后次序来挑选作业</strong>，先进入系统的作业优先被挑选进入内存。 它是非剥夺式算法，<strong>不利于短作业（短作业的平均周转时间会较长，因为需要等待前面的作业完成）</strong></p><ul><li>最短作业优先算法SJF</li></ul><p>SJF算法<strong>以进入系统的作业所要求的CPU时间为标准，总选取估计计算时间最短的作业投入运行。</strong>（但是由于这个时间只是估算的，并不能保证实际上一定是最短作业）。它也是非剥夺式算法，缺点是长作业可能出现饥饿现象（一直得不到调度），缺少剥夺机制，对分时实时处理不理想。</p><ul><li>最高响应比优先算法HRRF</li></ul><p>FCFS只考虑等待时间而忽视了作业的计算时间，SJF只考虑用户估计的作业计算时间而忽视了作业等待时间，因而比较片面。HRRF是介于FCFS与SJF之间的折中算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。 </p><p><code>响应比 = 周转时间/处理时间 = 1+已等待时间/估计运行时间</code></p><p>因而这种算法会<strong>根据作业已等待的时间和估计运行时间动态调整调度的优先级</strong>，短作业容易得到较高响应比，长作业等待时间足够长后，也将获得足够高的响应比，饥饿现象不会发生。</p><ul><li>优先级调度算法</li></ul><p>永远先选取优先级高的，这个优先级可能是用户指定的，也可能是系统根据作业的重要性等信息调整的。</p><ul><li>最短剩余时间优先算法SRTF</li></ul><p>这是一种剥夺式算法，当一个新作业进入就绪状态，<strong>如果新作业需要的CPU时间比当前正在执行的作业剩余下来还需的CPU时间短，SRTF强行赶走当前正在执行作业。</strong></p><ul><li>轮转调度算法RR</li></ul><p>轮流使用时间片，剥夺式调度。<strong>合适选取时间片的长度很重要，如果时间片太长了就会变成FCFS，如果太短了就会使系统调度开销很大。</strong></p><ul><li>多级反馈队列调度算法MLFQ</li></ul><p>又称反馈循环队列或多队列策略。主要思想是将就绪进程分为两级或多级，系统相应建立两个或多个就绪进程队列，<strong>较高优先级的队列一般分配给较短的时间片。</strong></p><p>处理器调度<strong>先从高级就绪进程队列中选取可占有处理器的进程，只有在选不到时，才从较低级的就绪进程队列中选取。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;处理器概念&quot;&gt;1 处理器概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.top/img/15870310461239.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;特权指令和非特权指令、管态和目态已在上一篇提及。&lt;/p&gt;
&lt;p&gt;Intel的X
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode56-合并区间</title>
    <link href="https://www.codetool.top/article/leetcode56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://www.codetool.top/article/leetcode56-合并区间/</id>
    <published>2020-04-16T06:29:48.000Z</published>
    <updated>2020-04-16T06:34:17.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]<br><strong>输出:</strong> [[1,6],[8,10],[15,18]]<br><strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [[1,4],[4,5]]<br><strong>输出:</strong> [[1,5]]<br><strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题和<a href="../leetcode435-无重叠区间">leetcode435-无重叠区间</a>方法有一点类似，先排序，再处理区间。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> intervals<span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token punctuation">(</span>array1<span class="token punctuation">,</span>array2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">return</span> array1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>array2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果两个区间没有重叠部分，都保留</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>intervals<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lastIndex <span class="token operator">=</span> cur<span class="token punctuation">;</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果两个区间重叠，合并两个区间</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>intervals<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [[1,3],[2,6],[8,10],[15
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode191-位1的个数</title>
    <link href="https://www.codetool.top/article/leetcode191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.codetool.top/article/leetcode191-位1的个数/</id>
    <published>2020-04-15T06:23:54.000Z</published>
    <updated>2020-04-15T06:59:12.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 3<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000010000000<br><strong>输出：</strong> 1<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 31<br><strong>解释：</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p></blockquote><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>进阶:</strong><br>如果多次调用这个函数，你将如何优化你的算法？</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>可以用位运算</p><h2 id="代码">2.2 代码</h2><p>冷酷无情的API选手做法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> num <span class="token operator">:</span>chars<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span>  sum <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>按位与算法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP浏览器缓存策略和相关首部字段</title>
    <link href="https://www.codetool.top/article/HTTP%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.codetool.top/article/HTTP浏览器缓存策略和服务器的缓存控制/</id>
    <published>2020-04-14T16:11:19.000Z</published>
    <updated>2020-04-14T17:58:07.305Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="noopener">HTTP强缓存和协商缓存 - JavaScript学习笔记 - SegmentFault 思否</a></p><p><a href="https://blog.csdn.net/jiangshangchunjiezi/article/details/88581824" target="_blank" rel="noopener">（七）条件请求If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since_Python_FixedStar 的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zl399615007/article/details/84534884" target="_blank" rel="noopener">强制缓存（200）和协商缓存（304）整理_网络_zlong的博客-CSDN博客</a></p><p>在一次HTTP通信中，最接近用户的缓存应该就是浏览器的缓存了，而浏览器到底什么时候走缓存，什么时候请求服务器呢？和服务器有关吗？这篇文章里，就来谈一谈浏览器的缓存策略。</p><h1 id="浏览器缓存概述">1 浏览器缓存概述</h1><p>浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。</p><p>浏览器缓存有以下优点：</p><ol><li>减少冗余数据传输</li><li>减少服务器负担</li><li>加载客户端加载网页的速度</li></ol><h1 id="浏览器请求资源流程图">2 浏览器请求资源流程图</h1><p><img src="https://api.codetool.top/img/15868806136371.png" alt></p><p>这张图里涉及到两个概念：<code>强缓存</code>和<code>协商缓存</code>，浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：<strong>强缓存命中的话不会发请求到服务器（比如 chrome 中的 200 from memory cache）</strong>，协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，<strong>如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。</strong></p><h1 id="强缓存">3 强缓存</h1><p>什么时候会使用强缓存？<strong>打开页面请求资源（或前进、后退、重定向）</strong>的时候会先获取该资源缓存的header信息，然后根据header中的<code>Cache-Control</code>和<code>Expires</code>来判断是否过期，<strong>如果发现本地缓存还没过期，则使用强缓存。</strong></p><p>强缓存利用http头中的<code>Expires</code>和<code>Cache-Control</code>两个字段来控制，用来表示<strong>资源缓存时间</strong>。但<strong>只要刷新就不会使用强缓存</strong>，普通刷新（F5或点击刷新按钮）会忽略它，但是不会清除它，并且请求会带上<code>Cache-Control: max-age=0</code>。强制刷新（Ctrl+F5）则会清除缓存。<strong>并且请求会带上<code>Cache-Control:no-cache</code></strong>，代表该请求不会使用缓存，且不会记录缓存。</p><p>控制强缓存的字段（选其一使用即可）：</p><h2 id="Expires">3.1 Expires</h2><p>Expires是HTTP/1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串，代表资源的失效时间，只要发送的请求在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以<strong>当服务器与客户端时间偏差较大时，就会导致缓存混乱</strong>。如果同时出现Cache-Control:max-age和Expires，那么<strong>max-age的优先级更高</strong>。</p><h2 id="Cache-Control">3.2 Cache-Control</h2><p>Cache-Control 是一个通用首部字段（请求头和响应头都可以用），也是 HTTP/1.1 控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p><ul><li><code>max-age</code>（单位为 s）：设置<strong>缓存的存在时间，相对于发送请求的时间（即响应头中的Date字段）</strong>。只有响应报文首部设置<code>Cache-Control</code>为<strong>非0的max-age</strong>或者设置了大于请求日期的 Expires才有可能命中强缓存。</li><li><code>no-cache</code> 表示<strong>请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存）</strong>，无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。浏览器强制刷新就会带上<code>Cache-Control:no-cache</code>。</li><li><code>no-store</code>：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面，<strong>一定不会出现强缓存和协商缓存</strong>。</li><li><code>must-revalidate</code>：如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。这个值通常配合<code>max-age</code>使用。</li><li><code>public</code>：表明响应可以被浏览器、CDN 等等缓存。</li><li><code>private</code>：响应只作为私有的缓存，不能被 CDN 等缓存。如果要求 HTTP 认证，响应会自动设置为 private。</li></ul><h1 id="协商缓存">4 协商缓存</h1><p>协商缓存就是<strong>由服务器来确定缓存的资源是否可用</strong>，所以客户端与服务器要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p><p>当缓存的<code>max-age</code>过期或浏览器普通刷新，就会启用协商缓存。浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器，服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同，若相同，就将<code>If-None-Match</code>的值设为<code>false</code>，返回状态<code>304</code>，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将<code>If-None-Match</code>的值设为<code>true</code>，返回状态为200，客户端重新解析服务器端返回的数据；<strong>客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的最后修改时间戳（<code>Last-Modified</code>）发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的</strong>，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</p><p>控制协商缓存的字段（选其一使用即可）：</p><h2 id="Last-Modified-If-Modified-Since">4.1 Last-Modified/If-Modified-Since</h2><p><strong><code>If-Modified-Since</code> 是一个请求首部字段</strong>，并且只能用在 GET 或者 HEAD 请求中。<strong><code>Last-Modified</code> 是一个响应首部字段</strong>，包含服务器认定的资源作出修改的日期及时间。<strong>当带着 If-Modified-Since 头访问服务器请求资源时，服务器会检查 Last-Modified，如果 Last-Modified 的时间早于或等于If-Modified-Since 则会返回一个不带主体的 304 响应，</strong>否则将重新返回资源。</p><h2 id="ETag-If-None-Match">4.2 ETag/If-None-Match</h2><p><code>ETag</code> 是一个响应首部字段，它是<strong>根据实体内容生成的一段 hash 字符串，标识资源的状态</strong>，由服务端产生。<code>If-None-Match</code> 是一个条件式的请求首部。<strong>如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的 ETag，则当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的 200 响应，否则服务器会返回不带实体的 304 响应。</strong> <strong>ETag 优先级比 Last-Modified 高</strong>，同时存在时会以 ETag 为准。</p><p><img src="https://api.codetool.top/img/15868853077728.png" alt></p><p>ETag 还有“强”“弱”之分：<strong>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个<code>“W/”</code>标记，只要求资源在语义上没有变化</strong>，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p><p>下面是一次etag命中（你可以打开开发者工具，尝试刷新我的博客，观察结果）：</p><p><img src="https://api.codetool.top/img/15868860702089.png" alt="请求头"></p><p><img src="https://api.codetool.top/img/15868861139012.png" alt="响应头"></p><p>因为 ETag 的特性，所以相较于 Last-Modified 有一些优势：</p><ol><li>某些情况下服务器无法获取资源的最后修改时间</li><li><strong>资源的最后修改时间变了但是内容没变，使用 <code>ETag</code>可以正确缓存</strong></li><li>如果资源修改非常频繁，在秒以下的时间进行修改，<code>Last-Modified</code> 只能精确到秒</li></ol><p>协商缓存属于HTTP<strong>条件请求</strong>的一部分，条件请求还有<code>If-Unmodified-Since</code>，<code>If-Match</code>，<code>If-Range</code>等字段（用于断点续传，和412状态码有关）</p><h1 id="详细总结流程图">5 详细总结流程图</h1><p><img src="https://api.codetool.top/img/15868850187041.png" alt></p><p>注意：Pragma已被废弃。</p><p>下表是用户操作对强缓存/协商缓存的影响：</p><table><thead><tr><th>用户操作</th><th>Expires/Cache-Control</th><th>Last-Modified/Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td>有效</td><td>有效</td></tr><tr><td>页面链接跳转</td><td>有效</td><td>有效</td></tr><tr><td>新开窗口</td><td>有效</td><td>有效</td></tr><tr><td>前进后退</td><td>有效</td><td>有效</td></tr><tr><td>F5刷新</td><td>无效</td><td>有效</td></tr><tr><td>Ctrl+F5强制刷新</td><td>无效</td><td>无效</td></tr></tbody></table><p>需要注意的是，我在chrome中实验发现，当服务器没有响应Cache-Control、Expire相关字段的时候，一定时间内再次访问网站依然会走<code>200(from disk cache)</code>强缓存，可能是和浏览器本身的策略有关，或是<code>Cache-Control</code>有默认值？我在网络上没有查询到资料明确指出<code>Cache-Control</code>是否有默认值，或者<code>max-age</code>的默认值为多少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008956069&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP强缓存和协商缓存 - JavaScript学习笔记 - Segme
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计网复习07-应用层之HTTP报文格式</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A007-%E5%BA%94%E7%94%A8%E5%B1%82%E4%B9%8BHTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/"/>
    <id>https://www.codetool.top/article/计网复习07-应用层之HTTP报文格式/</id>
    <published>2020-04-14T14:18:50.000Z</published>
    <updated>2020-04-14T15:49:30.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP报文概述">1 HTTP报文概述</h1><p>HTTP概述在<a href="../HTTP版本发展与Google的暗中助力/">HTTP版本发展与Google的暗中助力</a> 中已经说得差不多了，这篇文章来专门讲一下HTTP的报文格式</p><p><img src="https://api.codetool.top/img/15868743125701.png" alt></p><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）：描述请求或响应的基本信息；</li><li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li><li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li></ul><p>这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。</p><p>HTTP报文是面向文本的，因此header都是一些ASCII码串，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。（所以中文通常要经过urlencode）</p><p>HTTP 协议规定报文必须有 header，但可以没有 body，<strong>而且在 header 之后必须要有一个“空行”</strong>，也就是“CRLF”，十六进制的<code>“0D0A”</code>。</p><h1 id="请求行-amp-状态行">2 请求行&amp;状态行</h1><h2 id="请求行">2.1 请求行</h2><p><img src="https://api.codetool.top/img/15868744881740.png" alt></p><p>请求行是请求报文中的第一行，请求行由三部分构成：</p><ol><li>请求方法：是一个动词，如 GET/POST，表示对资源的操作。事实上，请求方法的语义并没有被严格遵守，直到RESTful API的广泛应用，才使得请求方法的语义变得重要了起来。</li></ol><table><thead><tr><th>方法（操作）</th><th>意义</th></tr></thead><tbody><tr><td>OPTION</td><td>请求一些选项的信息</td></tr><tr><td>GET</td><td>请求读取由 URL所标志的信息</td></tr><tr><td>HEAD</td><td>请求读取由 URL所标志的信息的首部</td></tr><tr><td>POST</td><td>给服务器添加信息（例如，注释）</td></tr><tr><td>PUT</td><td>在指明的 URL下存储一个文档</td></tr><tr><td>DELETE</td><td>删除指明的 URL所标志的资源</td></tr><tr><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><p>关于请求方法，我们通常谈到幂等性，相关内容可以参考<a href="../Http请求的幂等性/">Http请求的幂等性</a></p><ol start="2"><li>请求目标：通常是一个 URI，标记了请求方法要操作的资源。</li><li>版本号：表示报文使用的 HTTP 协议版本。</li></ol><p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p><h2 id="状态行">2.2 状态行</h2><p>状态行是响应报文中的第一行，与请求行的结构类似。</p><p><img src="https://api.codetool.top/img/15868750209984.png" alt></p><p>状态行包括三项内容:</p><ol><li>版本号：表示报文使用的 HTTP 协议版本。</li><li>状态码：一个三位数，用代码的形式表示处理的结果。我在<a href="../SpringBoot开发RESTful%20API">SpringBoot开发RESTful API</a>中列举了常用的HTTP状态码。</li><li>短语：解释状态码的简单短语，帮助人理解原因。对于常见的状态码200，后面跟的短语可能就是<code>OK</code>。</li></ol><h1 id="头部字段（首部行）">3 头部字段（首部行）</h1><p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头。请求报文和响应报文中的头部字段的格式都是一样的，只是字段可能有所区别。</p><p>头部字段是 key-value 的形式，key 和 value 之间用<code>“: ”</code>分隔，最后用 CRLF 换行表示字段结束。比如在<code>“Host: 127.0.0.1”</code>这一行里 key 就是<code>“Host”</code>，value 就是<code>“127.0.0.1”</code>。</p><p>使用头字段需要注意下面几点：</p><ul><li>字段名<strong>不区分大小写</strong>，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li><li>字段名里<strong>不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”</strong>。例如，<code>“test-name”</code>是合法的字段名，而<code>“test name”``“test_name”</code>是不正确的字段名；</li><li>字段名后面必须紧接着“:”，不能有空格，<strong>而“:”后的字段值前可以有多个空格</strong>；</li><li>字段的顺序是没有意义的，可以任意排列不影响语义；</li><li>字段<strong>原则上不能重复</strong>，除非这个字段本身的语义允许，例如 Set-Cookie。</li></ul><h2 id="Content-Type-amp-Content-Encoding">3.1 Content-Type&amp;Content-Encoding</h2><p><code>Content-Type</code>：标识body的内容类型，取值通过<code>“MIME type”</code>标准确定，MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串，巧得很，刚好也符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头字段里。</p><p>这里简单列举一下在 HTTP 里经常遇到的几个类别：</p><ul><li><code>text</code>：即文本格式的可读数据，我们最熟悉的应该就是 <code>text/html</code> 了，表示超文本文档，此外还有纯文本 <code>text/plain</code>、样式表 <code>text/css</code> 等。</li><li><code>image</code>：即图像文件，有 <code>image/gif</code>、<code>image/jpeg</code>、<code>image/png</code> 等。</li><li><code>audio/video</code>：音频和视频数据，例如 <code>audio/mpeg</code>、<code>video/mp4</code> 等。</li><li><code>application</code>：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 <code>application/json</code>，<code>application/javascript</code>、<code>application/pdf</code> 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 <code>application/octet-stream</code>，即不透明的二进制数据。</li></ul><p>需要注意的是以<code>x-</code>开头的类型是我们自定义的类型。使用<code>*</code>代表任意类型。</p><p><code>Content-Encoding</code>：告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。如果响应报文里没有 <code>Content-Encoding</code> 字段，就表示响应数据没有被压缩。常见的<code>Content-Encoding</code>：</p><ul><li><code>gzip</code>：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li><li><code>deflate</code>：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li><li><code>br</code>：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li></ul><h2 id="Accept-amp-Accept-Encoding">3.2 Accept&amp;Accept-Encoding</h2><p>如果服务器一厢情愿发送特定的数据类型而客户端解析不了也不行，所以请求首部字段中通常会有<code>Accept</code>字段，代表客户端可理解的 MIME type，用<code>,</code>做分隔符列出多个类型。对应的，也存在<code>Accept-Encoding</code>字段，代表客户端支持的压缩格式。服务器通常要通过这两个字段决定响应的数据类型。</p><h2 id="其他Accept-和Content-字段">3.3 其他Accept-和Content-字段</h2><p><code>Accept-Language</code>代表客户端可理解的自然语言，<code>Content-Language</code>告诉客户端实体数据使用的实际语言类型。</p><p><code>Accept-Charset</code>代表客户端可解析的字符集，<strong>响应报文并不会有<code>Content-Charset</code>，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示。</strong></p><p>不过现在的浏览器都支持多种字符集，通常不会发送 <code>Accept-Charset</code>，而服务器也不会发送 <code>Content-Language</code>，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 <code>Accept-Language</code> 字段，响应头里只会有 <code>Content-Type</code> 字段。</p><h2 id="内容协商的质量值">3.4 内容协商的质量值</h2><p>我们称以上<code>Accept-*</code>和<code>Content-*</code>字段为客户端和服务端对传输的内容进行<strong>内容协商</strong>，在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，<strong>还可以用一种特殊的“q”参数表示权重来设定优先级</strong>，这里的“q”是“quality factor”的意思。</p><p>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个<code>;</code>，然后是<code>q=value</code>。</p><p>例如：</p><pre><code>Accept: text/html,application/xml;q=0.9,*/*;q=0.8</code></pre><p>它表示浏览器最希望使用的是 HTML 文件，权重是 <code>1</code>，其次是 XML 文件，权重是 <code>0.9</code>，最后是任意数据类型，权重是 <code>0.8</code>。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p><h2 id="内容协商的结果">3.5 内容协商的结果</h2><p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个<code>Vary</code>字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p><pre><code>Vary: Accept-Encoding,User-Agent,Accept</code></pre><p>这个 <code>Vary</code> 字段表示服务器依据了 <code>Accept-Encoding</code>、<code>User-Agent</code> 和 <code>Accept</code> 这三个头字段，然后决定了发回的响应报文。</p><h2 id="其他常见的头部字段">3.6 其他常见的头部字段</h2><p><code>Host</code>字段，它属于<strong>请求字段</strong>，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里<strong>要求必须出现的字段</strong>，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。<strong>Host 字段告诉服务器这个请求应该由哪个主机来处理</strong>，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。</p><p><code>User-Agent</code>是<strong>请求字段</strong>，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是<code>“Mozilla”``“Chrome”``“Safari”</code>，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。</p><p><code>Date</code>字段是一个通用字段，但<strong>通常出现在响应头里，表示 HTTP 报文创建的时间</strong>，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p><p><code>Server</code>字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如<code>nginx/1.**</code>。<strong>Server 字段也不是必须要出现的</strong>，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，<strong>有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。</strong></p><p><code>Content-Length</code>，它表示报文里 body 的长度，也就是<strong>请求头或响应头空行后面数据的长度</strong>。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。<strong>如果没有这个字段，那么 body 就是不定长的，需要使用 <code>chunked</code> 方式分段传输。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP报文概述&quot;&gt;1 HTTP报文概述&lt;/h1&gt;&lt;p&gt;HTTP概述在&lt;a href=&quot;../HTTP版本发展与Google的暗中助力/&quot;&gt;HTTP版本发展与Google的暗中助力&lt;/a&gt; 中已经说得差不多了，这篇文章来专门讲一下HTTP的报文格式&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>计网复习06-应用层之域名系统DNS</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A006-%E5%BA%94%E7%94%A8%E5%B1%82%E4%B9%8B%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <id>https://www.codetool.top/article/计网复习06-应用层之域名系统DNS/</id>
    <published>2020-04-14T04:11:10.000Z</published>
    <updated>2020-04-14T05:24:05.417Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://blog.csdn.net/grace_yi/article/details/89419106" target="_blank" rel="noopener">全局负载均衡（GSLB）的实现方案_运维_奔向云计算的笨鸟的专栏-CSDN博客</a></p><p><a href="https://blog.csdn.net/cywosp/article/details/38017027" target="_blank" rel="noopener">每天进步一点点——负载均衡之DNS域名解析_运维_Cynric 的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/zhuxiangru/p/9536092.html" target="_blank" rel="noopener">几种域名解析类型和使用方式 - 菜鸟的一天 - 博客园</a></p><p>现在网站的数目非常多，如果全部用 IP 地址进行访问，恐怕很难记住。许多应用层软件经常直接使用<strong>域名系统</strong>(DNS, Domain Name System)，但计算机的用户只是间接而不是直接使用域名系统。 </p><h1 id="域名系统DNS">1 域名系统DNS</h1><p>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。<br>互联网采用了<strong>层次树状结构</strong>的命名方法，域名的结构由标号序列组成，各标号之间用点隔开：</p><pre><code>….三级域名.二级域名.顶级域名</code></pre><p>对于我的博客 <a href="http://www.codetool.top">http://www.codetool.top</a> ，top就是顶级域名，codetool是二级域名。</p><p>最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。</p><p>域名只是个逻辑概念，并不代表计算机所在的物理地点。</p><h2 id="常见顶级域名">1.1 常见顶级域名</h2><ol><li>国家顶级域名 nTLD<ul><li><code>.cn</code> 表示中国，</li><li><code>.us</code> 表示美国，</li><li><code>.uk</code> 表示英国，等等。</li></ul></li><li>通用顶级域名 gTLD<br> 最早的顶级域名是：<ul><li><code>.com</code>    （公司和企业）</li><li><code>.net</code>    （网络服务机构</li><li><code>.org</code>    （非赢利性组织）</li><li><code>.edu</code>    （美国专用的教育机构）</li><li><code>.gov</code>    （美国专用的政府部门）</li><li><code>.mil</code>    （美国专用的军事部门）</li><li><code>.int</code>    （国际组织）</li></ul></li><li>基础结构域名 (infrastructure domain)：这种顶级域名只有一个，即 <code>arpa</code>，用于反向域名解析，因此又称为反向域名。 </li></ol><p>随着互联网的发展，出现了很多新增的顶级域名，这里不谈。</p><h2 id="注意事项">1.2 注意事项</h2><ol><li>域名已经支持中文，不过不被广泛使用</li><li>域名的总长度限制在253个字符以内，而<strong>每一级域名长度不能超过63个字符</strong>。</li><li>域名是大小写无关的，但通常都使用小写的形式。</li><li>过长的域名或者过多的层次关系也会导致与IP 地址同样难于记忆的问题，所以常见的域名大多是两级或三级，四级以上的很少见。</li></ol><h1 id="DNS服务器">2 DNS服务器</h1><p><strong>域名到 IP 地址的解析是由若干个域名服务器程序完成的</strong>。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。  </p><p>一个服务器所负责管辖的（或有权限的）范围叫做区 (zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。  </p><p><img src="https://api.codetool.top/img/15868392791161.png" alt></p><p>域名服务器有以下四种类型：</p><ul><li>根域名服务器：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域名服务器：返回权威 DNS 服务器的 IP 地址</li><li>权限（权威）域名服务器：返回相应主机的 IP 地址</li><li>本地域名服务器 </li></ul><p><img src="https://api.codetool.top/img/15868398223943.png" alt></p><h2 id="根域名服务器">2.1 根域名服务器</h2><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。<strong>所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</strong></p><p>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</p><p>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a一直到m（前 13 个字母），它们又有数百台的镜像，保证一定能够被访问到。</p><p>根域名服务器共有 13 套装置，不是 13 个机器。这些根域名服务器相应的域名分别是：</p><pre><code>a.rootservers.netb.rootservers.net… m.rootservers.net</code></pre><p>到2016年2月，全世界已经在 588 个地点安装了根域名服务器，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器。 </p><h2 id="顶级域名服务器">2.2 顶级域名服务器</h2><p>顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。</p><p>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 </p><h2 id="权限域名服务器">2.3 权限域名服务器</h2><p>负责一个区的域名服务器。</p><p>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 </p><h2 id="本地域名服务器">2.4 本地域名服务器</h2><p>本地域名服务器对域名系统非常重要。</p><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。 </p><h1 id="域名的解析过程">3 域名的解析过程</h1><p><strong>主机向本地域名服务器的查询一般都是采用递归查询。</strong>如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p><p><img src="https://api.codetool.top/img/15868400281344.png" alt></p><p><strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询。</strong>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><p><img src="https://api.codetool.top/img/1586840043224.png" alt></p><h1 id="域名的高速缓存">4 域名的高速缓存</h1><p>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。 </p><p><strong>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项</strong>（例如，每个项目只存放两天）。</p><p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。 </p><p>另外，<strong>操作系统里也会对 DNS 解析结果做缓存</strong>，如果你之前访问过“<a href="http://www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到" target="_blank" rel="noopener">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p><h1 id="hosts文件">5 hosts文件</h1><p>操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是<code>“/etc/hosts”</code>，在 Windows 里是<code>“C:\WINDOWS\system32\drivers\etc\hosts”</code>，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p><h1 id="几种域名解析类型">6 几种域名解析类型</h1><h2 id="A记录">6.1 A记录</h2><p>最简单最常用，添加记录时候填写IP地址即可。A记录(Address)是用来<strong>指定主机名（或域名）对应的IP地址记录。</strong>通过A记录您可以将该域名指向到自己的网站服务器IP地址，同时也可以设置您域名的二级域名。 </p><h2 id="MX记录">6.2 MX记录</h2><p>是<code>Mail Exchanger</code>的缩写，意思是邮件交换记录。它<strong>指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。</strong>例如，当Internet上的某用户要发一封信给 <a href="mailto:user@vipiis.com" target="_blank" rel="noopener">user@vipiis.com</a>时，该用户的邮件系统通过DNS查找vipiis.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。 </p><h2 id="CNAME记录">6.3 CNAME记录</h2><p>也被称为别名记录，<strong>是双线智能解析和使用CDN加速必须用到的解析方法</strong>。CNAME解析通常是一个三级域名地址，您可以在主机管理后台”绑定域名”位置看到cname解析地址的信息提示，不同服务器会使用不同的cname解析地址。<strong>通过cname解析，可以让域名捆绑到多个服务器IP地址</strong>，需要注意的是cname解析地址后面有个英文“.”符号。 </p><p>通常来说，别名解析可以提供更大的灵活性，便于统一管理。举个例子来说，当主机因各种因素的影响需要更换IP时，如果域名做了CNAME记录，就可以同时更新别名的解析指向，不用需要进行新的解析操作，也就是说可以做到无缝更换IP，这对实际中IP的维护是很实用的。而且对于双线主机来说，电信和联通有不同的接口对应不同的IP,由于A记录只能指向一个IP,这时采用别名解析就可以很好的解决这个问题。当然了CNAME记录也存在一定的不足，很多人认为不同的IP会对网站优化产生一定的影响，当搜索引擎爬虫每次爬行的时候，IP变化容易让爬虫产生网站不稳定的误解。不过见仁见智，到底好不好还需要自己去判断。</p><h2 id="NS记录">6.4 NS记录</h2><p>是域名DNS服务器记录，全称Name Server记录，<strong>用来指定该域名由哪个DNS服务器来对您的域名进行解析。</strong>您注册域名时，总有默认的DNS服务器，每个注册的域名都是由一组DNS域名服务器来解析的。</p><h2 id="TXT记录">6.5 TXT记录</h2><p>一种文本记录，仅用于对主机名或者域名的记录信息，对解析无实质影响。</p><h2 id="TTL值">6.6 TTL值</h2><p>全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。默认即可。 </p><h1 id="基于DNS的负载均衡">7 基于DNS的负载均衡</h1><p>这里先谈谈什么是内部负载均衡（SLB）和全局负载均衡（GSLB）？</p><p>SLB(Server load balancing)是<strong>对集群内物理主机的负载均衡</strong>，而GSLB是<strong>对物理集群的负载均衡。</strong>这里的负载均衡可能不只是简单的流量均匀分配,而是会根据策略的不同实现不同场景的应用交付。</p><p>GSLB是依赖于用户和实际部署环境的互联网资源分发技术，不同的目的对应着一系列不同的技术实现。</p><h2 id="内部负载均衡">7.1 内部负载均衡</h2><p>使用DNS实现内部负载均衡较简单，直接<strong>将域名解析到多个IP地址</strong>，下面是利用DNS工作原理处理负载均衡的工作原理图：</p><p><img src="https://api.codetool.top/img/15868409833833.png" alt></p><p>由上图可以看出，在DNS服务器中应该配置了多个A记录，如：</p><pre><code>www.apusapp.com IN A 114.100.20.201;www.apusapp.com IN A 114.100.20.202;www.apusapp.com IN A 114.100.20.203;</code></pre><h2 id="全局负载均衡">7.2 全局负载均衡</h2><p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。</p><p>另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心（就近访问），这样，客户体验就会非常好，访问速度就会超快。</p><p>使用DNS实现全局负载均衡是在DNS服务器关联GSLB设备，它通过自定义的策略根据客户IP地理位置、运营商、可用集群等信息为客户分配合适的主机。</p><p><img src="https://api.codetool.top/img/15868416855058.png" alt></p><h1 id="DNS劫持">8 DNS劫持</h1><p>域名劫持是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，<strong>把目标网站域名解析到错误的IP地址</strong>从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址（网站）的目的。</p><p>如何解决？使用可靠的DNS服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/grace_yi/article/details/89419106&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全局负载均衡（GSLB）的实现方案_运维_奔向云计
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode445-两数相加II</title>
    <link href="https://www.codetool.top/article/leetcode445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://www.codetool.top/article/leetcode445-两数相加II/</id>
    <published>2020-04-14T02:42:43.000Z</published>
    <updated>2020-04-14T05:24:08.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>进阶：</strong></p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出:</strong> 7 -&gt; 8 -&gt; 0 -&gt; 7  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>栈</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> val1<span class="token punctuation">,</span>val2<span class="token punctuation">,</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            val1 <span class="token operator">=</span> stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            val2 <span class="token operator">=</span> stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">=</span> val1<span class="token operator">+</span>val2<span class="token operator">+</span>carry<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">>=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                carry <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                sum <span class="token operator">-=</span> <span class="token number">10</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>            head <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP版本发展与Google的暗中助力</title>
    <link href="https://www.codetool.top/article/HTTP%E7%89%88%E6%9C%AC%E5%8F%91%E5%B1%95%E4%B8%8EGoogle%E7%9A%84%E6%9A%97%E4%B8%AD%E5%8A%A9%E5%8A%9B/"/>
    <id>https://www.codetool.top/article/HTTP版本发展与Google的暗中助力/</id>
    <published>2020-04-13T06:57:58.000Z</published>
    <updated>2020-04-16T15:27:47.266Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://www.cnblogs.com/hanxuming/p/8026206.html" target="_blank" rel="noopener">http协议历史 - 承载梦想-韩旭明 - 博客园</a></p><p><a href="https://www.cnblogs.com/wupeixuan/p/8642100.html" target="_blank" rel="noopener">HTTP 0.9 HTTP 1.0 HTTP 1.1 HTTP 2.0区别 - 武培轩 - 博客园</a></p><p><a href="https://segmentfault.com/a/1190000013028798?utm_source=tag-newest" target="_blank" rel="noopener">HTTP1.0 HTTP1.1 HTTP2.0 主要特性对比 - 前端碎碎念 - SegmentFault 思否</a></p><p><a href="http://www.52im.net/thread-1309-1-1.html" target="_blank" rel="noopener">技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解-网络编程/专项技术区 - 即时通讯开发者社区!</a></p><p>极客时间《透视HTTP协议》课程</p><h1 id="HTTP协议概述">1 HTTP协议概述</h1><p>HTTP（HyperText Transfer Protocol）是一个简单的请求-响应协议，它通常运行在TCP之上。最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web， 万维网）</p><p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。他提出万维网的核心概念有：</p><ul><li>URI：即统一资源标识符，作为互联网上资源的唯一身份</li><li>HTML：即超文本标记语言，描述超文本文档</li><li>HTTP：即超文本传输协议，用来传输超文本。</li></ul><h1 id="HTTP版本审视">2 HTTP版本审视</h1><h2 id="HTTP-0-9">2.1 HTTP/0.9</h2><p>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是<strong>纯文本</strong>，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p><p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯-李最初设想的系统里的文档都是只读的，所以<strong>只允许用“GET”动作从服务器上获取 HTML 文档（不能是其他格式），并且在响应请求之后立即关闭连接</strong>，功能非常有限。</p><p>这个时期的HTTP并没有作为正式的标准被建立。HTTP/0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP/0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。</p><h2 id="HTTP-1-0">2.2 HTTP/1.0</h2><p>1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，计算机多媒体技术也有了新的发展。这些新软件新技术一经推出立刻就吸引了广大网民的热情，更多的人开始使用互联网，研究 HTTP 并提出改进意见，甚至实验性地往协议里添加各种特性，从用户需求的角度促进了 HTTP 的发展。</p><p>于是在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在1996年的5月正式发布，并记载于RFC1945。虽然说是初期标准，但该协议标准至今仍被使用在服务器端。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，特点有：</p><ul><li>任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</li><li>除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段</li><li>增加了响应状态码，标记可能的错误原因</li><li>引入了协议版本号概念</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活</li><li>其他还有支持长连接（使用<code>Connection: keep-alive</code>，但默认还是使用短连接），缓存机制，以及身份认证等</li></ul><p>HTTP/1.0的不足：</p><p>HTTP1.0规定浏览器和服务器保持短暂的连接，<strong>浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），无法复用连接</strong>，服务器不跟踪每个客户端也不记录过去的请求（无状态）。然而TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>其次就是队头阻塞（head of line blocking）。由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。</p><p>为了解决这些问题，HTTP1.1出现了。</p><h2 id="HTTP-1-1">2.3 HTTP/1.1</h2><p>1997年公布的HTTP/1.1是目前主流的HTTP协议版本。之前的标准是RFC2068，之后又发布了修订版RFC2616。</p><p>这个时期开始，HTTP协议已经成为了一份正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p><p>HTTP/1.1的特点有：</p><ul><li>引入了持久连接（persistent connection），即<strong>TCP连接默认不关闭，可以被多个请求复用，默认使用<code>Connection: keep-alive</code>。</strong>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接</li><li>引入了管道机制（pipelining），即<strong>在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</strong>需要注意的是，<strong>服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</strong>而这个响应过程是串行的。</li><li>新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名</li><li>增加了缓存管理和控制；</li><li>允许响应数据分块（chunked），利于传输大文件。对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li><li>提供了范围请求功能(宽带优化)：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<strong>HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。这是支持文件断点续传的基础。</strong></li></ul><p>HTTP/1.1的不足：</p><p>虽然1.1版允许复用TCP连接，但队头阻塞的问题仍存在，服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接（并发连接）。这导致了很多的网页优化技巧，比如<strong>合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）</strong>等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h2 id="SPDY协议与HTTP-2">2.4 SPDY协议与HTTP/2</h2><p>HTTP/1.1标准数十年没有更新，而为了解决对队头阻塞的问题，只能使用切图、JS 合并等网页优化手段。</p><p>Google 对此表示不满，并着手致力改进HTTP/1.1协议。首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY （读作SPeeDY）协议，并在 Chrome 里应用于自家的服务器。<strong>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作</strong>。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p><p>后来随着Chrome后来日趋增高的用户占有率，SPDY也成为了主流的协议，终于，互联网标准化组织忍不住了，开始以 SPDY 为基础制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p><p>我查阅这部分资料的时候，翻到了数十年前的一条新闻，现在看还挺有意思的：</p><p><a href="https://www.infoq.cn/article/2009/11/Google-SPDY-Replace-HTTP/" target="_blank" rel="noopener">Google正制订一项新协议，旨在替换掉HTTP - InfoQ</a></p><p>SPDY的基本特征：</p><ul><li>多路复用流：SPDY<strong>允许在一个连接上无限制并发流</strong>。因为请求在一个通道上，TCP效率更高：更少的网络连接，发出更少更密集的数据包。</li><li>请求优先级：虽然无限的并发流解决了序列化的问题，但他们引入了另一个问题：如果带宽通道受限制， 客户端可能会因防止堵塞通道而阻止请求。为了克服这个问题，SPDY实行请求优先级：客户端从服务器端请求它希望的项目数量，并<strong>为每个请求分配一个优先级。这可以防止在网络通道被非关键资源堵塞时，高优先级的请求被挂起。</strong></li><li><strong>HTTP报头压缩</strong>：SPDY压缩请求和响应HTTP报头，从而减少传输的数据包数量和字节数。</li><li>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li></ul><p>基于SPDY的HTTP2.0的特点：</p><ul><li>二进制协议，不再是纯文本</li><li>可发起多个请求，废弃了 1.1 里的管道（多路复用）</li><li>使用专用算法压缩头部，减少数据传输量</li><li>允许服务器主动向客户端推送数据（和websocket有点不一样，它类似于预测用户要用到什么数据，提前推送给客户端）</li><li>增强了安全性，“事实上”要求加密通信</li><li>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li></ul><h2 id="QUIC协议与HTTP-3">2.5 QUIC协议与HTTP/3</h2><p>HTTP 2.0 虽然大大增加了并发性，但还是有问题的。<strong>因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行</strong>。虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞，说到底这是TCP的固有问题。</p><p>于是Google又作妖了，着手研发QUIC协议。QUIC 是 <code>Quick UDP Internet Connections</code> 的缩写，在大概2014年的时候面世，它改造了UDP协议，通过UDP无连接的特性减小传输延迟，但改进和实现了部分TCP的功能，例如可靠传输。它和UDP一样是一个传输层的协议，在这种协议之上建立的HTTP协议称为<code>HTTP over QUIC</code></p><p><code>HTTP over QUIC</code> 相比现在广泛应用的 <code>http2+tcp+tls</code> 协议有如下优势：</p><ul><li>减少了 TCP 三次握手及 TLS 握手时间</li><li>改进的拥塞控制</li><li>避免队头阻塞的多路复用</li><li>连接迁移</li><li>前向冗余纠错</li></ul><p>这里就不详细介绍Quic了，实际上自定义UDP实现TCP的功能的场景并不少见，这里面牵扯到自定义连接机制、自定义重传机制、自定义流量控制、自定义拥塞控制等实现。</p><p>2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。（持怀疑态度）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hanxuming/p/8026206.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http协议历史 - 承载梦想-韩旭明 - 博客园&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://www.codetool.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode343-整数拆分</title>
    <link href="https://www.codetool.top/article/leetcode343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <id>https://www.codetool.top/article/leetcode343-整数拆分/</id>
    <published>2020-04-13T05:22:56.000Z</published>
    <updated>2020-04-13T05:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> 2<br><strong>输出:</strong> 1<br><strong>解释:</strong> 2 = 1 + 1, 1 × 1 = 1。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> 10<br><strong>输出:</strong> 36<br><strong>解释:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p></blockquote><p><strong>说明:</strong> 你可以假设 n 不小于 2 且不大于 58。</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我感觉我写的动态规划还挺暴力的。。。没看懂别人的动态规划，我看别人就两三行写完了QAQ<br>我确实8太行</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">integerBreak</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        matrix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cache<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cache <span class="token operator">=</span> <span class="token function">maxMult</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> cache<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxMult</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>num<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token keyword">return</span> matrix<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> cache<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cache <span class="token operator">=</span> <span class="token function">maxMult</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>num<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> cache<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            matrix<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>            <span class="token keyword">return</span> max<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，将其拆分为&lt;strong&gt;至少&lt;/strong&gt;两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;bl
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计网复习05-传输层</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A005-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://www.codetool.top/article/计网复习05-传输层/</id>
    <published>2020-04-12T08:20:25.000Z</published>
    <updated>2020-04-13T08:38:19.942Z</updated>
    
    <content type="html"><![CDATA[<p>这里的传输层指的是原理体系结构的传输层，对应OSI七层体系结构中的传输层，对应TCP/IP四层体系结构中的传输层。它为应用层提供服务。</p><h1 id="传输层协议概述">1 传输层协议概述</h1><p><img src="https://api.codetool.top/img/15866799087510.png" alt></p><h2 id="复用和分用">1.1 复用和分用</h2><p>因为在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。这表明运输层有一个很重要的功能——复用 (multiplexing)和分用 (demultiplexing)。</p><p>应用层-&gt;传输层基于端口的TCP/UDP复用，整合为TCP报文段/UDP用户数据报。传输层-&gt;网络层是IP复用，整合为IP数据报。在接收端进行分用处理。</p><h1 id="用户数据报协议UDP">2 用户数据报协议UDP</h1><p><img src="https://api.codetool.top/img/15866799611274.png" alt></p><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><h2 id="UDP的主要特点">2.1 UDP的主要特点</h2><ol><li>UDP是<strong>无连接</strong>的，减少开销和发送数据之前的时延。</li><li>UDP使用<strong>最大努力交付</strong>，即不保证可靠交付。</li><li>UDP是<strong>面向报文</strong>的，适合一次性传输少量数据的网络应用。</li><li>UDP<strong>无拥塞控制</strong>，适合很多实时应用。</li><li>UDP的<strong>首部开销小</strong>，只有八字节</li></ol><h2 id="UDP的报文格式">2.2 UDP的报文格式</h2><p><img src="https://api.codetool.top/img/15866813837256.png" alt></p><p>源端口号是可有可无的（如果没有想收到回复的需求），可以填写全0。</p><p>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。</p><h3 id="校验和的计算">2.2.1 校验和的计算</h3><p><img src="https://api.codetool.top/img/15866818094214.png" alt></p><p>计算校验和时，会先抽象出一个“伪首部”，从IP数据报的首部获取信息。</p><p>伪首部只有在计算检验和时才出现，不向下传送也不向上递交。</p><p><img src="https://api.codetool.top/img/15866820631253.png" alt></p><p>在计算校验和时，将每组对齐的2字节对应的16位相加，得到的结果求反码。这样就产生了校验码，发送端将它填入。</p><p>接收端的验证也是将将每组对齐的2字节对应的16位相加，得到的结果求反码，若全为1说明校验通过，否则说明出错。</p><h1 id="传输控制协议TCP">3 传输控制协议TCP</h1><p><img src="https://api.codetool.top/img/15866808929918.png" alt></p><ul><li>发送缓存：准备发送的数和已发送但尚未收到确认的数据</li><li>接收缓存：按序到达但尚未被接受应用程序读取的数据和不按序到达的数据</li></ul><h1 id="可靠传输的工作原理">4 可靠传输的工作原理</h1><p><img src="https://api.codetool.top/img/15866809274469.png" alt></p><p>这部分的协议我用到的数据单位是“帧”，是因为这部分也可以由数据链路层来控制，传输层的思想与其一致。</p><h2 id="停止-等待协议">4.1 停止-等待协议</h2><p>为什么要有停止等待协议?</p><ul><li>除了比特出差错，底层信道还会出现丢包问题。</li><li>为了实现流量控制。</li></ul><p>每发送完一个帧就停止发送，等待对方的确认，在<strong>收到确认后再发送下一个帧</strong>。停止等待协议是一种特殊的滑动窗口协议。</p><p>如果未收到确认，就要有<strong>超时重传机制，通常这个超时时间比平均RTT更长一些，如果超时还没有收到接收方发来的确认帧，就重新发送一次上一帧。</strong></p><p><strong>发送帧和确认帧都有编号，这样即使帧重复，接收方也能知道是收到了重复帧。</strong></p><ul><li>停止等待协议：发送窗口大小=1，接收窗口大小=1;</li><li>后退N帧协议(GBN)：发送窗口大小&gt;1， 接收窗口大小=1:</li><li>选择重传协议(SR)：发送窗口大小&gt;1，接收窗口大小&gt;1;</li></ul><h2 id="滑动窗口协议">4.2 滑动窗口协议</h2><h3 id="后退N帧协议（GBN）">4.2.1 后退N帧协议（GBN）</h3><p><img src="https://api.codetool.top/img/1586335862716.png" alt></p><p>发送方有一个发送窗口，接收方有一个接收窗口（大小为1），发送方可以发出发送窗口范围内允许的发出的帧，当接收方收到一帧之后，接收窗口向后滑动一格，响应一个确认帧，发送方收到确认帧之后将发送窗口也向后滑动一格。</p><p>对于发送窗口内的发送帧都要有备份，为了超时重传。发送帧和确认帧都要有编号，为了区别传送中发生的错误。</p><p><strong>如果接收方收到了编号不连续的帧，说明中途发生了帧丢失，那么从此刻开始，将所有接收到的的帧丢弃，只响应上一个连续帧序列中最后一个帧的编号对应的确认帧，直到再次收到能形成连续编号的帧。</strong></p><p>若采用n个比特对帧编号，那么发送窗口的尺寸W<sub>T</sub>应满足: <span color="red">1≤W<sub>T</sub>≤2<sup>n</sup>-1<span>。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</span></span></p><h3 id="选择重传协议（SR）">4.2.2 选择重传协议（SR）</h3><p>选择重传协议的发送窗口大小和接收窗口大小均大于1。</p><p><img src="https://api.codetool.top/img/15863418002044.png" alt></p><p>发送窗口内某个帧的超时时间一过还没收到确认的，就进行重传。一旦发送窗口左侧有连续被确认的发送帧，就进行滑动，滑动到具有最小序号的未确认帧处。</p><p>接收方并不要求接收的帧是顺序的，只要是在接收窗口内的帧序号就接收。</p><p>发送窗口最好等于接收窗口，不大于2<sup>n-1</sup>。</p><h2 id="TCP报文格式">4.3 TCP报文格式</h2><p><img src="https://api.codetool.top/img/15866887476632.png" alt></p><ul><li>序号：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</li><li>确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。</li><li>数据偏移(首部长度) : TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即1个数值是4B。</li><li>六个控制位：<ul><li><strong>紧急位URG</strong>: URG=1时， 标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li><strong>确认位ACK</strong>: ACK=1时确认号有效， 在连接建立后所有传送的报文段都必须把ACK置为1。</li><li>推送位PSH: PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li>复位RST: RST=1时， 表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li><strong>同步位SYN</strong>: SYN=1时， 表明是一个连接请求/连接接受报文。</li><li><strong>终止位FIN</strong>: FIN=1时， 表明此报文段发送方数据已发完，要求释放连接。</li></ul></li><li>窗口：指的是<strong>发送本报文段的一方的接收窗口</strong>，即现在允许对方发送的数据量。</li><li>检验和：和UDP中的检验和类似，检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</li><li>紧急指针: URG=1时才有意义，指出本报文段中紧急数据的字节数。</li><li>选项:最大报文段长度MSS、窗口扩大、时间戳、选择确认…</li></ul><h2 id="TCP实现可靠传输的机制">4.4 TCP实现可靠传输的机制</h2><ul><li>累计确认——和首部中的确认号相关，接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li><li>超时重传——TCP采用自适应算法，动态改变重传时间RTTs (加权平均往返时间)</li><li>选择确认（累计确认的改进，明确指出自己只收到了哪些数据）——接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</li></ul><h1 id="TCP的流量控制">5 TCP的流量控制</h1><p><img src="https://api.codetool.top/img/1586679921603.png" alt></p><p>TCP利用滑动窗口机制实现流量控制。</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即<strong>接收窗口rwnd</strong>(接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。发送窗口=Min{接收窗口rwnd,拥塞窗口cwnd}</p><p><img src="https://api.codetool.top/img/15866978885363.png" alt></p><p>假设B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd = 400的报文段。</p><p>但这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待 A 发送的数据。</p><p>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>为了解决这个问题，TCP 为每一个连接设有一个<strong>持续计时器</strong> (persistence timer)。</p><p><strong>只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。若窗口仍然是0，那么发送方就重新设置持续计时器。</strong></p><h1 id="TCP的拥塞控制">6 TCP的拥塞控制</h1><p><img src="https://api.codetool.top/img/15866809887057.png" alt></p><p>假定:<br>1.数据单方向传送，而另一个方向只传送确认<br>2.接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</p><p><img src="https://api.codetool.top/img/15866985256419.png" alt="拥塞控制所起的作用"></p><h2 id="拥塞控制的一般原理">6.1 拥塞控制的一般原理</h2><p>在某段时间，<strong>若对网络中某资源的需求超过了该资源所能提供的可用部</strong>分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</p><p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。 </p><p>闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施： </p><ol><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>将拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol><p>TCP只能使用闭环控制，<strong>发送方维护一个拥塞窗口，是根据自己估算的网络拥塞程度而设置的窗口值</strong>，反映网络当前容量。<strong>只要网络没有出现拥塞，拥塞窗口就可以再增大一些</strong>，以便把更多的分组发送出去，这样就可以提高网络的利用率。但<strong>只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些</strong>，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><p>如何判断网络拥塞？</p><ul><li>重传定时器超时</li><li>收到三个相同（重复）的 ACK</li></ul><h2 id="慢开始-amp-拥塞避免">6.2 慢开始&amp;拥塞避免</h2><p><img src="https://api.codetool.top/img/15866984718786.png" alt></p><p>由小到大逐渐增大拥塞窗口数值。用来确定网络的负载能力。在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值，<strong>此时cwnd就是翻倍增长的</strong>。</p><p>新的 RFC 5681 把初始拥塞窗口 cwnd 设置为不超过2至4个SMSS的数值。</p><p>慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。<strong>到达这个上限使用拥塞避免算法增大cwnd，使用“加法增大”。</strong>一旦发生网络拥塞，此时的<code>swnd/2</code>得到新的ssthresh，再重新开始慢开始。</p><p>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</p><p>“拥塞避免”是说<strong>在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</strong>。 </p><h2 id="快重传-amp-快恢复">6.3 快重传&amp;快恢复</h2><p><img src="https://api.codetool.top/img/15866991261225.png" alt></p><p>采用快重传 FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。<strong>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</strong></p><p>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。<strong>此时发送方认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法</strong>：</p><p>直接将当前cwnd/2作为新的ssthresh值，并直接从这个值开始拥塞避免的“加法增大”。</p><h1 id="TCP的传输连接管理">7 TCP的传输连接管理</h1><p><img src="https://api.codetool.top/img/15866810135462.png" alt></p><h2 id="连接建立">7.1 连接建立</h2><p>TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。</p><p><img src="https://api.codetool.top/img/15866928231497.png" alt></p><p>假设运行在一台主机(客户)上的一个进程想与另一台主机(服务器)上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接:</p><ol><li>客户端发送连接请求报文段，无应用层数据。SYN=1，seq（首部中的序号）=x(随机)</li><li>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。<br>SYN=1，ACK=1，seq=y(随机)， ack=x+1</li><li>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。SYN=0，ACK=1，seq=x+1，ack=y+1</li></ol><h3 id="第三次握手失败-amp-SYN洪泛攻击">7.1.1 第三次握手失败&amp;SYN洪泛攻击</h3><p>当客户端收到服务端的 SYN+ACK 应答后，其状态变为 ESTABLISHED，并会发送 ACK 包给服务端，准备发送数据了。如果此时 ACK 在网络中丢失，过了超时计时器后，那么 Server端会重新发送 SYN+ACK 包，重传次数根据<code>/proc/sys/net/ipv4/tcp_synack_retries</code> 来指定，默认是 5 次。如果重传指定次数到了后，仍然未收到 ACK 应答，那么一段时间后，Server 自动关闭这个连接。但是 Client 认为这个连接已经建立，如果 Client 端向 Server 写数据，Server端将以 RST 包响应，方能感知到 Server 的错误。</p><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，<strong>而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态</strong>，也就是所谓的半连接状态，<strong>服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源</strong>。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p>如何应对SYN洪泛攻击？这里可以使用linux的两个参数：</p><p>第一个参数 <code>tcp_synack_retries = 0</code> 是关键，表示回应第二个握手包（SYN+ACK 包）给客户端 IP 后，如果收不到第三次握手包（ACK 包）后，不进行重试，加快回收“半连接”，不要耗光资源。</p><p>修改这个参数为 0 的副作用：网络状况很差时，如果对方没收到第二个握手包，可能连接服务器失败，但对于一般网站，用户刷新一次页面即可。这些可以在高峰期或网络状况不好时tcpdump 抓包验证下。</p><p>之所以可以把 tcp_synack_retries 改为 0，因为客户端还有 tcp_syn_retries 参数，默认是 5，即使服务器端没有重发 SYN+ACK 包，客户端也会重发 SYN 握手包。</p><p>第二个参数<code>tcp_max_syn_backlog</code>，从字面上就可以推断出是什么意思。<strong>在内核里有个队列用来存放还没有确认 ACK 的客户端请求，当等待的请求数大于 <code>tcp_max_syn_backlog</code> 时，后面的会被丢弃。</strong></p><p>所以，适当增大这个值，可以在压力大的时候提高握手的成功率。手册里推荐大于 1024。使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p><p>当半连接的请求数量超过了 <code>tcp_max_syn_backlog</code> 时，内核就会启用 <strong>SYN cookie 机制</strong>，不再把半连接请求放到队列里，而是用 SYN cookie 来检验。</p><p>启用之前，服务器在接到 SYN 数据包后，立即分配存储空间，并随机化一个数字作为 SYN号发送 SYN+ACK 数据包。然后保存连接的状态信息等待客户端确认。<strong>启用 SYN Cookie 之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个 SYN 号，替代完全随机的 SYN 号。发送完 SYN+ACK 确认报文之后，清空资源不保存任何状态信息。</strong>直到服务器接到客户端的最终 ACK 包，通过 Cookie 检验算法鉴定是否与发出去的 SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。当然，前文的高级攻击中有 SYN 混合 ACK 的攻击方法，则是对此种防御方法的反击，其中优劣由双方的硬件配置决定。</p><h2 id="连接释放">7.2 连接释放</h2><p>参与一条TCP连接的两个进程中的任何-一个都能终止该连接，连接结束后，主机中的“资源”(缓存和变量) 将被释放。</p><p><img src="https://api.codetool.top/img/15866928416535.png" alt></p><ol><li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。FIN=1，seq=u</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。ACK=1，seq=v，ack=u+1</li><li>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。FIN=1，ACK=1，seq=w，ack=u+1</li><li>客户端回送一一个确认报文段，再等到时间等待计时器设置的2MSL (最长报文段寿命)后，连接彻底关闭。</li></ol><p>这个过程也被称为“四次挥手”</p><p><strong>为什么要有time_wait？</strong></p><ol><li>可靠的终止 TCP 连接，<strong>若处于 time_wait 的 client 发送给 server 确认报文段丢失的话，server将在此又一次发送 FIN 报文段</strong>，那么 client 必须处于一个可接收的状态就是 time_wait 而不是 close 状态。</li><li>保证迟来的 TCP 报文段有足够的时间被识别并丢弃，linux 中一个 TCPport 不能打开两次或两次以上。当 client 处于 time_wait 状态时我们将无法使用此 port 建立新连接，<strong>假设不存在 time_wait 状态，新连接可能会收到旧连接的数据。</strong></li></ol><h2 id="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？">7.3 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h2><p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。<strong>但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了</strong>，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p><h2 id="TCP状态机">7.4 TCP状态机</h2><p><img src="https://api.codetool.top/img/15867588658698.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的传输层指的是原理体系结构的传输层，对应OSI七层体系结构中的传输层，对应TCP/IP四层体系结构中的传输层。它为应用层提供服务。&lt;/p&gt;
&lt;h1 id=&quot;传输层协议概述&quot;&gt;1 传输层协议概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://api.codetool.
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode79-单词搜索</title>
    <link href="https://www.codetool.top/article/leetcode79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.codetool.top/article/leetcode79-单词搜索/</id>
    <published>2020-04-12T06:54:58.000Z</published>
    <updated>2020-04-12T07:02:56.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例:</strong></p><pre style="color:#e8eaf6">board =[  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]给定 word = "<strong style="color:#e8eaf6">ABCCED</strong>", 返回 <strong style="color:#e8eaf6">true</strong>给定 word = "<strong style="color:#e8eaf6">SEE</strong>", 返回 <strong style="color:#e8eaf6">true</strong>给定 word = "<strong style="color:#e8eaf6">ABCB</strong>", 返回 <strong style="color:#e8eaf6">false</strong></pre><p><strong>提示：</strong></p><ul><li><code>board</code> 和 <code>word</code> 中只包含大写和小写英文字母。</li><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>1 &lt;= word.length &lt;= 10^3</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>因为同一个位置的字符不能用两次，得标记，dfs回溯的时候必须把标记清除。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>board <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>board<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!=</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> ans <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向上</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向左</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向右</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans<span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//清除标记</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>下面是利用短路或剪枝后的版本，按理说更快，leetcode测试也差不多：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>board <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>board<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span>String word<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!=</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向上</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向左</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//向右</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//清除标记</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯法" scheme="https://www.codetool.top/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>缓存一致性协议MESI</title>
    <link href="https://www.codetool.top/article/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEMESI/"/>
    <id>https://www.codetool.top/article/缓存一致性协议MESI/</id>
    <published>2020-04-11T11:46:48.000Z</published>
    <updated>2020-04-11T14:20:20.591Z</updated>
    
    <content type="html"><![CDATA[<p>明明记得在哪里学过这部分内容，还看到过一个贼好的图。。今天找了很久又没找着，这就是学了不记笔记的后果。。</p><p>本文参考资源：</p><p><a href="https://blog.csdn.net/yhb1047818384/article/details/79604976" target="_blank" rel="noopener">CPU体系结构之cache小结_运维_Hober-CSDN博客</a></p><p><a href="https://www.cnblogs.com/bjlhx/p/10658938.html" target="_blank" rel="noopener">001-CPU多级缓存架构 - bjlhx15 - 博客园</a></p><p><a href="https://blog.csdn.net/qq_26222859/article/details/52240256" target="_blank" rel="noopener">volatile与内存屏障_Java_weiqing的博客-CSDN博客</a></p><p>极客时间《深入浅出计算机组成原理》</p><h1 id="缓存一致性问题">1 缓存一致性问题</h1><p>在现代的CPU（大多数）上，所有的内存访问都需要通过层层的缓存来进行。也有些例外，比如，对映射成内存地址的I/O口、写合并（Write-combined）内存，这些访问至少会绕开这个流程的一部分。但这两者都是罕见的场景（意味着绝大多数的用户态代码都不会遇到这两种情况）。并且由于程序通常具有良好的时间局部性和空间局部性，缓存对提高程序运行的效率起到很大帮助。</p><p><img src="https://api.codetool.top/img/15866064656454.png" alt="存储器层次"></p><p>然而上面这张图没有表示清楚的是，三级缓存和CPU核心之间的关系：（由于没有找到之前看过的那张图特意找了三张图好表示清楚）</p><p><img src="https://api.codetool.top/img/15866065781911.png" alt></p><p><img src="https://api.codetool.top/img/15866062735456.png" alt></p><p><img src="https://api.codetool.top/img/158660677492.png" alt></p><p>L1是最接近CPU的，它容量最小，速度最快，<strong>每个核上都有一个L1 Cache（准确地说每个核上有两个L1 Cache，一个存数据 L1d Cache，一个存指令 L1i Cache）</strong></p><p>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下<strong>每个核上都有一个独立的L2 Cache</strong>；二级缓存就是一级缓存的缓冲器：一级缓存制造成本很高因此它的容量有限，二级缓存的作用就是存储那些CPU处理时需要用到、一级缓存又无法存储的数据。</p><p>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是最慢的一级，<strong>在同一个CPU插槽之间的核共享一个L3 Cache</strong>。三级缓存和内存可以看作是二级缓存的缓冲器，它们的容量递增，但单位制造成本却递减。</p><p><img src="https://api.codetool.top/img/15866073161132.png" alt="我电脑上的CPU cache"></p><p>高速缓存行的结构这里不提，有时间把CSAPP里面的笔记放上来。</p><p>那么这样设计的问题是什么呢？因为 CPU 的每个核各有各的缓存，互相之间的操作又是各自独立的，就会带来缓存一致性（Cache Coherence）的问题。</p><p>这里需要先提到cache写机制</p><h2 id="cache写机制">1.1 cache写机制</h2><p>Write-through（直写模式）<strong>在数据更新时，同时写入缓存Cache和后端存储</strong>。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。</p><p>Write-back（回写模式）<strong>在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储</strong>。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p><h2 id="缓存一致性问题-1">1.2 缓存一致性问题</h2><p>试想下面这样一个情况。</p><ol><li>CPU1 读取了一个字节，以及它和它相邻的字节被读入CPU1的高速缓存。</li><li>CPU2 做了上面同样的工作。这样CPU1，CPU2的高速缓存拥有同样的数据。</li><li>CPU1 修改了那个字节，被修改后，那个字节被放回CPU1的高速缓存行。但是该信息并没有被写入RAM。</li><li>CPU2 访问该字节，但由于CPU1并未将数据写入RAM（回写模式），导致了数据不同步。</li></ol><p>为了解决这个缓存不一致的问题，我们就需要有一种机制，来同步两个不同核心里面的缓存数据。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。</p><p>第一点叫<strong>写传播（Write Propagation）</strong>。写传播是说，在一个CPU 核心里，我们的 Cache 数据更新，必须能够传播到其他的对应节点的 Cache Line 里。</p><p>第二点叫<strong>事务的串行化（Transaction Serialization）</strong>，事务串行化是说，我们在一个 CPU 核心里面的读取和写入，在其他的节点看起来，顺序是一样的。</p><p>写传播很容易理解。既然我们数据写完了，自然要同步到其他 CPU 核的 Cache 里。而事务的串行化，则是指假设很短时间内，一个数据被两次修改，并且分别是由两个CPU核心处理的，当它们同步数据更改到其他核心的时候，可能会出现顺序不一致的问题，即对不同的核心表现为修改的顺序不一致，造成最终结果不一致。</p><p>而在 CPU Cache 里做到事务串行化，需要做到两点，第一点是<strong>一个 CPU 核心对于数据的操作，需要同步通信给到其他 CPU 核心</strong>。第二点是，<strong>如果两个 CPU 核心里有同一个数据的 Cache，那么对于这个 Cache 数据的更新，需要有一个“锁”的概念。只有拿到了对应 Cache Block 的“锁”之后，才能进行对应的数据更新</strong>。接下来，我们就看看实现了这两个机制的 MESI 协议。</p><h1 id="总线嗅探与MESI协议">2 总线嗅探与MESI协议</h1><h2 id="总线嗅探">2.1 总线嗅探</h2><p>要解决缓存一致性问题，首先要解决的是多个 CPU 核心之间的数据传播问题。最常见的一种解决方案呢，叫作<strong>总线嗅探</strong>。</p><p>这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p><p>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议。不过其中最常用的，就是今天我们要讲的 MESI 协议。和很多现代的 CPU 技术一样，MESI 协议也是在 Pentium 时代，被引入到 Intel CPU 中的。</p><h2 id="MESI协议">2.2 MESI协议</h2><p>MESI 协议，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，<strong>只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 Cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。</strong></p><p>相对于写失效协议，还有一种叫作写广播（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的 CPU 核心，同时更新各个核心里的 Cache。</p><p>写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的 CPU 核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他 CPU 核心。</p><p>MESI 协议的由来呢，来自于我们对 Cache Line 的四个不同的标记，分别是：</p><ul><li>M：代表已修改（Modified）</li><li>E：代表独占（Exclusive）</li><li>S：代表共享（Shared）</li><li>I：代表已失效（Invalidated）</li></ul><p><img src="https://api.codetool.top/img/15866087435201.png" alt="MESI状态机"></p><p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。所谓的“已修改”，就是“脏”的 Cache Block。Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面。而所谓的“已失效”，自然是这个 Cache Block 里面的数据已经失效了，我们不可以相信这个 Cache Block 里面的数据。</p><p>然后，我们再来看“独占”和“共享”这两个状态。这就是 MESI 协议的精华所在了。<strong>无论是独占状态还是共享状态，缓存里面的数据都是“干净”的。</strong>这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，Cache Block 里面的数据和主内存里面的数据是一致的。</p><p>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，<strong>在独占状态下，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</strong></p><p><strong>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，它就会变成共享状态。</strong>这个共享状态是因为，这个时候，另外一个 CPU 核心，也把对应的 Cache Block，从内存里面加载到了自己的 Cache 里来。</p><p>而<strong>在共享状态下，因为同样的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，都变成无效的状态，然后再更新当前 Cache 里面的数据。</strong>这个广播操作，一般叫作 RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权。</p><table cellspacing="0" cellpadding="0" border="1"><tbody><tr><td valign="top"><p align="center">当前状态</p></td><td valign="top"><p align="center">事件</p></td><td valign="top"><p align="center">行为</p></td><td valign="top"><p align="center">下一个状态</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">I(Invalid)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E；</p><p align="left">如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S；</p><p align="left">如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S</p></td><td valign="top"><p align="center">E/S</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">从内存中取数据，在Cache中修改，状态变成M；</p><p align="left">如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存；</p><p align="left">如果其它Cache有这份数据，则其它Cache的Cache line状态变成I</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">既然是Invalid，别的核的操作与它无关</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">既然是Invalid，别的核的操作与它无关</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">E(Exclusive)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">从Cache中取数据，状态不变</p></td><td valign="top"><p align="center">E</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">修改Cache中的数据，状态变成M</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">数据和其它核共用，状态变成了S</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">数据被修改，本Cache line不能再使用，状态变成I</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">S(Shared)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">从Cache中取数据，状态不变</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">修改Cache中的数据，状态变成M，</p><p align="left">其它核共享的Cache line状态变成I</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">状态不变</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">数据被修改，本Cache line不能再使用，状态变成I</p></td><td valign="top"><p align="center">I</p></td></tr><tr><td rowspan="4" valign="top"><p align="center">M(Modified)</p></td><td valign="top"><p align="center">Local Read</p></td><td valign="top"><p align="left">从Cache中取数据，状态不变</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Local Write</p></td><td valign="top"><p align="left">修改Cache中的数据，状态不变</p></td><td valign="top"><p align="center">M</p></td></tr><tr><td valign="top"><p align="center">Remote Read</p></td><td valign="top"><p align="left">这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S</p></td><td valign="top"><p align="center">S</p></td></tr><tr><td valign="top"><p align="center">Remote Write</p></td><td valign="top"><p align="left">这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据，</p><p align="left">状态变成I</p></td><td valign="top"><p align="center">I</p></td></tr></tbody></table><h1 id="MESI协议与java-volatile关键字的关系">3 MESI协议与java volatile关键字的关系</h1><p><a href="https://www.zhihu.com/question/296949412" target="_blank" rel="noopener">既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？ - 知乎</a></p><p>volatile的语义有：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序</li></ol><p>对于x86的体系结构，voltile变量的访问代码会被java编译器生成不乱序的，带有lock指令前缀的机器码。而lock的实现还要区分，这个数据在不在CPU核心的专有缓存中（一般是指L1/L2）。如果在，MESI才有用武之地。如果不满足就会要用其他手段，涉及到内存屏障。</p><p>通过反汇编可以发现，Java中volatile变量修饰的共享变量在进行写操作时候会多出一行汇编：</p><pre><code>lock addl $0×0,(%esp);</code></pre><p>在x86架构中，Lock前缀指令可以用作storeLoad barrier，在支持SSE2拓展指令集的cpu上还可以使用mfence指令。在多核处理器环境中，lock前缀指令保证了某个处理器对共享内存的独占使用。<strong>内存屏障不仅仅是MESI这么简单。</strong></p><p>多处理器总线嗅探:</p><ol><li>为了提高处理速度,处理器不直接和内存进行通信,而是先将系统内存的数据读到内部缓存后在进行操作,但<strong>写回操作</strong>不知道这个更改何时回写到内存。</li><li>但是对变量使用volatile进行写操作时，JVM就会向处理器发送一条lock前缀的指令,将这个变量所在的缓存行的数据写回到系统内存。</li><li>在多处理器中,为了保证各个处理器的缓存一致性，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行设置为无效状态，就相当于<strong>写回时发现状态标识为0失效</strong>，当这个处理器对数据进行修改操作时,会重新从系统内存中读取数据到CPU缓存中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;明明记得在哪里学过这部分内容，还看到过一个贼好的图。。今天找了很久又没找着，这就是学了不记笔记的后果。。&lt;/p&gt;
&lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yhb1047818384/article/details/7
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="操作系统" scheme="https://www.codetool.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode887-鸡蛋掉落</title>
    <link href="https://www.codetool.top/article/leetcode887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/"/>
    <id>https://www.codetool.top/article/leetcode887-鸡蛋掉落/</id>
    <published>2020-04-11T02:20:33.000Z</published>
    <updated>2020-04-11T03:16:01.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>你将获得 <code>K</code> 个鸡蛋，并可以使用一栋从 <code>1</code> 到 <code>N</code>  共有 <code>N</code> 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 <code>F</code> ，满足 <code>0 &lt;= F &lt;= N</code> 任何从高于 <code>F</code> 的楼层落下的鸡蛋都会碎，从 <code>F</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 <code>X</code> 扔下（满足 <code>1 &lt;= X &lt;= N</code>）。</p><p>你的目标是<strong>确切地</strong>知道 <code>F</code> 的值是多少。</p><p>无论 <code>F</code> 的初始值如何，你确定 <code>F</code> 的值的最小移动次数是多少？</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> K = 1, N = 2<br><strong>输出：</strong> 2<br><strong>解释：</strong><br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> K = 2, N = 6<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> K = 3, N = 14<br><strong>输出：</strong> 4</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= K &lt;= 100</code></li><li><code>1 &lt;= N &lt;= 10000</code></li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题是一道经典的谷歌面试题，思路李永乐老师讲过：<a href="https://www.bilibili.com/video/BV1KE41137PK" target="_blank" rel="noopener">复工复产找工作？先来看看这道面试题：双蛋问题_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>总而言之就是动态规划，定义dp(k,n)为最小移动次数，假设第一次在x层楼处扔下鸡蛋，如果鸡蛋碎了，代表F&lt;x，即还需要<code>dp(k-1,x-1)</code>次移动才能求出，如果鸡蛋没碎，还需要<code>dp(k,n-x)</code>次移动才能求出，取他们俩的最大值加一，然而光用这个思路在leetcode中会超时，因为x需要从1~k枚举，还可以使用二分法进一步优化。</p><h2 id="代码">2.2 代码</h2><p>动态规划：（超时）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">superEggDrop</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Integer min <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> div <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>div<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>div<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> count <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>div<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">==</span>null<span class="token operator">||</span>count<span class="token operator">&lt;</span>min<span class="token punctuation">)</span> min <span class="token operator">=</span> count<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>动态规划+二分：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">superEggDrop</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>K<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//dp[k-1][div-1]从小递增，dp[k][n-div]从大递减，只需找到一处刚好使得dp[k-1][div-1]>=dp[k][n-div]</span>                <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> high <span class="token operator">=</span> n<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> div <span class="token operator">=</span> low<span class="token operator">+</span><span class="token punctuation">(</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>div<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        low <span class="token operator">=</span> div<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>div<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> div<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> low <span class="token operator">=</span> div<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>low<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>K<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;你将获得 &lt;code&gt;K&lt;/code&gt; 个鸡蛋，并可以使用一栋从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;N&lt;/code&gt;  共有 &lt;code&gt;N&lt;/code&gt; 层楼的建筑。&lt;/p&gt;
&lt;p&gt;每个蛋的功能都是一样的，如果一个蛋碎
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计网复习04-网络层</title>
    <link href="https://www.codetool.top/article/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A004-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://www.codetool.top/article/计网复习04-网络层/</id>
    <published>2020-04-10T03:55:29.000Z</published>
    <updated>2020-04-14T05:26:46.593Z</updated>
    
    <content type="html"><![CDATA[<p>这里的网络层指的是原理体系结构的网络层，对应OSI七层体系结构中的网络层，对应TCP/IP四层体系结构中的网际层。它为传输层提供服务，主要功能：</p><ol><li>路由选择与分组转发</li><li>异构网络互联</li><li>拥塞控制<ul><li>若<strong>所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态</strong>。因此要采取一定措施，缓解这种拥塞。</li><li>解决方案：开环控制、闭环控制</li></ul></li></ol><h1 id="提供的两种服务">1 提供的两种服务</h1><p><img src="https://api.codetool.top/img/15864909591668.png" alt></p><p>数据报方式为网络层提供无连接服务，虚电路方式为网络层提供连接服务。</p><p>无连接服务:不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p><p>连接服务:首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p><p>网络层的最小数据单元是数据包（在TCP/IP体系结构里称为IP数据报）或分组。</p><h2 id="数据报">1.1 数据报</h2><p>每个分组携带源和目的地址。</p><p>路由器根据分组的目的地址转发分组:</p><ul><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路。</li></ul><h2 id="虚电路">1.2 虚电路</h2><p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p><p>虚电路:<strong>一条源主机到目的主机类似于电路的路径(逻辑连接)</strong>，路径上所有结点都要维持这条虚电路的建立，都维持一张<strong>虚电路表</strong>，每一项记录了一个打开的虚电路的信息。</p><p>虚电路的通信过程</p><ol><li>建立连接</li><li>数据传输</li><li>释放连接</li></ol><p>建立连接时携带目的地址，通信时每个分组携带虚电路号，而非目的地址。</p><h1 id="网际协议IP">2 网际协议IP</h1><p><img src="https://api.codetool.top/img/15864910288465.png" alt></p><p><img src="https://api.codetool.top/img/15865001638495.png" alt="TCP/IP协议栈"></p><h2 id="IP数据报格式">2.1 IP数据报格式</h2><p>IP数据报分为首部和数据部分，数据部分是传输层下发的内容。</p><p>首部格式：</p><ul><li>20字节固定部分</li><li>可变部分</li></ul><p><img src="https://api.codetool.top/img/15865012168301.png" alt></p><ul><li>版本：区分IPv4/IPv6。IP协议曾有v1、v2、v3等早期版本，但因为不够完善而没有对外发布，而v5则是仅用于实验室内部研究，也从未公开，所以我们看到的只有v4和v6两个版本。</li><li>首部长度：单位为4B，最小为5。</li><li>区分服务：指示期望获得哪种类型的服务。</li><li>总长度：首部+数据，单位是1B。</li><li>生存时间(TTL)：IP分组的保质期。经过一个路由器-1，变成0则丢弃。</li><li>协议：数据部分的协议</li><li>首部检验和：只检验首部</li></ul><p>可变部分的填充必须把首部填充为4字节的整数倍。</p><h2 id="IP数据报的分片">2.2 IP数据报的分片</h2><p>因为IP数据报经过链路层需要作为数据部分装配为数据帧，数据帧的数据部分具有最大长度，即MTU，通常是1500字节。如果IP数据报大于这个长度，需要分片。</p><p>首部中，有三个字段和分片有联系：</p><ul><li>标识：同一数据报的分片使用同一标识。</li><li>标志：三位，只有最后两位有意义<ul><li>中间位DF=1代表禁止分片，DF=0代表允许分片。</li><li>最低位MF=1代表后面还有分片，MF=0代表最后一片/没有分片</li></ul></li><li>片偏移：指出较长分组分片后,某片在原分组中的相对位置，<strong>以8B为单位</strong>。</li></ul><h2 id="IP地址">2.3 IP地址</h2><p>32位，分为网络号和主机号，通常表示为点分十进制。</p><h3 id="分类的IP地址">2.3.1 分类的IP地址</h3><p><img src="https://api.codetool.top/img/15865150045553.png" alt></p><p><strong>特殊的IP地址：</strong></p><table><thead><tr><th>NetID网络号</th><th>HostID主机号</th><th>作为IP分组源地址</th><th>作为IP分组目的地址</th><th>用途</th></tr></thead><tbody><tr><td>全0</td><td>全0</td><td>可以</td><td>不可以</td><td>本网范围内表示主机，路由表中用于表示默认路由(表示整个Internet网络)</td></tr><tr><td>全0</td><td>特定值</td><td>不可以</td><td>可以</td><td>表示本网内某个特定主机</td></tr><tr><td>全1</td><td>全1</td><td>不可以</td><td>可以</td><td>本网广播地址(路由器不转发)</td></tr><tr><td>特定值</td><td>全0</td><td>不可以</td><td>不可以</td><td>网络地址，表示一个网络</td></tr><tr><td>特定值</td><td>全1</td><td>不可以</td><td>可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td>127</td><td>任何数(非全0/1)</td><td>可以</td><td>可以</td><td>用于本地软件换回测试，称为环回地址</td></tr></tbody></table><p><strong>私有IP地址：</strong></p><table><thead><tr><th>地址类别</th><th>地址范围</th><th>网段个数</th></tr></thead><tbody><tr><td>A类</td><td>10.0.0.0~10.255.255.255</td><td>1</td></tr><tr><td>B类</td><td>172.16.0.0~172.31.255.255</td><td>16</td></tr><tr><td>C类</td><td>192.168.0.0~192.168.255.255</td><td>256</td></tr></tbody></table><p><strong>A、B、C三类地址范围：</strong></p><table><thead><tr><th>网络类别</th><th>最大可用网络数</th><th>第一个可用的网络号</th><th>最后一个可用的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2<sup>7</sup>-2</td><td>1</td><td>126</td><td>2<sup>24</sup>-2</td></tr><tr><td>B</td><td>2<sup>14</sup>-1</td><td>128.1</td><td>191.255</td><td>2<sup>16</sup>-2</td></tr><tr><td>C</td><td>2<sup>21</sup>-1</td><td>192.0.1</td><td>223.255.255</td><td>2<sup>8</sup>-2</td></tr></tbody></table><p>路由器对目的地址是私有IP地址的数据报一律不进行转发。</p><h2 id="网络地址转换NAT">2.4 网络地址转换NAT</h2><p>网络地址转换NAT(Network Address Translation) :在<strong>专用网连接到因特网</strong>的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。</p><p>NAT路由器有一个NAT转换表。</p><h2 id="IP组播-多播">2.5 IP组播/多播</h2><p>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</p><p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有组播路由器的支持)。</p><p>IP组播地址让源设备能够将分组发送给一组设备。 属于多播组的设备将被分配一个组播组IP地址（一群共同需求主机的相同标识）</p><p>组播地址范围为224.0.0.0~239.255.255.255 (D类地址)，一个D类地址表示一个组播组。只能用作分组的目标地址。源地址总是为单播地址。</p><p>特点：</p><ol><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</li><li>对组播数据报不产生ICMP差错报文。</li><li>并非所有D类地址都可以作为组播地址。</li></ol><p>同单播地址一样，<strong>组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧</strong>。组播MAC地址以十六进制值<code>01-00-5E</code>打头，余下的6个十六进制位是根据IP组播组地址的最后23位转换得到的。</p><h2 id="ARP协议">2.6 ARP协议</h2><p>ARP协议将IP地址解析为硬件（mac）地址，属于数据链路层协议。</p><p>对于每个主机，都有一份ARP高速缓存，里面存的是已知主机IP地址到硬件地址的映射表。ARP缓存是有一定过期时间的。</p><p>如何获取这个映射表的数据？假设当前主机缺少一个IP地址对mac地址的映射数据，它首先会检查这个IP是否是同一个网段内的，如果是则它会向当前局域网广播一个ARP请求分组，目的mac地址可以填写<code>FF-FF-FF-FF-FF-FF</code>。目标主机（发现自己的IP吻合）收到该分组之后，会响应一个单播ARP响应分组，附带自己的mac地址。</p><p>如果目的主机不在当前局域网，首先查询默认网关的IP地址，将该分组发往默认网关，目的mac地址填写默认网关的mac地址，路由器再帮忙转发该分组。</p><p>ARP协议4种典型情况:</p><ol><li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器(网关)的硬件地址</li><li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</li></ol><p><img src="https://api.codetool.top/img/15866029383187.png" alt="ARP报文的格式"></p><h2 id="DHCP协议">2.7 DHCP协议</h2><p>主机如何获得IP地址？</p><ol><li>静态配置</li><li>动态配置</li></ol><p>动态主机配置协议DHCP是<strong>应用层</strong>协议，使用<strong>客户/服务器</strong>方式，客户端和服务端通过<strong>广播</strong>方式进行交互，基于UDP。</p><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><p>主机从DHCP服务器获取IP流程：</p><ol><li>主机广播DHCP发现报文</li><li>DHCP服务器广播DHCP提供报文</li><li>主机广播DHCP请求报文</li><li>DHCP服务器广播DHCP确认报文</li></ol><p>为什么第二步、第三步、第四步还是广播？因为第一步中可能有多台DHCP服务器收到发现报文并提前准备好一个可用的IP。第二步中发送提供报文给目标主机，然而目标主机此时还没有IP地址，于是仍使用广播地址，第三步中主机通常会选择第一个收到的提供报文对应的DHCP服务器，并广播一个请求报文，广播该请求报文的意义在于，其他DHCP服务器接收到该报文后，便知道对应的主机已经有了IP提供者，可以收回自己准备的IP地址了。第四步原因同第二步。</p><h2 id="ICMP协议">2.8 ICMP协议</h2><p>ICMP协议支持主机或路由器，功能：</p><ul><li>差错(或异常)报告，对应ICMP差错报告报文</li><li>网络探询，对应ICMP询问报文，重要的应用是ping</li></ul><p>ICMP报文格式：</p><p><img src="https://api.codetool.top/img/15865297661616.png" alt></p><p>类型又分两大类：</p><ul><li>ICMP差错报告报文：<ul><li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。（该类型不再使用）</li><li>时间超过：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。</li></ul></li><li>ICMP询问报文：<ul><li>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。（PING的原理）</li><li>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。</li></ul></li></ul><p>不应发送ICMP差错报文的情况：</p><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文。</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</li></ol><h2 id="IGMP协议">2.9 IGMP协议</h2><p>互联网组管理协议（IGMP）是因特网协议家族中的一个组播协议，TCP/IP协议族的一个子协议，用于<strong>IP主机向任一个直接相邻的路由器报告他们的组成员情况</strong>。允许Internet主机参加多播，也是IP主机用作向相邻多目路由器报告多目组成员的协议。多目路由器是支持组播的路由器，向本地网络发送IGMP查询。主机通过发送IGMP报告来应答查询。组播路由器负责将组播包转发到所有网络中组播成员。　</p><p>IGMP协议让路由器知道本局域网上是否有主机(的进程)参加或退出了某个组播组。</p><p><strong>IGMP工作的两个阶段</strong></p><ul><li>某主机要加入组播组时，该主机向组播组的组播地址发送一- 个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</li><li>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的:如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</li></ul><h2 id="IPv6">2.10 IPv6</h2><p>IPv6使用128位二进制数表示，通常使用冒号十六进制记法: <code>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</code>，可以将连续的0压缩省略。</p><h3 id="IPv6数据报">2.10.1 IPv6数据报</h3><p>IPv6数据报格式：</p><ul><li>40字节基本首部</li><li>有效载荷，其中包括拓展首部</li></ul><p><img src="https://api.codetool.top/img/15865314027415.png" alt></p><h3 id="Ipv6的改进">2.10.2 Ipv6的改进</h3><ol><li>IPv6将地址从32位(4B) 扩大到128位(16B) ，更大的地址空间。</li><li>IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间。</li><li>IPv6将IPv4的可选字段移出首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6支持即插即用(即自动配置)，不需要DHCP协议。</li><li>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍。</li><li>IPv6只能在主机处分片，IPv4可以在路由器和主机处分片。</li><li><code>ICMPv6</code>：附加报文类型“分组过大”。</li><li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用。</li><li>IPv6取消了协议字段，改成下一个首部字段。</li><li>IPv6取消了总长度字段，改用有效载荷长度字段。</li><li>IPv6取消了服务类型字段。</li></ol><p>IPv6基本地址类型：</p><ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul><h3 id="IPv6向IPv4过渡的策略">2.10.3 IPv6向IPv4过渡的策略</h3><p>双栈协议：</p><p>双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</p><p>隧道技术：</p><p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。</p><h1 id="转发分组的流程">3 转发分组的流程</h1><p><img src="https://api.codetool.top/img/15864910448779.png" alt></p><h1 id="划分子网和构造超网">4 划分子网和构造超网</h1><p><img src="https://api.codetool.top/img/15864910696407.png" alt></p><h2 id="子网划分">4.1 子网划分</h2><p>子网划分又将IP地址中的主机号划分为子网号和主机号，这里的主机号仍不能是全0或全1。<strong>某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。</strong></p><p>如何确定子网号和主机号的位数就需要通过子网掩码。它是个类IP地址的形式，<strong>网络号和子网号对应的位全为1，主机号对应的位全为0。</strong></p><h2 id="构造超网">4.2 构造超网</h2><h3 id="无分类编址CIDR">4.2.1 无分类编址CIDR</h3><p>CIDR消除了传统的A类，B类和C类地址以及划分子网的概念，将IP地址划分为网络前缀和主机号，网络前缀的位数是任意的，在IP地址后加上<code>/</code>，然后写上网络前缀的位数。</p><p>CIDR把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”。</p><p>CIDR也可以有子网掩码的概念，网络前缀有多少位，子网掩码中就有多少位连续的1。</p><h3 id="构成超网">4.2.2 构成超网</h3><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>方法:将网络前缀缩短。</p><p>使用CIDR时，查找路由表可能得到几个匹配结果，<strong>应选择具有最长网络前缀的路由</strong>。前缀越长，地址块越小，路由越具体。</p><h1 id="路由选择协议">5 路由选择协议</h1><p><img src="https://api.codetool.top/img/15864910953755.png" alt></p><h2 id="RIP协议">5.1 RIP协议</h2><p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是简单。</p><p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离)。</p><p>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达。</strong></p><p>RIP协议让<strong>相邻路由器之间交换自己的路由表</strong>，每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</p><p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</p><p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即 <strong>“收敛”</strong>。</p><p>RIP协议也是应用层协议，使用UDP传输数据，RIP协议只适用于小互联网。</p><p><strong>RIP协议好消息传得快，坏消息传得慢</strong>：当网络出现故障时，要经过比较长的时间(例如数分钟)才能将此信息传送到所有的路由器，这种特点称为 <strong>“慢收敛”</strong>。</p><h2 id="OSPF协议（简介）">5.2 OSPF协议（简介）</h2><p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了Djkstra提出的最短路径算法SPF。</p><p>特点：</p><ol><li>使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器（相当于广播）。最终整个区域内所有路由器都得到了这个信息的一个副本。</li><li>发送的信息就是<strong>与本路由器相邻的所有路由器的链路状态</strong>（本路由器和哪些路由器相邻，以及该链路的度量/代价——费用、距离、时延、带宽等）。</li><li><strong>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</strong></li></ol><p>最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。然后使用Djkstra算法确定最短路径。</p><p>其他特点：</p><ol><li>每隔30min,要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。</li><li>OSPF不存在坏消息传的慢的问题，它的收敛速度很快。</li></ol><p>OSPF基于IP协议，归为传输层协议。</p><h2 id="BGP协议（简介）">5.3 BGP协议（简介）</h2><p>BGP属于外部网关协议，在不同的自治系统（AS）间进行路由，相邻的自治系统通过<strong>BGP发言人</strong>（一台边界路由器）交换网络可达性的信息，即要到达某个网络所要经过的一系列AS。</p><p>BGP所交换的网络可达性的信息就是要<strong>到达某个网络所要经过的一系列AS</strong>。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。首次交换的是整个路由表，其他时候交换的是有变换的部分。</p><p>BGP是应用层协议，通过TCP传送。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的网络层指的是原理体系结构的网络层，对应OSI七层体系结构中的网络层，对应TCP/IP四层体系结构中的网际层。它为传输层提供服务，主要功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由选择与分组转发&lt;/li&gt;
&lt;li&gt;异构网络互联&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;ul&gt;
&lt;li&gt;若&lt;s
      
    
    </summary>
    
    
      <category term="计算机相关" scheme="https://www.codetool.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="计算机网络" scheme="https://www.codetool.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer06-从尾到头打印链表</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.codetool.top/article/剑指offer06-从尾到头打印链表/</id>
    <published>2020-04-10T03:47:37.000Z</published>
    <updated>2020-04-10T16:42:31.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> head = [1,3,2]<br><strong>输出：</strong> [2,3,1]  </p></blockquote><p><strong>限制：</strong></p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>栈</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈StringBuffer、StringBuilder及String在JDK9中的变化</title>
    <link href="https://www.codetool.top/article/%E8%B0%88%E4%B8%80%E8%B0%88StringBuffer%E3%80%81StringBuilder%E5%8F%8AString%E5%9C%A8JDK9%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>https://www.codetool.top/article/谈一谈StringBuffer、StringBuilder及String在JDK9中的变化/</id>
    <published>2020-04-09T05:49:25.000Z</published>
    <updated>2020-04-09T06:53:36.498Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考资源：</p><p><a href="https://blog.csdn.net/qq_41376740/article/details/80143215" target="_blank" rel="noopener">JAVA9 String新特性，说说你不知道的东西_Java_人在江湖-CSDN博客</a></p><h1 id="StringBuffer和StringBuilder的区别">1 StringBuffer和StringBuilder的区别</h1><p>这里谈的是JDK8中StringBuffer和StringBuilder的实现，JDK9后随着String的变化，这两个类的实现也有了些许变化。</p><ol><li>String是不可变的，String类和它的内部value数组都被声明为final。因此通常对字符串进行拼接操作总是会生成一个新的String对象，效率较低。</li><li>为了改进字符串拼接的效率，出现了StringBuffer和StringBuilder，<strong>StringBuffer是线程安全的，因为它在主要方法上加了synchronized关键字</strong>，不过也因此会有加锁解锁的开销，性能会收到影响，而StringBuilder就是StringBuffer的线程不安全版本，它没有使用synchronized关键字，性能最好。</li><li>StringBuffer和StringBuilder都继承自AbstractStringBuilder，主要方法也都由这个父类实现了，基本的原理是它内部有一个字符数组，append的时候通过<code>System.arraycopy</code>将String中的字符数组拷贝至该builder的数组末尾，如果数组空间不足，则扩容为两倍大小，toString的时候通过这个字符数组来构造字符串。</li><li>StringBuffer和StringBuider都可以在构造函数中自定义初始化时内部字符数组的大小，如果知道要拼接字符串最后的大致大小，<strong>建议给它一个初始容量，避免数组扩容带来的开销</strong>，这点就和ArrayList差不多。</li></ol><p><img src="https://api.codetool.top/img/15864128585274.png" alt="StringBuffer和StringBuilder的关系"></p><p>AbstractStringBuilder中append的实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>String中getChars的实现：（由String负责将自己内部数组内容附加到builder中的数组末尾）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getChars</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcBegin<span class="token punctuation">,</span> <span class="token keyword">int</span> srcEnd<span class="token punctuation">,</span> <span class="token keyword">char</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcEnd <span class="token operator">></span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcBegin <span class="token operator">></span> srcEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StringIndexOutOfBoundsException</span><span class="token punctuation">(</span>srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> srcBegin<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> srcEnd <span class="token operator">-</span> srcBegin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="JDK9-String解读">2 JDK9 String解读</h1><p>很久之前，我在<a href="../详解java中的unicode编码（码点）">详解java中的unicode编码（码点）</a>中提到，java使用的char编码就是UTF-16，并且String的底层也是一个char数组。</p><p>UTF-16的编码规则是什么，这里复习一下：</p><ul><li>BMP（基本多语言平面）内的字符，统一使用2个字节表示，我们称其为一个码点，它已经可以表示大多数常见文字。</li><li>辅助平面内的字符，使用高代理码点和低代理码点联合表示，共四个字节，可以表示完所有unicode中的字符。</li></ul><p>但是，UTF-16存在的问题是，对于大多数拉丁语系中的字符（例如ASCII码中的字符），都可以使用1个字节表示，然而UTF-16必须使用两个字节来表示它，就会导致空间浪费。</p><p>于是JDK9中，大刀阔斧地对String及相关方法进行了重构。</p><p><img src="https://api.codetool.top/img/15864132876511.png" alt="图为String内部字段的变化，左为JDK8，右为JDK9"></p><p>需要注意的是，JDK9中的value数组变为了byte数组，意味着最小允许单字节的存在。并且多了一个coder字段，javadoc中是这样描述的：</p><blockquote><p>The identifier of the encoding used to encode the bytes in value. The supported values in this implementation are LATIN1 UTF16</p></blockquote><p>说明<code>coder</code>用于标识这个bytes数组的编码是utf-16还是latin1。（根据测试1代表UTF16，0代表latin1）</p><p><img src="https://api.codetool.top/img/15864140086085.png" alt="JDK8中的&quot;123abc&quot;"></p><p><img src="https://api.codetool.top/img/15864140321197.png" alt="JDK9中的&quot;123abc&quot;"></p><p>可以看到占用空间直接减少了1/2。</p><p>由于byte数组的使用方式，引申出了两个类StringLatin1和StringUTF16两个类，分担String类的操作。</p><p>我们来看看JDK9中String几个方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">codePointCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beginIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> beginIndex <span class="token operator">></span> endIndex <span class="token operator">||</span>        endIndex <span class="token operator">></span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLatin1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> endIndex <span class="token operator">-</span> beginIndex<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> StringUTF16<span class="token punctuation">.</span><span class="token function">codePointCount</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> beginIndex<span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法用于计算码点数，对于latin1编码，自然就是byte数组的长度。对于UTF16，和JDK8中的思想类似：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">codePointCount</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">,</span> <span class="token keyword">boolean</span> checked<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> beginIndex <span class="token operator">&lt;=</span> endIndex<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> endIndex <span class="token operator">-</span> beginIndex<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> beginIndex<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>checked <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkBoundsBeginEnd</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> endIndex<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> endIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isHighSurrogate</span><span class="token punctuation">(</span><span class="token function">getChar</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            Character<span class="token punctuation">.</span><span class="token function">isLowSurrogate</span><span class="token punctuation">(</span><span class="token function">getChar</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再来看<code>length()</code>:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> value<span class="token punctuation">.</span>length <span class="token operator">>></span> <span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> COMPACT_STRINGS<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    COMPACT_STRINGS <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">byte</span> <span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> COMPACT_STRINGS <span class="token operator">?</span> coder <span class="token operator">:</span> UTF16<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>javadoc对<code>COMPACT_STRINGS</code>的解释是：</p><blockquote><p>If String compaction is disabled, the bytes in value are always encoded in UTF16</p></blockquote><p>即COMPACT_STRINGS默认是开启的，即同时支持UTF16和LATIN1，但具体的编译器可以将其关闭，使其只支持UTF16。</p><p>这里计算长度的方法依然很简单，对于LATIN1就是byte数组的长度，对于UTF16则是byte数组长度除以2。</p><p>JDK9中对字符串的改动带来的问题是什么呢？可能有人知道，java中数组的大小是有上限的，许多集合类都有下面这个字段：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** The maximum size of array to allocate.* Some VMs reserve some header words in an array.* Attempts to allocate larger arrays may result in* OutOfMemoryError: Requested array size exceeds VM limit*/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>即数组的大小上限不应该超过<code>Integer.MAX_VALUE - 8</code>，那么大小相等的情况下，JDK9中byte数组自然也就比JDK8中的char数组能存储的信息少了1/2。</p><h1 id="JDK9带来的StringBuffer-StringBuilder变化">3 JDK9带来的StringBuffer/StringBuilder变化</h1><p>JDK9中String的改版，使得StringBuffer/StringBuilder的实现也有了小变化。如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The value is used for character storage.     */</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The id of the encoding used to encode the bytes in {@code value}.     */</span>    <span class="token keyword">byte</span> coder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p>AbstractStringBuilder中的内部数组也变为了byte数组，并且增加了coder字段。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putStringAt</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putStringAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getCoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> str<span class="token punctuation">.</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> index<span class="token punctuation">,</span> coder<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span> dst<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> dstBegin<span class="token punctuation">,</span> <span class="token keyword">byte</span> coder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> coder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin <span class="token operator">&lt;&lt;</span> coder<span class="token punctuation">,</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// this.coder == LATIN &amp;&amp; coder == UTF16</span>        StringLatin1<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> dstBegin<span class="token punctuation">,</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到加入了一些对coder的判断，Builder和String必须维持相同的coder。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41376740/article/details/80143215&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAVA9 String新特性，说说你不知道
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码分析" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22-括号生成</title>
    <link href="https://www.codetool.top/article/leetcode22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://www.codetool.top/article/leetcode22-括号生成/</id>
    <published>2020-04-09T04:46:43.000Z</published>
    <updated>2020-04-09T14:46:19.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p><strong>示例:</strong></p><pre style="color:#e8eaf6"><strong style="color:#e8eaf6">输入：</strong>n = 3<strong style="color:#e8eaf6">输出：</strong>[       "((()))",       "(()())",       "(())()",       "()(())",       "()()()"     ]</pre><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>我是使用的dfs，递归太爽了。其他的思路如动态规划也可以。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addToAns</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//left：当前左括号数，right：当前右括号数。</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addToAns</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span>String s<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> n<span class="token operator">&amp;&amp;</span>right <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>n<span class="token punctuation">)</span> <span class="token function">addToAns</span><span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//仅当右括号数小于左括号数才能添加右括号</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>left<span class="token punctuation">)</span> <span class="token function">addToAns</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre style=&quot;color:#e8eaf6&quot;&gt;&lt;strong s
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://www.codetool.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>try-catch-finally字节码实例探究</title>
    <link href="https://www.codetool.top/article/try-catch-finally%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/"/>
    <id>https://www.codetool.top/article/try-catch-finally字节码实例探究/</id>
    <published>2020-04-08T15:20:32.000Z</published>
    <updated>2020-04-08T17:34:00.389Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用Idea的jclasslib插件查看字节码。本文全程自言自语，请勿自行代入。</p><h1 id="概述">1 概述</h1><p>java是怎么处理try-catch-finally的？</p><p>我们在<a href="../深入理解java虚拟机第三版读书笔记06">深入理解java虚拟机第三版读书笔记06</a>学习过，在class字节码中的属性表中，存在<code>code</code>属性，它用于存放各方法的字节码、属性等。其中就包括<code>exception_info</code>，即异常表，它记录了当一个异常发生后，应跳转到哪一行继续执行，而finally里面的代码块编译成字节码后则是被复制成许多份分别附在try和各catch块的后面。这篇文章，我们就通过一些实例来看看，java中的try-catch-finally引申出的一些问题。</p><h1 id="普通的例子">2 普通的例子</h1><h2 id="普通中的普通例子">2.1 普通中的普通例子</h2><p>我们先来一个普通的例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"try-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"finally"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个相信大家都知道是输出try-finally，因为没有异常出现，那么它的字节码是：</p><pre><code> 0 getstatic #4 &lt;java/lang/System.out&gt; 3 ldc #5 &lt;try-&gt; 5 invokevirtual #6 &lt;java/io/PrintStream.print&gt;---------------- 上面这部分输出&quot;try-&quot;----------------- 8 getstatic #4 &lt;java/lang/System.out&gt;11 ldc #7 &lt;finally&gt;13 invokevirtual #6 &lt;java/io/PrintStream.print&gt;---------------- 上面这部分输出&quot;finally&quot;--------------16 goto 50 (+34)-----------正常流程，跳转到50行直接return--------------19 astore_020 getstatic #4 &lt;java/lang/System.out&gt;23 ldc #8 &lt;catch&gt;25 invokevirtual #6 &lt;java/io/PrintStream.print&gt;-----上面这部分输出&quot;catch&quot;,astore_0存入的是异常信息-----28 getstatic #4 &lt;java/lang/System.out&gt;31 ldc #7 &lt;finally&gt;33 invokevirtual #6 &lt;java/io/PrintStream.print&gt;36 goto 50 (+14)-----注意上面这部分也是输出&quot;finally&quot;，和之前某部分一样----39 astore_140 getstatic #4 &lt;java/lang/System.out&gt;43 ldc #7 &lt;finally&gt;45 invokevirtual #6 &lt;java/io/PrintStream.print&gt;48 aload_149 athrow-----注意上面这部分也是输出&quot;finally&quot;，但抛出了一个异常----50 return</code></pre><p>我们看看异常表：</p><p><img src="https://api.codetool.top/img/15863605314214.png" alt></p><p>如何解读：</p><ul><li>0-8行（不包括8）的语句出现异常（类型为Exception，是我们catch的异常类型），交由19行处理（catch代码块），我们注意到28行执行完catch代码块后，就执行finally代码块。</li><li>0-8行的语句出现异常（类型为any，代表任何异常），交由39行处理，为什么这里会有这一项呢？<strong>是因为我们定义了finally</strong>，如果在try中出现了我们没有catch的异常类型，就可能会出现finally中的代码没有执行的情况，所以<strong>为了防止finally中的代码不执行，编译器会自动为我们暂时store这个异常信息（对应39行），执行完finally语句块后再抛出（对应49行）</strong></li><li>19-28行的语句出现异常（类型为any，代表任何异常），交由39行处理。为什么这里会有这一项呢？原因和上面一样，<strong>如果执行catch代码块又出现了异常，也要保证finally代码块的执行。</strong></li></ul><h2 id="普通例子举一反三">2.2 普通例子举一反三</h2><p>有了上面这个例子，我们就来思考一下，如果没有finally代码块，字节码会是什么样子的呢？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"try-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>首先能想到的是，正常流程执行完try中的内容就应该直接返回。而出现异常就应该跳转至中间一段用于处理异常的代码块。因为没有finally代码块，应该也不会有那么多冗余代码块被复制。</p><p>验证：</p><pre><code> 0 getstatic #4 &lt;java/lang/System.out&gt; 3 ldc #5 &lt;try-&gt; 5 invokevirtual #6 &lt;java/io/PrintStream.print&gt;----------上面输出&quot;try-&quot;------------------------- 8 goto 20 (+12)----------正常流程跳转至20行之间返回--------------11 astore_012 getstatic #4 &lt;java/lang/System.out&gt;15 ldc #7 &lt;catch&gt;17 invokevirtual #6 &lt;java/io/PrintStream.print&gt;------上面输出&quot;catch&quot;，是catch代码块的内容---------20 return</code></pre><p>这么一看确实清爽多了，再看看异常表：</p><p><img src="https://api.codetool.top/img/15863612854501.png" alt></p><p>确实异常表也清爽多了，因为不必保证finally代码块的执行，这里只有我们显式catch的一种异常。</p><h1 id="没事自己抛出异常玩玩，会发生什么？">3 没事自己抛出异常玩玩，会发生什么？</h1><h2 id="try抛出异常">3.1 try抛出异常</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwAndCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"骚一下"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抓住了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在外面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码的原型来自牛客网一道题，输出是什么？</p><p>答案应该是<code>抓住了</code>和<code>我在外面</code>，catch是可以捕获在try中手动抛出的异常的，但因为部分编译器优化程度过高知道<code>System.out.println(&quot;骚一下&quot;);</code>是不可达语句，会报编译错误。我没找到怎么关闭这个异常检查 TT_TT</p><h2 id="catch抛出异常">3.2 catch抛出异常</h2><p>catch中抛出异常的情况，我们把上面那段代码改成：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwAndCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出现异常了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抓住了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在外面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>为什么要抛RuntimeException？因为RuntimeException是非受查异常，可以不用catch，否则即使是在catch中抛出异常还是需要再嵌套一层catch。</p><p>那么这段代码会输出什么？我相信这里可能就有人猜不准了，正确答案应该是<code>抓住了</code>，并接着抛出运行时异常。</p><p>来看一下字节码：</p><pre><code> 0 iconst_1 1 iconst_0 2 idiv 3 istore_0---------上面这段代码做1/0的除法-------------------- 4 getstatic #4 &lt;java/lang/System.out&gt; 7 ldc #8 &lt;出现异常了&gt; 9 invokevirtual #9 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;出现异常了&quot;----------------------12 goto 32 (+20)-------正常流程跳转32行，执行外面的代码--------------15 astore_016 getstatic #4 &lt;java/lang/System.out&gt;19 ldc #10 &lt;抓住了&gt;21 invokevirtual #9 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;抓住了&quot;----------------------24 new #11 &lt;java/lang/RuntimeException&gt;27 dup28 invokespecial #12 &lt;java/lang/RuntimeException.&lt;init&gt;&gt;31 athrow----------上面抛出运行时异常----------------------32 getstatic #4 &lt;java/lang/System.out&gt;35 ldc #13 &lt;我在外面&gt;37 invokevirtual #9 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;我在外面&quot;----------------------40 return</code></pre><p>来看看异常表：</p><p><img src="https://api.codetool.top/img/1586362944559.png" alt></p><p>显然这里也只有我们显式catch的Exception处理。那我们来分析一下执行流程：</p><ul><li>0-3行，执行<code>1/0</code>的除法，出现了除以零的异常，因为此时行号处于0-12之间，就交给15行继续处理，所以”出现异常了”没有输出。</li><li>15-21行，输出”抓住了”，继续执行。</li><li>24-31行，new了一个<code>RuntimeException</code>，并抛出，因为没有该异常没有对应的处理，程序终止，后面的”我在外面”也不会输出。</li></ul><h2 id="举一反三">3.3 举一反三</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwAndCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出现异常了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抓住了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"必须执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我在外面"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>来看看这段代码，增加了一个finally语句块会输出什么呢？这里就不研究字节码了，因为原因之前在普通例子的时候就提到过了，如果catch代码块中出现异常，并且存在finally代码块，会先把异常信息存起来，执行完finally之后再抛出异常。</p><p>那么相信你也知道了，这里的输出应该是：<code>抓住了</code>和<code>必须执行</code>。</p><h1 id="我都要return了，finally还会执行吗？">4 我都要return了，finally还会执行吗？</h1><h2 id="普通例子">4.1 普通例子</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成10了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成20了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成30了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子开始有一点难度了，你能告诉我它会输出什么吗？</p><p>首先catch内的代码是不会执行的，因为没有异常抛出，你觉得finally中的代码会执行吗？</p><p>答案是会的，看看输出：</p><pre><code>修改成10了哦修改成30了哦10</code></pre><p>是否会大吃一惊？finally中的代码执行了，应该也将i修改为30了，怎么输出的还是10？</p><p>看看字节码：</p><pre><code> 0 bipush 10 2 istore_0----------上面将10存储到局部变量表---------------- 3 getstatic #2 &lt;java/lang/System.out&gt; 6 ldc #16 &lt;修改成10了哦&gt; 8 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;修改成10了哦&quot;------------------11 iload_012 istore_1-----上面将10先读出，又存储到局部变量表的1号槽位-----13 bipush 3015 istore_0------上面将30存储到局部变量表的0号槽位------------16 getstatic #2 &lt;java/lang/System.out&gt;19 ldc #17 &lt;修改成30了哦&gt;21 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;修改成30了哦&quot;------------------24 iload_125 ireturn----------从一号槽位读出数据，并返回---------------26 astore_127 bipush 2029 istore_0------上面将20存储到局部变量表的0号槽位------------30 getstatic #2 &lt;java/lang/System.out&gt;33 ldc #18 &lt;修改成20了哦&gt;35 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----------上面输出&quot;修改成20了哦&quot;------------------38 bipush 3040 istore_041 getstatic #2 &lt;java/lang/System.out&gt;44 ldc #17 &lt;修改成30了哦&gt;46 invokevirtual #10 &lt;java/io/PrintStream.println&gt;----这段和之前看过的一段一样，是finally块会干的事-----49 goto 66 (+17)52 astore_253 bipush 3055 istore_056 getstatic #2 &lt;java/lang/System.out&gt;59 ldc #17 &lt;修改成30了哦&gt;61 invokevirtual #10 &lt;java/io/PrintStream.println&gt;64 aload_265 athrow----这段和之前看过的一段一样，是finally块会干的事-----66 iload_067 ireturn----------从零号槽位读出数据，并返回---------------</code></pre><p>这段字节码是不是看着头疼，其实只需要注意到它在频繁地操作局部变量表就行了。其他流程和我们在普通例子里介绍的差不多。</p><p>看看异常表：</p><p><img src="https://api.codetool.top/img/15863642246448.png" alt></p><p>嗯。。确实跟我们之前介绍的普通例子差不多，那么为什么会出现这种奇异输出呢？我们来分析一下执行流程：</p><ul><li>0-2行，将10存储于局部变量表0号槽。</li><li>3-8行输出”修改成10了哦”</li><li>11-15行，将10转移到局部变量表1号槽，将30存入0号槽</li><li>19-21行，输出”修改成30了哦”</li><li>24-25行，从1号槽中读出10，并返回。</li></ul><p>牛的！其实执行的流程就这么点，注意到finally执行前后，程序分别将10存入局部变量表和从局部变量表中取出，实现了finally中对变量的修改不影响即将return的结果。</p><p>为什么会出现这种情况，<strong>因为编译器知道try中即将return数据，但是finally还是得执行，所以为了保护即将返回的数据，会先将该数据存起来，等finally执行完再取出并返回。</strong></p><h2 id="举一反三-1">4.2 举一反三</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成10了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成20了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成30了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子稍微更复杂点了，执行到catch中去了，那么输出是什么呢？</p><p>如果你有好好得跟着我看下来，应该不难猜到，try中异常前的语句、catch和finally中得语句都会执行，实际上，finally也不会影响catch返回的结果：</p><pre><code>修改成10了哦修改成20了哦修改成30了哦20</code></pre><h1 id="抢着return，谁优先？">5 抢着return，谁优先？</h1><h2 id="普通例子-1">5.1 普通例子</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个例子不复杂吧，经过了这么多历练，你能猜到结果吗？</p><p>答案其实是30，注意finally中如果出现了return语句，由于finally必会执行，总是finally中的return语句生效。</p><p>字节码也不难：</p><pre><code> 0 bipush 10 2 istore_0 3 bipush 30 5 ireturn-----在此处就执行了finally并返回----- 6 astore_0 7 bipush 20 9 istore_110 bipush 3012 ireturn13 astore_214 bipush 3016 ireturn</code></pre><h2 id="举一反三-2">5.2 举一反三</h2><p>稍微修改一下上面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出是什么？如果你能很快给出答案，我觉得你对try-catch-finally的理解已经差不多了</p><p><button onclick="document.getElementById('ans').style.display='inline';">点击查看答案</button></p><p><span id="ans" style="display:none">这道题的答案依然是30，因为编译器知道catch中即将要return了，再不执行finally来不及了，于是保存现场去执行finally，结果在finally中就return掉了。所以我们一般推荐不要在finally代码块中使用return语句，因为它会覆盖掉其他地方的return语句，程序的可读性不好，如果你不是看了我这篇文章，也想不到这段代码返回30吧？</span></p><p><span style="color:gray">有人可能要问了，学习这些是为了什么呢？谁写代码会这么写呢？那不都是为了应付面试吗😀</span></p><h1 id="finally不会执行的例外情况">6 finally不会执行的例外情况</h1><p>有人看了全文就要说了，懂了！反正finally必执行，记住这个就万无一失了！</p><p>其实finally也不是那么的保险，比如我给你举个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finally执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码中，finally就不会执行了，遇到<code>System.exit</code>，程序会直接退出，相当于杀进程了。</p><p>其他情况例如你外部杀进程，断电脑电源（手动滑稽），finally也是不会执行的。</p><p>OK，那么这篇文章就写到这了，长篇原创好文希望大家支持(<em>^_^</em>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文使用Idea的jclasslib插件查看字节码。本文全程自言自语，请勿自行代入。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;java是怎么处理try-catch-finally的？&lt;/p&gt;
&lt;p&gt;我们在&lt;a href=&quot;../深入理解java虚拟机第三版读
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="jvm" scheme="https://www.codetool.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer13-机器人的运动范围</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://www.codetool.top/article/剑指offer13-机器人的运动范围/</id>
    <published>2020-04-08T03:31:45.000Z</published>
    <updated>2020-04-08T04:15:09.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题（来源Leetcode）">1 原题（来源Leetcode）</h1><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong> m = 2, n = 3, k = 1<br><strong>输出：</strong> 3  </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> m = 3, n = 1, k = 0<br><strong>输出：</strong> 1  </p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>dfs，数组中会出现一些符合条件但不可达的格子。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">numSum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">numSum</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span>k <span class="token operator">||</span> x<span class="token operator">>=</span>visited<span class="token punctuation">.</span>length<span class="token operator">||</span>y<span class="token operator">>=</span>visited<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">||</span> visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        count <span class="token operator">++</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">+=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题（来源Leetcode）&quot;&gt;1 原题（来源Leetcode）&lt;/h1&gt;&lt;p&gt;地上有一个m行n列的方格，从坐标 &lt;code&gt;[0,0]&lt;/code&gt; 到坐标 &lt;code&gt;[m-1,n-1]&lt;/code&gt; 。一个机器人从坐标 &lt;code&gt;[0, 0]&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
