<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2020-03-04T12:44:33.753Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引概述及索引的分类</title>
    <link href="https://www.codetool.top/article/MySQL%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>https://www.codetool.top/article/MySQL索引概述及索引的分类/</id>
    <published>2020-03-04T12:44:22.000Z</published>
    <updated>2020-03-04T12:44:33.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><img src="https://api.codetool.top/img/15833118439934.png" alt></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。（在有聚簇索引的概念时指向聚簇索引的值）</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><p><strong>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong></p><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h1 id="索引分类——从逻辑角度">2 索引分类——从逻辑角度</h1><ol><li>主键索引<br>索引列的值必须唯一，并且不允许有空值</li><li>唯一索引<br>索引列的值必须唯一，但允许有空值</li><li>单值索引<br>一个索引只包含单个列，一个表可以有多个单列索引</li><li>复合索引<br>一个索引包含多个列</li></ol><h1 id="索引分类——从数据结构角度">3 索引分类——从数据结构角度</h1><h2 id="B树-B-树">3.1 B树,B+树</h2><p>之前的博客有介绍<a href="../多叉平衡查找树-B树与B-树/">多叉平衡查找树-B树与B-树</a></p><p>通常在 B+树上有两个头指针，一个指向根结点（进行随机搜索），一个指向关键字最小的叶<br>结点（进行顺序搜索）。</p><h3 id="B-树与B树的比较">3.1.1 B+树与B树的比较</h3><p><strong>组织方式不一样</strong></p><p>B+树：所有有效的索引关键字值都必须存储在叶结点中，其内部结点中的键值只用于索引<br>项的查找定位。<br>B树：有效的索引关键字值可以出现在B树的任意一个结点中。</p><p>因此：<br>B+树：所有关键字的查找速度基本一致<br>B树：依赖于查找关键字所在结点的层次</p><p><strong>叶结点不同</strong></p><p>B+树中叶节点间增加链表指针，提供对索引关键字的顺序扫描功能；叶节点的个数未必符<br>合 m 叉查找树的要求，它依赖于键值字节数和指针字节数，为 m1 阶。</p><h3 id="MySQL中的B-树适用场景">3.1.2 MySQL中的B+树适用场景</h3><p>InnoDB 存储引擎使用的是 B+树。</p><p>B+树为对如下类型的查询有效：</p><ol><li>全值匹配：和索引中的所有列进行匹配（复合索引）</li><li>匹配最左前缀：只使用索引的第一列或前几列</li><li>匹配列前缀：只匹配某一列的值的开头部分</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>覆盖索引/只访问索引的查询</li></ol><p>一般来说，如果 B+树可以按照某种方式查找到值，那么也可以按照这种方式用于排序。如果 ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。</p><p>下面是一些关于B+树索引的限制：</p><ol><li>如果不是按照索引的最左列开始查找，则无法使用索引</li><li>不能跳过索引中的列</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li></ol><h2 id="Hash-索引">3.2 Hash 索引</h2><p>Hash树我在博客<a href="../高效查找的数据结构-HashTree（哈希树）/">高效查找的数据结构-HashTree（哈希树）</a>也提到过了。</p><p>只有精确匹配索引所有列的查询才有效，<br>在 MySQL 中，只有 Memory 引擎显式支持 Hash 索引。</p><p><strong>限制：</strong></p><ol><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读<br>取行（无法使用覆盖索引）。不过，访问内存中的行的速度很快。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li><li>哈希索引不支持部分索引列匹配查找。比如建立复合哈希索引(A,B)，无法仅使用 A 使用<br>哈希索引去查询</li><li>不支持范围查询，仅支持等值查询</li><li>哈希冲突严重时，索引维护的代码很高。</li></ol><h2 id="B树索引与Hash索引比较">3.3 B树索引与Hash索引比较</h2><ol><li>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相<br>应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该<br>键所在位置，然后再根据链表往后扫描，直到找到相应的数据；<br>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈<br>希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li><li>哈希索引也没办法利用索引完成排序，以及 <code>like ‘xxx%’</code> 这样的部分模糊查询（这种部分<br>模糊查询，其实本质上也是范围查询）；</li><li>哈希索引也不支持多列联合索引的最左匹配规则；</li><li>B+树索引的关键字检索效率比较平均，在有大量重复键值情况下，哈希索引的效率是极<br>低的，因为存在所谓的哈希碰撞问题。</li></ol><h1 id="索引分类——从物理存储角度">4 索引分类——从物理存储角度</h1><h2 id="聚簇索引（聚集索引）">4.1 聚簇索引（聚集索引）</h2><p>InnoDB 的聚簇索引实际上<strong>在同一个结构中保存了B+树索引和数据行。</strong></p><p><strong>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。</strong>聚簇表示数据行和相邻的键值紧紧地存储在一起。因为无法同时把数据行存储在两个不同的地方，所以<strong>一个表只能有一个聚簇索引。</strong></p><p>InnoDB 通过主键聚簇数据。</p><p>每张表都会有一个聚簇索引。聚簇索引是一级索引。</p><p>聚簇索引一般是主键；没有主键，就是第一个唯一键；没有唯一键，就是隐藏ID。<strong>聚簇索引以外的所有索引都称为二级索引（即非聚簇索引）。</strong> 在 InnoDB 中，二级索引中的每条记录都包含该行的主键列，以及为二级索引指定的列。 InnoDB 使用这个主键值来搜索聚簇索引中的行。</p><p><strong>聚簇索引的优点：</strong></p><ol><li>可以将相关数据保存在一起，<strong>只需一次 IO 就可以取出相邻的数据</strong></li><li>数据访问更快，因为索引和数据保存在同一个 B+树中</li><li>使用覆盖索引扫描的查询可以直接使用叶节点中的主键值</li></ol><p><strong>缺点：</strong></p><ol><li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE命令重新组织一下表</li><li><strong>更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置</strong></li><li>插入新行或者更新主键导致需要移动行的时候，可能面临页分裂的问题。<strong>当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行</strong>，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li><li><strong>可能导致全表扫描变慢</strong>，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li><li>二级索引（非聚簇索引）可能会更大， 因为在<strong>二级索引的叶子节点包含了引用行的主键值</strong>。这样的策略减少了当出现行移动或者页分裂时二级索引的维护工作。</li><li><strong>二级索引访问需要两次 B 树索引查找</strong>，而不是一次。因为二级索引中叶子节点保存的是行的主键值，要找到数据行，还需要拿主键值到聚簇索引中进行一次查找。</li></ol><p>对于 InnoDB，自适应哈希索引能够减少这样的重复工作。</p><h1 id="索引使用的基本原则">5 索引使用的基本原则</h1><ul><li>最经常查询的列上建立聚簇索引以提高查询效率</li><li>一个基本表最多只建立一个聚簇索引</li><li>经常更新的列不宜建立聚簇索引</li><li>主键和唯一键会自动创建索引</li></ul><h1 id="SQL索引语法">6 SQL索引语法</h1><h2 id="创建索引">6.1 创建索引</h2><pre><code>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type]ON tbl_name(index_col_name,...)index_col_name : column_name[(length)][ASC | DESC]</code></pre><ul><li>unique:唯一索引</li><li>fulltext:全文索引</li><li>spatial：空间索引</li></ul><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> PersonIndex<span class="token keyword">ON</span> Person <span class="token punctuation">(</span>LastName<span class="token punctuation">)</span> </code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> PersonIndex<span class="token keyword">ON</span> Person <span class="token punctuation">(</span>LastName <span class="token keyword">DESC</span><span class="token punctuation">)</span> </code></pre><p>复合索引：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> PersonIndex<span class="token keyword">ON</span> Person <span class="token punctuation">(</span>LastName<span class="token punctuation">,</span> FirstName<span class="token punctuation">)</span></code></pre><h2 id="查看索引">6.2 查看索引</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span></code></pre><p>会显示所有建在该表上的索引信息</p><h2 id="删除索引">6.3 删除索引</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> tbl_name<span class="token punctuation">;</span></code></pre><p>老版本好像是</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span></code></pre><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> idx_city_name <span class="token keyword">on</span> city<span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>常用开源数据库连接池C3P0、Druid介绍</title>
    <link href="https://www.codetool.top/article/%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0C3P0%E3%80%81Druid%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/常用开源数据库连接池C3P0、Druid介绍/</id>
    <published>2020-03-04T08:44:11.000Z</published>
    <updated>2020-03-04T08:45:25.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">1 概述</h1><p>很多时候，连接的混乱管理所造成的系统资源开销过大成为制约大型企业级应用效率的瓶颈。因为每一次WEB请求都要建立一次数据库连接，建立连接是一个耗费资源的活动，每次都得花费0.05-1s的时间，而且系统还要分配内存资源。</p><p>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。于现在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从缓冲池中取出一个，使用完毕以后再放回去即可。</p><h1 id="C3P0">2 C3P0</h1><p>C3P0是一款优秀的开源数据库连接池，被广泛使用。</p><h2 id="使用">2.1 使用</h2><p>maven依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9.1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>基本配置：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c3p0-config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 默认配置，如果没有指定则使用这个配置 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>default-config</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://192.168.91.1:3306/test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>default-config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 命名的配置,可以通过方法调用实现 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>named-config</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- ... --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>named-config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c3p0-config</span><span class="token punctuation">></span></span></code></pre><p>其他配置：</p><table><thead><tr><th>参数</th><th>默认值</th><th>解释</th></tr></thead><tbody><tr><td>initialPoolSize</td><td>3</td><td>连接池初始化时创建的连接数（介于maxPoolSize和minPoolSize之间）</td></tr><tr><td>maxPoolSize</td><td>15</td><td>连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大</td></tr><tr><td>minPoolSize</td><td>3</td><td>连接池保持的最小连接数，后面的maxIdleTimeExcessConnections跟这个配合使用来减轻连接池的负载</td></tr><tr><td>acquireIncrement</td><td>3</td><td>连接池在无空闲连接可用时一次性创建的新数据库连接数</td></tr><tr><td>maxIdleTime</td><td>0</td><td>连接的最大空闲时间，如果超过这个时间，某个数据库连接还没有被使用，则会断开掉这个连接如果为0，则永远不会断开连接</td></tr><tr><td>maxConnectorAge</td><td>0</td><td>连接的最大绝对年龄，单位是秒，0表示绝对年龄无限大</td></tr><tr><td>maxIdleTimeExcessConnection</td><td>0</td><td>单位秒，为了减轻连接池的负载，当连接池经过数据访问高峰创建了很多连接，但是后面连接池不需要维护这么多连接，必须小于maxIdleTime.配置不为0，则将连接池的数量保持到minPoolSize</td></tr><tr><td>automaticTestTable</td><td>null</td><td>如果不为null，c3p0将生成指定名称的空表，使用该表来测试连接</td></tr><tr><td>connectionTesterClassName</td><td>com.mchange.v2.c3p0.impl.<br>DefaultConnectionTester</td><td>通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。</td></tr><tr><td>idleConnectionTestPeriod</td><td>0</td><td>每个几秒检查所有连接池中的空闲连接</td></tr><tr><td>preferredTestQuery</td><td>null</td><td>定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意： 测试的表必须在初始数据源的时候就存在</td></tr><tr><td>testConnectionOnCheckin</td><td>FALSE</td><td>如果设为true那么在取得连接的同时将校验连接的有效性</td></tr><tr><td>testConnectionOnCheckout</td><td>FALSE</td><td>如果为true，在连接释放的同事将校验连接的有效性。</td></tr><tr><td>maxStatements</td><td>0</td><td>JDBC的标准参数，用以控制数据源内加载d的PreparedStatements数量</td></tr><tr><td>maxStatementsPerConnection</td><td>0</td><td>maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数</td></tr><tr><td>statementCacheNum-<br>DeferredCloseThreads</td><td>0</td><td>如果大于零，则语句池将延迟物理close()缓存语句直到其父连接未被任何客户端使用，或者在其内部（例如在测试中）由池本身使用。</td></tr><tr><td>acquireRetryAttempts</td><td>30</td><td>定义在从数据库获取新连接失败后重复尝试的次数</td></tr><tr><td>acquireRetryDelay</td><td>1000</td><td>两次连接间隔时间，单位毫秒</td></tr><tr><td>breakAfterAcquireFailure</td><td>FALSE</td><td>获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效  保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 获取连接失败后该数据源将申明已断开并永久关闭</td></tr><tr><td>autoCommitOnClose</td><td>FALSE</td><td>连接关闭时默认将所有未提交的操作回滚。如果为true，则未提交设置为待提交而不是回滚。</td></tr><tr><td>forceIgnoreUnresolvedTransactions</td><td>FALSE</td><td>官方文档建议这个不要设置为true</td></tr><tr><td>checkoutTimeout</td><td>0</td><td>当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException,如设为0则无限期等待。单位毫秒。</td></tr><tr><td>factoryClassLocation</td><td>0</td><td>指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可</td></tr><tr><td>numHelperThreads</td><td>3</td><td>c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能通过多线程实现多个操作同时被执行</td></tr></tbody></table><p>使用：</p><pre class=" language-java"><code class="language-java">DataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>它会自动去类路径下查找名为<code>c3p0-config.xml</code>配置文件并加载。</p><p>可以使用命名的配置：</p><pre class=" language-java"><code class="language-java">DataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用的就是<code>name=&quot;test&quot;</code>的<code>named-config</code></p><h1 id="Druid">3 Druid</h1><p>Druid是阿里开源的一个数据库连接池，借鉴了C3P0等成熟连接池的思想，具有诸多优点</p><h2 id="使用-1">3.1 使用</h2><p>maven依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>基本配置：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">driverClassName</span> <span class="token punctuation">=</span> <span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">url</span> <span class="token punctuation">=</span> <span class="token attr-value">jdbc:mysql://192.168.91.1:3306/test</span><span class="token attr-name">username</span> <span class="token punctuation">=</span> <span class="token attr-value">root</span><span class="token attr-name">password</span> <span class="token punctuation">=</span> <span class="token attr-value">123456</span></code></pre><p>其他配置：</p><table><thead><tr><th>配置</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显式调用 init  方法，或者第一次getConnection 时</td></tr><tr><td>maxActive</td><td>8</td><td>最大允许的连接数</td></tr><tr><td>maxIdle</td><td></td><td>已过期</td></tr><tr><td>minIdle</td><td></td><td>最小的空闲连接数</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了 maxWait 之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置  useUnfairLock 属性为 true 使用非公平锁。</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的 sql，要求是一个查询语句。</td></tr><tr><td>testOnBorrow</td><td>TRUE</td><td>申请连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>FALSE</td><td>归还连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>FALSE</td><td>设置空闲时是否检测连接可用性。建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于  timeBetweenEvictionRunsMillis，执行 validationQuery 检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>检测需要关闭的空闲连接的间隔时间</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接在池中的最小生存时间</td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><p>使用：</p><pre class=" language-java"><code class="language-java">Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>InputStream in <span class="token operator">=</span> Demo1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>DataSource dataSource <span class="token operator">=</span> DruidDataSourceFactory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用连接池</span>conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="源码">3.2 源码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> DruidPooledConnection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token keyword">long</span> maxWaitMillis<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FilterChainImpl filterChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterChainImpl</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filterChain<span class="token punctuation">.</span><span class="token function">dataSource_connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> maxWaitMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getConnectionDirect</span><span class="token punctuation">(</span>maxWaitMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>DruidPooledConnection内部包装了一个Connection，增强了close等方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>disable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DruidConnectionHolder holder <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>holder<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>holder <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dupCloseLogEnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LOG<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"dup close"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DruidAbstractDataSource dataSource <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isSameThread <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSameThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dataSource<span class="token punctuation">.</span><span class="token function">setAsyncCloseConnectionEnable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dataSource<span class="token punctuation">.</span><span class="token function">isAsyncCloseConnectionEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">syncClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ConnectionEventListener listener <span class="token operator">:</span> holder<span class="token punctuation">.</span><span class="token function">getConnectionEventListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        listener<span class="token punctuation">.</span><span class="token function">connectionClosed</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConnectionEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Filter<span class="token operator">></span> filters <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getProxyFilters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FilterChainImpl filterChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterChainImpl</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChain<span class="token punctuation">.</span><span class="token function">dataSource_recycle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>disable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>【附】了解：DBUtils的使用</p><p>QueryRunner、DbUtils、ResultSetHandler。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;1 概述&lt;/h1&gt;&lt;p&gt;很多时候，连接的混乱管理所造成的系统资源开销过大成为制约大型企业级应用效率的瓶颈。因为每一次WEB请求都要建立一次数据库连接，建立连接是一个耗费资源的活动，每次都得花费0.05-1s的时间，而且系统还要分配内存资源。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="javaweb" scheme="https://www.codetool.top/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>leetcode994-腐烂的橘子</title>
    <link href="https://www.codetool.top/article/leetcode994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>https://www.codetool.top/article/leetcode994-腐烂的橘子/</id>
    <published>2020-03-03T17:23:30.000Z</published>
    <updated>2020-03-03T17:46:49.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p><strong>示例 1:</strong></p><p><img src="https://api.codetool.top/img/15832562668258.png" alt></p><blockquote><p><strong>输入:</strong> [[2,1,1],[1,1,0],[0,1,1]]<br><strong>输出:</strong> 4</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [[2,1,1],[0,1,1],[1,0,1]]<br><strong>输出:</strong> -1<br><strong>解释:</strong> 左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> [[0,2]]<br><strong>输出:</strong> 0<br><strong>解释:</strong> 因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= grid.length &lt;= 10</code></li><li><code>1 &lt;= grid[0].length &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ol><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>广度优先搜索，每次将搜索到的新鲜橘子搞成2，最后再搜索一遍全图是否有剩余的新鲜橘子。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">int</span> width<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">orangesRotting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        height <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>height <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        width <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>height<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>width<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token operator">*</span>width<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Integer i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                cur<span class="token operator">++</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> i<span class="token operator">/</span>width<span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> i<span class="token operator">%</span>width<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token function">toInt</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                grid<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>height<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token function">toInt</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                grid<span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token function">toInt</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">!=</span>width<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token function">toInt</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>height<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>width<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">toInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>width<span class="token operator">+</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;p&gt;值 0 代表空单元格；&lt;br&gt;值 1 代表新鲜橘子；&lt;br&gt;值 2 代表腐烂的橘子。&lt;br&gt;每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。&lt;/p
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Redis高并发环境下出现的各种问题详解</title>
    <link href="https://www.codetool.top/article/Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%87%BA%E7%8E%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.codetool.top/article/Redis高并发环境下出现的各种问题详解/</id>
    <published>2020-03-03T16:43:37.000Z</published>
    <updated>2020-03-03T16:45:29.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存预热">1 缓存预热</h1><p>服务器启动后迅速宕机</p><p>问题原因：</p><ol><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ol><h2 id="解决方案">1.1 解决方案</h2><p>前置准备工作：</p><ol><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列<br>例如：storm与kafka配合</li></ol><p>准备工作：</p><ol><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时预热<br>实施：</li><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ol><h2 id="总结">1.2 总结</h2><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h1 id="缓存雪崩">2 缓存雪崩</h1><p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现<br>（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><h2 id="问题体现">2.1 问题体现</h2><ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ol><h2 id="原因分析">2.2 原因分析</h2><ol><li>在一个较短的时间内，缓存中较多的key集中过期</li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ol><h2 id="解决方案-1">2.3 解决方案</h2><p>降低数据库压力：</p><ol><li>更多的页面静态化处理</li><li>构建多级缓存架构<br>Nginx缓存+redis缓存+ehcache缓存</li><li>检测Mysql严重耗时业务进行优化<br>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li><li>灾难预警机制<br> 监控redis服务器性能指标<ul><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li>限流、降级<br>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ol><p>避免短时间大量key集中过期：</p><ol><li>LRU与LFU切换</li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li></ul></li><li>超热数据使用永久key</li><li>定期维护（自动+人工）<br>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁<br> 慎用！</li></ol><h1 id="缓存击穿">3 缓存击穿</h1><p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。</p><h2 id="问题体现-1">3.1 问题体现</h2><ol><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃</li></ol><h2 id="原因分析-1">3.2 原因分析</h2><ol><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ol><h2 id="解决方案-2">3.3 解决方案</h2><p>防止高热key过期：</p><ol><li>预先设定<br>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长<br>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li><li>现场调整<br>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据<br>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存<br>设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁<br>分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li></ol><p>关于雪崩中降低数据库压力的方法也适用。</p><h1 id="缓存穿透">4 缓存穿透</h1><p>缓存穿透访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p><p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p><h2 id="问题体现-2">4.1 问题体现</h2><ol><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ol><h2 id="原因分析-2">4.2 原因分析</h2><ol><li>出现非正常URL访问（通常是黑客攻击）</li><li>Redis中大面积出现未命中</li><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据。</li><li>反复出现以上情况，redis和数据库的压力激增。</li></ol><h2 id="解决方案-3">4.3 解决方案</h2><ol><li>缓存null<br>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li><li>白名单策略  <ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li><li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li></ul></li><li>实施监控<br> 实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比<ul><li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li><li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象<br>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li></ul></li><li>key加密<br>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验。<br>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问。</li></ol><h1 id="Redis性能指标监控">5 Redis性能指标监控</h1><h2 id="性能指标">5.1 性能指标</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>latency</td><td>Redis响应一个请求的时间</td></tr><tr><td>instantaneous_ops_per_sec</td><td>平均每秒处理请求总数</td></tr><tr><td>hit rate (calculated)</td><td>缓存命中率(计算出来的)</td></tr></tbody></table><h2 id="内存指标">5.2 内存指标</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>used_memory</td><td>已使用内存</td></tr><tr><td>mem_fragmentation_ratio</td><td>内存碎片率</td></tr><tr><td>evicted_keys</td><td>由于最大内存限制被移除的key的数量</td></tr><tr><td>blocked_clients</td><td>由于BLPOP,BRPOP,or BRPOPLPUSH而被阻塞的客户端</td></tr></tbody></table><h2 id="基本活动指标">5.3 基本活动指标</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>connected_clients</td><td>客户端连接数</td></tr><tr><td>connected_slaves</td><td>Slave数量</td></tr><tr><td>master_last_io_seconds_ago</td><td>最近一次主从交互之后的秒数</td></tr><tr><td>keyspace</td><td>数据库中的key值总数</td></tr></tbody></table><h2 id="持久性指标">5.4 持久性指标</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>rdb_last_save_time</td><td>最后一次持久化保存到磁盘的时间戳</td></tr><tr><td>rdb_changes_since_last_save</td><td>自最后一次持久化以来数据库的更改数</td></tr></tbody></table><h2 id="错误指标">5.5 错误指标</h2><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>rejected_connections</td><td>由于达到maxclient限制而被拒绝的连接数</td></tr><tr><td>keyspace_misses</td><td>Key值查找失败(没有命中)次数</td></tr><tr><td>master_link_down_since_seconds</td><td>主从断开的持续时间(以秒为单位)</td></tr></tbody></table><h2 id="监控方式">5.6 监控方式</h2><p>监控方式</p><ul><li>工具<ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul></li><li>命令<ul><li>benchmark</li><li>redis-cli<ul><li>monitor</li><li>slowlog</li></ul></li></ul></li></ul><h3 id="benchmark">5.6.1 benchmark</h3><p>命令：</p><pre><code>redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</code></pre><p>不带参数运行<code>redis-benchmark</code>会测试50个连接，10000次请求对应的性能</p><pre><code>redis-benchmark -c 100 -n 5000</code></pre><p>可以测试100个连接，5000次请求对应的性能</p><table><thead><tr><th>选项</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>-h</td><td>指定服务器主机名</td><td>127.0.0.1</td></tr><tr><td>-p</td><td>指定服务器端口</td><td>6379</td></tr><tr><td>-s</td><td>指定服务器 socket</td><td></td></tr><tr><td>-c</td><td>指定并发连接数</td><td>50</td></tr><tr><td>-n</td><td>指定请求数</td><td>10000</td></tr><tr><td>-d</td><td>以字节的形式指定SET/GET值的数据大小</td><td>2</td></tr><tr><td>-k</td><td>1=keep alive 0=reconnect</td><td>1</td></tr><tr><td>-r</td><td>SET/GET/INCR使用随机key,SADD使用随机值</td><td></td></tr><tr><td>-P</td><td>通过管道传输&lt;numreq&gt;请求</td><td>1</td></tr><tr><td>-q</td><td>强制退出redis。仅显示query/sec值</td><td></td></tr><tr><td>–csv</td><td>以CSV格式输出</td><td></td></tr><tr><td>-l</td><td>生成循环,永久执行测试</td><td></td></tr><tr><td>-t</td><td>仅运行以逗号分隔的测试命令列表。</td><td></td></tr><tr><td>-I</td><td>Idle模式。仅打开N个idle连接并等待。</td><td></td></tr></tbody></table><h2 id="monitor">5.7 monitor</h2><p>在redis-cli中使用指令 monitor 打印服务器的调试信息。</p><h2 id="slowlog">5.8 slowlog</h2><pre><code>slowlog [operator]</code></pre><p>operator可取：</p><ul><li>get ：获取慢查询日志</li><li>len ：获取慢查询日志条目数</li><li>reset ：重置慢查询日志</li></ul><p>相关配置：</p><pre class=" language-conf"><code class="language-conf">slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：微妙slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存预热&quot;&gt;1 缓存预热&lt;/h1&gt;&lt;p&gt;服务器启动后迅速宕机&lt;/p&gt;
&lt;p&gt;问题原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求数量较高&lt;/li&gt;
&lt;li&gt;主从之间数据吞吐量较大，数据同步操作频度较高&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;1.1 解决方案&lt;/h
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制、哨兵、集群详解</title>
    <link href="https://www.codetool.top/article/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E9%9B%86%E7%BE%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.codetool.top/article/Redis主从复制、哨兵、集群详解/</id>
    <published>2020-03-03T15:03:16.000Z</published>
    <updated>2020-03-03T15:15:32.017Z</updated>
    
    <content type="html"><![CDATA[<p>【补充】<br>高可用：（总时间-宕机时间）/总时间，目标是99.999%</p><h1 id="主从复制">1 主从复制</h1><p>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服<br>务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续<br>提供服务，实现Redis的高可用，同时实现数据冗余备份。</p><p>提供数据方：master<br>接收数据方：slave</p><p>从机通常不允许写，当主机宕机，需要临时推选出一个从机代替主机工作。</p><h2 id="作用">1.1 作用</h2><ul><li>读写分离：master写、slave读，提高服务器的负载能力。</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数<br>量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul><h2 id="工作流程">1.2 工作流程</h2><p>主从复制过程大体可以分为3个阶段</p><ul><li>建立连接阶段（即准备阶段）</li><li>数据同步阶段</li><li>命令传播阶段</li></ul><h3 id="建立连接">1.2.1 建立连接</h3><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p><p>步骤1：设置master的地址和端口，保存master信息</p><p>步骤2：建立socket连接</p><p>步骤3：发送ping命令（定时器任务）（断开重连）</p><p>步骤4：身份验证</p><p>步骤5：发送slave端口信息</p><p><strong>具体实现：</strong></p><p>设置master信息：</p><ul><li>方式一：客户端发送命令<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li><li>方式二：启动服务器参数<code>redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li><li>方式三：服务器配置<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul><p>断开方式：<code>slaveof no one</code></p><p><strong>配置授权认证：</strong></p><p>master设置密码的方法：</p><ul><li>配置文件：<code>requirepass &lt;password&gt;</code> </li><li>指令设置密码：<code>config set requirepass &lt;password&gt;</code></li></ul><p>slave密码认证方法：</p><ul><li>指令：<code>auth &lt;password&gt;</code></li><li>启动客户端参数：<code>redis-cli -a &lt;password&gt;</code></li><li>配置文件：<code>masterauth &lt;password&gt;</code></li></ul><h3 id="数据同步">1.2.2 数据同步</h3><ul><li>在slave初次连接master后，复制master中的所有数据到slave</li><li>将slave的数据库状态更新成master当前的数据库状态</li></ul><p>连接后的第一次同步是<strong>全量复制</strong>：</p><ul><li>slave发送指令：psync2</li><li>master执行bgsave，产生rdb文件，这段时间内执行的指令放在命令缓冲区中</li><li>master将rdb文件发给slave</li><li>slave从rdb文件中恢复数据</li></ul><p>然后是<strong>部分（增量）复制</strong>：</p><ul><li>master将命令缓冲区中指令以aof的格式发送给slave</li><li>slave执行指令以同步</li></ul><p><strong>数据同步阶段master说明：</strong></p><ol><li>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。<br>相关配置：<code>repl-backlog-size 1mb</code></li><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</li></ol><p><strong>数据同步阶段slave说明：</strong></p><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务<br>相关配置：<code>slave-serve-stale-data yes|no</code></li><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</li><li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</li></ol><h3 id="命令传播">1.2.3 命令传播</h3><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li></ul><p><strong>命令传播阶段的部分复制：</strong></p><p>如果命令传播阶段出现了断网现象：</p><ul><li>网络闪断闪连 ——忽略</li><li>短时间网络中断 ——部分复制</li><li>长时间网络中断 ——全量复制</li></ul><p><strong>部分复制的三个核心要素：</strong></p><ol><li>服务器的运行ID</li></ol><p>服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id。</p><p>组成：运行id由40位字符组成，是一个随机的十六进制字符<br>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce。</p><p>作用：运行id被用于在服务器间进行传输，识别身份。<br>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别。</p><p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid。</p><ol start="2"><li>主服务器的复制积压缓冲区</li></ol><p>复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p><p>内容就是AOF文件的格式，每个字节值还有一个偏移量。</p><ol start="3"><li>主从服务器的复制偏移量</li></ol><p>一个数字，描述复制缓冲区中的指令字节位置</p><p><strong>分类：</strong></p><ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul><p><strong>作用：</strong>同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p><h3 id="工作流程总结">1.2.4 工作流程总结</h3><p><img src="https://api.codetool.top/img/15832485134650.png" alt></p><h2 id="心跳机制">1.3 心跳机制</h2><p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线。</p><p>master心跳：</p><ul><li>指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul><p>slave心跳任务</p><ul><li>指令：REPLCONF ACK {offset}</li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul><p><strong>注意:</strong></p><ul><li>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作  </li></ul><p>相关配置：</p><pre><code>min-slaves-to-write 2min-slaves-max-lag 8</code></pre><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</p><ul><li>slave数量由slave发送REPLCONF ACK命令做确认</li><li>slave延迟由slave发送REPLCONF ACK命令做确认</li></ul><h2 id="主从复制常见问题">1.4 主从复制常见问题</h2><h3 id="频繁的全量复制（1）">1.4.1 频繁的全量复制（1）</h3><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</p><p>内部优化调整方案：</p><ol><li>master内部创建<code>master_replid</code>变量，使用<code>runid</code>相同的策略生成，长度41位，并发送给所有slave</li><li>在master关闭时执行命令<code>shutdown save</code>，进行RDB持久化,<strong>将runid与offset保存到RDB文件中</strong><ul><li>repl-id repl-offset</li><li>通过redis-check-rdb命令可以查看该信息</li></ul></li><li>master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中<ul><li>master_repl_id = repl master_repl_offset = repl-offset</li><li>通过info命令可以查看该信息</li></ul></li></ol><p><strong>作用：</strong><br>本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p><h3 id="频繁的全量复制（2）">1.4.2 频繁的全量复制（2）</h3><p><strong>问题现象:</strong></p><p>网络环境不佳，出现网络中断，slave不提供服务</p><p><strong>问题原因:</strong></p><p>复制缓冲区过小，断网后slave的offset越界，触发全量复制</p><p><strong>最终结果:</strong></p><p>slave反复进行全量复制</p><p><strong>解决方案:</strong></p><ul><li>修改复制缓冲区大小</li><li>建议设置如下：<ol><li>测算从master到slave的重连平均时长<code>second</code></li><li>获取master平均每秒产生写命令数据总量<code>write_size_per_second</code></li><li>最优复制缓冲区空间 = <code>2 * second * write_size_per_second</code></li></ol></li></ul><h3 id="频繁的网络中断（1）">1.4.3 频繁的网络中断（1）</h3><p><strong>问题现象:</strong></p><p>master的CPU占用过高 或 slave频繁断开连接</p><p><strong>问题原因：</strong></p><ul><li>slave每1秒发送REPLCONF ACK命令到master</li><li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能</li><li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li></ul><p><strong>最终结果：</strong></p><p>master各种资源（输出缓冲区、带宽、连接等）被严重占用</p><p><strong>解决方案：</strong></p><p>通过设置合理的超时时间<code>repl-timeout</code>，确认是否释放slave。该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p><h3 id="频繁的网络中断（2）">1.4.4 频繁的网络中断（2）</h3><p><strong>问题现象：</strong></p><p>slave与master连接断开</p><p><strong>问题原因：</strong></p><ul><li>master发送ping指令频度较低</li><li>master设定超时时间较短</li><li>ping指令在网络中存在丢包</li></ul><p><strong>解决方案：</strong></p><p>提高ping指令发送的频度</p><p><code>repl-ping-slave-period</code></p><p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p><h3 id="数据不一致">1.4.5 数据不一致</h3><p><strong>问题现象：</strong></p><p>多个slave获取相同数据不同步</p><p><strong>问题原因：</strong></p><p>网络信息不同步，数据发送有延迟</p><p><strong>解决方案：</strong></p><ul><li>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</li><li>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</li></ul><p><code>slave-serve-stale-data yes|no</code></p><p>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p><h1 id="哨兵模式">2 哨兵模式</h1><p>上面提到如果主机宕机，需要临时推选出一个从机代替主机工作。</p><h2 id="作用-1">2.1 作用</h2><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。</p><p><strong>监控：</strong></p><p>不断的检查master和slave是否正常运行。</p><p>master存活检测、master与slave运行情况检测</p><p><strong>通知（提醒）：</strong></p><p>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</p><p><strong>自动故障转移：</strong></p><p>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</p><p><strong>注意：</strong></p><ul><li>哨兵也是一台redis服务器，只是不提供数据服务</li><li>通常哨兵配置数量为单数</li></ul><h2 id="启用哨兵">2.2 启用哨兵</h2><p>启用哨兵命令：</p><pre class=" language-shell"><code class="language-shell">redis-sentinel sentinel-配置.conf</code></pre><p>配置文件：</p><pre><code>sentinel monitor mymaster 127.0.0.1 6379 2  # 配置监控的主节点# 这个配置项格式为sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;# 意义为监视一个名为mymaster的主节点（这里的mymaster可以自定义，主要是为了标识这个集群）# 主节点ip地址是127.0.0.1，端口为6379# 法定票数为2票。表示至少需要2个哨兵认为节点down了，才算down了。sentinel down-after-milliseconds mymaster 30000# 监控到指定的集群的主节点异常状态持续多久方才将标记为“故障”；sentinel parallel-syncs mymaster 1# 指在failover过程中，能够被sentinel并行配置的从节点的数量；数值越大，要求网络资源越高，要求越小，同步时间约长sentinel failover-timeout 180000# sentinel必须在此指定的时长内完成故障转移操作，否则，将视为故障转移操作失败</code></pre><h2 id="哨兵工作原理">2.3 哨兵工作原理</h2><p>哨兵在进行主从切换过程中经历三个阶段</p><ul><li>监控</li><li>通知</li><li>故障转移</li></ul><h3 id="监控阶段">2.3.1 监控阶段</h3><p>用于同步各个节点的状态信息</p><ul><li>获取各个sentinel的状态（是否在线）</li><li>获取master的状态<ul><li>master属性<ul><li>runid</li><li>role：master</li></ul></li><li>各个slave的详细信息</li></ul></li><li>获取所有slave的状态（根据master中的slave信息）<ul><li>slave属性<ul><li>runid</li><li>role：slave</li><li>master_host、master_port</li><li>offset</li><li>……</li></ul></li></ul></li></ul><h3 id="通知阶段">2.3.2 通知阶段</h3><p>sentinel之间也会组建连接网共享master和slave的状态。</p><p>每个sentinel收集到了信息都会共享给其他的sentinel。</p><h3 id="故障转移阶段">2.3.3 故障转移阶段</h3><p>如果某一sentinel某时刻联系不上主机并且超过<code>failover-timeout</code>时间，就对其他sentinel发起通知<code>SENTINEL is-master-down-by-addr ……</code>，此时该sentinel对主机的判定为<code>SRI_S_DOWN</code>，即主观下线。</p><p>其他sentinel收到通知后也对主机做出评判，如果有超半数(法定票数)的sentinel认为主机宕机了，就判定该主机为<code>SRI_O_DOWN</code>，即客观下线。</p><p>然后sentinel内部开始发送竞选指令争选作为处理该故障的哨兵。所有哨兵根据收到竞选指令的先后和一些评判标准投票，获得投票数最多的哨兵处理该故障。</p><p><strong>哨兵的任务：</strong></p><p>在服务器列表中挑选备选master：</p><ul><li>筛选在线的</li><li>剔除响应慢的</li><li>剔除与原master断开时间久的</li><li>按照优先原则<ul><li>优先级</li><li>offset</li><li>runid</li></ul></li></ul><p>根据以上方法挑选出一个备选master后，开始替换master：</p><ul><li>发送指令（sentinel）</li><li>向新的master发送slaveof no one</li><li>向其他slave发送slaveof 新masterIP端口</li></ul><h1 id="集群">3 集群</h1><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p><p><strong>集群的作用</strong></p><ul><li>分散单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul><h2 id="设计">3.1 设计</h2><ul><li>通过算法设计，计算出key应该保存的位置</li><li>将所有的存储空间计划切割成16384份槽，每台主机保存一部分<br>每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间</li></ul><p>集群内部也有通信，每台机器都知道一个指定的槽放在哪个机器上，如果槽未命中，则会通知用户正确位置。</p><h2 id="cluster集群搭建">3.2 cluster集群搭建</h2><p>参考<a href="https://www.cnblogs.com/toutou/p/redis_cluster.html" target="_blank" rel="noopener">详解Redis Cluster集群 - 请叫我头头哥 - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【补充】&lt;br&gt;高可用：（总时间-宕机时间）/总时间，目标是99.999%&lt;/p&gt;
&lt;h1 id=&quot;主从复制&quot;&gt;1 主从复制&lt;/h1&gt;&lt;p&gt;为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服&lt;br&gt;务器上，连接在一起，并保证数据是同
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级数据类型介绍</title>
    <link href="https://www.codetool.top/article/Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/Redis高级数据类型介绍/</id>
    <published>2020-03-03T10:26:52.000Z</published>
    <updated>2020-03-03T10:27:35.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bitmaps">1 Bitmaps</h1><p>之前的博客有提到过<a href="../海量数据算法-BitMap介绍和实现/">海量数据算法-BitMap介绍和实现</a></p><p>实际上Redis也有这样的数据结构——就是一个一个的字节（实际上也就是String类型），相关指令：</p><ul><li><code>setbit key index 1|0</code>：将对应的位设置为1/0。</li><li><code>getbit key index</code>：获取对应的位的值。</li><li><code>bitop op destKey key1 [key2...]</code>：bitmap之间的位运算，op可以是：<ul><li>and：与</li><li>or：或</li><li>not：非</li><li>xor：异或</li></ul></li><li><code>bitcount key [start end]</code>：统计bitmap中1的数量</li></ul><h1 id="HyperLogLog">2 HyperLogLog</h1><p>作用：统计不重复数据的数量。</p><p>虽然Bitmap也可以实现这个功能，但它的空间复杂度极高，而HyperLogLog中的<code>LogLog</code>代表的是它的空间复杂度，即这种算法的空间复杂度仅有<code>O(log2(log2(Nmax)))</code>。</p><p>它的原理基于基数估计算法(Cardinality Estimation Algorithm)：<code>LogLogCounting</code>（这种算法以后有机会再研究）</p><p>相关操作：</p><ul><li><code>pfadd key element [element ...]</code>：添加数据</li><li><code>pfcount key [key ...]</code>：统计数据，返回不重复数据的个数</li><li><code>pfmerge destkey sourcekey [sourcekey ...]</code>：合并数据</li></ul><p>这种算法是一种概率算法，它存在一定的误差。它只需要12K内存，在标准误差0.81%的前提下，能够统计2<sup>​64</sup>个数据。</p><p>pfadd命令并不是一次性分配12k内存使用，会随着基数的增加内存逐渐增大。</p><p>但是只要使用了pfmerge命令合并了空间，得到的合并后的空间就是12k。</p><h1 id="GEO">3 GEO</h1><p>功能：计算两个经纬度坐标点之间的距离。</p><p>相关操作：</p><ul><li><code>geoadd key longitude latitude member [longitude latitude member]</code>：添加坐标点</li><li><code>geopos key member [member ...]</code>：获取坐标点</li><li><code>geodist key member1 member2 [unit]</code>：计算坐标点，默认单位是米</li><li><code>georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code>：根据坐标求范围内的数据</li><li><code>georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code>：根据点求范围内的数据</li><li><code>geohash key member [member ...]</code>：获取指定点对应的坐标hash值</li></ul><p>示例：</p><pre><code>127.0.0.1:6379&gt; geoadd map 1 1 a(integer) 1127.0.0.1:6379&gt; geoadd map 2 2 b(integer) 1127.0.0.1:6379&gt; geopos map a1) 1) &quot;0.99999994039535522&quot;   2) &quot;0.99999945914297683&quot;127.0.0.1:6379&gt; geodist map a b&quot;157270.0561&quot;127.0.0.1:6379&gt; geodist map a b km&quot;157.2701&quot;127.0.0.1:6379&gt; georadiusbymember map a 180 km withdist1) 1) &quot;a&quot;   2) &quot;0.0000&quot;2) 1) &quot;b&quot;   2) &quot;157.2701&quot;127.0.0.1:6379&gt; georadiusbymember map a 120 km withdist1) 1) &quot;a&quot;   2) &quot;0.0000&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bitmaps&quot;&gt;1 Bitmaps&lt;/h1&gt;&lt;p&gt;之前的博客有提到过&lt;a href=&quot;../海量数据算法-BitMap介绍和实现/&quot;&gt;海量数据算法-BitMap介绍和实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实际上Redis也有这样的数据结构——就是一个一个的字节（实际上也就
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务、分布式锁、删除策略介绍</title>
    <link href="https://www.codetool.top/article/Redis%E4%BA%8B%E5%8A%A1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/Redis事务、分布式锁、删除策略介绍/</id>
    <published>2020-03-03T09:25:22.000Z</published>
    <updated>2020-03-03T09:25:45.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis事务">1 Redis事务</h1><h2 id="指令">1.1 指令</h2><p><code>multi</code>：开启事务<br><code>exec</code>: 结束并执行事务<br><code>discard</code>：终止并放弃事务</p><h2 id="注意">1.2 注意</h2><ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</li><li>如果一个事务在执行过程中某指令出现错误，不影响其他能执行的指令。程序员可以根据需要手动回滚（没有回滚指令，只能用逆操作）。</li></ul><h2 id="锁">1.3 锁</h2><p>Redis中可以使用锁来操控基于特定条件的事务执行。</p><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行：<code>watch key1 [key2……]</code></p><p>取消对所有 key 的监视：<code>unwatch</code></p><h2 id="分布式锁">1.4 分布式锁</h2><p>使用setnx设置一个公共锁：<code>setnx lock-key value</code></p><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p><ul><li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li></ul><p>操作完毕通过del操作释放锁</p><p><strong>注意：</strong></p><p>因为解锁操作依赖于用户控制，必定会出现加锁后未解锁的风险。</p><p><strong>解决方案：</strong> 使用<code>expire/pexpire</code>设置锁的过期时间，到点自动释放。</p><p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul><h1 id="删除策略">2 删除策略</h1><p>对于那些ttl=-2的已经过期的数据，redis真的将它们删除了吗？</p><ol><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ol><p>redis内存中有一块区域用于存储时效性数据的过期时间，它将数据的存储地址和过期时间关联了起来。</p><h2 id="定时删除">2.1 定时删除</h2><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。</p><ul><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li></ul><p>总结：用处理器性能换取存储空间 （拿时间换空间）</p><h2 id="惰性删除">2.2 惰性删除</h2><p>数据到达过期时间，不做处理。<strong>等下次访问该数据</strong>时如果未过期，返回数据，如果发现已过期，删除，返回不存在。</p><ul><li>优点：节约CPU性能，发现必须删除的时候才删除</li><li>缺点：内存压力很大，出现长期占用内存的数据</li></ul><p>总结：用存储空间换取处理器性能（拿时间换空间）</p><h2 id="定期删除">2.3 定期删除</h2><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p><p>每秒钟执行server.hz次<code>serverCron()</code>-&gt;<code>databasesCron()</code>-&gt;<code>activeExpireCycle()</code>。</p><p><code>activeExpireCycle()</code>对每个expires[*]逐一进行检测，每次执行250ms/server.hz</p><p>对某个expires[*]检测时，随机挑选W个key检测</p><ul><li>如果key超时，删除key</li><li>如果一轮中删除的key的数量&gt;W*25%，循环该过程</li><li>如果一轮中删除的key的数量≤W<em>25%，检查下一个expires[</em>]，0-15循环</li></ul><p>注意：</p><ul><li><code>W</code>取值=<code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code>属性值</li><li>参数<code>current_db</code>用于记录<code>activeExpireCycle()</code>:进入哪个expires[*] 执行</li><li>如果<code>activeExpireCycle()</code>执行时间到期，下次从current_db继续向下执行</li></ul><p>特点：</p><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p><ul><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查存储空间（随机抽查，重点抽查）</li></ul><h1 id="逐出算法">3 逐出算法</h1><p>Redis使用内存存储数据，在执行每一个命令前，会调用<code>freeMemoryIfNeeded()</code>检测内存是否充足。<strong>如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。</strong>清理数据的策略称为逐出算法。</p><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所<br>有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</p><pre><code>(error) OOM command not allowed when used memory &gt;&#39;maxmemory&#39;</code></pre><h2 id="相关配置">3.1 相关配置</h2><ul><li><p><code>maxmemory</code>：即redis最多能使用的物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p><code>maxmemory-samples</code>：每次选取待删除数据的个数。选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p><code>maxmemory-policy</code>：删除策略。</p></li></ul><p>对于会过期的数据：</p><ol><li>volatile-lru：挑选最近最少使用的数据淘汰</li><li>volatile-lfu：挑选最近使用次数最少的数据淘汰</li><li>volatile-ttl：挑选将要过期的数据淘汰</li><li>volatile-random：任意选择数据淘汰<br>检测全库数据：</li><li>allkeys-lru：挑选最近最少使用的数据淘汰</li><li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li><li>allkeys-random：任意选择数据淘汰<br>放弃数据驱逐：</li><li>no-enviction（驱逐）：禁止驱逐数据（redis5.0中默认策略），会引发错误OOM（Out Of Memory）</li></ol><p>通过指令info Stats可以看到缓存的命中次数和丢失次数。</p><h1 id="Redis配置拓展">4 Redis配置拓展</h1><ul><li><code>bind</code>：绑定主机地址</li><li><code>databases</code>：设置数据库的数量，默认16</li></ul><h2 id="日志配置">4.1 日志配置</h2><ul><li><code>loglevel debug|verbose|notice|warning</code>：设置服务器以指定日志记录级别，默认verbose</li><li><code>logfile 端口号.log</code>：日志记录文件名</li></ul><h2 id="客户端配置">4.2 客户端配置</h2><ul><li><code>maxclients 0</code>：设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis会关闭新的连接。</li><li><code>timeout 300</code>：客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭此功能，设置为0。</li></ul><h2 id="多服务器快捷配置">4.3 多服务器快捷配置</h2><p><code>include *.conf</code>：导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis事务&quot;&gt;1 Redis事务&lt;/h1&gt;&lt;h2 id=&quot;指令&quot;&gt;1.1 指令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;multi&lt;/code&gt;：开启事务&lt;br&gt;&lt;code&gt;exec&lt;/code&gt;: 结束并执行事务&lt;br&gt;&lt;code&gt;discard&lt;/code&gt;：终止并放弃
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode46-全排列</title>
    <link href="https://www.codetool.top/article/leetcode46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode46-全排列/</id>
    <published>2020-03-02T18:54:23.000Z</published>
    <updated>2020-03-02T18:59:47.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3]<br><strong>输出:</strong><br>[<br>&nbsp;&nbsp;[1,2,3],<br>&nbsp;&nbsp;[1,3,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[2,3,1],<br>&nbsp;&nbsp;[3,1,2],<br>&nbsp;&nbsp;[3,2,1]<br>]   </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>做这道题的时候我才发现我做这类回溯算法的题还是蛮少的，对集合的浅复制api不是很熟悉。主要是浅复制真的蛮麻烦 -。-|| </p><p>思想就是回溯啦，可以用一个数组记录使用过了的元素。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> globalNums<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        globalNums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">trackback</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>used<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trackback</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">,</span><span class="token keyword">int</span> usedCount<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>usedCount<span class="token operator">==</span>globalNums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>globalNums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                copy<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>globalNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> usedCopy <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>used<span class="token punctuation">,</span>used<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                usedCopy<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token function">trackback</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span>usedCopy<span class="token punctuation">,</span>usedCount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个&lt;strong&gt;没有重复&lt;/strong&gt;数字的序列，返回其所有可能的全排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; [1,
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯法" scheme="https://www.codetool.top/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化方式RDB和AOF介绍</title>
    <link href="https://www.codetool.top/article/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8FRDB%E5%92%8CAOF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.codetool.top/article/Redis持久化方式RDB和AOF介绍/</id>
    <published>2020-03-02T14:58:43.000Z</published>
    <updated>2020-03-02T14:59:40.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持久化简介">1 持久化简介</h1><p>将内存中的数据隔段时间在硬盘中做备份，防止数据突然丢失</p><ul><li>快照方法 RDB</li><li>日志方法 AOF</li></ul><h1 id="RDB">2 RDB</h1><h2 id="启动方式">2.1 启动方式</h2><h3 id="指令：save">2.1.1 指令：save</h3><ul><li>谁：redis操作者（用户）</li><li>什么时间：即时（随时进行）</li><li>干什么事情：保存数据</li></ul><p>手动执行一次保存一次数据，产生在日志文件夹下的rdb文件(二进制)</p><p>save指令会阻塞当前redis服务器，线上环境不推荐使用。</p><h3 id="指令：bgsave">2.1.2 指令：bgsave</h3><ul><li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li><li>什么时间：即时（发起）；合理的时间（执行）</li><li>干什么事情：保存数据</li></ul><pre><code>127.0.0.1:6379&gt; bgsaveBackground saving started</code></pre><p>原理：调用linux的fork函数生成子进程，由这个子进程负责创建rdb文件。</p><h3 id="自动执行">2.1.3 自动执行</h3><ul><li>谁：redis服务器发起指令（基于条件）</li><li>什么时间：满足条件</li><li>干什么事情：保存数据</li></ul><p>发起的还是bgsave</p><p>配置：</p><p><code>save second changes</code>：满足限定时间范围内key的变化数量达到指定数量即进行持久化。</p><p>示例：</p><pre class=" language-conf"><code class="language-conf">save 900 1save 300 10save 60 10000</code></pre><h3 id="其他启动方式">2.1.4 其他启动方式</h3><ol><li>全量复制</li><li>服务器运行过程中重启 <code>debug reload</code></li><li>关闭服务器时指定保存数据 <code>shutdown save</code></li></ol><h2 id="相关配置">2.2 相关配置</h2><ul><li><code>dbfilename dump.rdb</code><ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb</li><li>经验：通常设置为dump-端口号.rdb</li></ul></li><li><code>dir</code><ul><li>说明：设置存储.rdb文件的路径</li><li>经验：通常设置成存储空间较大的目录中，目录名称data</li></ul></li><li><code>rdbcompression yes</code><ul><li>说明：<strong>设置存储至本地数据库时是否压缩数据</strong>，默认为 yes，采用 LZF 压缩</li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li><code>rdbchecksum yes</code><ul><li>说明：<strong>设置是否进行RDB文件格式校验</strong>，该校验过程在写文件和读文件过程均进行</li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li><li><code>stop-writes-on-bgsave-error yes</code><ul><li>说明：后台存储过程中如果出现错误现象，是否停止保存操作</li><li>经验：通常默认为开启状态</li></ul></li></ul><h2 id="优点">2.3 优点</h2><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li><li>RDB恢复数据的速度要比AOF快很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul><h2 id="缺点">2.4 缺点</h2><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li></ul><h1 id="AOF">3 AOF</h1><h2 id="概述">3.1 概述</h2><p>AOF（append-only-file）:以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令<br>达到恢复数据的目的。与RDB相比可以简单描述为<strong>改记录数据为记录数据产生的过程</strong></p><p>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p><p>这个文件是一个文本文件</p><h2 id="AOF写数据三种策略">3.2 AOF写数据三种策略</h2><ul><li>always（每次）<br>每次写入操作均同步到AOF文件中，数据零误差，性能较低，命令写入到aof_buf后，会调用系统fsync操作同步到文件中。  </li><li>everysec（每秒）<br>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高，是默认配置。只调用系统write操作，fsync同步文件操作由专门进程每秒调用一次。<br>在系统突然宕机的情况下丢失1秒内的数据</li><li>no（系统控制）<br>由操作系统控制每次同步到AOF文件的周期，整体过程不可控，只调用系统write操作，不对AOF文件做fsync操作。</li></ul><h2 id="相关配置-1">3.3 相关配置</h2><ul><li><code>appendonly yes|no</code> 开启AOF</li><li><code>appendfsync always|everysec|no</code> 写数据策略</li></ul><h2 id="AOF重写">3.4 AOF重写</h2><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将<strong>对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令</strong>进行记录。</p><h3 id="作用">3.4.1 作用</h3><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h3 id="重写规则">3.4.2 重写规则</h3><ul><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令如del key1、hdel key2、srem key3、set key4 111、set key4 222等</li><li>对同一数据的多条写命令合并为一条命令，如<code>lpush list1 a</code>、<code>lpush list1 b</code>、 <code>lpush list1 c</code> 可以转化为：<code>lpush list1 a b c</code>。</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul><h3 id="重写方式">3.4.3 重写方式</h3><p>手动重写：<code>bgrewriteaof</code></p><p>自动重写：</p><pre class=" language-conf"><code class="language-conf"># aof_current_size达到最小size开始重写auto-aof-rewrite-min-size size# (aof_current_size-aof_base_size)/aof_base_size>percentage开始重写auto-aof-rewrite-percentage percentage</code></pre><p>配置自动重写要了解两个参数：</p><pre><code>aof_current_sizeaof_base_size</code></pre><p><code>aof_current_size</code>表示当前AOF文件大小，<code>aof_base_size</code>指的就是上一次重写后AOF文件的大小。这两个参数可以通过运行指令<code>info Persistence</code>查看。</p><p>原理和bgsave类似，也是用子进程去重写。</p><h1 id="RDB与AOF区别">4 RDB与AOF区别</h1><table><thead><tr><th>持久化方式</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级：压缩）</td><td>大（指令级：重写）</td></tr><tr><td>存储速度</td><td>慢</td><td>快</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>会丢失数据</td><td>依据策略决定</td></tr><tr><td>资源消耗</td><td>高/重量级</td><td>低/轻量级</td></tr><tr><td>启动优先级</td><td>低</td><td>高</td></tr></tbody></table><p>如何选择？</p><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结：</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;持久化简介&quot;&gt;1 持久化简介&lt;/h1&gt;&lt;p&gt;将内存中的数据隔段时间在硬盘中做备份，防止数据突然丢失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快照方法 RDB&lt;/li&gt;
&lt;li&gt;日志方法 AOF&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;RDB&quot;&gt;2 RDB&lt;/h1&gt;&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL回顾-存储过程与触发器</title>
    <link href="https://www.codetool.top/article/MySQL%E5%9B%9E%E9%A1%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://www.codetool.top/article/MySQL回顾-存储过程与触发器/</id>
    <published>2020-03-02T12:04:21.000Z</published>
    <updated>2020-03-04T13:00:00.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储过程">1 存储过程</h1><h2 id="概述">1.1 概述</h2><p>存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。</p><p>一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。</p><h2 id="优点">1.2 优点</h2><p>存储过程通常有如下优点：</p><ol><li>封装性<br>存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。</li><li>可增强 SQL 语句的功能和灵活性<br>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li><li>可减少网络流量<br>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。</li><li>高性能<br>存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。</li><li>提高数据库的安全性和数据的完整性<br>使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。</li></ol><h2 id="编写">1.3 编写</h2><h3 id="基本的存储过程">1.3.1 基本的存储过程</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">BEGIN</span>        <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">as</span> priceaverage <span class="token keyword">FROM</span> products<span class="token punctuation">;</span>    <span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>创建名为 productpricing 的储存过程。如果存储过程中需要传递参数，则将他们在括号中列举出来即可。括号必须有。<strong>BEGIN 和 END 关键字用来限制存储过程体。</strong>上述存储过程体本身是一个简单的 select 语句。注意这里只是创建存储过程并没有进行调用。</p><p>储存过程的使用：<br><code>Call productpring();</code></p><h3 id="使用参数的存储过程">1.3.2 使用参数的存储过程</h3><p>一般存储过程并不显示结果，而是把结果返回给你指定的变量上。</p><p>变量：内存中一个特定的位置，用来临时存储数据。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> prod<span class="token punctuation">(</span>    <span class="token keyword">OUT</span> pl <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">OUT</span> ph <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">OUT</span> pa <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">BEGIN</span>        <span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">INTO</span> pl <span class="token keyword">FROM</span> products<span class="token punctuation">;</span>        <span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">INTO</span> ph <span class="token keyword">FROM</span> products<span class="token punctuation">;</span>        <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">INTO</span> pa <span class="token keyword">FROM</span> products<span class="token punctuation">;</span>    <span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>关键字 OUT 指出相应的参数用来从存储过程传出一个值(返回给调用者)。</p><p>MySQL 支持 <strong>in(传递给存储过程)、out(从存储过程传出，这里所用)和 inout(对存储过程传入和传出)</strong>类型的参数。存储过程的代码位于 begin 和 end 语句内。他们是一系列 select 语句，用来检索值。然后<strong>保存到相对应的变量(通过 INTO 关键字)。</strong>存储过程的参数允许的数据类型与表中使用的类型相同。注意记录集是不被允许的类型，因此，不能通过一个参数返回多个行和列，这也是上面为什么要使用 3 个参数和 3 条 select语句的原因。</p><p>使用：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">call</span> <span class="token keyword">PROCEDURE</span><span class="token punctuation">(</span><span class="token variable">@pricelow</span><span class="token punctuation">,</span><span class="token variable">@pricehigh</span><span class="token punctuation">,</span><span class="token variable">@priceaverage</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@pricelow</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@pricehigh</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@pricelow</span><span class="token punctuation">,</span><span class="token variable">@pricehigh</span><span class="token punctuation">,</span><span class="token variable">@priceaverage</span><span class="token punctuation">;</span></code></pre><p>为调用此存储过程，必须指定 3 个变量名。如上所示。3 个参数是存储过程保存结果的 3 个变量的名字。调用时，语句并不显示任何数据，它返回以后可以显示的变量(或在其他处理中使用)。</p><p>注意：所有的 MySQL 变量都是以@开头。</p><p>使用IN的示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span>    <span class="token operator">IN</span> innumber <span class="token keyword">int</span><span class="token punctuation">,</span>    <span class="token keyword">OUT</span> outtotal <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">BEGIN</span>        <span class="token keyword">SELECT</span> <span class="token function">Sum</span><span class="token punctuation">(</span>item_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token keyword">FROM</span> orderitems <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span>        innumber <span class="token keyword">INTO</span> outtotal<span class="token punctuation">;</span>    <span class="token keyword">END</span><span class="token punctuation">;</span> <span class="token keyword">CALL</span> ordertotal<span class="token punctuation">(</span><span class="token number">20005</span><span class="token punctuation">,</span><span class="token variable">@total</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@total</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 得到 20005 订单的合计</span><span class="token keyword">CALL</span> ordertotal<span class="token punctuation">(</span><span class="token number">20009</span><span class="token punctuation">,</span><span class="token variable">@total</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token variable">@total</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//得到 20009 订单的合计</span></code></pre><h3 id="带有控制语句的存储过程">1.3.3 带有控制语句的存储过程</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span>    <span class="token operator">IN</span> onumber <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token operator">IN</span> taxable <span class="token keyword">BOOLEAN</span><span class="token punctuation">,</span>    <span class="token keyword">OUT</span> ototal <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'Obtain order total, optionally adding tax'</span>    <span class="token keyword">BEGIN</span>        <span class="token comment" spellcheck="true">-- declear variable for total</span>        <span class="token keyword">DECLARE</span> total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">-- declear tax percentage</span>        <span class="token keyword">DECLARE</span> taxrate <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">-- get the order total</span>        <span class="token keyword">SELECT</span> <span class="token function">Sum</span><span class="token punctuation">(</span>item_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token keyword">FROM</span> orderitems <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span>        onumber <span class="token keyword">INTO</span> total<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">-- IS this taxable?</span>        <span class="token keyword">IF</span> taxable <span class="token keyword">THEN</span>            <span class="token comment" spellcheck="true">-- yes ,so add taxrate to the total</span>            <span class="token keyword">SELECT</span> total<span class="token operator">+</span><span class="token punctuation">(</span>total<span class="token operator">/</span><span class="token number">100</span><span class="token operator">*</span>taxrate<span class="token punctuation">)</span><span class="token keyword">INTO</span> total<span class="token punctuation">;</span>        <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">-- finally ,save to out variable</span>        <span class="token keyword">SELECT</span> total <span class="token keyword">INTO</span> ototal<span class="token punctuation">;</span>    <span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>在存储过程中我们使用了 <code>DECLARE</code> 语句，他们表示定义两个局部变量，DECLARE 要求指定变量名和数据类型。它也支持可选的默认值(taxrate 默认 6%)，因为后期我们还要判断要不要增加税，所以，我们把 SELECT 查询的结果存储到局部变量 total 中，然后在 IF 和 THEN 的配合下，检查 taxable 是否为真，然后在真的情况下，我们利用另一条 SELECT 语句增加营业税到局部变量 total 中，然后我们再利用 SELECT 语句将 total(增加税或者不增加税的结果)保存到总的 ototal 中。</p><p>上面的 COMMENT 关键字可以给出或者不给出，如果给出，将在 <code>SHOW PROCEDURE STATUS</code> 的结果中显示。</p><p>所有语法：</p><p>变量相关：</p><ul><li><code>DECLARE var_name[,...] type [DEFAULT value]</code>：声明变量</li><li><code>SET var_name = expr [, var_name = expr] ...</code>：变量赋值</li><li><code>select ... into var_name</code>：将查询的结果赋值给变量</li></ul><p>分支循环：</p><p><strong>if_then elseif_then else_then</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">if</span> search_condition <span class="token keyword">then</span> statement_list    <span class="token punctuation">[</span>elseif search_condition <span class="token keyword">then</span> statement_list<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span><span class="token keyword">else</span> statement_list<span class="token punctuation">]</span><span class="token keyword">end</span> <span class="token keyword">if</span><span class="token punctuation">;</span></code></pre><p><strong>case</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CASE</span> case_value  <span class="token keyword">WHEN</span> when_value <span class="token keyword">THEN</span> statement_list  <span class="token punctuation">[</span><span class="token keyword">WHEN</span> when_value <span class="token keyword">THEN</span> statement_list<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">[</span><span class="token keyword">ELSE</span> statement_list<span class="token punctuation">]</span><span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span></code></pre><p><strong>while</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">while</span> search_condition <span class="token keyword">do</span>    statement_list<span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span></code></pre><p><strong>repeat</strong></p><p>while 是满足条件才执行，repeat 是满足条件就退出循环。</p><pre class=" language-sql"><code class="language-sql">REPEAT  statement_list  UNTIL search_condition<span class="token keyword">END</span> REPEAT<span class="token punctuation">;</span></code></pre><p><strong>loop</strong></p><p>通常配合leave语句退出循环，也可以死循环</p><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span>begin_label:<span class="token punctuation">]</span> LOOP  statement_list<span class="token keyword">END</span> LOOP <span class="token punctuation">[</span>end_label<span class="token punctuation">]</span></code></pre><p><strong>leave</strong></p><p>退出循环</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> pro_test11<span class="token punctuation">(</span>n <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>  <span class="token keyword">declare</span> total <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>  ins: LOOP    <span class="token keyword">IF</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token keyword">then</span>      leave ins<span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> total <span class="token operator">=</span> total <span class="token operator">+</span> n<span class="token punctuation">;</span>    <span class="token keyword">set</span> n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">END</span> LOOP ins<span class="token punctuation">;</span>  <span class="token keyword">select</span> total<span class="token punctuation">;</span><span class="token keyword">END</span>$</code></pre><h3 id="使用游标的存储过程">1.3.4 使用游标的存储过程</h3><p>游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>声明光标：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DECLARE</span> cursor_name <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> select_statement <span class="token punctuation">;</span></code></pre><p>代表这个变量是一个cursor类型，对应的是select_statement语句的结果集。</p><p>OPEN 光标：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">OPEN</span> cursor_name <span class="token punctuation">;</span></code></pre><p>FETCH 光标：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">FETCH</span> cursor_name <span class="token keyword">INTO</span> var_name <span class="token punctuation">[</span><span class="token punctuation">,</span> var_name<span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>CLOSE 光标：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CLOSE</span> cursor_name <span class="token punctuation">;</span></code></pre><p>实例：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查询emp表中数据, 并逐行获取进行展示</span><span class="token keyword">DELIMITER</span> $<span class="token keyword">create</span> <span class="token keyword">procedure</span> pro_test12<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>  <span class="token keyword">DECLARE</span> id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">DECLARE</span> name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">DECLARE</span> age <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">DECLARE</span> salary <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">DECLARE</span> has_data <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">DECLARE</span> emp_result <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>  <span class="token keyword">DECLARE</span> <span class="token keyword">EXIT</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">set</span> has_data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">open</span> emp_result<span class="token punctuation">;</span>  repeat    <span class="token keyword">fetch</span> emp_result <span class="token keyword">into</span> id <span class="token punctuation">,</span> name <span class="token punctuation">,</span> age <span class="token punctuation">,</span> salary<span class="token punctuation">;</span>    <span class="token keyword">select</span> concat<span class="token punctuation">(</span><span class="token string">'id为'</span><span class="token punctuation">,</span>id<span class="token punctuation">,</span> <span class="token string">', name 为'</span> <span class="token punctuation">,</span>name <span class="token punctuation">,</span> <span class="token string">', age为 '</span> <span class="token punctuation">,</span>age <span class="token punctuation">,</span> <span class="token string">', 薪水为: '</span><span class="token punctuation">,</span> salary<span class="token punctuation">)</span><span class="token punctuation">;</span>    until has_data <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">end</span> repeat<span class="token punctuation">;</span>  <span class="token keyword">close</span> emp_result<span class="token punctuation">;</span><span class="token keyword">end</span>$<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> </code></pre><p>通过<code>DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0;</code>相当于在光标获取不到下一行的时候给has_data赋值为0。</p><h2 id="修改存储过程">1.4 修改存储过程</h2><p>MySQL 中修改存储过程的语法格式如下：</p><p><code>ALTER PROCEDURE 存储过程名 [ 特征 ... ]</code></p><p>特征指定了存储过程的特性，可能的取值有：</p><ul><li><code>CONTAINS SQL</code> 表示子程序包含 SQL 语句，但不包含读或写数据的语句。</li><li><code>NO SQL</code> 表示子程序中不包含 SQL 语句。</li><li><code>READS SQL DATA</code> 表示子程序中包含读数据的语句。</li><li><code>MODIFIES SQL DATA</code> 表示子程序中包含写数据的语句。</li><li><code>SQL SECURITY { DEFINER |INVOKER }</code> 指明谁有权限来执行。<ul><li><code>DEFINER</code> 表示只有定义者自己才能够执行。</li><li><code>INVOKER</code> 表示调用者可以执行。</li></ul></li><li><code>COMMENT &#39;string&#39;</code> 表示注释信息。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">PROCEDURE</span> showstuscore <span class="token keyword">MODIFIES SQL DATA</span> SQL SECURITY <span class="token keyword">INVOKER</span><span class="token punctuation">;</span></code></pre><p>提示：<code>ALTER PROCEDURE</code> 语句用于修改存储过程的某些特征。如果要修改存储过程的内容，可以先删除原存储过程，再以相同的命名创建新的存储过程；如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。</p><h2 id="删除存储过程">1.5 删除存储过程</h2><p>MySQL 中使用 <code>DROP PROCEDURE</code> 语句来删除数据库中已经存在的存储过程。语法格式如下：</p><p><code>DROP { PROCEDURE | FUNCTION } [ IF EXISTS ] &lt;过程名&gt;</code></p><p>IF EXISTS：指定这个关键字用于防止因删除不存在的存储过程而引发的错误。</p><h1 id="触发器">2 触发器</h1><h2 id="概述-1">2.1 概述</h2><p>MySQL 数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用。</p><p>触发程序的优点如下：</p><ul><li>触发程序的执行是自动的，当对触发程序相关表的数据做出相应的修改后立即执行。</li><li>触发程序可以通过数据库中相关的表层叠修改另外的表。</li><li>触发程序可以实施比 <code>FOREIGN KEY</code> 约束、<code>CHECK</code> 约束更为复杂的检查和操作。</li></ul><p>在 MySQL 中，只有执行 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作时才能激活触发器。</p><h2 id="创建触发器">2.2 创建触发器</h2><p>在创建触发器时，需要给出 4 条语句（规则）：</p><ol><li>唯一的触发器名；</li><li>触发器关联的表；</li><li>触发器应该响应的活动；</li><li>触发器何时执行(处理之前或者之后)</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> newproduct <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> products <span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span><span class="token string">'Product added'</span> <span class="token keyword">INTO</span> <span class="token variable">@info</span><span class="token punctuation">;</span></code></pre><p>CREATE TRIGGER 用来创建名为 newproduct 的新触发器。触发器可以在一个操作发生前或<br>者发生后执行，这里 AFTER INSERT 是指此触发器在 INSERT 语句成功执行后执行。这个触<br>发器还指定 FOR EACH ROW ， 因此代码对每个插入行都会执行。文本 Product added 将<br>对每个插入的行显示一次</p><h2 id="INSERT-触发器">2.3 INSERT 触发器</h2><p>是在 insert 语句执行之前或者执行之后被执行的触发器。</p><ol><li>在 insert 触发器代码中，可引入一个名为 new 的虚拟表，访问被插入的行（普通插入语句之后也存在这个表）</li><li><strong>在 before insert 触发器中，new 中的值也可以被更新(允许更改被插入的值)</strong></li><li>对于 auto_increment 列，new 在 insert 执行之前包含 0，在 insert 执行之后包含新的自动生成值</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> neworder <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> orders <span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span>NEW<span class="token punctuation">.</span>order_num<span class="token punctuation">;</span></code></pre><p>该语句创建一个名为 neworder 的触发器，按照 <code>AFTER INSERT ON orders</code> 执行。在插入一个新订单到 orders 表时，MySQL 生成一个新的订单号并保存到 order_num 中。触发器从NEW.order_num 取得这个值并返回它。此触发器必须按照 AFTER INSERT 执行，<strong>因为在BEFORE INSERT 语句执行之前，新 order_num 还没有生成。</strong> 对于 orders 的每次插入使用这个触发器总是返回新的订单号。</p><h2 id="DELETE-触发器">2.4 DELETE 触发器</h2><p>Delete 触发器在 delete 语句执行之前或者之后执行。</p><ol><li>在 delete 触发器的代码内,可以引用一个名为 OLD 的虚拟表，用来访问被删除的行。</li><li>OLD 中的值全为只读，不能更新。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> deleteorder BEFORE <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> orders <span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> archive_orders<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span>order_date<span class="token punctuation">,</span>cust_id<span class="token punctuation">)</span> <span class="token keyword">values</span>    <span class="token punctuation">(</span>OLD<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span>OLD<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span>OLD<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>在任意订单被删除前将执行此触发器，它使用一条 INSERT 语句将 OLD 中的值(要被删除的订单) 保存到一个名为 archive_orders 的存档表中(为实际使用这个例子，我们需要用与orders 相同的列创建一个名为 archive_orders 的表)</p><p><strong>使用 BEFORE DELETE 触发器的优点(相对于 AFTER DELETE 触发器来说)为，如果由于某种原因，订单不能存档，delete 本身将被放弃。</strong></p><p>我们在这个触发器使用了 BEGIN 和 END 语句标记触发器体。这在此例子中并不是必须的，只是为了说明使用BEGIN END 块的好处是触发器能够容纳多条SQL 语句(在BEGIN END块中一条挨着一条)。</p><h2 id="UPDATE-触发器">2.5 UPDATE 触发器</h2><p>在 update 语句执行之前或者之后执行</p><ol><li>在 update 触发器的代码内,可以引用一个名为 OLD 的虚拟表，用来访问以前(UPDATE 语句之前)的值，引用一个名为 NEW 的虚拟表访问新更新的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被用于更新(允许更改将要用于 UPDATE语句中的值)</li><li>OLD 中的值全为只读，不能更新。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> updatevendor BEFORE <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> vendors <span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SET</span>NEW<span class="token punctuation">.</span>vend_state <span class="token operator">=</span> Upper<span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>vemd_state<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>保证州名缩写总是大写(不管 UPFATE 语句中是否给出了大写)，每次更新一行时，NEW.vend_state 中的值(将用来更新表行的值)都用 Upper(NEW.vend_state)替换。</p><h2 id="总结">2.6 总结</h2><ol><li>与其他 DBMS 相比，MySQL 5 中支持的触发器相当初级，未来的 MySQL 版本中估计会存在一些改进和增强触发器的支持。</li><li>通常 before 用于数据的验证和净化(为了保证插入表中的数据确实是需要的数据) 也适用于 update 触发器。</li><li>创建触发器可能需要特殊的安全访问权限，但是触发器的执行时自动的，如果 insert，update，或者 delete 语句能够执行，则相关的触发器也能执行。</li><li>用触发器来保证数据的一致性(大小写，格式等)。在触发器中执行这种类型的处理的优点就是它总是进行这种处理，而且透明的进行，与客户机应用无关。</li><li>触发器的一种非常有意义的使用就是创建审计跟踪。使用触发器，把更改(如果需要，甚至还有之前和之后的状态)记录到另外一个表是非常容易的。</li><li>MySQL 触发器不支持 call 语句，无法从触发器内调用存储过程。</li></ol><p>总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。</p><p>若对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。</p><p>若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。</p><p>若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。</p><p>仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行AFTER触发程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储过程&quot;&gt;1 存储过程&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;1.1 概述&lt;/h2&gt;&lt;p&gt;存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL回顾-约束、常用函数和视图</title>
    <link href="https://www.codetool.top/article/MySQL%E5%9B%9E%E9%A1%BE-%E7%BA%A6%E6%9D%9F%E3%80%81%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
    <id>https://www.codetool.top/article/MySQL回顾-约束、常用函数和视图/</id>
    <published>2020-03-02T10:35:41.000Z</published>
    <updated>2020-03-02T15:04:04.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="约束">1 约束</h1><ul><li>主键约束：不允许重复记录，避免数据冗余</li><li>外键约束：保证本事务所关联的其他事务是存在的（主键表中的这个字段）<ul><li>实际开发中通常不使用外键约束，影响效率。</li></ul></li><li>check约束：限制值在某一个范围之内</li><li>default约束： 确定默认值( 可以更改) 保证事务的某个属性一定会有一个值</li><li>unique约束：唯一键，不可重复，但允许为空<ul><li>unique 和 not null 可以组合使用，顺序任意。</li><li>主键和唯一键的关系：不要用业务逻辑字段当做主键，应添加一个没有任何实际意义的字段（代理主键）当做主键。</li></ul></li><li>not null约束 要求用户必须为该字段赋一个值，否则出错</li></ul><h1 id="MySQL常用函数">2 MySQL常用函数</h1><h2 id="文本处理函数">2.1 文本处理函数</h2><ul><li><code>LEFT(x,len)</code> 返回串左边指定长度的字串（长度为 len）</li><li><code>RIGHT(x,len)</code> 返回串右边指定长度的字串（长度为 len）</li><li><code>LENGTH(x)/CHAR_LENGTH(str)</code> – 返回串的长度</li><li><code>LOCATE(x,sub_x)</code> – 找出串的一个子串</li><li><code>SUBSTRING(x, from, to)</code> 返回子字符串</li><li><code>LOWER(x)</code> 全部转小写</li><li><code>UPPER(x)</code> 全部转大写</li><li><code>LTRIM(x)</code> 左边所有的空格被删除</li><li><code>RTRIM(x)</code> 右边所有的空格被删除</li><li><code>TRIM(x)</code> 删除两边的空格</li><li><code>CONCAT(s1,s2…sn)</code> 字符串 s1,s2 等多个字符串合并为一个字符串</li></ul><h2 id="日期时间处理函数">2.2 日期时间处理函数</h2><ul><li><code>CURDATE()</code>/<code>CURRENT_DATE()</code> 返回当前日期，格式<code>2019-02-19</code></li><li><code>CURTIME()</code>/<code>CURRENT_TIME()</code> 返回当前时间，格式<code>11:40:45</code></li><li><code>CURRENT_TIMESTAMP()</code> 返回当前日期和时间，格式<code>2019-02-19 11:41:32</code></li><li><code>ADDDATE(d,n)</code> 计算起始日期 d 加上 n 天的日期</li><li><code>ADDTIME(t,n)</code> 时间 t 加上 n 秒的时间</li><li><code>DATE(str)</code> 从日期或日期时间表达式中提取日期值</li><li><code>DAY(d)</code> 返回日期值 d 的日期部分，也可以使用<code>EXTRACT(type FROM d)</code> type可以取MONTH,DAY,HOUR,MINUTE等</li><li><code>DATEDIFF(d1,d2)</code> 计算日期d1-&gt;d2之间相隔的天数</li><li><code>DATE_FORMAT(d,f)</code> DATE_FORMAT按表达式 f的要求显示日期 d</li><li><code>DAYOFMONTH(d)</code> 计算日期 d 是本月的第几天</li><li><code>DAYOFWEEK(d)</code> 日期 d 今天是星期几，1 星期日，2 星期一，以此类推</li><li><code>DAYOFYEAR(d)</code> 计算日期 d 是本年的第几天</li><li><code>UNIX_TIMESTAMP()</code> 得到时间戳</li><li><code>FROM_UNIXTIME()</code> 时间戳转日期</li></ul><h2 id="数值处理函数">2.3 数值处理函数</h2><ul><li><code>ABS(x)</code> 返回绝对值</li><li><code>AVG(expression)</code> 返回一个表达式的平均值，expression是一个字段</li><li><code>EXP(x)</code> 返回e的x次方</li><li><code>CEIL(x)</code>/<code>FLOOR(x)</code> 向上取整、向下取整</li><li><code>MOD()</code>（取余）</li><li><code>PI()</code> 圆周率</li><li><code>RAND()</code> 返回0到1的随机数</li><li><code>SQRT(x)</code> 返回x的平方根</li><li><code>ROUND(x)</code> 返回离 x 最近的整数</li></ul><h1 id="视图">3 视图</h1><p>视图是虚拟的表，与包含数据的表不同，视图只包含使用时动态检索数据的查询,主要是用于查询。</p><h2 id="为什么使用视图">3.1 为什么使用视图</h2><ul><li>重用 sql 语句</li><li>简化复杂的 sql 操作，在编写查询后，可以方便地重用它而不必知道他的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><p>注意：</p><ul><li>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行 select 操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。</li><li>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据时从其他表中检索出来的。在添加和更改这些表中的数据时，视图将返回改变过的数据。</li><li>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一检索。如果你使用多个连接和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</li></ul><h2 id="视图的规则和限制">3.2 视图的规则和限制</h2><ul><li>与表一样，视图必须唯一命名；</li><li>可以创建任意多的视图；</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li><li>视图可以嵌套，可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>Order by 可以在视图中使用，但如果从该视图检索数据 select 中也是含有 order by，那么该视图的 order by 将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值</li><li>视图可以和表一起使用 </li></ul><h2 id="视图操作的SQL语句">3.3 视图操作的SQL语句</h2><ul><li>利用 <code>create view view_name as 查询语句</code> 语句来进行创建视图</li><li>使用 <code>show create view view_name</code> 来查看创建视图的语句</li><li>用 <code>drop view view_name</code> 来删除视图</li><li>更新视图可以先 drop 再 create，也可以使用 <code>create or replace view_name as ...</code>。</li></ul><h2 id="视图的更新">3.4 视图的更新</h2><p>视图是否可以更新，要视情况而定。</p><p>通常情况下视图是可以更新的，可以对他们进行 insert，update 和 delete。更新视图就是更新其基表(视图本身没有数据)。如果你对视图进行增加或者删除行，实际上就是对基表进行增加或者删除行。</p><p>但是，如果 MySQL 不能正确的确定更新的基表数据，则不允许更新(包括插入和删除)，这<br>就意味着视图中如果存在以下操作则不能对视图进行更新：</p><ol><li>分组(使用 group by 和having )</li><li>联结</li><li>子查询</li><li>并</li><li>聚集函数</li><li>dictinct</li><li>导出(计算)列</li></ol><p>不推荐更改视图，会使得业务逻辑混淆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;约束&quot;&gt;1 约束&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;主键约束：不允许重复记录，避免数据冗余&lt;/li&gt;
&lt;li&gt;外键约束：保证本事务所关联的其他事务是存在的（主键表中的这个字段）&lt;ul&gt;
&lt;li&gt;实际开发中通常不使用外键约束，影响效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="数据库" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.codetool.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>leetcode35-搜索插入位置</title>
    <link href="https://www.codetool.top/article/leetcode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://www.codetool.top/article/leetcode35-搜索插入位置/</id>
    <published>2020-03-01T17:09:30.000Z</published>
    <updated>2020-03-01T17:11:17.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,3,5,6], 5<br><strong>输出:</strong> 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [1,3,5,6], 2<br><strong>输出:</strong> 1</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> [1,3,5,6], 7<br><strong>输出:</strong> 4</p></blockquote><p><strong>示例 4:</strong></p><blockquote><p><strong>输入:</strong> [1,3,5,6], 0<br><strong>输出:</strong> 0</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>二分查找</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://www.codetool.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Redis通用指令和Jedis使用</title>
    <link href="https://www.codetool.top/article/Redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4%E5%92%8CJedis%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.codetool.top/article/Redis通用指令和Jedis使用/</id>
    <published>2020-03-01T15:48:46.000Z</published>
    <updated>2020-03-02T14:59:11.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="key通用指令">1 key通用指令</h1><p>常用操作</p><ul><li><code>del key</code> 删除指定key</li><li><code>exists key</code> 获取key是否存在</li><li><code>type key</code> 获取key的类型</li></ul><p>key 时效性控制</p><ul><li><p><code>expire key seconds</code> 设置过期时间</p></li><li><p><code>pexpire key milliseconds</code> （毫秒版）</p></li><li><p><code>expireat key timestamp</code>（使用时间戳版）</p></li><li><p><code>pexpireat key milliseconds-timestamp</code> </p></li><li><p><code>ttl key</code> 获取过期时间（不存在返回-2，永久返回-1）</p></li><li><p><code>pttl key</code> （毫秒版）</p></li><li><p><code>persist key</code> 将key从时效性转换为永久性</p></li></ul><p>key 查询操作</p><ul><li><code>keys pattern</code>：查询符合条件的所有key，pattern的规则：<ul><li><code>*</code>匹配任意数量的任意符号</li><li><code>?</code>匹配一个任意符号</li><li><code>[]</code>匹配括号内的任意一个符号</li></ul></li></ul><p>key 其他操作</p><ul><li><p><code>renane key newkey</code> 重命名key</p></li><li><p><code>renamenx key newkey</code> 如果新名字不存在才会重命名</p></li><li><p><code>sort</code> 对集合中所有value排序，只能排list或set</p></li></ul><h1 id="数据库通用操作">2 数据库通用操作</h1><p>redis为每个服务提供有16个数据库，编号从0到15，每个数据库之间的数据相互独立</p><ul><li><p><code>select index</code> 切换数据库</p></li><li><p><code>move key db</code> 将某个键移入其他数据库中</p></li><li><p><code>dbsize</code> 当前db键的个数</p></li><li><p><code>flushdb</code> 清空当前数据库</p></li><li><p><code>flushall</code> 清空所有数据库</p></li></ul><h1 id="Jedis">3 Jedis</h1><h2 id="基本使用">3.1 基本使用</h2><p>方法名和指令名一致。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.连接redis</span>Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.操作redis</span>jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"rhett"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3.关闭连接</span>jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意方法的返回值</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.连接redis</span>Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.操作redis</span><span class="token comment" spellcheck="true">//字符串</span>jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"rhett"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//list</span>jedis<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"list1"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>jedis<span class="token punctuation">.</span><span class="token function">rpush</span><span class="token punctuation">(</span><span class="token string">"list1"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list1 <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">lrange</span><span class="token punctuation">(</span><span class="token string">"list1"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list1<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//set</span>jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">,</span><span class="token string">"a1"</span><span class="token punctuation">,</span><span class="token string">"a1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">,</span><span class="token string">"a2"</span><span class="token punctuation">,</span><span class="token string">"a2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">,</span><span class="token string">"a3"</span><span class="token punctuation">,</span><span class="token string">"a3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hash</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> hash1 <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hash1<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//set</span>jedis<span class="token punctuation">.</span><span class="token function">sadd</span><span class="token punctuation">(</span><span class="token string">"set1"</span><span class="token punctuation">,</span><span class="token string">"50"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>jedis<span class="token punctuation">.</span><span class="token function">sadd</span><span class="token punctuation">(</span><span class="token string">"set1"</span><span class="token punctuation">,</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>jedis<span class="token punctuation">.</span><span class="token function">sadd</span><span class="token punctuation">(</span><span class="token string">"set1"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set1 <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">smembers</span><span class="token punctuation">(</span><span class="token string">"set1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set1<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3.关闭连接</span>jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>incr</code>操作返回的是Long</p><h2 id="连接池">3.2 连接池</h2><p><code>JedisPool</code>:Jedis提供的连接池技术</p><p>基于连接池的工厂类的编写：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JedisPool jp <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String host<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> port<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> maxTotal<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> maxIdle<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        ResourceBundle rb <span class="token operator">=</span> ResourceBundle<span class="token punctuation">.</span><span class="token function">getBundle</span><span class="token punctuation">(</span><span class="token string">"redis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        host <span class="token operator">=</span> rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.host"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        port <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        maxTotal <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.maxTotal"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        maxIdle <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.maxIdle"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JedisPoolConfig jpc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jpc<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span>maxTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>        jpc<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span>maxIdle<span class="token punctuation">)</span><span class="token punctuation">;</span>        jp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>jpc<span class="token punctuation">,</span>host<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Jedis <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> jp<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>redis.properties:</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">redis.host</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span><span class="token attr-name">redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span><span class="token attr-name">redis.maxTotal</span><span class="token punctuation">=</span><span class="token attr-value">30</span><span class="token attr-name">redis.maxIdle</span><span class="token punctuation">=</span><span class="token attr-value">10</span></code></pre><h1 id="Redis可视化管理工具">4 Redis可视化管理工具</h1><p>Redis Desktop Manager</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;key通用指令&quot;&gt;1 key通用指令&lt;/h1&gt;&lt;p&gt;常用操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del key&lt;/code&gt; 删除指定key&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exists key&lt;/code&gt; 获取key是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯试题-翻硬币</title>
    <link href="https://www.codetool.top/article/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98-%E7%BF%BB%E7%A1%AC%E5%B8%81/"/>
    <id>https://www.codetool.top/article/蓝桥杯试题-翻硬币/</id>
    <published>2020-03-01T14:36:17.000Z</published>
    <updated>2020-03-01T14:39:44.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p><strong>资源限制</strong></p><p>时间限制：1.0s   内存限制：256.0MB</p><p><strong>问题描述</strong></p><p>小明正在玩一个“翻硬币”的游戏。</p><p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。</p><p>比如，可能情形是：<code>**oo***oooo</code></p><p>如果同时翻转左边的两个硬币，则变为：<code>oooo***oooo</code></p><p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p><p>我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：</p><p><strong>输入格式</strong></p><p>两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;1000</p><p><strong>输出格式</strong></p><p>一个整数，表示最小操作步数。</p><p><strong>样例输入1</strong></p><p><code>**********</code><br><code>o****o****</code></p><p><strong>样例输出1</strong></p><p>5</p><p><strong>样例输入2</strong></p><p><code>*o**o***o***</code><br><code>*o***o**o***</code></p><p><strong>样例输出2</strong></p><p>1</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>如果翻动的次数最少，一定是从左翻到右，这道题符合贪心法</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> source <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> target <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>source<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">)</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'o'</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'o'</span><span class="token punctuation">)</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'*'</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">)</span>source<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'o'</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'o'</span><span class="token punctuation">)</span>source<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'*'</span><span class="token punctuation">;</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;资源限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间限制：1.0s   内存限制：256.0MB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小明正在玩一个“翻硬币”的游戏。&lt;/p&gt;
&lt;p&gt;桌上
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心法" scheme="https://www.codetool.top/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
      <category term="蓝桥杯" scheme="https://www.codetool.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯试题-哈夫曼树</title>
    <link href="https://www.codetool.top/article/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>https://www.codetool.top/article/蓝桥杯试题-哈夫曼树/</id>
    <published>2020-03-01T14:28:31.000Z</published>
    <updated>2020-03-01T14:32:29.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p><strong>Description</strong></p><p>Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。</p><p>给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下：</p><ol><li><p>找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa+ pb。</p></li><li><p>重复步骤1，直到{pi}中只剩下一个数。</p></li></ol><p>在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。</p><p>本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。</p><p>例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：</p><ol><li><p>找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。</p></li><li><p>找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。</p></li><li><p>找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。</p></li><li><p>找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。</p></li><li><p>现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。</p></li></ol><p><strong>Input</strong></p><p>输入的第一行包含一个正整数n（n&lt;=100）。</p><p>接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。</p><p><strong>Output</strong></p><p>输出用这些数构造Huffman树的总费用。</p><p><strong>Sample Input 1</strong></p><blockquote><p>5<br>5 3 8 2 9</p></blockquote><p><strong>Sample Output 1</strong></p><blockquote><p>59</p></blockquote><p><strong>Hint</strong></p><blockquote><p>HINT:时间限制：1.0s 内存限制：512.0MB</p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>用一个最小堆，每次弹出两个两个最小数然后把和再放入堆中。</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> cost <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">+=</span> cost<span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。&lt;/p&gt;
&lt;p&gt;给出一列数{pi}={p0, p1, …, pn-1}，用
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="https://www.codetool.top/tags/%E5%A0%86/"/>
    
      <category term="蓝桥杯" scheme="https://www.codetool.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode99-恢复二叉搜索树</title>
    <link href="https://www.codetool.top/article/leetcode99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/leetcode99-恢复二叉搜索树/</id>
    <published>2020-03-01T08:33:53.000Z</published>
    <updated>2020-03-01T09:16:59.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,3,null,null,2]   </p><p>&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;/<br>&nbsp;3<br>&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2  </p><p><strong>输出:</strong> [3,1,null,null,2]</p><p>&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;/<br>&nbsp;1<br>&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;2  </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [3,1,4,null,null,2]  </p><p>&nbsp;&nbsp;3<br>&nbsp;/&nbsp;\<br>1&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;/<br>&nbsp;&nbsp;2  </p><p><strong>输出:</strong> [2,1,4,null,null,3]  </p><p>&nbsp;&nbsp;2<br>&nbsp;/&nbsp;\<br>1&nbsp;&nbsp;&nbsp;4<br>&nbsp;&nbsp;&nbsp;/<br>&nbsp;&nbsp;3  </p></blockquote><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>这道题可以使用中序遍历得到一个序列，这个序列的特征是一个有序序列中的两个元素被交换了，那么问题就变成如何找到这两个元素。</p><p>看一个例子： <code>1 2 8 6 7 4 9</code> ，有序序列中的两个元素被交换了一定会造成一个较大的元素交换到了前面(8)，一个较小的元素交换到了后面(4)，体现在序列中就是两个异常的情况：6比8小，4比7小。所以可以判断：第一次出现的某节点比前驱节点的值要小的情况，前驱节点就是一个被交换了的节点，而第二次出现的某节点比前驱节点的值要小的情况，该节点就是第二个被交换了的节点。</p><p>而还有一种可能是，两个连续的元素被交换了，如：<code>1 3 2 4</code>，出现的情况就是只出现一次某节点比前驱节点的值要小的情况，那么两个被交换的节点就分别是当前节点(2)和其前驱节点(3)。</p><p>找到了这两个节点，就可以使用值交换将二叉搜索树恢复回来。</p><h2 id="代码">2.2 代码</h2><p>递归中序遍历：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    TreeNode pred<span class="token punctuation">;</span>    TreeNode former<span class="token punctuation">,</span>latter<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">recurTree</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cache <span class="token operator">=</span> former<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        former<span class="token punctuation">.</span>val <span class="token operator">=</span> latter<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        latter<span class="token punctuation">.</span>val <span class="token operator">=</span> cache<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recurTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">recurTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span> pred <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> pred<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>former <span class="token operator">==</span> null<span class="token punctuation">)</span> former <span class="token operator">=</span> pred<span class="token punctuation">;</span>            latter <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pred <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token function">recurTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;二叉搜索树中的两个节点被错误地交换。&lt;/p&gt;
&lt;p&gt;请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="搜索树" scheme="https://www.codetool.top/tags/%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer46-把数字翻译成字符串</title>
    <link href="https://www.codetool.top/article/%E5%89%91%E6%8C%87offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.codetool.top/article/剑指offer46-把数字翻译成字符串/</id>
    <published>2020-02-29T15:55:26.000Z</published>
    <updated>2020-02-29T16:05:26.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入：</strong> 12258<br><strong>输出：</strong> 5<br><strong>解释：</strong> 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”  </p></blockquote><p><strong>提示:</strong></p><ul><li>0 &lt;= num &lt; 2<sup>31</sup></li></ul><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>动态规划：</p><p>可以使用<a href="../leetcode70-爬楼梯/">leetcode70-爬楼梯</a>的思想，每次翻译一位数看成跳一步，翻译两位数看成跳两步，那么对于任意要跳的一个位置来说，例如<code>12258</code>中的8，由于最后两位是58不能翻译，也就是只能由<code>1225</code>跳过来，此时<code>f(12258)==f(1225)</code>，而对于<code>1225</code>，由于最后两位是25可以翻译，所以可以从<code>12</code>跳过来，也可以从<code>122</code>跳过来，此时<code>f(1225) == f(12)+f(122)</code>。将这两种情况一般化就能得出结论：</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//去除最后一位数的last</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> num<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//计算出最后两位数的大小</span>        left <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">*</span><span class="token punctuation">(</span>num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span>left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//去除最后两位数的lastOfLast</span>        <span class="token keyword">int</span> lastOfLast <span class="token operator">=</span> num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span><span class="token number">25</span><span class="token operator">||</span>left<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">translateNum</span><span class="token punctuation">(</span>lastOfLast<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。&lt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.codetool.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="剑指offer" scheme="https://www.codetool.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Redis概述和使用</title>
    <link href="https://www.codetool.top/article/Redis%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.codetool.top/article/Redis概述和使用/</id>
    <published>2020-02-29T14:50:38.000Z</published>
    <updated>2020-03-02T14:59:20.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoSQL">1 NoSQL</h1><p>not only SQL</p><p>优势：</p><ul><li>High Performance</li><li>Huge Storage</li><li>High Scalability &amp; High Availibility</li></ul><table align="left" border="1" cellspacing="0"><tbody><tr><td><p><span>类型</span></p></td><td><p><span>部分代表</span></p></td><td><p><span>特点</span></p></td></tr><tr><td><p><span>列存储</span></p></td><td><p><strong><span>Hbase</span></strong></p><p><span>Cassandra</span></p><p><span>Hypertable</span></p></td><td><p><span>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</span></p></td></tr><tr><td><p><span>文档存储</span></p></td><td><p><strong><span>MongoDB</span></strong></p><p><span>CouchDB</span></p></td><td><p><span>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。</span></p></td></tr><tr><td><p><span>key-value</span><span>存储</span></p></td><td><p><span>Tokyo&nbsp;Cabinet/Tyrant</span></p><p><span>Berkeley&nbsp;DB</span></p><p><span>MemcacheDB</span></p><p><strong><span>Redis</span></strong></p></td><td><p><span>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</span></p></td></tr><tr><td><p><span>图存储</span></p></td><td><p><strong><span>Neo4J</span></strong></p><p><span>FlockDB</span></p></td><td><p><span>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</span></p></td></tr><tr><td><p><span>对象存储</span></p></td><td><p><span>db4o</span></p><p><span>Versant</span></p></td><td><p><span>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</span></p></td></tr><tr><td><p><span>xml</span><span>数据库</span></p></td><td><p><span>Berkeley DB XML</span></p><p><span>BaseX</span></p></td><td><p><span>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</span></p></td></tr></tbody></table><h1 id="Redis概述">2 Redis概述</h1><p>Redis是一种键值对数据库。</p><h2 id="特征">2.1 特征</h2><ol><li>数据间没有必然的关联关系</li><li>内部采用单线程机制进行工作</li><li>高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</li><li>多数据类型支持<ul><li>字符串类型 string</li><li>列表类型 list</li><li>散列类型 hash</li><li>集合类型 set</li><li>有序集合类型 sorted_set</li></ul></li><li>持久化支持。可以进行数据灾难恢复</li></ol><h2 id="应用">2.2 应用</h2><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的 session 分离</li><li>消息队列</li><li>分布式锁</li></ul><h2 id="安装">2.3 安装</h2><p>安装之后修改安装目录下的redis.conf，将<code>daemonize no</code>改为<code>daemonize yes</code></p><p>基本配置：</p><pre class=" language-conf"><code class="language-conf">port 6379 #启动端口daemonize yes #守护进程logfile "6379.log" #日志文件名dir /usr/local/redis/data #日志文件、持久化文件目录</code></pre><p>启动redis的方式：</p><pre class=" language-shell"><code class="language-shell">src/redis-server redis.conf</code></pre><p>更改端口启动：</p><pre class=" language-shell"><code class="language-shell">redis-server --port 6380</code></pre><p>或者更改配置文件的port：（可在一台主机上启动多个服务）</p><p>连接时使用：</p><pre><code>redis-cli -p 6380</code></pre><p>配置服务：</p><pre class=" language-shell"><code class="language-shell">mkdir /etc/rediscp redis.conf /etc/redis/6379.confcp utils/redis_init_script /etc/init.d/redis</code></pre><p>启动服务：</p><pre class=" language-shell"><code class="language-shell">service redis start</code></pre><p>默认端口：6379</p><h1 id="Redis基本操作">3 Redis基本操作</h1><p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 命令参考 — Redis 命令参考</a></p><p>清除屏幕信息：<code>clear</code></p><p>查看命令帮助：<code>help 命令</code></p><h2 id="String类型">3.1 String类型</h2><p>String的最大存储量是512MB</p><p>String的用途之一是存json数据</p><p>键名通常有规范，例如<code>user:id:xxxxxxx:fans</code>（表名:主键名:主键值:字段名）</p><pre><code>set key value [EX seconds] [DX miliseconds]</code></pre><p>新增、更新键值对。它相当于 <code>setex key seconds value</code> 和 <code>psetex key milliseconds value</code>。</p><pre><code>get key</code></pre><p>获取值</p><pre><code>del key</code></pre><p>删除键值对</p><pre><code>ttl key</code></pre><p>查看ttl（剩余生存）时间</p><pre><code>expire key seconds</code></pre><p>设置过期时间</p><pre><code>keys *</code></pre><p>查看所有的key</p><pre><code>mset key1 value1 key2 value2...</code></pre><p>同时设置多个键值对，对应还有mget，可以同时取多个值</p><pre><code>getset key</code></pre><p>更新值的同时返回旧值。</p><pre><code>incr key</code></pre><p>自增value（只对纯数字的字符串有效）</p><pre><code>decr value</code></pre><p>自减value</p><pre><code>incrby key num</code></pre><p>以num值自增（decrby同理），类似的还有incrbyfloat（增加小数）</p><p><strong>注意：</strong> </p><ul><li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>能获取的最大整数范围是java中long的最大值。 </li></ul><pre><code>append key toAppend </code></pre><p>将一段字符串附加到旧值上。</p><pre><code>strlen key</code></pre><p>计算值的长度</p><pre><code>setnx key value</code></pre><p>(set not exist)如果key不存在则设置并返回1，如果key存在不更新返回0</p><h2 id="Hash类型">3.2 Hash类型</h2><ul><li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li><li>需要的存储结构：一个存储空间保存多个键值对数据</li></ul><p>hash类型实际上值存的还是一个类似于哈希表的结构，里面的键值对叫field-value</p><p>hash存储结构优化</p><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul><p>注意事项</p><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型</li><li>每个hash可以存储2<sup>32</sup>-1个键值对</li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ul><pre><code>hset hashname field value</code></pre><p>设置对应hash的键值对</p><pre><code>hget hashname field</code></pre><p>获取对应的哈希中对应的键对应的值</p><pre><code>hmset hashname field1 value1 field2 value2... </code></pre><p>多重设置</p><pre><code>hmget hashname field1 field2...</code></pre><p>多重获取</p><pre><code>hdel hashname</code></pre><p>删除键</p><pre><code>hsetnx hashname field value</code></pre><p>类似setnx，只有不存在才添加。</p><pre><code>hlen hashname</code></pre><p><strong>获取哈希中field的个数</strong></p><pre><code>hexists hashname field</code></pre><p>判断field是否存在，存在返回1</p><pre><code>hkeys hashname</code></pre><p>获取某哈希所有的field名</p><pre><code>hvals hashname</code></pre><p>获取某哈希所有的value</p><pre><code>hgetall hashname</code></pre><p>获取所有的field名和value</p><pre><code>hincrby hashname field increment</code></pre><p>注意这个只有hincrby没有hincr</p><h2 id="List类型">3.3 List类型</h2><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型：保存多个数据，底层使用双向链表存储结构实现</li></ul><p>list的元素可以重复</p><pre><code>lpush listname val1 val2...rpush listname val1 val2...</code></pre><p>lpush从左边插入，rpush从右边插入。如果list不存在，会先创建list，然后插入。</p><pre><code>lrange listname start stop</code></pre><p>从左边数的范围，start和stop索引允许负值，-1代表最后一个元素，-2代表倒数第二个元素……</p><pre><code>lpop listname rpop listname</code></pre><p>从左边（右边）弹出元素</p><pre><code>blpop listname timeoutbrpop listname timeout</code></pre><p>阻塞版本的lpop/rpop，如果此时列表中没有元素则阻塞，可以设置最长等待时间</p><pre><code>llen listname</code></pre><p>返回列表的长度</p><pre><code>lset listname index value</code></pre><p>修改列表中索引index对应的值</p><pre><code>lindex listname index </code></pre><p>获取索引index对应的value</p><pre><code>lrem listname count value</code></pre><p>移除值等于指定值的元素count个</p><pre><code>linsert listname before/after pivot value</code></pre><p>这个pivot代表的是list中一个元素的值</p><h2 id="Set类型">3.4 Set类型</h2><ul><li>新的存储需求：存储大量的数据，在查询方面提供更高的效率</li><li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</li></ul><pre><code>sadd setname member</code></pre><p>向集合中添加元素</p><pre><code>smembers setname</code></pre><p>返回集合的全部成员</p><pre><code>srem setname member</code></pre><p>移除元素</p><pre><code>scard setname</code></pre><p>返回集合中元素的个数</p><pre><code>sismember setname member</code></pre><p>判断是否在集合里。</p><pre><code>srandmember setname [count]</code></pre><p>随机获取集合中指定数量的数据</p><pre><code>spop setname</code></pre><p>返回并移除随机一个元素</p><pre><code>sinter setname1 setname2sunion setname1 setname2sdiff setname1 setname2</code></pre><p>求两个集合的交、并、差集。</p><p>还有sinterstore等指令可以把结果存储到指定集合中。</p><pre><code>smove source destination member</code></pre><p>将元素从source集合中移动到destination中。</p><h2 id="Sorted-set类型">3.5 Sorted_set类型</h2><ul><li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</li><li>需要的存储结构：新的存储模型，可以保存可排序的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li></ul><pre><code>zadd setname score1 member1 [score2 member2]</code></pre><p>添加元素，注意要带上一个用于排序的数据（相当于权）。</p><pre><code>zrange setname start end [withscores]zrevrange setname start stop [WITHSCORES]</code></pre><p>zrange从小到大显示指定元素范围，如果带有withscores则会连着score一起返回。<br>zrevrange相反，从大到小。</p><pre><code>zcard setnamezcount setname min max</code></pre><p>zcard显示集合中有多少个元素<br>zcount显示在min-max之间的元素有多少个</p><pre><code>zrem setname member</code></pre><p>移除member</p><pre><code>zrangebyscore setname min max [WITHSCORES] [LIMIT];zrevrangebyscore setname [WITHSCORES];</code></pre><p>按条件获取处于min-max之间的数据</p><pre><code>zremrangebyrank setname start stopzremrangebyscore setname min max</code></pre><p>zremrangebyrank按排名删除元素  </p><p>zremrangebyscore删除值在min-max之间的元素</p><pre><code>zrank setname memberzrevrank setname member</code></pre><p>查看元素的正序或倒序排名</p><pre><code>zscore setname memberzincrby setname increment member</code></pre><p>score值获取与修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NoSQL&quot;&gt;1 NoSQL&lt;/h1&gt;&lt;p&gt;not only SQL&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;High Performance&lt;/li&gt;
&lt;li&gt;Huge Storage&lt;/li&gt;
&lt;li&gt;High Scalability &amp;amp; Hi
      
    
    </summary>
    
    
      <category term="中间件/工具/框架" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B7%A5%E5%85%B7-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Redis" scheme="https://www.codetool.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode12-整数转罗马数字</title>
    <link href="https://www.codetool.top/article/leetcode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://www.codetool.top/article/leetcode12-整数转罗马数字/</id>
    <published>2020-02-29T08:25:42.000Z</published>
    <updated>2020-02-29T08:31:44.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><pre><code>字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> “III”  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> 4<br><strong>输出:</strong> “IV”   </p></blockquote><p><strong>示例3:</strong></p><blockquote><p><strong>输入:</strong> 9<br><strong>输出:</strong> “IX”  </p></blockquote><p><strong>示例4:</strong></p><blockquote><p><strong>输入:</strong> 58<br><strong>输出:</strong> “LVIII”<br><strong>解释:</strong> L = 50, V = 5, III = 3.</p></blockquote><p><strong>示例5:</strong></p><blockquote><p><strong>输入:</strong> 1994<br><strong>输出:</strong> “MCMXCIV”<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.  </p></blockquote><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>每一位的数字+所在位决定了在罗马数字中用什么表示。</p><h2 id="代码">2.2 代码</h2><p>简单粗暴</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">intToRoman</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> thous <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"MM"</span><span class="token punctuation">,</span><span class="token string">"MMM"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> hundr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"CC"</span><span class="token punctuation">,</span><span class="token string">"CCC"</span><span class="token punctuation">,</span><span class="token string">"CD"</span><span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">,</span><span class="token string">"DC"</span><span class="token punctuation">,</span><span class="token string">"DCC"</span><span class="token punctuation">,</span><span class="token string">"DCCC"</span><span class="token punctuation">,</span><span class="token string">"CM"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ten <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"X"</span><span class="token punctuation">,</span><span class="token string">"XX"</span><span class="token punctuation">,</span><span class="token string">"XXX"</span><span class="token punctuation">,</span><span class="token string">"XL"</span><span class="token punctuation">,</span><span class="token string">"L"</span><span class="token punctuation">,</span><span class="token string">"LX"</span><span class="token punctuation">,</span><span class="token string">"LXX"</span><span class="token punctuation">,</span><span class="token string">"LXXX"</span><span class="token punctuation">,</span><span class="token string">"XC"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> one <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"I"</span><span class="token punctuation">,</span><span class="token string">"II"</span><span class="token punctuation">,</span><span class="token string">"III"</span><span class="token punctuation">,</span><span class="token string">"IV"</span><span class="token punctuation">,</span><span class="token string">"V"</span><span class="token punctuation">,</span><span class="token string">"VI"</span><span class="token punctuation">,</span><span class="token string">"VII"</span><span class="token punctuation">,</span><span class="token string">"VIII"</span><span class="token punctuation">,</span><span class="token string">"IX"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>thous<span class="token punctuation">[</span>num<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>hundr<span class="token punctuation">[</span>num<span class="token operator">/</span><span class="token number">100</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ten<span class="token punctuation">[</span>num<span class="token operator">/</span><span class="token number">10</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>one<span class="token punctuation">[</span>num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯试题-小数第n位</title>
    <link href="https://www.codetool.top/article/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98-%E5%B0%8F%E6%95%B0%E7%AC%ACn%E4%BD%8D/"/>
    <id>https://www.codetool.top/article/蓝桥杯试题-小数第n位/</id>
    <published>2020-02-28T16:24:46.000Z</published>
    <updated>2020-02-28T16:29:05.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题">1 原题</h1><p>资源限制</p><p>时间限制：1.0s  内存限制：256.0MB</p><hr><p>问题描述</p><p>　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。<br>　　如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。</p><p>　　本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。</p><hr><p>输入格式</p><p>　　一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&lt;a,b,n&lt;1000000000）</p><hr><p>输出格式</p><p>　　一行3位数字，表示：a除以b，小数后第n位开始的3位数字。</p><hr><p>样例输入</p><p>1 8 1</p><hr><p>样例输出</p><p>125</p><hr><p>样例输入</p><p>1 8 3</p><hr><p>样例输出</p><p>500</p><hr><p>样例输入</p><p>282866 999000 6</p><hr><p>样例输出</p><p>914</p><h1 id="解法">2 解法</h1><h2 id="思想">2.1 思想</h2><p>一开始想把被除数给乘以10的多少次幂之后再除以除数，然后发现会溢出，这道题还是模拟除法规则求解</p><h2 id="代码">2.2 代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> divide <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> divideBy <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> begin <span class="token operator">=</span> divide<span class="token operator">%</span>divideBy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>start<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            begin <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>start<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>begin<span class="token operator">/</span>divideBy<span class="token punctuation">)</span><span class="token punctuation">;</span>            begin <span class="token operator">%=</span> divideBy<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;1 原题&lt;/h1&gt;&lt;p&gt;资源限制&lt;/p&gt;
&lt;p&gt;时间限制：1.0s  内存限制：256.0MB&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。&lt;br&gt;　　如果我们把有限小数的末尾加上无限
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="蓝桥杯" scheme="https://www.codetool.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
</feed>
