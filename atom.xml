<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码段小站</title>
  <icon>https://www.gravatar.com/avatar/4c71a513a84e4d430b9f9aed224237fc</icon>
  <subtitle>CodeBand CodeTool - 个人计算机类练手小博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.codetool.top/"/>
  <updated>2019-12-05T08:01:35.970Z</updated>
  <id>https://www.codetool.top/</id>
  
  <author>
    <name>Rhett Peng</name>
    <email>pctdyx@qq.net</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WinForm截图OCR小项目的开发-瞥见知识的融会贯通</title>
    <link href="https://www.codetool.top/article/winform%E6%88%AA%E5%9B%BEOCR%E5%B0%8F%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E5%8F%91-%E7%9E%A5%E8%A7%81%E7%9F%A5%E8%AF%86%E7%9A%84%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A/"/>
    <id>https://www.codetool.top/article/winform截图OCR小项目的开发-瞥见知识的融会贯通/</id>
    <published>2019-12-04T14:04:55.000Z</published>
    <updated>2019-12-05T08:01:35.970Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为有个需要截图OCR的需求，再加上需要交一个C#大作业，就做了一个WinForm截图OCR小项目出来。<br>（不过后来发现QQ截图好像已经有这功能了🌚）</p><p>运行截图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15754686525352.png" alt="主窗口" title="">                </div>                <div class="image-caption">主窗口</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15754689358448.png" alt="截图处理窗口" title="">                </div>                <div class="image-caption">截图处理窗口</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15754689633703.png" alt="截图处理窗口2" title="">                </div>                <div class="image-caption">截图处理窗口2</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15754690358637.png" alt="历史日志" title="">                </div>                <div class="image-caption">历史日志</div>            </figure><p>谈一谈挺有意思的一些知识点：</p><h1 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h1><h2 id="Delegate委托回调"><a href="#Delegate委托回调" class="headerlink" title="Delegate委托回调"></a>Delegate委托回调</h2><p>我封装了一个POST请求的函数：<br>需要下载一个<code>Newtonsoft.Json</code>用于处理响应的JSON数据<br>这种方式是使用了一个委托回调，类似于JavaScript中的回调函数，C#中叫<strong>Delegate回调</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">AfterRequest</span>(<span class="params">JObject data</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">HttpUtil</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发出POST请求</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="url"&gt;</span>请求的url<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="requestBody"&gt;</span>url参数格式的字符串，如"key1=value1&amp;key2=value2",需要经过urlencode处理<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="function"&gt;</span>回调函数,data是一个json转换为的一个JObject对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PostAsync</span>(<span class="params">String url, <span class="keyword">string</span> requestBody, AfterRequest function</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> responseBody = <span class="literal">null</span>;</span><br><span class="line">            HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">            <span class="comment">//StringContent content = new StringContent(requestBody,System.Text.Encoding.UTF8, "application/x-www-form-urlencoded");</span></span><br><span class="line">            StringContent content = <span class="keyword">new</span> StringContent(requestBody);</span><br><span class="line"></span><br><span class="line">            content.Headers.ContentType =</span><br><span class="line">                <span class="keyword">new</span> System.Net.Http.Headers.MediaTypeHeaderValue(<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">            HttpResponseMessage response = <span class="literal">null</span>;</span><br><span class="line">            response = httpClient.PostAsync(url, content).Result;</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line">            <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">            &#123;</span><br><span class="line">                responseBody = response.Content.ReadAsStringAsync().Result;</span><br><span class="line">            &#125;</span><br><span class="line">            JObject data = JObject.Parse(responseBody);</span><br><span class="line">            function(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"\nException Caught!"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Message :&#123;0&#125; "</span>, e.Message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>实际上还有一种能使代码更清晰、简洁的方法，并且这种方法更受C#推荐：Async/Await</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HttpUtil</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发出POST请求</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="url"&gt;</span>请求的url<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="requestBody"&gt;</span>url参数格式的字符串，如"key1=value1&amp;key2=value2",需要经过urlencode处理<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;JObject&gt; <span class="title">PostAsync</span>(<span class="params">String url, <span class="keyword">string</span> requestBody</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> responseBody = <span class="literal">null</span>;</span><br><span class="line">            HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">            <span class="comment">//StringContent content = new StringContent(requestBody,System.Text.Encoding.UTF8, "application/x-www-form-urlencoded");</span></span><br><span class="line">            StringContent content = <span class="keyword">new</span> StringContent(requestBody);</span><br><span class="line"></span><br><span class="line">            content.Headers.ContentType =</span><br><span class="line">                <span class="keyword">new</span> System.Net.Http.Headers.MediaTypeHeaderValue(<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">            HttpResponseMessage response = <span class="literal">null</span>;</span><br><span class="line">            response = <span class="keyword">await</span> httpClient.PostAsync(url, content);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line">            <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">            &#123;</span><br><span class="line">                responseBody = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JObject data = JObject.Parse(responseBody);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"\nException Caught!"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Message :&#123;0&#125; "</span>, e.Message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方法，能避免回调地狱，让调用时代码不会多层嵌套。<br>甚至ES7也支持了这种方法，语法和C#类似。</p><p><strong>原理：</strong></p><blockquote><p>函数执行时，一旦遇到await就会返回。等到触发的异步操作完成（并且调用栈清空），再接着执行函数体内后面的语句</p></blockquote><p>实际上async/await只是个语法糖，内部执行顺序和回调函数并无区别。</p><h1 id="API鉴权"><a href="#API鉴权" class="headerlink" title="API鉴权"></a>API鉴权</h1><p>因为做这个应用去调用了百度云和腾讯云提供的OCR api，恰巧发现两家的api鉴权机制正是目前主流验证方式之中具有代表性的两种。</p><h2 id="百度云：Token"><a href="#百度云：Token" class="headerlink" title="百度云：Token"></a>百度云：Token</h2><p>看看百度云的Token获取方法：</p><p>向授权服务地址<code>https://aip.baidubce.com/oauth/2.0/token</code>发送请求（推荐使用POST），并在URL中带上以下参数：</p><ul><li>grant_type： 必须参数，固定为client_credentials；</li><li>client_id： 必须参数，应用的API Key；</li><li>client_secret： 必须参数，应用的Secret Key；</li></ul><p>token验证方式就是给每个用户分配一套账号和密码（这里是client_id和client_secret），服务器能通过这套认证信息获取用户的权限，生成一个token字符串，保存在本地并返回给用户，用户请求api的时候就要带上这个token（可以是放在请求体或请求头中），服务器就能通过token验证用户的身份。</p><p><strong>安全隐患：</strong> Token被劫持，伪造请求和篡改参数。</p><h2 id="腾讯云：签名验证"><a href="#腾讯云：签名验证" class="headerlink" title="腾讯云：签名验证"></a>腾讯云：签名验证</h2><p>可以看看腾讯云提供的计算签名的步骤：</p><ol><li>将&lt;key, value&gt;请求参数对按key进行字典升序排序，得到有序的参数对列表N</li><li>将列表N中的参数对按URL键值对的格式拼接成字符串，得到字符串T（如：key1=value1&amp;key2=value2），URL键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8，而不是小写%e8</li><li>将应用密钥以app_key为键名，组成URL键值拼接到字符串T末尾，得到字符串S（如：key1=value1&amp;key2=value2&amp;app_key=密钥)</li><li>对字符串S进行MD5运算，将得到的MD5值所有字符转换成大写，得到接口请求签名</li></ol><p>可以看出腾讯云的验证机制更为复杂，在计算签名的时候需要用到当前时间戳、一个随机字符串和用户的app_key，这样得到的签名每次请求的时候都是不同的，即使中间者劫持了签名也无法利用签名进行第二次重复请求，如果请求参数被篡改也能识别出。</p><p>Token和签名验证并不冲突，签名验证是在身份认证的基础上防止请求重放、参数篡改等攻击。百度云这种加密机制也可以使用某种密钥将带有token的参数字符串生成签名进行验证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>许多知识都有融会贯通之处，即使做C#项目也能学习到JS相关的异步思想，能学到后端的验证机制。要善于思考，以行促学。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为有个需要截图OCR的需求，再加上需要交一个C#大作业，就做了一个WinForm截图OCR小项目出来。&lt;br&gt;（不过后来发现QQ截图好像已经有这功能了🌚）&lt;/p&gt;
&lt;p&gt;运行截图：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
        
      
    
    </summary>
    
    
    
      <category term=".net" scheme="https://www.codetool.top/tags/net/"/>
    
      <category term="API鉴权" scheme="https://www.codetool.top/tags/API%E9%89%B4%E6%9D%83/"/>
    
      <category term="异步" scheme="https://www.codetool.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>HashSet源码分析</title>
    <link href="https://www.codetool.top/article/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/HashSet源码分析/</id>
    <published>2019-12-02T07:19:32.000Z</published>
    <updated>2019-12-02T07:57:08.396Z</updated>
    
    <content type="html"><![CDATA[<p>Set家族一览：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15752712219660.png" alt="Set层次" title="">                </div>                <div class="image-caption">Set层次</div>            </figure><h1 id="HashSet简介"><a href="#HashSet简介" class="headerlink" title="HashSet简介"></a>HashSet简介</h1><p>Set是Collection三大接口其中之一，意为集合，且元素不能重复。Set接口中的方法和Collection中的方法完全一致，只是起到一个标记名的作用。</p><p>HashSet是哈希集的意思，就是通过hashcode来实现set不能出现重复元素的一个实现类。</p><p>内部其实是通过哈希表HashMap来实现的，实际上set中存放的元素是内部hashmap中的键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();<span class="comment">//所有的键对应的值都是一个冗余的Object对象</span></span><br></pre></td></tr></table></figure><p>在构造方法中初始化哈希表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>浪费时间警告：这是一个纯HashMap实现的类</strong></p><h1 id="重载的构造方法"><a href="#重载的构造方法" class="headerlink" title="重载的构造方法"></a>重载的构造方法</h1><h2 id="public-HashSet-Collection-lt-extends-E-gt-c"><a href="#public-HashSet-Collection-lt-extends-E-gt-c" class="headerlink" title="public HashSet(Collection&lt;? extends E&gt; c)"></a>public HashSet(Collection&lt;? extends E&gt; c)</h2><p>通过一个集合来构造HashSet，默认哈希表的容量是<code>集合的容量*4/3 + 1</code>和<code>16</code>中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-HashSet-int-initialCapacity-float-loadFactor"><a href="#public-HashSet-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashSet(int initialCapacity, float loadFactor)"></a>public HashSet(int initialCapacity, float loadFactor)</h2><p>这个实际上就是提供两个构造HashMap的参数，一个是初始大小，一个是负载因子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-HashSet-int-initialCapacity"><a href="#public-HashSet-int-initialCapacity" class="headerlink" title="public HashSet(int initialCapacity)"></a>public HashSet(int initialCapacity)</h2><p>这个就是提供HashMap的初始大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h2><p>HashMap的size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o)"></a>public boolean contains(Object o)</h2><p>HashMap中是否有对应的键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h2><p>将一个记录插入HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一个纯使用HashMap实现的数据结构。<br>仔细看了一下TreeSet也是用TreeMap实现的，那我就不搞TreeSet了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Set家族一览：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
   
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码研究" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"/>
    
      <category term="集合" scheme="https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码分析</title>
    <link href="https://www.codetool.top/article/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/LinkedList源码分析/</id>
    <published>2019-12-02T06:27:16.000Z</published>
    <updated>2019-12-03T11:46:18.073Z</updated>
    
    <content type="html"><![CDATA[<p><strong>相关文章：</strong><br><a href="https://www.codetool.top/article/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ArrayList源码分析</a></p><p>List家族一览：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15752679306935.png" alt="List层次" title="">                </div>                <div class="image-caption">List层次</div>            </figure><h1 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15752682516156.png" alt="LinkedList的超类" title="">                </div>                <div class="image-caption">LinkedList的超类</div>            </figure><p>LinkedList的超类有List、Queue，说明它既有List的性质也有Queue的性质，它直接实现于Deque，说明它体现更多的是双向链表的性质。不过通常将它当作普通的Queue使用：</p><p><code>Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</code></p><p>它的内部字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//代表头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//代表尾节点</span></span><br></pre></td></tr></table></figure><h1 id="重要的内部类"><a href="#重要的内部类" class="headerlink" title="重要的内部类"></a>重要的内部类</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>这是一个静态内部类，代表着LinkedList中存放数据的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重要的内部方法"><a href="#重要的内部方法" class="headerlink" title="重要的内部方法"></a>重要的内部方法</h1><h2 id="void-linkLast-E-e"><a href="#void-linkLast-E-e" class="headerlink" title="void linkLast(E e)"></a>void linkLast(E e)</h2><p><code>offer</code>依赖的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="private-E-unlinkFirst-Node-f"><a href="#private-E-unlinkFirst-Node-f" class="headerlink" title="private E unlinkFirst(Node f)"></a>private E unlinkFirst(Node<E> f)</h2><p><code>poll</code>和<code>remove</code>依赖的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Node-node-int-index"><a href="#Node-node-int-index" class="headerlink" title="Node node(int index)"></a>Node<E> node(int index)</h2><p>获取处于index上的节点，这个方法用于支持随机访问，特别是List中定义的get，set等方法。<br>可见，该方法会根据index所处位置的不同分为从头查找或是从尾查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以说，LinkedList的实现还是挺简单的，由于是链表实现不需要考虑那么多关于空间的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;相关文章：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.codetool.top/article/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&quot;&gt;ArrayList源码分析&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码研究" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"/>
    
      <category term="集合" scheme="https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>tomcat整体架构</title>
    <link href="https://www.codetool.top/article/tomcat%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://www.codetool.top/article/tomcat整体架构/</id>
    <published>2019-11-29T15:04:49.000Z</published>
    <updated>2019-11-29T15:09:41.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat整体架构"><a href="#tomcat整体架构" class="headerlink" title="tomcat整体架构"></a>tomcat整体架构</h1><p>Tomcat Http服务器不直接调用业务类，而是将请求转发给Servlet容器，Servlet加载业务类处理请求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/28/QFym4I.png" alt="img" title="Servlet容器工作流程">                </div>                <div class="image-caption">Servlet容器工作流程</div>            </figure><p>核心组件：</p><ul><li>连接器 Connector</li><li>容器 Container</li></ul><p>连接器处理Socket请求，容器进行servlet的调用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QkgeFH.png" alt="img" title="Tomcat整体架构">                </div>                <div class="image-caption">Tomcat整体架构</div>            </figure><h1 id="连接器-Coyote"><a href="#连接器-Coyote" class="headerlink" title="连接器 Coyote"></a>连接器 Coyote</h1><p>Coyote 是 Tomcat的连接器框架的名称，是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受相应。</p><p>Coyote封装了底层的网络通信（Socket请求及相应处理），为Catalina容器提供了统一的接口，使<strong>Catalina容器与具体的请求协议及IO操作方式完全解耦</strong>。Coyote将Socket输入转换封装为Request对象，交由Catalina容器进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流。</p><p>Coyote作为独立的模块，只负责<strong>具体协议和IO的相关操作</strong>，与Servlet规范实现没有直接关系，因此即使是Request和Response对象也并未实现Servlet规范对应的接口，而是<strong>在Catalina中将他们进一步封装为ServletRequest和ServletResponse</strong>。</p><h2 id="IO模型与协议"><a href="#IO模型与协议" class="headerlink" title="IO模型与协议"></a>IO模型与协议</h2><p>在Coyote中，Tomcat支持的多种I/O模型和应用层协议：</p><p>Tomcat支持的IO模型（8.0前默认是BIO，自8.5/9.0版本起，tomcat移除了对BIO的支持）：</p><table><thead><tr><th>IO模型</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>非阻塞I/O，采用Java NIO类库实现。</td></tr><tr><td>NIO2</td><td>异步I/O，采用JDK7最新的NIO2类库实现。</td></tr><tr><td>APR</td><td>采用Apache可移植运行库实现，是C/C++编写的本地库。如果选择该方案，需要单独安装APR库。</td></tr></tbody></table><p>Tomcat支持的应用层协议：</p><table><thead><tr><th>应用层协议</th><th>描述</th></tr></thead><tbody><tr><td>HTTP/1.1</td><td>这是大部分Web应用采用的访问协议。</td></tr><tr><td>AJP</td><td>用于和Web服务器集成（如Apache），以实现对静态资源的优化以及集群部署，当前支持AJP/1.3。</td></tr><tr><td>HTTP/2</td><td>HTTP2.0大幅度地提升了Web性能。下一代HTTP协议，自8.5以及9.0版本之后支持。</td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QkW5n0.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="连接器组件"><a href="#连接器组件" class="headerlink" title="连接器组件"></a>连接器组件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QkfEjI.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>EndPoint</li><li>Processor</li><li>Adapter</li><li>ProtocolHandler</li></ul><h3 id="EndPoint"><a href="#EndPoint" class="headerlink" title="EndPoint"></a>EndPoint</h3><ol><li>Coyote通信端点，即通信监听的接口，是具体Socket接收和发送处理器，是对传输层的抽象，因此EndPoint用来实现TCP/IP协议的。</li><li>Tomcat并没有EndPoint接口，而是提供了一个抽象类AbstractEndPoint，里面定义了两个内部类：Acceptor和SocketProcessor。Acceptor用于监听Socket连接请求。SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里调用协议处理组件Processor进行处理。为了提高处理能力，SocketProcessor被提交到线程池来执行。而这个线程池叫执行器（Executor）。</li></ol><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p>Coyote协议处理接口，如果说EndPoint是用来实现TCP/IP协议的，那么Processor用来实现HTTP协议，Processor接收来自EndPoint的Socket，读取字节流解析成Tomcat Recuest和Response对象,并通过Adapter将其提交到容器处理, Processor是对应用层协议的抽象。</p><h3 id="ProtocolHandler"><a href="#ProtocolHandler" class="headerlink" title="ProtocolHandler"></a>ProtocolHandler</h3><p>Coyote 协议接口，通过Endpoint和Processor，实现针对具体协议的处理能力。Tomcat按照协议和I/O提供了6个实现类：AjpNioProtocol，AjpAprProtocol,AjpNio2Protocol,Http11NioProtocol,Http11Nio2Protocol,Http11AprProtocol。我们在配置tomcat/conf/server.xml时，至少要指定具体的ProtocolHandler,当然也可以指定协议名称，如：HTTP/1.1，如果安装了APR，那么将使用Http11AprProtocol，否则使用 Http11NioProtocol。</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来“存放”这些请求信息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。Tomcat设计者的解决方案是引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法。</p><h1 id="容器-Catalina"><a href="#容器-Catalina" class="headerlink" title="容器 Catalina"></a>容器 Catalina</h1><h2 id="Tomcat的模块分层图"><a href="#Tomcat的模块分层图" class="headerlink" title="Tomcat的模块分层图"></a>Tomcat的模块分层图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QANBtK.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>和org.apache包下的包一一对应</p><h2 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QAUp3F.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如上图所示，Catalina负责管理Server，而Server表示着整个服务器。Server下面有多个服务Service，每个服务都包含着多个连接器组件Connector（Coyote 实现）和一个容器组件Container。在Tomcat启动的时候，会初始化一个Catalina的实例。</p><p>Catalina各个组件的职责：</p><table><thead><tr><th>组件</th><th>职责</th></tr></thead><tbody><tr><td>Catalina</td><td>负责解析Tomcat的配置文件，以此来创建服务器Server组件，并根据命令来对其进行管理。</td></tr><tr><td>Server</td><td>服务器表示整个Catalina Servlet容器以及其它组件，负责组装并启动Servlet引擎，Tomcat连接器。Server通过实现Lifecycle接口，提供了一种优雅的启动和关闭整个系统的方式。</td></tr><tr><td>Service</td><td>服务是Server内部的组件，一个Server包含多个Service。它将若干个Connector组件绑定到一个Container(Engine)上</td></tr><tr><td>Connector</td><td>连接器，处理与客户端的通信，它负责接收客户请求，然后转给相关的容器处理，最后向客户返回响应结果</td></tr><tr><td>Container</td><td>容器，负责处理用户的servlet请求，并返回对象给web用户的模块。</td></tr></tbody></table><h2 id="Container结构"><a href="#Container结构" class="headerlink" title="Container结构"></a>Container结构</h2><p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器不是平行关系，而是父子关系，Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QABy1f.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th>组件</th><th>职责</th></tr></thead><tbody><tr><td>Engine</td><td>表示整个Catalina的Servlet引擎,用来管理多个虚拟站点，一个Service最多只能有一个Engine ,但是一个引擎可包含多个Host。</td></tr><tr><td>Host</td><td>代表一个虚拟主机， 或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可包含多个Context。</td></tr><tr><td>Context</td><td>表示一个web应用程序，一个Web应用可包含多个Wrapper。</td></tr><tr><td>Wrapper</td><td>表示一个Servlet，Wrapper作为容器中的最底层。 不能包含子容器。</td></tr></tbody></table><p>我们也可以再通过Tomcat的server.xml配置文件来加深对Tomcat容器的理解。Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，Tomcat是怎么管理这些容器的呢？你会发现这些容器具有父子关系，形成一个树形结构，你可能马上就想到了设计模式中的组合模式。没错，Tomcat就是用组合模式来管理这些容器的。具体实现方法是，所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/29/QAfb7V.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>LifeCycle接口用于统一管理各组件的生命周期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tomcat整体架构&quot;&gt;&lt;a href=&quot;#tomcat整体架构&quot; class=&quot;headerlink&quot; title=&quot;tomcat整体架构&quot;&gt;&lt;/a&gt;tomcat整体架构&lt;/h1&gt;&lt;p&gt;Tomcat Http服务器不直接调用业务类，而是将请求转发给Servlet
      
    
    </summary>
    
    
      <category term="中间件/软件设计" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="javaEE" scheme="https://www.codetool.top/tags/javaEE/"/>
    
      <category term="tomcat" scheme="https://www.codetool.top/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>使用maven方式编译tomcat源码</title>
    <link href="https://www.codetool.top/article/%E4%BD%BF%E7%94%A8maven%E6%96%B9%E5%BC%8F%E7%BC%96%E8%AF%91tomcat%E6%BA%90%E7%A0%81/"/>
    <id>https://www.codetool.top/article/使用maven方式编译tomcat源码/</id>
    <published>2019-11-28T14:04:57.000Z</published>
    <updated>2019-11-28T14:09:23.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat源码下载"><a href="#Tomcat源码下载" class="headerlink" title="Tomcat源码下载"></a>Tomcat源码下载</h1><p>官网下载：</p><p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p><p>页面下方的Source Code Distribution，下载zip文件。</p><h1 id="Idea用maven方式编译源码"><a href="#Idea用maven方式编译源码" class="headerlink" title="Idea用maven方式编译源码"></a>Idea用maven方式编译源码</h1><p>在源码文件夹内创建一个<code>home/</code>目录，将<code>webapp/</code>和<code>conf/</code>移到这个文件夹下。</p><p>在根目录添加pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Tomcat8.5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tomcat8.5<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>Tomcat8.5<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定源文件为java 、test --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;testSourceDirectory&gt;test&lt;/testSourceDirectory&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>test<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 指定jdk 编译 版本 ，没装jdk 1.7的可以变更为1.6 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加tomcat8 所需jar包依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxrpc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.easymock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easymock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ecj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在idea中导入该maven项目，等待maven构建。</p><p>idea的项目运行配置（Edit Configurations）：</p><p>Edit Configurations-&gt; + -&gt; Application -&gt; Main Class选择<code>org.apache.catalina.startup.Bootstrap</code> -&gt; VM Options填入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home=D:/Tomcat/apache-tomcat-8.5.49-src/home</span><br><span class="line">-Dcatalina.base=D:/Tomcat/apache-tomcat-8.5.49-src/home</span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file=D:/Tomcat/apache-tomcat-8.5.49-src/home/conf/logging.properties</span><br></pre></td></tr></table></figure><p><strong><code>D:/Tomcat/apache-tomcat-8.5.49-src/</code>是我电脑上的源码的存放位置</strong></p><p>然后就可以尝试编译了。还会出现一些错误，可以参考：</p><p><a href="https://juejin.im/post/5b7cd3336fb9a019c112619d" target="_blank" rel="noopener">@Version@错误</a></p><p><a href="https://blog.csdn.net/yekong1225/article/details/81000446" target="_blank" rel="noopener">tomcat页面打不开500,jsp没有初始化错误</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat源码下载&quot;&gt;&lt;a href=&quot;#Tomcat源码下载&quot; class=&quot;headerlink&quot; title=&quot;Tomcat源码下载&quot;&gt;&lt;/a&gt;Tomcat源码下载&lt;/h1&gt;&lt;p&gt;官网下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tomcat.a
      
    
    </summary>
    
    
      <category term="中间件/软件设计" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="tomcat" scheme="https://www.codetool.top/tags/tomcat/"/>
    
      <category term="maven" scheme="https://www.codetool.top/tags/maven/"/>
    
      <category term="idea" scheme="https://www.codetool.top/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>servlet4.0初识总结</title>
    <link href="https://www.codetool.top/article/servlet4-0%E5%88%9D%E5%AD%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://www.codetool.top/article/servlet4-0初学总结/</id>
    <published>2019-11-28T11:57:54.000Z</published>
    <updated>2019-11-28T12:14:47.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaEE8"><a href="#JavaEE8" class="headerlink" title="JavaEE8"></a>JavaEE8</h1><p>JavaEE8,是自2013年6月Java企业版的首次更新。JAVAEE8提供了一些新的API，提供了对HTTP/2的新支持。</p><h1 id="Servlet4-0"><a href="#Servlet4-0" class="headerlink" title="Servlet4.0"></a>Servlet4.0</h1><p>Servlet API是JAVA开发人员最熟悉的API之一。</p><p>Servlet在JAVAweb的开发中发挥着重要的作用。JAVAEE8对Servlet进行了重要的更新：</p><ul><li>服务器推送</li><li>提供了对Servlet映射的运行时发现。</li><li>简化了Filter的开发。</li></ul><p>其中<strong>服务器推送</strong>是最主要的更新</p><p>配置需要：</p><ul><li>jdk8+</li><li>tomcat9（支持HTTP/2）</li><li>tomcat-native</li><li>openssl</li></ul><h2 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h2><p>编辑<code>server.xml</code>，将原来的<code>port=&quot;8080&quot; HTTP/1.1</code>替换成:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8443"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">UpgradeProtocol</span> <span class="attr">className</span>=<span class="string">"org.apache.coyote.http2.Http2Protocol"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SSLHostConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Certificate</span> <span class="attr">certificateKeyFile</span>=<span class="string">"conf/localhost-rsa-key.pem"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">certificateFile</span>=<span class="string">"conf/localhost-rsa-cert.pem"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">type</span>=<span class="string">"RSA"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SSLHostConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Connector</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成SSL证书"><a href="#生成SSL证书" class="headerlink" title="生成SSL证书"></a>生成SSL证书</h2><p>生成私钥和证书文件在tomcat-native目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OpenSSL&gt; genrsa -out localhost-rsa-key.pem 2048</span><br><span class="line">OpenSSL&gt; req -new -x509 -key localhost-rsa-key.pem -out localhost-rsa-cert.pem -days 3650</span><br></pre></td></tr></table></figure><p>将<code>localhost-rsa-key.pem</code>和<code>localhost-rsa-cert.pem</code>复制到tomcat的<code>conf/</code>文件夹下。</p><p>将tomcat-native中<code>bin/(x64/)</code>下的<code>tcnative-1.dll</code>和<code>tcnative-1-src.pdb</code>复制到JAVA_HOME的<code>/bin</code>目录下</p><p>然后重启tomcat就能用HTTP/2来连接了。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>将用户所需的WEB资源提前推送到用户的浏览器缓存中，当用户使用浏览器访问所需WEB资源时，用户不需要再次下载所需的WEB资源，因为用户所需的WEB资源已经存在于用户的浏览器缓存中。</p><p><strong>获取：</strong></p><p><code>request.newPushBuilder();</code></p><p><strong>方法：</strong></p><p><code>PushBuilder.path()</code>设置要推送资源的路径。<br><code>PushBuilder.push()</code>推送WEB资源到用户的浏览器缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    PushBuilder pb = request.newPushBuilder();</span><br><span class="line">    pb.path(<span class="string">"pic01.jpg"</span>);</span><br><span class="line">    pb.push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PushBuilder pb = request.newPushBuilder();</span><br><span class="line">pb.path(<span class="string">"pic01.jpg"</span>).push();</span><br><span class="line">pb.path(<span class="string">"pic02.jpg"</span>).push();</span><br></pre></td></tr></table></figure><h2 id="HttpServletMapping"><a href="#HttpServletMapping" class="headerlink" title="HttpServletMapping"></a>HttpServletMapping</h2><p>在运行时获取Servlet的映射信息（反射机制）</p><p><strong>获取：</strong></p><p><code>request.getHttpServletMapping();</code></p><p><strong>方法：</strong></p><p><code>getMappingMatch()</code> 请求路径的类型<br><code>getMatchValue()</code> 映射的资源名<br><code>getPattern()</code> 返回Servlet映射的路径<br><code>getServletName()</code> 返回Servlet的名称  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpServletMapping mapping = request.getHttpServletMapping();</span><br><span class="line">    MappingMatch match = mapping.getMappingMatch();</span><br><span class="line">    System.out.println(match);</span><br><span class="line">    String value = mapping.getMatchValue();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    String pattern = mapping.getPattern();</span><br><span class="line">    System.out.println(pattern);</span><br><span class="line">    String name = mapping.getServletName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpFilter"><a href="#HttpFilter" class="headerlink" title="HttpFilter"></a>HttpFilter</h2><p>Filter的实现类：  </p><ul><li><code>GenericFilter</code>  </li><li><code>HttpFilter</code>，是<code>GenericFilter</code>的子类。</li></ul><p>通过继承<code>HttpFilter</code>来实现Filter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"FilterDemo"</span>,urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"FilterDemo:放行前"</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">"FilterDemo:放行后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaEE8&quot;&gt;&lt;a href=&quot;#JavaEE8&quot; class=&quot;headerlink&quot; title=&quot;JavaEE8&quot;&gt;&lt;/a&gt;JavaEE8&lt;/h1&gt;&lt;p&gt;JavaEE8,是自2013年6月Java企业版的首次更新。JAVAEE8提供了一些新的API，提供
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="javaEE" scheme="https://www.codetool.top/tags/javaEE/"/>
    
      <category term="servlet" scheme="https://www.codetool.top/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>nginx+keepalived高可用的并发解决方案</title>
    <link href="https://www.codetool.top/article/nginx-keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://www.codetool.top/article/nginx-keepalived高可用的并发解决方案/</id>
    <published>2019-11-27T12:55:04.000Z</published>
    <updated>2019-11-27T13:36:17.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>nginx是一个高性能的HTTP和反向代理服务器，也是一个邮件服务器，支持负载均衡和高并发。</p><h1 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h1><blockquote><p>Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，类似的工具还有heartbeat、corosync、pacemaker。但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。</p></blockquote><h1 id="Nginx-keepalived架构"><a href="#Nginx-keepalived架构" class="headerlink" title="Nginx+keepalived架构"></a>Nginx+keepalived架构</h1><p>对于一台轮询的nginx服务器，如果宕机，则整个集群都不能收到请求。所以通常即使只是用作轮询的服务器，也要有后备服务器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/27/QCs1bR.jpg" alt="img" title="架构示意图">                </div>                <div class="image-caption">架构示意图</div>            </figure><p>在这种架构中，外界用户访问的是虚拟IP，keepalived主机（master）会占用这个ip地址，其他后备服务器待命。如果master服务器宕机，backup服务器能感知到并及时接管这个虚拟IP。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nginx&quot;&gt;&lt;a href=&quot;#nginx&quot; class=&quot;headerlink&quot; title=&quot;nginx&quot;&gt;&lt;/a&gt;nginx&lt;/h1&gt;&lt;p&gt;nginx是一个高性能的HTTP和反向代理服务器，也是一个邮件服务器，支持负载均衡和高并发。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="中间件/软件设计" scheme="https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="nginx" scheme="https://www.codetool.top/tags/nginx/"/>
    
      <category term="高并发" scheme="https://www.codetool.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>今日ipv4地址正式耗尽</title>
    <link href="https://www.codetool.top/article/%E4%BB%8A%E6%97%A5ipv4%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%BC%8F%E8%80%97%E5%B0%BD/"/>
    <id>https://www.codetool.top/article/今日ipv4地址正式耗尽/</id>
    <published>2019-11-26T13:47:23.000Z</published>
    <updated>2019-11-27T13:37:18.677Z</updated>
    
    <content type="html"><![CDATA[<p>插播一条科技快讯： </p><p>北京时间11月26日下午消息，据国外媒体报道，负责英国、欧洲、中东和部分中亚地区互联网资源分配的欧洲网络协调中心（RIPE NCC）今日宣布：</p><blockquote><p>全球所有43亿个IPv4地址已全部分配完毕，这意味着没有更多的IPv4地址可以分配给ISP（网络服务提供商）和其他大型网络基础设施提供商。</p></blockquote><p>一想想我手上两台服务器有两个独立的ipv4地址还有点小激动呢。</p><p><strong>珍惜IPv4地址,吉祥号码，全球唯一，错过今日，毁一生。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插播一条科技快讯： &lt;/p&gt;
&lt;p&gt;北京时间11月26日下午消息，据国外媒体报道，负责英国、欧洲、中东和部分中亚地区互联网资源分配的欧洲网络协调中心（RIPE NCC）今日宣布：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全球所有43亿个IPv4地址已全部分配完毕，这意味着没
      
    
    </summary>
    
    
      <category term="日常/随笔" scheme="https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日常" scheme="https://www.codetool.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>java基础查缺补漏01</title>
    <link href="https://www.codetool.top/article/java%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F01/"/>
    <id>https://www.codetool.top/article/java基础查缺补漏01/</id>
    <published>2019-11-26T10:45:24.000Z</published>
    <updated>2019-12-03T11:46:18.073Z</updated>
    
    <content type="html"><![CDATA[<p><strong>某些点会在不远的将来深挖。</strong></p><ol><li><p>&gt;&gt;是逻辑右移，&gt;&gt;&gt;是算术右移</p></li><li><p><code>JDK6</code> 可以使用Console.readPassword从控制台中读取密码，用户输入的过程中密码是不可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Console cs = System.console();</span><br><span class="line">    String username = cs.readLine(<span class="string">"User name: "</span>);</span><br><span class="line">    <span class="keyword">char</span>[] passwd = cs.readPassword(<span class="string">"Password: "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>printf格式化输出中的<code>%s</code>转换符能格式化任意的对象，对于实现了<code>Formattable</code>接口的对象将调用<code>formatTo</code>方法，否则将调用<code>ToString</code>方法。</p></li><li><p>Java的文件读取：通过File构造一个Scanner对象；写入文件：构造一个PrintWriter对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"myfile.txt"</span>,<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"myfile.txt"</span>,<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Math中的<code>BigInteger</code>和<code>BigDecimal</code>可以满足高精度的运算需要。</p></li><li><p>匿名数组的写法：<code>new int[]{17,19,23,29,31,37}</code></p></li><li><p>finalize方法：相当于析构方法，在垃圾回收器清除对象之前调用。但不推荐使用这个方法，因为很难确定这个方法在什么时候才能被调用。</p></li><li><p><code>import static</code>是静态导入，可以导入某个类中的静态方法和静态字段。</p></li><li><p>可变参数列表：<code>function(Object... values)</code>，在函数内部可以把values看成一个参数数组。</p></li><li><p>java8方法引用：</p><ul><li>对象的方法引用 <code>object::instanceMethod</code></li><li>类的静态方法引用 <code>Class::staticMethod</code></li><li>任意类的任意对象的方法引用：<code>Class::instanceMethod</code>，它只能被该类的实例对象调用。</li><li>类的构造器调用 <code>Class::new</code></li></ul></li><li><p>内部类<br><strong>为什么要使用内部类</strong></p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li><li>内部类可以对同一个包种的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li></ul><p><strong>内部类类型</strong></p><ul><li>普通内部类</li><li>局部内部类（在方法中定义的内部类，不能有访问修饰符，不能是static）<br>  局部内部类可以访问<strong>当前代码块</strong>的常量，和此外围类的所有成员。</li><li>静态内部类（声明为static，不依赖于外部类的对象存在，实际上成为了一个顶级类）</li><li>匿名内部类（立刻使用，代码短小，只用到一个实例）<br>  语法：<code>new SuperType(construction parameter){inner class methods and data}</code></li></ul><p><strong>内部类底层实现（普通内部类）：</strong></p><ol><li>编译器自动为内部类添加一个成员变量，该成员变量的类型和外部类的类型相同，这个成员变量就是指向外部类对象引用。</li><li>编译器自动为内部类的构造方法添加一个参数，参数的类型是外部类的类型，在构造方法内部使用这个参数为1中添加的成员变量赋值。</li><li>在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</li></ol></li><li><p>Java动态代理：<a href="https://www.jianshu.com/p/95970b089360" target="_blank" rel="noopener">https://www.jianshu.com/p/95970b089360</a></p></li><li><p>Throwable分层：<br><img src="https://api.codetool.top/img/15751278573048.png" alt=""><br>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。<br>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查异常，所有其他的异常称为受查异常。</p></li><li><p>断言：</p><ul><li>assert 条件;</li><li>assert 条件:表达式;<br>如果结果是false，抛出一个AssertionError异常，第二种形式使用表达式构造AssertionError，转换成消息字符串。</li></ul></li><li><p>可以在普通类里面定义泛型方法：<code>&lt;T&gt; T function(T... param)</code><br><code>&lt;T extends BoundingType&gt;</code>代表T是BoundingType的子类。<br><code>&lt;T super BoundingType&gt;</code>代表T是BoundingType的超类。<br>BoundingType可以是用”&amp;”分隔的多个类<br>java泛型-类型擦除：<a href="https://www.cnblogs.com/joeblackzqq/p/10813143.html" target="_blank" rel="noopener">https://www.cnblogs.com/joeblackzqq/p/10813143.html</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;某些点会在不远的将来深挖。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;gt;&amp;gt;是逻辑右移，&amp;gt;&amp;gt;&amp;gt;是算术右移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JDK6&lt;/code&gt; 可以使用Console.readPasswor
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>详解java中的unicode编码（码点）</title>
    <link href="https://www.codetool.top/article/unicode%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.codetool.top/article/unicode知识/</id>
    <published>2019-11-25T14:16:19.000Z</published>
    <updated>2019-11-26T13:16:08.748Z</updated>
    
    <content type="html"><![CDATA[<p><strong>致谢：</strong></p><p>本文参考网页：<br><a href="https://blog.csdn.net/vcj1009784814/article/details/93477957" target="_blank" rel="noopener">Unicode字符集以及UTF-8，UTF-16编码的总结 - vcj1009784814的博客 - CSDN博客</a></p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>unicode的码点从U+0000到U+10FFFF，即共有<code>2^20+2^16-1=1114111</code>个码点。<br>通常来说，常见字符可以用2个字节（16位）来表示。但还有很多其他表意字符、辅助字符需要表示。</p><p>Unicode将所有码点分成了17个代码级别，又称<strong>平面</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.ibm.com/developerworks/cn/java/unicode-programming-language/image001.jpg" alt="img" title="unicode的17个平面">                </div>                <div class="image-caption">unicode的17个平面</div>            </figure><p>其中第一个平面称为基本的多语言级别（basic multilingual plane, <code>BMP</code>），其他的统称为<strong>辅助平面</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.ibm.com/developerworks/cn/java/unicode-programming-language/image002.jpg" alt="img" title="unicode的平面划分">                </div>                <div class="image-caption">unicode的平面划分</div>            </figure><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><p>由于unicode会有1个字节-4个字节不等，如果定长存储每个字符都需要占用四个字节，十分浪费空间，utf-8是一种变长存储方式，具体编码方式如下：</p><ul><li>第一个字节提示了这个unicode编码由几个字节组成<ol><li>首字节以0开头，表示单字节编码</li><li>首字节以110开头，表示双字节编码，后续字节以10开头</li><li>首字节以1110开头，表示三字节编码，后续字节以10开头</li><li>首字节以11110开头，表示四字节编码，后续字节以10开头</li></ol></li><li>有效位对应的字节数<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.ibm.com/developerworks/cn/java/unicode-programming-language/image003.jpg" alt="img" title="有效位对应的字节数，最后两行应该是用不上的">                </div>                <div class="image-caption">有效位对应的字节数，最后两行应该是用不上的</div>            </figure></li></ul><h2 id="utf-16"><a href="#utf-16" class="headerlink" title="utf-16"></a>utf-16</h2><p>UTF-16源于UCS-2，UCS-2将字符码点直接映射为字符编码，中间无特别的编码算法。</p><p>UCS-2编码方式固定2字节编码，只覆盖了BMP的码点，对于SMP的码点，2字节的16位二进制数是不足以表示的。</p><p>而UTF-16扩展了原来的UCS-2编码，解决了辅助平面码点的字符无法表示的问题：</p><ul><li>BMP中的有效码点，用固定2字节16位来为其编码，数值等于对应的码点，同UCS-2</li><li>辅助平面中的有效码点，使用<strong>代理对</strong>进行编码。<strong>在BMP中，有一个范围的码点是未定义的</strong>，被称为<strong>代理区</strong>，其码点范围是<code>0xD800~0xDFFF</code>，共2<sup>11</sup>个码点，代理区又被分为<strong>高代理码点</strong>和<strong>低代理码点</strong>，其中高代理码点范围是<code>0xD800~0XDBFF</code>，低代理码点范围是<code>0xDC00~0XDFFF</code>，高代理码点和低代理码点结合在一起，就表示一个辅助平面中的字符。由于辅助平面中的字符共有2<sup>20</sup>个（<code>0x10000~0x10FFFF</code>），高代理码点和低代理码点皆有2<sup>10</sup>个取值，两者结合，恰好有2<sup>20</sup>种不同的组合。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/26/MzutAS.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>也就是说，UTF-16可以表示完unicode中的字符，BMP中的字符需要一个字节，其他的需要两个字节。</p><h1 id="java中的unicode"><a href="#java中的unicode" class="headerlink" title="java中的unicode"></a>java中的unicode</h1><p>这里使用到一个工具：<br><a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="noopener">Unicode编码转换，UTF编码转换（UTF-8、UTF-16、UTF-32）</a></p><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><p>java中的char是定长以16位（两个字节存储的），并且内部编码为utf-16。<br>也就是说，一个char只能表示BMP中的字符，若要表示一个辅助平面内的字符，需要两个char。</p><p>来看一个BMP中的字符：”我”</p><blockquote><p>Unicode编码：<code>U+6211</code><br>UTF8编码：<code>E68891</code><br>UTF16BE编码：<code>FEFF6211</code><br>UTF16LE编码：<code>FFFE1162</code></p></blockquote><p>UTF16BE、UTF16LE分别指的是机器中的大端表示和小端表示，前面的<code>FEFF</code>或<code>FFFE</code>编译器会帮我们过滤掉，我们这里只看大端表示。</p><p>对于UTF-8表示，先将<code>6211</code>转换为二进制编码<code>110 001000 010001</code>，是15个有效位。对照utf-8编码表，可知需要用三个字节(<code>1110xxxx 10xxxxxxxx 10xxxxxxxx</code>)来表示，将有效位填入，得utf-8编码：<code>11100110 10001000 10010001</code>，转换为16进制，就是<code>E68891</code>。</p><p>对于UTF-16表示，6211是可以用两个字节表示完的，所以UTF-16的编码就是<code>6621</code>。</p><p>验证：</p><iframe src="https://run.codetool.top/?id=1" frameBorder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>对于辅助平面内的字符，一个char可不够用了，需要由两个char来存储，或是用String来表示。</p><p>来看一个emoji字符：”👉”</p><blockquote><p>Unicode编码：<code>U+1F449</code><br>UTF8编码：<code>F09F9189</code><br>UTF16BE编码：<code>FEFFD83DDC49</code><br>UTF16LE编码：<code>FFFE3DD849DC</code>  </p></blockquote><p>对于UTF-8表示，先将<code>1F449</code>转换为二进制编码<code>11111 010001 001001</code>，是17个有效位。对照utf-8编码表，可知需要用四个字节(<code>11110xxx 10xxxxxxxx 10xxxxxxxx 10xxxxxx</code>)来表示，将有效位填入，得utf-8编码：<code>11110000 10011111 10010001 10001001</code>，转换为16进制，就是<code>F09F9189</code>。</p><p>对于UTF-16表示，需要用到代理对进行编码：首先用<code>1F449</code>-<code>10000</code>得到<code>F449</code>，将<code>F449</code>转换为20位二进制<code>0000111101 0001001001</code>，高10位转成十六进制得<code>3D</code>,加上<code>D800</code>得<code>D83D</code>，后10位转成十六进制得<code>49</code>，加上<code>DC00</code>得<code>DC49</code>,所以它的utf-16编码为<code>D83D DC49</code>。</p><p>验证：  </p><iframe src="https://run.codetool.top/?id=3" frameBorder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p><strong>问题：</strong><br>String.length()会将一个非bmp中的字符算为1还是算为2呢？<br>测试↓</p><iframe src="https://run.codetool.top/?id=17" frameBorder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe>可见，如果String中存在非bmp中的字符，String会将它算成两个字符长度。看String.length()的源码也可知道这点：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>value</code>是String内部的一个字符数组。</p><h2 id="java对码点计算的支持"><a href="#java对码点计算的支持" class="headerlink" title="java对码点计算的支持"></a>java对码点计算的支持</h2><p>其实String中也提供了计算码点的方法：<code>String.codePointCount(int beginIndex, int endIndex)</code></p><iframe src="https://run.codetool.top/?id=18" frameBorder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p>利用的是<code>Character</code>类能判断一个码点是否为代理码点：<br><code>Character.isHighSurrogate</code>：是否为高位代理码点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHighSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Help VM constant-fold; MAX_HIGH_SURROGATE + 1 == MIN_LOW_SURROGATE</span></span><br><span class="line">    <span class="keyword">return</span> ch &gt;= MIN_HIGH_SURROGATE &amp;&amp; ch &lt; (MAX_HIGH_SURROGATE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>MIN_HIGH_SURROGATE=\uD800</code>和<code>MAX_HIGH_SURROGATE=\uDBFF</code>，注明了高位代理码点的值边界。</p><p><code>Character.isLowSurrogate</code>：是否为低位代理码点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch &gt;= MIN_LOW_SURROGATE &amp;&amp; ch &lt; (MAX_LOW_SURROGATE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>MIN_HIGH_SURROGATE=\uDC00</code>和<code>MAX_HIGH_SURROGATE=\uDFFF</code>，注明了高位代理码点的值边界。</p><p>要判断字符串内有没有代理码点，只需确定连续的两个码点一个是高位代理码点一个是低位代理码点就行了。</p><p><code>String.codePointCount</code>依赖的方法<code>Character.codePointCountImpl</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointCountImpl</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endIndex = offset + count;</span><br><span class="line">    <span class="keyword">int</span> n = count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; endIndex; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isHighSurrogate(a[i++]) &amp;&amp; i &lt; endIndex &amp;&amp;</span><br><span class="line">            isLowSurrogate(a[i])) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要遍历一个字符串中的字符，可能需要考虑是否有非kmp中的字符的情况。那么就需要用码点为单位来处理：</p><p><strong>反例：</strong></p><iframe src="https://run.codetool.top/?id=19" frameBorder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe><p><strong>正确处理方式：</strong></p><p><code>String.codePoints()</code>得到一个int类型的流，代表这个码点的unicode编码，用<code>System.out.printf()</code>中的<code>%c</code>格式化输出它，就可以看到这个字符。</p><iframe src="https://run.codetool.top/?id=20" frameBorder="0" height="500" style="width:100%;border:1px solid #ccc;"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;致谢：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文参考网页：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/vcj1009784814/article/details/93477957&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="基础知识" scheme="https://www.codetool.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="字符编码" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>AVL树-自平衡的二叉搜索树</title>
    <link href="https://www.codetool.top/article/AVL%E6%A0%91-%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://www.codetool.top/article/AVL树-自平衡的二叉搜索树/</id>
    <published>2019-11-25T11:11:29.000Z</published>
    <updated>2019-11-26T04:23:02.774Z</updated>
    
    <content type="html"><![CDATA[<p>本文图片来源：<a href="https://www.cnblogs.com/coding-nerver-die/p/10975599.html" target="_blank" rel="noopener">手把手教，手写AVL树 - 不止是编程 - 博客园</a></p><h1 id="AVL树的概念"><a href="#AVL树的概念" class="headerlink" title="AVL树的概念"></a>AVL树的概念</h1><h2 id="自平衡"><a href="#自平衡" class="headerlink" title="自平衡"></a>自平衡</h2><p>当二叉搜索树处于平衡状态的时候，其操作时间复杂度为<em>O</em>(log<em>N</em>)，但当二叉搜索树是单支树的时候，其搜索效率则为<em>O</em>(<em>N</em>)。可见，二叉搜索树的平衡性是影响其操作效率的关键。<br>由此出发，学者们设计了第一个平衡二叉搜索树，即<strong>AVL树</strong>。AVL树作为第一个平衡的二叉搜索树，其影响非常深远，后来的很多平衡结构都借鉴了AVL树的设计思想。</p><h2 id="AVL树的定义"><a href="#AVL树的定义" class="headerlink" title="AVL树的定义"></a>AVL树的定义</h2><p>一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树：</p><ul><li>它的左子树和右子树都是AVL树。</li><li>左子树和右子树的高度之差的<strong>绝对值不超过1</strong>。</li></ul><p>要注意，AVL的平衡性是一种相对的平衡，并非一种绝对的平衡。它不要求左子树和右子树的高度绝对相等，而仅仅是左子树和右子树的高度之差的绝对值不超过1即可。因为绝对的平衡难以实现。</p><p>如果给AVL树中的每一个节点都附加一个数字，该数字指示该节点右子树的高度减去左子树的高度所得的高度差，那么这个数字即为该节点的<strong>平衡因子</strong>。根据AVL树的定义，任一节点的平衡因子只能取-1、0或1。</p><h2 id="AVL树的旋转"><a href="#AVL树的旋转" class="headerlink" title="AVL树的旋转"></a>AVL树的旋转</h2><p>在一个平衡的二叉搜索树中插入一个新节点，就会造成其失衡，需要从插入位置沿通向根的路径回溯，检查各节点的平衡因子，在某一节点发现高度不平衡，则停止回溯。然后<strong>从发生不平衡的节点起，往下取三层</strong>，可以归纳为四种情况：</p><ol><li>向某节点的左子树中插入一个左孩子。</li><li>向某节点的右子树中插入一个右孩子。</li><li>向某节点的左子树中插入一个右孩子。</li><li>向某节点的右子树中插入一个左孩子。</li></ol><p>对应的处理方式：</p><h3 id="单旋"><a href="#单旋" class="headerlink" title="单旋"></a>单旋</h3><ol><li>右旋操作  </li></ol><p>以中间节点为轴，进行顺时针旋转，该中间节点的原父节点将变成该节点的右子节点，该中间节点的右子树则变成其原父节点的左子树。<br><img src="https://s2.ax1x.com/2019/11/26/MzVk9I.png" alt="img" title="基本情况">  </p><p><img src="https://s2.ax1x.com/2019/11/26/MzVEgP.png" alt="img" title="中间节点含有右子树"></p><ol start="2"><li>左旋操作</li></ol><p>对应的，左旋的方法是以三个呈直线排列的节点的中间节点为轴，进行逆时针旋转。该中间节点的原父节点将变成该节点的左子节点，该中间节点的左子树则变成其原父节点的右子树</p><h3 id="双旋"><a href="#双旋" class="headerlink" title="双旋"></a>双旋</h3><ol start="3"><li>先左后右双旋转</li></ol><p>以3个成折线排列的节点中的末节点为轴，进行逆时针旋转。使末节点代替中间节点的位置，也就是让末节点成为原中间节点的父节点，这时，三个节点将成一直线排列，再以新的中间节点为旋转轴做右旋操作，即可完成平衡化操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/26/MzVmDS.png" alt="img" title="基本情况">                </div>                <div class="image-caption">基本情况</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/26/MzVQ4s.png" alt="img" title="复杂情况">                </div>                <div class="image-caption">复杂情况</div>            </figure><ol start="4"><li>先右后左双旋转</li></ol><p>以3个成折线排列的节点中的末节点为轴，进行顺时针旋转。使末节点代替中间节点的位置，也就是让末节点成为原中间节点的父节点，这时，三个节点将成一直线排列，再以新的中间节点为旋转轴做左旋操作，即可完成平衡化操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文图片来源：&lt;a href=&quot;https://www.cnblogs.com/coding-nerver-die/p/10975599.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手把手教，手写AVL树 - 不止是编程 - 博客园&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树形搜索" scheme="https://www.codetool.top/tags/%E6%A0%91%E5%BD%A2%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200-岛屿数量</title>
    <link href="https://www.codetool.top/article/leetcode200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://www.codetool.top/article/leetcode200-岛屿数量/</id>
    <published>2019-11-24T14:18:01.000Z</published>
    <updated>2019-11-24T14:27:18.511Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说这种题确实麻烦。大一做过一遍C++版本的了今天做一遍JAVA的还是搞了好久。C++还有数据结构pair可以用，java还得存储偏移地址然后手算x、y。</p><h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong><br>11110<br>11010<br>11000<br>00000  <br/><br><strong>输出:</strong> 1 </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong><br>11000<br>11000<br>00100<br>00011  <br/><br><strong>输出:</strong> 3 </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><blockquote><p>BFS：<br>线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动广度优先搜索。将其放入队列中，并将值设为 0 以标记访问过该结点。迭代地搜索队列中的每个结点，直到队列为空。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] marked;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> width = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;height;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    queue.offer(i*width+j);</span><br><span class="line">                    <span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">                        <span class="keyword">int</span> index_x = index/width;</span><br><span class="line">                        <span class="keyword">int</span> index_y = index%width;</span><br><span class="line">                        <span class="keyword">if</span>(index_x!=height-<span class="number">1</span> &amp;&amp; grid[index_x+<span class="number">1</span>][index_y]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer((index_x+<span class="number">1</span>)*width+index_y);</span><br><span class="line">                            grid[index_x+<span class="number">1</span>][index_y] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(index_x!=<span class="number">0</span> &amp;&amp; grid[index_x-<span class="number">1</span>][index_y]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer((index_x-<span class="number">1</span>)*width+index_y);</span><br><span class="line">                            grid[index_x-<span class="number">1</span>][index_y] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(index_y!=<span class="number">0</span> &amp;&amp; grid[index_x][index_y-<span class="number">1</span>]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer(index_x*width+index_y-<span class="number">1</span>);</span><br><span class="line">                            grid[index_x][index_y-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(index_y!=width-<span class="number">1</span> &amp;&amp; grid[index_x][index_y+<span class="number">1</span>]==<span class="string">'1'</span>)&#123; </span><br><span class="line">                            queue.offer(index_x*width+index_y+<span class="number">1</span>);</span><br><span class="line">                            grid[index_x][index_y+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不得不说这种题确实麻烦。大一做过一遍C++版本的了今天做一遍JAVA的还是搞了好久。C++还有数据结构pair可以用，java还得存储偏移地址然后手算x、y。&lt;/p&gt;
&lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://www.codetool.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode622-设计循环队列</title>
    <link href="https://www.codetool.top/article/leetcode622-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://www.codetool.top/article/leetcode622-设计循环队列/</id>
    <published>2019-11-24T11:22:09.000Z</published>
    <updated>2019-11-24T11:34:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><ul><li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code>isEmpty()</code>: 检查循环队列是否为空。</li><li><code>isFull()</code>: 检查循环队列是否已满。</li></ul><p><strong>示例:</strong></p><blockquote><p>MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3<br/><br>circularQueue.enQueue(1);  // 返回 true<br/><br>circularQueue.enQueue(2);  // 返回 true<br/><br>circularQueue.enQueue(3);  // 返回 true<br/><br>circularQueue.enQueue(4);  // 返回 false，队列已满<br/><br>circularQueue.Rear();  // 返回 3<br/><br>circularQueue.isFull();  // 返回 true<br/><br>circularQueue.deQueue();  // 返回 true<br/><br>circularQueue.enQueue(4);  // 返回 true<br/><br>circularQueue.Rear();  // 返回 4<br/>  </p></blockquote><p><strong>提示:</strong></p><ul><li>所有的值都在 0 至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>根据循环队列的定义来实现，理解head指针和tail指针指向的位置。<br><strong>通常情况下：</strong><br>添加元素，tail++。<br>删除元素，head++。<br><strong>当tail或head处于数组的最末端的时候：</strong><br>操作之后应该指向下标0。<br><strong>当数组为空：</strong><br>不能移除元素。<br><strong>当数组满了：</strong><br>不能添加元素。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = -<span class="number">1</span>;</span><br><span class="line">        tail = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(tail == queue.length-<span class="number">1</span>) &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">            queue[<span class="number">0</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> queue[++tail] = value; </span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span>(head==-<span class="number">1</span>) head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">            tail = -<span class="number">1</span>;</span><br><span class="line">            head = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head == queue.length-<span class="number">1</span>)&#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == queue.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.enQueue(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.Rear();</span></span><br><span class="line"><span class="comment"> * boolean param_5 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_6 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://www.codetool.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode283-移动零</title>
    <link href="https://www.codetool.top/article/leetcode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>https://www.codetool.top/article/leetcode283-移动零/</id>
    <published>2019-11-23T12:01:11.000Z</published>
    <updated>2019-11-23T12:14:19.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [0,1,0,3,12]<br><strong>输出:</strong> [1,3,12,0,0]  </p></blockquote><p><strong>说明:</strong></p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>双指针解法，i始终不经过0，如果j遍历到了非0元素，i++，并把非0元素赋值给i。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                nums[i++]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            nums[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26-删除排序数组中的重复项</title>
    <link href="https://www.codetool.top/article/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://www.codetool.top/article/leetcode26-删除排序数组中的重复项/</id>
    <published>2019-11-23T11:37:25.000Z</published>
    <updated>2019-11-23T12:17:02.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><blockquote><p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 <code>nums</code> = <code>[0,0,1,1,1,2,2,3,3,4]</code>,<br>函数应该返回新的长度 <strong>5</strong>, 并且原数组 nums 的前五个元素被修改为 <strong>0, 1, 2, 3, 4</strong>。<br>你不需要考虑数组中超出新长度后面的元素。 </p></blockquote><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);  <br/><br>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}  </p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>双指针解法，i始终停留在第一个出现的重复元素上，j一旦遇到不重复的元素，i++，然后将不重复的元素赋给<code>nums[i]</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i])</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个排序数组，你需要在&lt;strong&gt;原地&lt;/strong&gt;删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针技巧" scheme="https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>leetcode557-反转字符串中的单词III</title>
    <link href="https://www.codetool.top/article/leetcode557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/"/>
    <id>https://www.codetool.top/article/leetcode557-反转字符串中的单词III/</id>
    <published>2019-11-23T11:12:52.000Z</published>
    <updated>2019-11-23T11:20:42.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> “Let’s take LeetCode contest”<br><strong>输出:</strong> “s’teL ekat edoCteeL tsetnoc” </p></blockquote><p><strong>注意：</strong> 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>翻转字符串可以用StringBuffer的reverse方法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            sb.append(<span class="keyword">new</span> StringBuffer(word).reverse().toString());</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1:&lt;/stron
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="https://www.codetool.top/article/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.codetool.top/article/ArrayList源码分析/</id>
    <published>2019-11-22T09:17:44.000Z</published>
    <updated>2019-12-02T07:13:46.067Z</updated>
    
    <content type="html"><![CDATA[<p>这是我最后一次这么详细地把所有方法列出来了。。。以后只记录重点。。。</p><p>这篇文章虽然贼长但是总结下来重点只有：</p><ol><li>如果使用无参构造函数建立ArrayList，在添加第一个元素的时候会分配10个元素的空间。</li><li>ArrayList的扩容是以1.5倍为基准的。</li></ol><p>以下为原文</p><hr><p>先来看看ArrayList的Hierarchy：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/11/12/M8MmnI.png" alt="img" title="ArrayList层次结构">                </div>                <div class="image-caption">ArrayList层次结构</div>            </figure><p>父类们：<br><a href="https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/">Collection接口研究</a><br><a href="https://www.codetool.top/article/AbstractCollection%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AbstractCollection源码分析</a>  </p><p>先来看看List接口：</p><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>List代表有序集合，元素可以重复。</p><p>List家族一览：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://api.codetool.top/img/15752679306935.png" alt="List层次" title="">                </div>                <div class="image-caption">List层次</div>            </figure><p>相比Collection接口增加的方法：</p><h2 id="boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="boolean addAll(int index, Collection&lt;? extends E&gt; c);"></a>boolean addAll(int index, Collection&lt;? extends E&gt; c);</h2><p>将给定集合中所有的元素插入到指定位置上。</p><h2 id="default-void-replaceAll-UnaryOperator-operator"><a href="#default-void-replaceAll-UnaryOperator-operator" class="headerlink" title="default void replaceAll(UnaryOperator operator);"></a>default void replaceAll(UnaryOperator<E> operator);</h2><p>以指定的方法替换List中的所有元素，<code>UnaryOperator</code>是一个函数式接口，输入一个类型对象，返回一个同类型对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">        li.set(operator.apply(li.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.replaceAll(a-&gt;a+<span class="number">1</span>); <span class="comment">//list = [2,4,6]</span></span><br></pre></td></tr></table></figure><h2 id="default-void-sort-Comparator-lt-super-E-gt-c"><a href="#default-void-sort-Comparator-lt-super-E-gt-c" class="headerlink" title="default void sort(Comparator&lt;? super E&gt; c);"></a>default void sort(Comparator&lt;? super E&gt; c);</h2><p>根据排序方法排序。还是先转为了Array再使用Arrays的sort方法进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-get-int-index"><a href="#E-get-int-index" class="headerlink" title="E get(int index);"></a>E get(int index);</h2><p>根据index返回一个元素。</p><h2 id="E-set-int-index-E-element"><a href="#E-set-int-index-E-element" class="headerlink" title="E set(int index, E element);"></a>E set(int index, E element);</h2><p>将element替换index上的元素。返回原来index位置上的元素。</p><h2 id="void-add-int-index-E-element"><a href="#void-add-int-index-E-element" class="headerlink" title="void add(int index, E element);"></a>void add(int index, E element);</h2><p>在index处添加元素。</p><h2 id="E-remove-int-index"><a href="#E-remove-int-index" class="headerlink" title="E remove(int index);"></a>E remove(int index);</h2><p>删除index处的元素，并<strong>返回该元素。</strong></p><h2 id="int-indexOf-Object-o"><a href="#int-indexOf-Object-o" class="headerlink" title="int indexOf(Object o);"></a>int indexOf(Object o);</h2><p>得到某个元素在List中第一次出现的index，如果不存在该元素，返回-1。</p><h2 id="int-lastIndexOf-Object-o"><a href="#int-lastIndexOf-Object-o" class="headerlink" title="int lastIndexOf(Object o);"></a>int lastIndexOf(Object o);</h2><p>得到某个元素在List中最后一次出现的index，如果不存在该元素，返回-1。</p><h2 id="ListIterator-listIterator"><a href="#ListIterator-listIterator" class="headerlink" title="ListIterator listIterator();"></a>ListIterator<E> listIterator();</h2><p>得到该List的迭代器。</p><h2 id="ListIterator-listIterator-int-index"><a href="#ListIterator-listIterator-int-index" class="headerlink" title="ListIterator listIterator(int index);"></a>ListIterator<E> listIterator(int index);</h2><p>返回一个从指定index处开始的迭代器。（迭代器第一次next操作会得到index处的元素）。</p><h2 id="List-subList-int-fromIndex-int-toIndex"><a href="#List-subList-int-fromIndex-int-toIndex" class="headerlink" title="List subList(int fromIndex, int toIndex);"></a>List<E> subList(int fromIndex, int toIndex);</h2><p>返回一个包含fromIndex下标但不包含toIndex下标元素的子List。<br>这个函数和<code>indexOf()</code>、<code>lastIndexOf()</code>结合起来有妙用。</p><h2 id="default-Spliterator-spliterator"><a href="#default-Spliterator-spliterator" class="headerlink" title="default Spliterator spliterator();"></a>default Spliterator<E> spliterator();</h2><blockquote><p>Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.ORDERED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><h3 id="核心：transient-Object-elementData"><a href="#核心：transient-Object-elementData" class="headerlink" title="核心：transient Object[] elementData;"></a>核心：transient Object[] elementData;</h3><p>ArrayList的元素底层还是存储在这个数组中。</p><h3 id="private-int-size"><a href="#private-int-size" class="headerlink" title="private int size;"></a>private int size;</h3><p>记录空间大小。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="public-ArrayList"><a href="#public-ArrayList" class="headerlink" title="public ArrayList();"></a>public ArrayList();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中宏<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>是一个空数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="public-ArrayList-int-initialCapacity"><a href="#public-ArrayList-int-initialCapacity" class="headerlink" title="public ArrayList(int initialCapacity);"></a>public ArrayList(int initialCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个初始容量初始化ArrayList。<br>如果传入的参数大于0，则分配一个这么大的数组。<br>如果等于0，令其等于一个空数组。<br>其中宏<code>EMPTY_ELEMENTDATA</code>也是一个空数组，至于为什么要区分EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA，注释解释的是：</p><blockquote><p>We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.</p></blockquote><p>当第一个元素被加进来的时候能知道应该扩容多少。（与后文的calculateCapacity方法有关）</p><h3 id="public-ArrayList-Collection-lt-extends-E-gt-c"><a href="#public-ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="public ArrayList(Collection&lt;? extends E&gt; c);"></a>public ArrayList(Collection&lt;? extends E&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法使得ArrayList可以由其他Collection子类的对象生成，但也取决于它的toArray方法是怎么实现的。</p><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="E-elementData-int-index"><a href="#E-elementData-int-index" class="headerlink" title="E elementData(int index);"></a>E elementData(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取元素,这个方法没有访问修饰符，也就是包内所有的类都可以访问，说明jdk给ArrayList不进行边界检查去元素的方法也留了后路。</p><h3 id="private-void-rangeCheck-int-index"><a href="#private-void-rangeCheck-int-index" class="headerlink" title="private void rangeCheck(int index);"></a>private void rangeCheck(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边界检查。</p><blockquote><p>rangeCheck方法是提供给get,remove，set之类的方法检查的,是给已经存在元素的集合操作的，范围0至size-1,这个方法把检查负责的职责交给了数组的访问,像get(-1)时会报异常ArrayIndexOutOfBoundsException。</p></blockquote><h3 id="private-void-rangeCheckForAdd-int-index"><a href="#private-void-rangeCheckForAdd-int-index" class="headerlink" title="private void rangeCheckForAdd(int index);"></a>private void rangeCheckForAdd(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是提供给add和addAll的，会检查负数。因为如果扩容了数组再抛出异常就白扩容了。</p><h3 id="private-void-ensureCapacityInternal-int-minCapacity"><a href="#private-void-ensureCapacityInternal-int-minCapacity" class="headerlink" title="private void ensureCapacityInternal(int minCapacity);"></a>private void ensureCapacityInternal(int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需保证ArrayList能容纳minCapacity个元素，数组的大小可能需要扩容。</p><h3 id="private-static-int-calculateCapacity-Object-elementData-int-minCapacity"><a href="#private-static-int-calculateCapacity-Object-elementData-int-minCapacity" class="headerlink" title="private static int calculateCapacity(Object[] elementData, int minCapacity);"></a>private static int calculateCapacity(Object[] elementData, int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于计算数组应该具有多少空间，其中<code>DEFAULT_CAPACITY=10</code>。<br>这说明：如果ArrayList是以<strong>无参构造方法</strong>建立的，在添加第一个元素时会直接分配<strong>10个</strong>元素的空间。</p><h3 id="private-void-ensureExplicitCapacity-int-minCapacity"><a href="#private-void-ensureExplicitCapacity-int-minCapacity" class="headerlink" title="private void ensureExplicitCapacity(int minCapacity);"></a>private void ensureExplicitCapacity(int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于确保数组的容量大于minCapacity<br><code>modCount</code>用于计数数组的大小被改变了多少次。<br>如果minCapacity大于内部数组的大小，调用grow方法扩容</p><h3 id="private-void-grow-int-minCapacity"><a href="#private-void-grow-int-minCapacity" class="headerlink" title="private void grow(int minCapacity);"></a>private void grow(int minCapacity);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//即newCapacity = 1.5*oldCapacity</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出数组是以1.5倍为基准扩容的，如果1.5倍后大于<code>MAX_ARRAY_SIZE (Integer.MAX_VALUE - 8)</code>，则使用<code>hugeCapacity(minCapacity)</code>确认。</p><h3 id="private-static-int-hugeCapacity-int-minCapacity"><a href="#private-static-int-hugeCapacity-int-minCapacity" class="headerlink" title="private static int hugeCapacity(int minCapacity)"></a>private static int hugeCapacity(int minCapacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和AbstractCollection类似。。。</p><h2 id="List实现方法"><a href="#List实现方法" class="headerlink" title="List实现方法"></a>List实现方法</h2><h3 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size();"></a>public int size();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明size是实时的size</p><h3 id="public-boolean-isEmpty"><a href="#public-boolean-isEmpty" class="headerlink" title="public boolean isEmpty();"></a>public boolean isEmpty();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过size判断</p><h3 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains(Object o);"></a>public boolean contains(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>indexOf()</code>方法判断（如果不存在该元素indexOf返回-1）</p><h3 id="public-int-indexOf-Object-o"><a href="#public-int-indexOf-Object-o" class="headerlink" title="public int indexOf(Object o);"></a>public int indexOf(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历内部数组，比较是否存在对象o，<code>null</code>要分开判断，<strong>如果不存在返回-1。</strong></p><h3 id="public-int-lastIndexOf-Object-o"><a href="#public-int-lastIndexOf-Object-o" class="headerlink" title="public int lastIndexOf(Object o);"></a>public int lastIndexOf(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和indexOf类似，从尾部开始遍历。</p><h3 id="public-Object-toArray"><a href="#public-Object-toArray" class="headerlink" title="public Object[] toArray();"></a>public Object[] toArray();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接复制返回内部数组。</p><h3 id="public-T-toArray-T-a"><a href="#public-T-toArray-T-a" class="headerlink" title="public  T[] toArray(T[] a);"></a>public <T> T[] toArray(T[] a);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了Arrays.copyOf转类型的重载方法。<br>在数组大小大于List大小的情况下，使用了System.arraycopy拷贝连续内存空间，然后将a[size]设成了null，可见原数组index&gt;size的元素并没有被清空，只是访问不到了。</p><h3 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index);"></a>public E get(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只检查index是不是大于数组大小减一，负数异常交给数组处理。</p><h3 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element);"></a>public E set(int index, E element);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置元素，负数异常也交给数组处理。</p><h3 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先保证能容纳size+1个元素，再添加元素。</p><h3 id="public-void-add-int-index-E-element"><a href="#public-void-add-int-index-E-element" class="headerlink" title="public void add(int index, E element);"></a>public void add(int index, E element);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index后面的先整体后移，然后设置元素。</p><h3 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index);"></a>public E remove(int index);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>System.arraycopy</code>这个native方法真的很常用。</p><h3 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o);"></a>public boolean remove(Object o);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fastRemove</code>是<code>public E remove(int index)</code>的精简版，移除方法一致。</p><h3 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear();"></a>public void clear();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环设为null</p><h3 id="public-boolean-addAll-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(Collection&lt;? extends E&gt; c);"></a>public boolean addAll(Collection&lt;? extends E&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是arraycopy的使用，确实省事</p><h3 id="public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#public-boolean-addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="public boolean addAll(int index, Collection&lt;? extends E&gt; c);"></a>public boolean addAll(int index, Collection&lt;? extends E&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的方法类似。</p><h3 id="public-boolean-removeAll-Collection-lt-gt-c"><a href="#public-boolean-removeAll-Collection-lt-gt-c" class="headerlink" title="public boolean removeAll(Collection&lt;?&gt; c);"></a>public boolean removeAll(Collection&lt;?&gt; c);</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>batchRemove</code>：false:删除c中包含的元素，true：删除c中不包含的元素。</p><h3 id="public-boolean-retainAll-Collection-lt-gt-c"><a href="#public-boolean-retainAll-Collection-lt-gt-c" class="headerlink" title="public boolean retainAll(Collection&lt;?&gt; c)"></a>public boolean retainAll(Collection&lt;?&gt; c)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是使用了<code>batchRemove</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我最后一次这么详细地把所有方法列出来了。。。以后只记录重点。。。&lt;/p&gt;
&lt;p&gt;这篇文章虽然贼长但是总结下来重点只有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果使用无参构造函数建立ArrayList，在添加第一个元素的时候会分配10个元素的空间。&lt;/li&gt;
&lt;li&gt;ArrayLi
      
    
    </summary>
    
    
      <category term="编程语言" scheme="https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="https://www.codetool.top/tags/java/"/>
    
      <category term="jdk" scheme="https://www.codetool.top/tags/jdk/"/>
    
      <category term="源码研究" scheme="https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"/>
    
      <category term="集合" scheme="https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode151-翻转字符串里的单词</title>
    <link href="https://www.codetool.top/article/leetcode151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>https://www.codetool.top/article/leetcode151-翻转字符串里的单词/</id>
    <published>2019-11-22T09:01:15.000Z</published>
    <updated>2019-11-22T09:09:50.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong>   “the sky is blue”<br><strong>输出:</strong>  “blue is sky the”   </p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong>  “&nbsp;&nbsp;hello world!&nbsp;&nbsp;”<br><strong>输出:</strong> “world! hello”<br><strong>解释:</strong> 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong>  “a good&nbsp;&nbsp;&nbsp;example”<br><strong>输出:</strong> “example good a”<br><strong>解释:</strong> 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p><strong>说明:</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>直接使用jdk中String的<code>trim()</code>和<code>split()</code>方法得到单词的数组，或者遍历字符串字符，记录单词数组。再反向遍历输出。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"\\s+"代表正则表达式1个或多个空白字符</span></span><br><span class="line">        String[] words = s.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">        <span class="keyword">int</span> size = words.length;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            str.append(words[size-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=size-<span class="number">1</span>) str.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode119-杨辉三角II</title>
    <link href="https://www.codetool.top/article/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/"/>
    <id>https://www.codetool.top/article/leetcode119-杨辉三角II/</id>
    <published>2019-11-22T08:54:01.000Z</published>
    <updated>2019-11-22T09:00:06.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。<br><img src="https://s2.ax1x.com/2019/11/15/Mdetds.gif" alt="img"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> 3<br><strong>输出:</strong> [1,3,3,1]</p></blockquote><p><strong>进阶：</strong></p><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>可以利用<a href="https://www.codetool.top/article/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/">leetcode118-杨辉三角</a>中的函数来解决。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rowIndex == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">return</span> getRowByPrev(rowIndex,getRow(rowIndex-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上一行计算第n行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRowByPrev</span><span class="params">(<span class="keyword">int</span> n,List&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        ret.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(n+<span class="number">2</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            ret.add(nums.get(i-<span class="number">1</span>)+nums.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            ret.add(ret.get(size-i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个非负索引 &lt;em&gt;k&lt;/em&gt;，其中 &lt;em&gt;k&lt;/em&gt; ≤ 33，返回杨辉三角的第 &lt;em&gt;k&lt;/em&gt; 行。&lt;br&gt;&lt;img 
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode189-旋转数组</title>
    <link href="https://www.codetool.top/article/leetcode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://www.codetool.top/article/leetcode189-旋转数组/</id>
    <published>2019-11-22T08:45:26.000Z</published>
    <updated>2019-11-22T08:52:43.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h1><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,5,6,7] 和 <em>k</em> = 3<br><strong>输出:</strong> [5,6,7,1,2,3,4]<br><strong>解释:</strong><br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]  </p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> [-1,-100,3,99] 和 <em>k</em> = 2<br><strong>输出:</strong> [3,99,-1,-100]<br><strong>解释:</strong><br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]  </p></blockquote><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 原地 算法。</li></ul><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>将旋转点前后的部分交换。注意当k大于数组大小size的情况相当于<code>k=k%size</code>的情况</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(k==size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//k大于size的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;size) k = k%size;</span><br><span class="line">        <span class="comment">//用另一个数组暂时存放结果</span></span><br><span class="line">        <span class="keyword">int</span>[] rotate = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="comment">//将旋转点后面的部分移到新数组前面来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            rotate[i] = nums[size-k+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将旋转点前面的部分移到新数组后面去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i&lt;size;i++)&#123;</span><br><span class="line">            rotate[i] = nums[i-k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组中的值赋值回原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            nums[i] = rotate[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h1&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;em&gt;k&lt;/em&gt; 个位置，其中 &lt;em&gt;k&lt;/em&gt; 是非负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示
      
    
    </summary>
    
    
      <category term="算法/数据结构" scheme="https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://www.codetool.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
