{"meta":{"title":"代码段小站","subtitle":"CodeBand CodeTool - 个人计算机类练手小博客","description":"","author":"Rhett Peng","url":"https://www.codetool.top","root":"/"},"pages":[{"title":"关于","date":"2019-11-08T13:55:48.722Z","updated":"2019-11-08T13:55:48.722Z","comments":false,"path":"about/index.html","permalink":"https://www.codetool.top/about/index.html","excerpt":"","text":"@column-2{ 很帅的一张图 曾用logo } @column-2{ @card{ 神秘的站长现南昌大学软件学院大三学生，学习作风差，不务正业.喜欢折腾新奇的东西，学习黑科技正在由一只小菜鸡成为一只大菜鸡的转变的路上（其实我也不知道小菜鸡为啥要写博客，反正也没人看） } @card{ 关于小站代码段小站（CodeBand）创建于2018年8月19日，闲时在这里随便写点东西。可能是脑海里的一些闪光点，也可能是某一天的学习内容的记录，更多的是有关编程方面的、我觉得有意义记下来的一些知识。也希望这个网站能伴随我从编程新手小白成长为一个不算太小白的小白? } } @timeline{ 2019@item{ 11月8日抛弃wordpress，使用hexo重新搭建博客，完全搬至国内服务器 } @item{ 9月6日新服务器域名通过备案，使用国内服务器反向代理 } @item{ 8月19日更换wordpress主题 } 2018@item{ 8月19日使用wordpress搭建了第一版博客写下了我的第一篇博客《Java抽象类和接口的区别》 } }"},{"title":"","date":"2019-11-08T11:01:26.614Z","updated":"2019-11-08T11:01:26.614Z","comments":false,"path":"categories/index.html","permalink":"https://www.codetool.top/categories/index.html","excerpt":"","text":""},{"title":"在线写代码","date":"2019-11-08T14:16:45.000Z","updated":"2019-11-12T11:58:05.665Z","comments":true,"path":"runcode/index.html","permalink":"https://www.codetool.top/runcode/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-08T11:01:30.613Z","updated":"2019-11-08T11:01:30.613Z","comments":false,"path":"tags/index.html","permalink":"https://www.codetool.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AVL树-自平衡的二叉搜索树","slug":"AVL树-自平衡的二叉搜索树","date":"2019-11-25T11:11:29.000Z","updated":"2019-11-25T13:16:24.326Z","comments":true,"path":"article/AVL树-自平衡的二叉搜索树/","link":"","permalink":"https://www.codetool.top/article/AVL%E6%A0%91-%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"本文图片来源：手把手教，手写AVL树 - 不止是编程 - 博客园 AVL树的概念自平衡当二叉搜索树处于平衡状态的时候，其操作时间复杂度为O(logN)，但当二叉搜索树是单支树的时候，其搜索效率则为O(N)。可见，二叉搜索树的平衡性是影响其操作效率的关键。由此出发，学者们设计了第一个平衡二叉搜索树，即AVL树。AVL树作为第一个平衡的二叉搜索树，其影响非常深远，后来的很多平衡结构都借鉴了AVL树的设计思想。 AVL树的定义一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树： 它的左子树和右子树都是AVL树。 左子树和右子树的高度之差的绝对值不超过1。 要注意，AVL的平衡性是一种相对的平衡，并非一种绝对的平衡。它不要求左子树和右子树的高度绝对相等，而仅仅是左子树和右子树的高度之差的绝对值不超过1即可。因为绝对的平衡难以实现。 如果给AVL树中的每一个节点都附加一个数字，该数字指示该节点右子树的高度减去左子树的高度所得的高度差，那么这个数字即为该节点的平衡因子。根据AVL树的定义，任一节点的平衡因子只能取-1、0或1。 AVL树的旋转在一个平衡的二叉搜索树中插入一个新节点，就会造成其失衡，需要从插入位置沿通向根的路径回溯，检查各节点的平衡因子，在某一节点发现高度不平衡，则停止回溯。然后从发生不平衡的节点起，往下取三层，可以归纳为四种情况： 向某节点的左子树中插入一个左孩子。 向某节点的右子树中插入一个右孩子。 向某节点的左子树中插入一个右孩子。 向某节点的右子树中插入一个左孩子。 对应的处理方式： 单旋 右旋操作 以中间节点为轴，进行顺时针旋转，该中间节点的原父节点将变成该节点的右子节点，该中间节点的右子树则变成其原父节点的左子树。 左旋操作 对应的，左旋的方法是以三个呈直线排列的节点的中间节点为轴，进行逆时针旋转。该中间节点的原父节点将变成该节点的左子节点，该中间节点的左子树则变成其原父节点的右子树 双旋 先左后右双旋转 以3个成折线排列的节点中的末节点为轴，进行逆时针旋转。使末节点代替中间节点的位置，也就是让末节点成为原中间节点的父节点，这时，三个节点将成一直线排列，再以新的中间节点为旋转轴做右旋操作，即可完成平衡化操作。 基本情况 复杂情况 先右后左双旋转 以3个成折线排列的节点中的末节点为轴，进行顺时针旋转。使末节点代替中间节点的位置，也就是让末节点成为原中间节点的父节点，这时，三个节点将成一直线排列，再以新的中间节点为旋转轴做左旋操作，即可完成平衡化操作。","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.codetool.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树形搜索","slug":"树形搜索","permalink":"https://www.codetool.top/tags/%E6%A0%91%E5%BD%A2%E6%90%9C%E7%B4%A2/"}]},{"title":"leetcode200-岛屿数量","slug":"leetcode200-岛屿数量","date":"2019-11-24T14:18:01.000Z","updated":"2019-11-24T14:27:18.511Z","comments":true,"path":"article/leetcode200-岛屿数量/","link":"","permalink":"https://www.codetool.top/article/leetcode200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","excerpt":"","text":"不得不说这种题确实麻烦。大一做过一遍C++版本的了今天做一遍JAVA的还是搞了好久。C++还有数据结构pair可以用，java还得存储偏移地址然后手算x、y。 原题给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例1: 输入:11110110101100000000 输出: 1 示例2: 输入:11000110000010000011 输出: 3 解法思想 BFS：线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动广度优先搜索。将其放入队列中，并将值设为 0 以标记访问过该结点。迭代地搜索队列中的每个结点，直到队列为空。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int numIslands(char[][] grid) &#123; int[][] marked; int count = 0; int height = grid.length; if(height==0) return 0; int width = grid[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for(int i = 0;i&lt;height;i++)&#123; for(int j = 0;j&lt;width;j++)&#123; if(grid[i][j]=='1')&#123; grid[i][j] = '0'; queue.offer(i*width+j); while(queue.size()&gt;0)&#123; int index = queue.poll(); int index_x = index/width; int index_y = index%width; if(index_x!=height-1 &amp;&amp; grid[index_x+1][index_y]=='1')&#123; queue.offer((index_x+1)*width+index_y); grid[index_x+1][index_y] = '0'; &#125; if(index_x!=0 &amp;&amp; grid[index_x-1][index_y]=='1')&#123; queue.offer((index_x-1)*width+index_y); grid[index_x-1][index_y] = '0'; &#125; if(index_y!=0 &amp;&amp; grid[index_x][index_y-1]=='1')&#123; queue.offer(index_x*width+index_y-1); grid[index_x][index_y-1] = '0'; &#125; if(index_y!=width-1 &amp;&amp; grid[index_x][index_y+1]=='1')&#123; queue.offer(index_x*width+index_y+1); grid[index_x][index_y+1] = '0'; &#125; &#125; count++; &#125; &#125; &#125; return count; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"BFS","slug":"BFS","permalink":"https://www.codetool.top/tags/BFS/"}]},{"title":"leetcode622-设计循环队列","slug":"leetcode622-设计循环队列","date":"2019-11-24T11:22:09.000Z","updated":"2019-11-24T11:34:19.015Z","comments":true,"path":"article/leetcode622-设计循环队列/","link":"","permalink":"https://www.codetool.top/article/leetcode622-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"原题设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例: MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 提示: 所有的值都在 0 至 1000 的范围内； 操作数将在 1 至 1000 的范围内； 请不要使用内置的队列库。 解法思想根据循环队列的定义来实现，理解head指针和tail指针指向的位置。通常情况下：添加元素，tail++。删除元素，head++。当tail或head处于数组的最末端的时候：操作之后应该指向下标0。当数组为空：不能移除元素。当数组满了：不能添加元素。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class MyCircularQueue &#123; int[] queue; int head; int tail; int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) &#123; queue = new int[k]; size = 0; head = -1; tail = -1; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) &#123; if(isFull()) return false; if(tail == queue.length-1) &#123; tail = 0; queue[0] = value; &#125; else queue[++tail] = value; size++; if(head==-1) head = 0; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if(isEmpty()) return false; if(size==1)&#123; tail = -1; head = -1; &#125;else if(head == queue.length-1)&#123; head = 0; &#125;else&#123; head++; &#125; size--; return true; &#125; /** Get the front item from the queue. */ public int Front() &#123; if(head==-1) return -1; return queue[head]; &#125; /** Get the last item from the queue. */ public int Rear() &#123; if(tail==-1) return -1; return queue[tail]; &#125; /** Checks whether the circular queue is empty or not. */ public boolean isEmpty() &#123; return size == 0; &#125; /** Checks whether the circular queue is full or not. */ public boolean isFull() &#123; return size == queue.length; &#125;&#125;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue obj = new MyCircularQueue(k); * boolean param_1 = obj.enQueue(value); * boolean param_2 = obj.deQueue(); * int param_3 = obj.Front(); * int param_4 = obj.Rear(); * boolean param_5 = obj.isEmpty(); * boolean param_6 = obj.isFull(); */","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://www.codetool.top/tags/%E9%98%9F%E5%88%97/"}]},{"title":"leetcode283-移动零","slug":"leetcode283-移动零","date":"2019-11-23T12:01:11.000Z","updated":"2019-11-23T12:14:19.185Z","comments":true,"path":"article/leetcode283-移动零/","link":"","permalink":"https://www.codetool.top/article/leetcode283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"","text":"原题给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解法思想双指针解法，i始终不经过0，如果j遍历到了非0元素，i++，并把非0元素赋值给i。 代码12345678910111213class Solution &#123; public void moveZeroes(int[] nums) &#123; int i=0; for(int j=0;j&lt;nums.length;j++)&#123; if (nums[j]!=0) &#123; nums[i++]=nums[j]; &#125; &#125; for (int j=i;j&lt;nums.length;j++)&#123; nums[j]=0; &#125; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode26-删除排序数组中的重复项","slug":"leetcode26-删除排序数组中的重复项","date":"2019-11-23T11:37:25.000Z","updated":"2019-11-23T12:17:02.212Z","comments":true,"path":"article/leetcode26-删除排序数组中的重复项/","link":"","permalink":"https://www.codetool.top/article/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"原题给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 解法思想双指针解法，i始终停留在第一个出现的重复元素上，j一旦遇到不重复的元素，i++，然后将不重复的元素赋给nums[i]。 代码12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; int j = 0; int count = 0; while(j&lt;nums.length-1)&#123; j++; if(nums[j]!=nums[i]) nums[++i] = nums[j]; &#125; return i+1; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode557-反转字符串中的单词III","slug":"leetcode557-反转字符串中的单词III","date":"2019-11-23T11:12:52.000Z","updated":"2019-11-23T11:20:42.656Z","comments":true,"path":"article/leetcode557-反转字符串中的单词III/","link":"","permalink":"https://www.codetool.top/article/leetcode557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/","excerpt":"","text":"原题给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例1: 输入: “Let’s take LeetCode contest”输出: “s’teL ekat edoCteeL tsetnoc” 注意： 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 解法思想翻转字符串可以用StringBuffer的reverse方法。 代码123456789101112class Solution &#123; public String reverseWords(String s) &#123; String[] words = s.split(\" \"); StringBuilder sb = new StringBuilder(); for(String word:words)&#123; sb.append(new StringBuffer(word).reverse().toString()); sb.append(\" \"); &#125; return sb.toString().trim(); &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2019-11-22T09:17:44.000Z","updated":"2019-11-23T15:54:49.398Z","comments":true,"path":"article/ArrayList源码分析/","link":"","permalink":"https://www.codetool.top/article/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"这是我最后一次这么详细地把所有方法列出来了。。。以后只记录重点。。。 这篇文章虽然贼长但是总结下来重点只有： 如果使用无参构造函数建立ArrayList，在添加第一个元素的时候会分配10个元素的空间。 ArrayList的扩容是以1.5倍为基准的。 以下为原文 先来看看ArrayList的Hierarchy： ArrayList层次结构 父类们：Collection接口研究AbstractCollection源码分析 先来看看List接口： List接口相比Collection接口增加的方法： boolean addAll(int index, Collection&lt;? extends E&gt; c);将给定集合中所有的元素插入到指定位置上。 default void replaceAll(UnaryOperator operator);以指定的方法替换List中的所有元素，UnaryOperator是一个函数式接口，输入一个类型对象，返回一个同类型对象。 1234567default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125;&#125; 示例： 12345List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list.add(3);list.add(5);list.replaceAll(a-&gt;a+1); //list = [2,4,6] default void sort(Comparator&lt;? super E&gt; c);根据排序方法排序。还是先转为了Array再使用Arrays的sort方法进行排序。 123456789default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; E get(int index);根据index返回一个元素。 E set(int index, E element);将element替换index上的元素。返回原来index位置上的元素。 void add(int index, E element);在index处添加元素。 E remove(int index);删除index处的元素，并返回该元素。 int indexOf(Object o);得到某个元素在List中第一次出现的index，如果不存在该元素，返回-1。 int lastIndexOf(Object o);得到某个元素在List中最后一次出现的index，如果不存在该元素，返回-1。 ListIterator listIterator();得到该List的迭代器。 ListIterator listIterator(int index);返回一个从指定index处开始的迭代器。（迭代器第一次next操作会得到index处的元素）。 List subList(int fromIndex, int toIndex);返回一个包含fromIndex下标但不包含toIndex下标元素的子List。这个函数和indexOf()、lastIndexOf()结合起来有妙用。 default Spliterator spliterator(); Spliterator是一个可分割迭代器(splitable iterator)，可以和iterator顺序遍历迭代器一起看。jdk1.8发布后，对于并行处理的能力大大增强，Spliterator就是为了并行遍历元素而设计的一个迭代器。 123default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, Spliterator.ORDERED);&#125; ArrayList字段核心：transient Object[] elementData;ArrayList的元素底层还是存储在这个数组中。 private int size;记录空间大小。 构造方法public ArrayList();123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 其中宏DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空数组。 1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; public ArrayList(int initialCapacity);12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125; 使用一个初始容量初始化ArrayList。如果传入的参数大于0，则分配一个这么大的数组。如果等于0，令其等于一个空数组。其中宏EMPTY_ELEMENTDATA也是一个空数组，至于为什么要区分EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA，注释解释的是： We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added. 当第一个元素被加进来的时候能知道应该扩容多少。（与后文的calculateCapacity方法有关） public ArrayList(Collection&lt;? extends E&gt; c);1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 这个方法使得ArrayList可以由其他Collection子类的对象生成，但也取决于它的toArray方法是怎么实现的。 关键方法E elementData(int index);123E elementData(int index) &#123; return (E) elementData[index];&#125; 取元素,这个方法没有访问修饰符，也就是包内所有的类都可以访问，说明jdk给ArrayList不进行边界检查去元素的方法也留了后路。 private void rangeCheck(int index);1234private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 边界检查。 rangeCheck方法是提供给get,remove，set之类的方法检查的,是给已经存在元素的集合操作的，范围0至size-1,这个方法把检查负责的职责交给了数组的访问,像get(-1)时会报异常ArrayIndexOutOfBoundsException。 private void rangeCheckForAdd(int index);1234private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 这个方法是提供给add和addAll的，会检查负数。因为如果扩容了数组再抛出异常就白扩容了。 private void ensureCapacityInternal(int minCapacity);123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 需保证ArrayList能容纳minCapacity个元素，数组的大小可能需要扩容。 private static int calculateCapacity(Object[] elementData, int minCapacity);123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 用于计算数组应该具有多少空间，其中DEFAULT_CAPACITY=10。这说明：如果ArrayList是以无参构造方法建立的，在添加第一个元素时会直接分配10个元素的空间。 private void ensureExplicitCapacity(int minCapacity);1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 用于确保数组的容量大于minCapacitymodCount用于计数数组的大小被改变了多少次。如果minCapacity大于内部数组的大小，调用grow方法扩容 private void grow(int minCapacity);123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //即newCapacity = 1.5*oldCapacity int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 可以看出数组是以1.5倍为基准扩容的，如果1.5倍后大于MAX_ARRAY_SIZE (Integer.MAX_VALUE - 8)，则使用hugeCapacity(minCapacity)确认。 private static int hugeCapacity(int minCapacity)1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 和AbstractCollection类似。。。 List实现方法public int size();123public int size() &#123; return size;&#125; 说明size是实时的size public boolean isEmpty();123public boolean isEmpty() &#123; return size == 0;&#125; 通过size判断 public boolean contains(Object o);123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 通过indexOf()方法判断（如果不存在该元素indexOf返回-1） public int indexOf(Object o);123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 遍历内部数组，比较是否存在对象o，null要分开判断，如果不存在返回-1。 public int lastIndexOf(Object o);123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 和indexOf类似，从尾部开始遍历。 public Object[] toArray();123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 直接复制返回内部数组。 public T[] toArray(T[] a);123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 使用了Arrays.copyOf转类型的重载方法。在数组大小大于List大小的情况下，使用了System.arraycopy拷贝连续内存空间，然后将a[size]设成了null，可见原数组index&gt;size的元素并没有被清空，只是访问不到了。 public E get(int index);12345public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 这里只检查index是不是大于数组大小减一，负数异常交给数组处理。 public E set(int index, E element);1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 设置元素，负数异常也交给数组处理。 public boolean add(E e)12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 首先保证能容纳size+1个元素，再添加元素。 public void add(int index, E element);123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; index后面的先整体后移，然后设置元素。 public E remove(int index);1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; System.arraycopy这个native方法真的很常用。 public boolean remove(Object o);12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; fastRemove是public E remove(int index)的精简版，移除方法一致。 public void clear();123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 循环设为null public boolean addAll(Collection&lt;? extends E&gt; c);12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125; 又是arraycopy的使用，确实省事 public boolean addAll(int index, Collection&lt;? extends E&gt; c);12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 和上面的方法类似。 public boolean removeAll(Collection&lt;?&gt; c);1234public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125; batchRemove：false:删除c中包含的元素，true：删除c中不包含的元素。 public boolean retainAll(Collection&lt;?&gt; c)1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125; 也是使用了batchRemove","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.codetool.top/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.codetool.top/tags/jdk/"},{"name":"源码研究","slug":"源码研究","permalink":"https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"},{"name":"集合","slug":"集合","permalink":"https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"}]},{"title":"leetcode151-翻转字符串里的单词","slug":"leetcode151-翻转字符串里的单词","date":"2019-11-22T09:01:15.000Z","updated":"2019-11-22T09:09:50.096Z","comments":true,"path":"article/leetcode151-翻转字符串里的单词/","link":"","permalink":"https://www.codetool.top/article/leetcode151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/","excerpt":"","text":"原题给定一个字符串，逐个翻转字符串中的每个单词。 示例 1: 输入: “the sky is blue”输出: “blue is sky the” 示例 2: 输入: “&nbsp;&nbsp;hello world!&nbsp;&nbsp;”输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3: 输入: “a good&nbsp;&nbsp;&nbsp;example”输出: “example good a”解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 解法思想直接使用jdk中String的trim()和split()方法得到单词的数组，或者遍历字符串字符，记录单词数组。再反向遍历输出。 代码12345678910111213class Solution &#123; public String reverseWords(String s) &#123; //\"\\\\s+\"代表正则表达式1个或多个空白字符 String[] words = s.trim().split(\"\\\\s+\"); int size = words.length; StringBuilder str = new StringBuilder(); for(int i = 0;i&lt;size;i++)&#123; str.append(words[size-1-i]); if(i!=size-1) str.append(\" \"); &#125; return str.toString(); &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode119-杨辉三角II","slug":"leetcode119-杨辉三角II","date":"2019-11-22T08:54:01.000Z","updated":"2019-11-22T09:00:06.414Z","comments":true,"path":"article/leetcode119-杨辉三角II/","link":"","permalink":"https://www.codetool.top/article/leetcode119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/","excerpt":"","text":"原题给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解法思想可以利用leetcode118-杨辉三角中的函数来解决。 代码123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; list = new ArrayList(); list.add(1); if(rowIndex == 0) return list; return getRowByPrev(rowIndex,getRow(rowIndex-1)); &#125; //通过上一行计算第n行 public List&lt;Integer&gt; getRowByPrev(int n,List&lt;Integer&gt; nums)&#123; List&lt;Integer&gt; ret = new ArrayList(); ret.add(1); for(int i=1;i&lt;(n+2)/2;i++)&#123; ret.add(nums.get(i-1)+nums.get(i)); &#125; int size = (n+1)/2; for(int i=0;i&lt;size;i++)&#123; ret.add(ret.get(size-i-1)); &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode189-旋转数组","slug":"leetcode189-旋转数组","date":"2019-11-22T08:45:26.000Z","updated":"2019-11-22T08:52:43.215Z","comments":true,"path":"article/leetcode189-旋转数组/","link":"","permalink":"https://www.codetool.top/article/leetcode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"","text":"原题给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例1: 输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例2: 输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 解法思想将旋转点前后的部分交换。注意当k大于数组大小size的情况相当于k=k%size的情况 代码12345678910111213141516171819202122class Solution &#123; public void rotate(int[] nums, int k) &#123; int size = nums.length; if(k==size) return; //k大于size的情况 if(k&gt;size) k = k%size; //用另一个数组暂时存放结果 int[] rotate = new int[size]; //将旋转点后面的部分移到新数组前面来 for(int i = 0;i&lt;k;i++)&#123; rotate[i] = nums[size-k+i]; &#125; //将旋转点前面的部分移到新数组后面去 for(int i = k;i&lt;size;i++)&#123; rotate[i] = nums[i-k]; &#125; //将新数组中的值赋值回原数组 for(int i = 0;i&lt;size;i++)&#123; nums[i] = rotate[i]; &#125; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode209-长度最小的子数组","slug":"leetcode209-长度最小的子数组","date":"2019-11-20T10:06:18.000Z","updated":"2019-11-20T10:15:57.146Z","comments":true,"path":"article/leetcode209-长度最小的子数组/","link":"","permalink":"https://www.codetool.top/article/leetcode209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"原题给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例: 输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解法思想使用两个指针i、j从下标为0处开始遍历。如果i-j内的总数小于s，将j向后移动，如果i-j内的总数大于s，将i向后移动，直到获取所有子数组的长度，并比较出最短长度。 代码1234567891011121314151617181920class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; int i = 0; int j = -1; int size = nums.length; int sum = 0; int min = 0; while(i&lt;size&amp;&amp;j&lt;size)&#123; if(sum&gt;=s)&#123; if(min==0) min = j-i+1; else min = j-i+1&lt;min?j-i+1:min; sum -= nums[i++]; &#125;else&#123; if(j==size-1) return min; sum += nums[++j]; &#125; &#125; return min; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode485-最大连续1的个数","slug":"leetcode485-最大连续1的个数","date":"2019-11-20T09:58:18.000Z","updated":"2019-11-20T10:07:47.063Z","comments":true,"path":"article/leetcode485-最大连续1的个数/","link":"","permalink":"https://www.codetool.top/article/leetcode485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"原题给定一个二进制数组， 计算其中最大连续1的个数。 示例 1: 输入： [1,1,0,1,1,1]输出： 3解释： 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含0和1。 输入数组的长度是正整数，且不超过 10,000。 解法思想使用一个数遍历数组，另一个数记录遇到的连续的1的个数，记录最大值。 代码1234567891011121314151617class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int j=0; int max=0; for(int i:nums)&#123; if(i==1)&#123; j++; &#125;else&#123; if(j&gt;max) max=j; j=0; &#125; &#125; if(j&gt;max) max=j; return max; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode27-移除元素","slug":"leetcode27-移除元素","date":"2019-11-20T09:50:02.000Z","updated":"2019-11-20T09:57:52.942Z","comments":true,"path":"article/leetcode27-移除元素/","link":"","permalink":"https://www.codetool.top/article/leetcode27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"","text":"原题给定一个数组 nums 和一个值 val*，你需要原地移除所有数值等于 *val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以 “引用” 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 解法思想我们继续使用两个指针：一个仍然用于迭代，而第二个指针总是指向下一次添加的位置。 代码123456789101112class Solution &#123; public int removeElement(int[] nums, int val) &#123; int k = 0; for(int i = 0;i&lt;nums.length;i++)&#123; if(nums[i]!=val)&#123; nums[k] = nums[i]; k++; &#125; &#125; return k; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode167-两数之和II-输入有序数组","slug":"leetcode167-两数之和II-输入有序数组","date":"2019-11-20T09:44:33.000Z","updated":"2019-11-20T10:16:12.932Z","comments":true,"path":"article/leetcode167-两数之和II-输入有序数组/","link":"","permalink":"https://www.codetool.top/article/leetcode167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"原题给定一个已按照 升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值index1和index2，其中index1必须小于index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解法思想因为给的数组是有序的，可以使用双指针逼近目标数。 代码1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int[] index = new int[2]; int index1 = 0; int index2 = numbers.length - 1; while (index1 &lt; index2) &#123; if (numbers[index1] + numbers[index2] &gt; target) index2--; else if (numbers[index1] + numbers[index2] &lt; target) index1++; //找到了 else &#123; index[0] = index1 + 1; index[1] = index2 + 1; break; &#125; &#125; return index; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"AbstractCollection源码分析","slug":"AbstractCollection源码分析","date":"2019-11-18T13:40:38.000Z","updated":"2019-11-22T09:18:34.130Z","comments":true,"path":"article/AbstractCollection源码分析/","link":"","permalink":"https://www.codetool.top/article/AbstractCollection%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"上次谈到了Collection接口研究 这次来看看其中的一个子类，但也是个抽象类：AbstractCollection。相比Collection接口并没有新增公开方法，但它提供了许多方法的默认实现。 public boolean contains(Object o);提供了一个默认实现： 12345678910111213public boolean contains(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o==null) &#123; while (it.hasNext()) if (it.next()==null) return true; &#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) return true; &#125; return false;&#125; 很容易理解，也很依赖于iterator()和equals()方法的实现 public boolean isEmpty();123public boolean isEmpty() &#123; return size() == 0;&#125; 依赖于size()方法的实现 public Object[] toArray();1234567891011public Object[] toArray() &#123; // Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); &#125; return it.hasNext() ? finishToArray(r, it) : r;&#125; 注意该实现判断了iterator遍历的元素个数可能跟size()的结果不同的情况。并且以iterator遍历的所有元素为准。 private static T[] finishToArray(T[] r, Iterator&lt;?&gt; it);是toArray()函数调用的一个私密静态方法，它将it迭代器遍历的所有元素存入一个数组，并且不依赖size()的实现，可以给传入的数组扩容。 12345678910111213141516private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123; int i = r.length; while (it.hasNext()) &#123; int cap = r.length;//容量capacity的概念 if (i == cap) &#123; int newCap = cap + (cap &gt;&gt; 1) + 1;// n+n/2+1扩容 // overflow-conscious code if (newCap - MAX_ARRAY_SIZE &gt; 0) newCap = hugeCapacity(cap + 1); //新容量等于Integer.MAX_VALUE或MAX_ARRAY_SIZE r = Arrays.copyOf(r, newCap); &#125; r[i++] = (T)it.next(); &#125; // trim if overallocated return (i == r.length) ? r : Arrays.copyOf(r, i);&#125; private static int hugeCapacity(int minCapacity);是finishToArray()函数调用的用于容量逼近Integer.MAX_VALUE给数组扩容的方法 123456789private static int hugeCapacity(int minCapacity) &#123; //超出int范围 if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError (\"Required array size too large\"); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; public boolean add(E e);123public boolean add(E e) &#123; throw new UnsupportedOperationException();&#125; 不允许单个添加元素。 public boolean remove(Object o);12345678910111213141516171819public boolean remove(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o==null) &#123; while (it.hasNext()) &#123; if (it.next()==null) &#123; it.remove(); return true; &#125; &#125; &#125; else &#123; while (it.hasNext()) &#123; if (o.equals(it.next())) &#123; it.remove(); return true; &#125; &#125; &#125; return false;&#125; 注意null要分开来判断，因为null不能被equals()调用删除的方式是通过迭代器的remove()方法 public boolean containsAll(Collection&lt;?&gt; c);123456public boolean containsAll(Collection&lt;?&gt; c) &#123; for (Object e : c) if (!contains(e)) return false; return true;&#125; 循环调用contains()方法判断 public boolean addAll(Collection&lt;? extends E&gt; c)1234567public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified;&#125; 这个操作不能保证所有元素都被添加成功了，这依赖于add()方法的实现，但只要有一个元素被添加成功了，就返回true。 public boolean removeAll(Collection&lt;?&gt; c)123456789101112public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) &#123; if (c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; 同理，该操作也不能保证所有元素都被移除成功了，但只要有一个元素被移除成功了，就返回true。 public boolean retainAll(Collection&lt;?&gt; c)123456789101112public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; if (!c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; 和removeAll()的实现相反，将c中含有的元素保留了下来。 public void clear();1234567public void clear() &#123; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; it.next(); it.remove(); &#125;&#125; 移除所有元素。 public String toString()123456789101112131415public String toString() &#123; Iterator&lt;E&gt; it = iterator(); if (! it.hasNext()) return \"[]\"; StringBuilder sb = new StringBuilder();//sb sb.append('['); for (;;) &#123; E e = it.next(); sb.append(e == this ? \"(this Collection)\" : e); if (! it.hasNext()) return sb.append(']').toString(); sb.append(',').append(' '); &#125;&#125; 以[*,*,*...]的形式输出字符串，还考虑到了元素可能是它本身的情况","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.codetool.top/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.codetool.top/tags/jdk/"},{"name":"源码研究","slug":"源码研究","permalink":"https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"},{"name":"集合","slug":"集合","permalink":"https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"}]},{"title":"leetcode561-数组拆分I","slug":"leetcode561-数组拆分I","date":"2019-11-18T11:59:58.000Z","updated":"2019-11-18T12:12:44.777Z","comments":true,"path":"article/leetcode561-数组拆分I/","link":"","permalink":"https://www.codetool.top/article/leetcode561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/","excerpt":"","text":"原题给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 输入：[1,4,3,2]输出： 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 解法思想通过观察发现，最后总和应该是所有数排完序后偶数下标的元素的值的总和。 代码123456789101112class Solution &#123; public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int i = 0; int sum = 0; while(i&lt;nums.length)&#123; sum+=nums[i]; i+=2; &#125; return sum; &#125;&#125; 还有一种排序方法：因为已知数的范围都是在[-10000, 10000]中，可以利用额外的空间排序。这种方法由于排序更快，时间复杂度较低，但只适用于数值范围已知且对空间复杂度要求不高的情况。 1234567891011121314public class Solution &#123; public int arrayPairSum(int[] nums) &#123; int[] arr = new int[20001]; int lim = 10000; for (int num: nums) arr[num + lim]++; int d = 0, sum = 0; for (int i = -10000; i &lt;= 10000; i++) &#123; sum += (arr[i + lim] + 1 - d) / 2 * i; d = (2 + arr[i + lim] - d) % 2; &#125; return sum; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode344-反转字符串","slug":"leetcode344-反转字符串","date":"2019-11-18T11:57:35.000Z","updated":"2019-11-18T11:58:34.267Z","comments":true,"path":"article/leetcode344-反转字符串/","link":"","permalink":"https://www.codetool.top/article/leetcode344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"原题编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1: 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2: 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 解法思想将第一个元素与末尾进行交换，再向前移动到下一个元素，并不断地交换，直到它到达中间位置。 我们可以同时使用两个指针来完成迭代：一个从第一个元素开始，另一个从最后一个元素开始。持续交换它们所指向的元素，直到这两个指针相遇。 代码1234567891011121314class Solution &#123; public void reverseString(char[] s) &#123; char temp; int i = 0; int j = s.length-1; while(i&lt;=j)&#123; temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode14-最长公共前缀","slug":"leetcode14-最长公共前缀","date":"2019-11-18T11:43:52.000Z","updated":"2019-11-18T11:57:54.843Z","comments":true,"path":"article/leetcode14-最长公共前缀/","link":"","permalink":"https://www.codetool.top/article/leetcode14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"","text":"原题编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl” 示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解法思想以第一个字符串的每一个位置上的字符为基准，依次比对其余字符串对应位置上的字符，如果每个字符串对应的位置上都是这个字符，则将其append到结果上，一旦遇到一个字符不是公有的立刻将结果返回。 代码1234567891011121314151617181920class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int size = strs.length; if(size==0) return \"\"; if(size==1) return strs[0];//一个字符串直接返回本身 StringBuilder str = new StringBuilder();//为了避免java连接字符串的低效率使用StringBuilder for(int i = 0;i &lt; strs[0].length();i++)&#123; char letter = strs[0].charAt(i); for(int j = 1;j &lt; size;j++)&#123; //依次检查其余字符串各个字符是否对应第一个字符串中的字符 //为了避免其他字符串的长度小于第一个字符串，使用try捕获异常 try&#123; if(strs[j].charAt(i)!=letter) return str.toString(); &#125;catch(Exception e)&#123; return str.toString();&#125; &#125; str.append(letter); &#125; return str.toString(); &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode28-实现strStr()","slug":"leetcode28-实现strStr","date":"2019-11-15T10:19:05.000Z","updated":"2019-11-18T11:37:18.692Z","comments":true,"path":"article/leetcode28-实现strStr/","link":"","permalink":"https://www.codetool.top/article/leetcode28-%E5%AE%9E%E7%8E%B0strStr/","excerpt":"","text":"原题实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = “hello”, needle = “ll”输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba”输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解法JDK API在leetcode上，当然可以投机取巧地使用String.indexof()方法，不用重复造轮子： 12345class Solution &#123; public int strStr(String haystack, String needle) &#123; return haystack.indexOf(needle); &#125;&#125; 但这是一个经典的字符串精准模式匹配问题，历史上出现过很多解决这个问题的算法，掌握它们的思想还是有必要的： BF算法（朴素算法）思想这是最直观、最简单的算法。从主串的第start个字符起和模式的第1个字符比较，如果相等继续逐个比较后续字符。比较过程中一旦发现不相等的情况，则回溯至主串中的第start+1个字符位置处，重新与模式P的字符进行比较。该算法效率较低。 代码123456789101112131415class Solution &#123; public int strStr(String haystack, String needle) &#123; int mainLen = haystack.length(); int subLen = needle.length(); if(needle.equals(\"\")) return 0;//注意模式字符串为空的情况 for(int i=0;i&lt;mainLen;i++)&#123; for(int j =0;j&lt;subLen;j++)&#123; if(!(i+j&lt;mainLen)) return -1;//主串下标超出 if(!(haystack.charAt(i+j)==needle.charAt(j))) break; else if(j == subLen-1) return i;//完全匹配，返回主串下标 &#125; &#125; return -1; &#125;&#125; 算法的复杂度为O[(i-j)j] MP算法思路 指针不回溯，利用已得到的“部分匹配”结果，将模式向右“滑动”若干位置后继续比较。 参考下面给出的示例：haystack ：&quot;cdnidnidsm&quot;needle：&quot;nidsm&quot;按照BF算法的思想，在比较haystack[2]和needle[0]时，两个字符相等，然而比较到haystack[5]和needle[3]的时候两个字符不等，于是回溯继续向后比较haystack[3]和needle[0]。可是既然能确定haystack[2]-haystack[4]与needle[0]-needle[2]是完全对应的。那么比较haystack[3]和needle[0]实际上相当于比较needle[1]和needle[0]。并且我们知道needle中前三个字符都是不同的。所以只需要从haystack[5]处继续跟needle[0]比较就行了。并且needle中字符的这些关系完全是一开始就可以确定的。 我们称记录模式字符串中各个字符之间关系的函数为失效函数。失效函数的定义域是模式字符串在“失配”前匹配的字符串个数。取值j属于0~Len(P)-1 获取失效函数的方法： 失效函数的取值k满足P0P1…Pk = Pj-kPj-k+1…Pj。如果不存在这个k值，取-1。 直观的看k就是模式字符串前j个字符是否存在前k+1位等于后k+1位。 nidsm的失效函数为： j 0 1 2 3 4 p(j) n i d s m k -1 -1 -1 -1 -1 再举一个例子，caatcat的失效函数为： j 0 1 2 3 4 5 6 p(j) c a a t c a t k -1 -1 -1 -1 0 1 -1 得到了失效函数后，即可使用MP算法进行匹配。假设在某一轮比较中，失配的情况发生在模式P的第j位，如果j=0，进行下一轮比较时，目标指针向后移动一位，模式的起始比较地址回到P0，其他情况进行下一轮比较时，目标指针不发生回溯，而模式P的起始比较地址为j-1对应的失效函数的值+1。 当然也可以把这个值提前算出来便成为了Next()函数： j 0 1 2 3 4 5 6 7 p(j) c a a t c a t Next(j) -1 0 0 0 0 1 2 0 Next(7)可以用于继续匹配（可能要求找出所有匹配的子字符串）。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; //获取next函数 public int[] next(String needle)&#123; int len = needle.length(); int i = 0; int j = -1; int[] next = new int[len+1]; next[0] = -1; while(i &lt; len)&#123; while( j &gt; -1 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j];//j会有一个传递的效果，必须前一个i对应的j是1，下一个i对应的j才能是2。如果遇到不同的字符则j清零 next[++i] = ++j; &#125; return next; &#125; public int strStr(String haystack, String needle) &#123; int mainLen = haystack.length(); int subLen = needle.length(); if(needle.equals(\"\")) return 0;//注意模式字符串为空的情况 if(mainLen&lt;subLen) return -1; int[] next = next(needle); int i = 0; int j = 0; while(j &lt; mainLen)&#123; while(i&gt;-1 &amp;&amp; needle.charAt(i) != haystack.charAt(j)) i = next[i]; i++; j++; if(i &gt;= subLen)&#123; return j-i; &#125; &#125; return -1; &#125;&#125; KMP算法思路在MP算法的基础上，还要避免最长前缀之后的那个字符不等于原来失配的那个字符。下面在已知mpNext表的情况下，给出建立kmpNext表的规则。这个规则分为四种情况： 如果mpNext[j] = 0且Pj = P0，则令kmpNext[j] = -1。 如果mpNext[j] = 0且Pj ≠ P0，则令kmpNext[j] = 0。 如果mpNext[j] ≠ 0且Pj ≠ PmpNext[j]，则令kmpNext[j] = mpNext[j]。 如果mpNext[j] ≠ 0且Pj = PmpNext[j]，则用mpNext[j]的值替换原来mpNext[j]中的j值，直到情况转换为前3种情况的一种，进而递归地求解kmpNext[j]。 j 0 1 2 3 4 5 6 7 p(j) c a a t c a t mpNext(j) -1 0 0 0 0 1 2 0 kmpNext(j) -1 0 0 0 -1 0 2 0 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; //获取kmpNext数组 public int[] next(String needle)&#123; int len = needle.length(); int i = 0; int j = -1; int[] next = new int[len+1]; next[0] = -1; while(i &lt; len-1)&#123; while( j &gt; -1 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j]; i++; j++; if(needle.charAt(i) == needle.charAt(j)) next[i] = next[j]; else next[i] = j; &#125; return next; &#125; public int strStr(String haystack, String needle) &#123; int mainLen = haystack.length(); int subLen = needle.length(); if(needle.equals(\"\")) return 0;//注意模式字符串为空的情况 if(mainLen&lt;subLen) return -1; int[] next = next(needle); int i = 0; int j = 0; while(j &lt; mainLen)&#123; while(i&gt;-1 &amp;&amp; needle.charAt(i) != haystack.charAt(j)) i = next[i]; i++; j++; if(i &gt;= subLen)&#123; return j-i; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode67-二进制求和","slug":"leetcode67-二进制求和","date":"2019-11-15T09:49:29.000Z","updated":"2019-11-15T10:08:54.588Z","comments":true,"path":"article/leetcode67-二进制求和/","link":"","permalink":"https://www.codetool.top/article/leetcode67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","excerpt":"","text":"原题给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100” 示例 2: 输入: a = “1010”, b = “1011”输出: “10101” 解法思想通过加法规则实现，应注意进位的处理和字符的处理。不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式： 第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转 第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位 代码 copy了@灵魂画师牧码（guanpengchn）的思路： 12345678910111213141516class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder ans = new StringBuilder(); int ca = 0;//进位值 for(int i = a.length() - 1, j = b.length() - 1;i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int sum = ca; //将数组长度不够的情况一般化，负数下标对应的值用0计算。 sum += i &gt;= 0 ? a.charAt(i) - '0' : 0; sum += j &gt;= 0 ? b.charAt(j) - '0' : 0; ans.append(sum % 2); ca = sum / 2;//得到进位 &#125; ans.append(ca == 1 ? ca : \"\");//如果最后进位值还为1则添加一位 return ans.reverse().toString();//反转字符串 &#125;&#125; 自己做的凌乱的思路： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public String addBinary(String a, String b) &#123; //获取两个字符串的长度和最大值最小值 int len_a = a.length(); int len_b = b.length(); int max,min; boolean carry = false;//进位标志 if( len_a &lt;= len_b )&#123; max = len_b; min = len_a; &#125;else&#123; max = len_a; min = len_b; &#125; char[] ret = new char[max]; for( int i = 0 ; i &lt; max ; i++ )&#123; char a_now = i&lt;len_a?a.charAt(len_a-1-i):'0'; char b_now = i&lt;len_b?b.charAt(len_b-1-i):'0'; //列举所有情况手动计算 if(a_now=='1'&amp;&amp;b_now=='1')&#123; ret[max-i-1] = carry?'1':'0'; carry = true; if(i==max-1)&#123; return \"1\"+ String.valueOf(ret);//如果当前为首位则在前面连接一个1 &#125; &#125;else if(a_now=='1'&amp;&amp;b_now=='0'||b_now=='1'&amp;&amp;a_now=='0')&#123; if(carry)&#123; ret[max-i-1] = '0'; if(i==max-1)&#123; return \"1\"+ String.valueOf(ret); &#125; &#125;else&#123; ret[max-i-1] = '1'; &#125; &#125;else if(a_now=='0'&amp;&amp;b_now=='0')&#123; ret[max-i-1] = carry?'1':'0'; carry = false; &#125; &#125; return String.valueOf(ret); &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode118-杨辉三角","slug":"leetcode118-杨辉三角","date":"2019-11-15T09:38:00.000Z","updated":"2019-11-15T09:48:01.286Z","comments":true,"path":"article/leetcode118-杨辉三角/","link":"","permalink":"https://www.codetool.top/article/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","excerpt":"","text":"原题给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[&nbsp;&nbsp;&nbsp;&nbsp;[1],&nbsp;&nbsp;&nbsp;[1,1],&nbsp;&nbsp;[1,2,1],&nbsp;[1,3,3,1],[1,4,6,4,1]] 解法思想根据上一行生成下一行，避免重复计算 代码12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;Integer&gt; row = new ArrayList(); List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int n = 0;n&lt;numRows;n++)&#123; row = getRow(n+1,row); ret.add(row); &#125; return ret; &#125; //n:第n行，nums：上一行（n-1行）的列表 public List&lt;Integer&gt; getRow(int n,List&lt;Integer&gt; nums)&#123; List&lt;Integer&gt; ret = new ArrayList(); ret.add(1);//第一个1不需要计算 if(n==1)&#123;//第一行直接返回 return ret; &#125; for(int i=1;i&lt;(n+1)/2;i++)&#123;//由上一行的数相加得到结果 ret.add(nums.get(i-1)+nums.get(i)); &#125; int size = n/2; for(int i=0;i&lt;size;i++)&#123;//镜像处理 ret.add(ret.get(size-i-1)); &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode54-螺旋矩阵","slug":"leetcode54-螺旋矩阵","date":"2019-11-15T09:19:53.000Z","updated":"2019-11-15T09:33:18.968Z","comments":true,"path":"article/leetcode54-螺旋矩阵/","link":"","permalink":"https://www.codetool.top/article/leetcode54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/","excerpt":"","text":"原题给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,6,9,8,7,4,5] 解法思想找拐点规律和移动规律： 当横坐标x等于纵坐标y+1时，且之前是向上移动的，拐点向右。 当横坐标x加纵坐标y等于列数减一，且之前是向右移动的，拐点向下。 当行数和横坐标x之差等于列数与纵坐标y之差时，且之前是向下移动的，拐点向左。 当横坐标x加纵坐标y等于行数减一，且之前是向左移动的，拐点向上。 当不满足上述拐点情况时，坐标会随着之前的运动方向继续运动。可以设置代表四个方向运动状态的布尔值来记录运动状态。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; if(matrix==null) return null; int x = matrix.length; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); if(x==0) return ret; int y = matrix[0].length;//获取二维数组的行数和列数，排除null和空情况。 int x_now=0,y_now=0; int size = x*y; //代表向各个方向移动的布尔值。 boolean toRight=true,toLeft=false,toTop=false,toBottom=false; for(int i=0;i&lt;size;i++) &#123; ret.add(matrix[x_now][y_now]); if(x_now==y_now+1&amp;&amp;toTop) &#123;//拐向右 toRight=true; toTop=false; &#125;else if(y_now==y-x_now-1&amp;&amp;toRight) &#123;//拐向下 toBottom=true; toRight=false; &#125;else if(x-x_now==y-y_now&amp;&amp;toBottom)&#123;//拐向左 toLeft=true; toBottom=false; &#125;else if(x_now==x-y_now-1&amp;&amp;toLeft) &#123;//拐向上 toTop=true; toLeft=false; &#125; //移动坐标 if(toRight) y_now++; if(toLeft) y_now--; if(toTop) x_now--; if(toBottom) x_now++; &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode498-对角线遍历","slug":"leetcode498-对角线遍历","date":"2019-11-14T07:49:09.000Z","updated":"2019-11-15T09:20:36.182Z","comments":true,"path":"article/leetcode498-对角线遍历/","link":"","permalink":"https://www.codetool.top/article/leetcode498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/","excerpt":"","text":"这是一个Z字形编排问题，JEPG的编码过程中也会用到。 原题给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,4,7,5,3,6,8,9]解释: 说明: 给定矩阵中的元素总数不会超过 100000 。 解法思想找拐点的规律： 当横坐标x为0，纵坐标y是偶数，且y不是最后一列的时候，拐点向右。 当横坐标x为最后一行，若行数为偶数且纵坐标y为奇数或行数为奇数但纵坐标y为偶数时，拐点向右。 当纵坐标y为0，横坐标x是奇数，且x不是最后一行的时候，拐点向下。 当纵坐标y为最后一列，若列数为偶数且横坐标x为偶数或列数为奇数但横坐标x为奇数时，拐点向右。 其他情况，当横坐标x为偶数且纵坐标y为奇数或x为奇数且y为偶数的时候，拐点向左下 当横坐标x为偶数且纵坐标y为偶数或x为奇数且y为奇数的时候，拐点向右上 代码123456789101112131415161718192021222324252627282930class Solution &#123; public int[] findDiagonalOrder(int[][] matrix) &#123; //获取二维数组的长宽、大小 int x = matrix.length; if(x == 0) return new int[0]; int y = matrix[0].length; int size = x*y; int x_now=0,y_now=0;//落点位置 int[] ret = new int[size];//用于存储并返回的一维数组 int i = 0; while( x_now &lt; x &amp;&amp; y_now &lt; y )&#123; ret[i] = matrix[x_now][y_now]; //存入元素 i++; if((x_now==0&amp;&amp;y_now%2==0&amp;&amp;y_now!=y-1)||(x_now == x-1&amp;&amp;(y_now+x)%2==0))&#123;//向右 y_now += 1; &#125;else if((y_now==0&amp;&amp;x_now%2==1&amp;&amp;x_now!=x-1)||(y_now == y-1&amp;&amp;(x_now+y)%2==1))&#123;//向下 x_now += 1; &#125; else if((x_now+y_now)%2==0)&#123;//向右上 y_now +=1; x_now -=1; &#125;else if((x_now+y_now)%2==1)&#123;//向左下 y_now -=1; x_now +=1; &#125; &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode66-加一","slug":"leetcode66-加一","date":"2019-11-14T06:18:26.000Z","updated":"2019-11-15T09:48:36.673Z","comments":true,"path":"article/leetcode66-加一/","link":"","permalink":"https://www.codetool.top/article/leetcode66-%E5%8A%A0%E4%B8%80/","excerpt":"","text":"原题给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 示例 2: 输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字4321。 解法思想根据加法规则进行计算，应注意进位的处理和全是9的特殊情况 代码 迭代 123456789101112131415161718class Solution &#123; public int[] plusOne(int[] digits) &#123; for(int i = digits.length-1;i&gt;=0;i--)&#123; if(digits[i]!=9) &#123;//不需进位 digits[i] += 1; break;//什么时候不需进位即可退出 &#125;else &#123; if (i == 0) &#123;//首位需进位的特殊情况，需分配一个大一位的数组 int[] ret = new int[digits.length+1]; ret[0] = 1; return ret; &#125; digits[i] = 0;//不是首位，需进位 &#125; &#125; return digits; &#125;&#125; 递归 1234567891011121314151617181920class Solution &#123; public int[] plusOne(int[] digits) &#123; return addOneAtPos(digits, digits.length-1); &#125; private int[] addOneAtPos(int[] num, int pos)&#123;//在pos位上加一 if(num[pos]!=9)&#123;//不需进位 num[pos]+=1; return num;//什么时候不需进位即可返回 &#125; else if(pos&gt;0)&#123;//不是首位，需进位 num[pos]=0; return addOneAtPos(num, pos-1); &#125; else &#123;//首位需进位的特殊情况，需分配一个大一位的数组 int length = num.length; int[] newNum = new int[length+1]; newNum[0]=1; return newNum; &#125; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"递归","slug":"递归","permalink":"https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"}]},{"title":"leetcode724-寻找数组的中心索引","slug":"leetcode724-寻找数组的中心索引","date":"2019-11-13T12:15:00.000Z","updated":"2019-11-15T09:20:47.137Z","comments":true,"path":"article/leetcode724-寻找数组的中心索引/","link":"","permalink":"https://www.codetool.top/article/leetcode724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/","excerpt":"","text":"原题给定一个整数类型的数组nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1: 输入:nums = [1, 7, 3, 6, 5, 6]输出: 3解释:索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 示例 2: 输入:nums = [1, 2, 3]输出: -1解释:数组中不存在满足此条件的中心索引。 说明: nums的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 解法思想避免重复计算，先计算完数组所有元素之和，再划分为两数之和的问题。 代码1234567891011121314151617181920212223242526class Solution &#123; public int pivotIndex(int[] nums) &#123; int i; int frontRet = 0, endRet = 0; //计算所有元素总和 for (int k = 0; k &lt; nums.length; k++) &#123; endRet += nums[k]; &#125; //从左向右试探，计算两部分的值 for (i = 0; i &lt; nums.length; i++) &#123; endRet -= nums[i]; if (frontRet == endRet) &#123; break; &#125; frontRet += nums[i]; &#125; if ((i &lt; 0) || (i &gt;= nums.length)) &#123; i = -1; &#125; return i; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Collection接口研究","slug":"Collection接口研究","date":"2019-11-13T11:24:33.000Z","updated":"2019-11-22T12:03:39.185Z","comments":true,"path":"article/Collection接口研究/","link":"","permalink":"https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/","excerpt":"","text":"以下内容基于jdk1.8 接口Collection分析 img 该接口实现了接口Iterable 方法： int size();返回元素的个数 boolean isEmpty();返回是否为空 boolean contains(Object o);返回是否包含某个对象抛出异常： @throws ClassCastException 参数不兼容 @throws NullPointerException 参数是null，并且容器不允许包含null元素 Object[] toArray();返回所有元素组成的一个数组数组是重新分配空间并创建的，它的元素不会由该容器维护，原文： The returned array will be “safe” in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. T[] toArray(T[] a);如果给定的数组大小能容纳该容器所有元素，则返回到给定数组中，否则会新分配一个可以容纳所有元素的数组并返回。 12345List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();Integer[] a = new Integer[2];list.add(3);list.add(5);list.toArray(a); // a = &#123;3,5&#125; 抛出异常： @throws ArrayStoreException 给定的数组运行类型不是该容器运行类型的超类 @throws NullPointerException 给定的数组是null boolean add(E e);确保该容器包含该指定的元素，如果因为这个操作改变了容器内的元素返回true，如果该容器已经有了该元素且不允许包含重复的元素则返回false 抛出异常： @throws UnsupportedOperationException 该容器不支持这个操作 @throws ClassCastException 给定的元素不能添加进容器中 @throws NullPointerException 参数是null，并且容器不允许包含null元素 @throws IllegalArgumentException 给定的元素的某些属性决定了它不能被添加进该容器中 @throws IllegalStateException 由于某些限制该时间不能添加该元素 boolean remove(Object o);移除某个元素抛出异常： @throws ClassCastException @throws NullPointerException @throws UnsupportedOperationException boolean containsAll(Collection&lt;?&gt; c)如果该容器包含给定的容器中的所有元素，返回true抛出异常： @throws ClassCastException @throws NullPointerException boolean addAll(Collection&lt;? extends E&gt; c)将给定容器中的所有元素插入到该容器中抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException @throws IllegalArgumentException @throws IllegalStateException boolean removeAll(Collection&lt;?&gt; c)将该容器和给定容器中共有的元素从该容器中删除抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException default boolean removeIf(Predicate&lt;? super E&gt; filter)Predicate是JAVA8新增的一个函数式接口（指如果填写lambda表达式则默认实现Predicate的test方法），这个方法删除所有符合条件的元素，如果成功返回true? super E指的是E或E的父类默认实现： 123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 调用实例： 1234Integer[] nums = &#123;1,2,3,4,5,6&#125;;ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(nums));list.removeIf(num-&gt;num&gt;3?true:false);//删除list中大于3的元素//这里的lambda表达式是简化的写法，将lambda表达式完整的写法是list.removeIf((Integer num)-&gt;&#123;return num&gt;3?true:false;&#125;); 抛出异常： @throws NullPointerException @throws UnsupportedOperationException 这个元素不能被删除 boolean retainAll(Collection&lt;?&gt; c);仅保留给定集合中的元素，删除其他元素。 抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException void clear();移除所有元素。 抛出异常： @throws UnsupportedOperationException default Stream stream();返回一个序列流。默认实现： 123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; default Stream parallelStream();返回一个并行流。默认实现： 123default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.codetool.top/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.codetool.top/tags/jdk/"},{"name":"源码研究","slug":"源码研究","permalink":"https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"},{"name":"集合","slug":"集合","permalink":"https://www.codetool.top/tags/%E9%9B%86%E5%90%88/"}]},{"title":"23种设计模式归纳","slug":"23种设计模式归纳","date":"2019-11-08T10:05:23.000Z","updated":"2019-11-13T12:15:57.814Z","comments":true,"path":"article/23种设计模式归纳/","link":"","permalink":"https://www.codetool.top/article/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%BA%B3/","excerpt":"","text":"参考文档 23种设计模式全解析 - codeTao - 博客园 设计模式（创建型） - 八一鱼 - 博客园 设计模式（结构型） - 八一鱼 - 博客园 代理模式和装饰者模式的区别 - 夜的第八章 - 博客园 简说设计模式——享元模式 - JAdam - 博客园 设计模式的分类 类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来；对象模式处理对象之间的关系，运行时发生变化，属于动态关系。 创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型模式 策略模式 模板方法模式 观察者模式 迭代器模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 设计模式遵守的设计原则也是类的设计遵守的原则 单一职责原则SRP每个类只做一件事，但该原则也不适用于聚合类。 聚合类需要优先使用对象组合，而不是类继承 里氏替换原则LSP 子类的对象提供了父类的所有行为，且加上子类额外的一些东西（可以是功能，也可以是属性） 当程序基于父类实现时，如果将子类替换父类而程序不需要修改，则说明符合LSP原则 子类必须能替换成它们的父类 依赖倒置原则DIP也叫依赖反转原则。 高层模块不应该直接依赖低层模块，两者都应该依赖抽象层。 抽象不能依赖细节，细节必须依赖抽象。 接口隔离原则ISP 客户端不应该被强迫去依赖它们并不需要的接口 不满足ISP的类应该拆分成多个接口， 通过一个抽象类去实现它们，再去继承这个抽象父类。 开闭原则 对拓展开放，对修改封闭 对使用者修改关闭，对提供者拓展开放 创建型模式解析 在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。 工厂方法模式（类） 创建一个工厂接口和创建多个工厂实现类 抽象工厂模式（对象） 区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 单例模式（对象） 在一个JVM中，该类只有一个对象实例存在。 12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 多线程下的优化： 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 原理： JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕 建造者模式（对象） 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 Director的作用： 隔离客户与生产过程。 负责控制产品的生成过程。 1234567891011121314151617181920public class Meal &#123; private String food; private String drink; public String getFood() &#123; return food; &#125; public void setFood(String food) &#123; this.food = food; &#125; public String getDrink() &#123; return drink; &#125; public void setDrink(String drink) &#123; this.drink = drink; &#125;&#125; 12345678910public abstract class MealBuilder &#123; Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal()&#123; return meal; &#125;&#125; 12345678910public class MealA extends MealBuilder&#123; public void buildDrink() &#123; meal.setDrink(\"可乐\"); &#125; public void buildFood() &#123; meal.setFood(\"薯条\"); &#125;&#125; 123456789101112131415161718public class KFCWaiter &#123; private MealBuilder mealBuilder; public KFCWaiter(MealBuilder mealBuilder) &#123; this.mealBuilder = mealBuilder; &#125; public Meal construct()&#123; //准备食物 mealBuilder.buildFood(); //准备饮料 mealBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return mealBuilder.getMeal(); &#125;&#125; 原型模式（对象） 有些对象是需要频繁创建的，用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的同类型的对象，分为浅克隆和深克隆，浅克隆只复制拷贝的对象，不复制引用的对象，即成员对象不复制；深克隆，引用也同样复制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); /* super.clone()是浅复制 */ return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 结构型模式解析结构型模式主要用于处理类和对象的组合 适配器模式（类和对象） 将一个接口转换成客户希望的另一个接口，从而使接口不兼容的那些类可以在一起工作。 类的适配器模式 通过一个具体的类，将适配者适配到目标接口当中 12345public class Source &#123; public void method1() &#123; System.out.println(\"this is original method!\"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; &#125; 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 对象的适配器模式 一个适配器可以将多个不同的适配者适配到同一目标 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 装饰者模式（对象） 给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例 12345678910111213141516171819202122232425262728//Sourceablepublic interface Sourceable &#123; public void method(); &#125; //Sourcepublic class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; //Decoratorpublic class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println(\"before decorator!\"); source.method(); System.out.println(\"after decorator!\"); &#125; &#125; 我寻思有点像servlet的过滤器 代理模式（对象） 多一个代理类出来，替原对象进行一些操作 12345678910111213141516171819202122232425262728293031public interface Sourceable &#123; public void method(); &#125; public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println(\"after proxy!\"); &#125; private void before() &#123; System.out.println(\"before proxy!\"); &#125; &#125; 装饰者模式和代理模式的区别： 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 外观模式（对象） 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用 外观模式包含如下角色： Facade: 外观角色 SubSystem:子系统角色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//CPUpublic class CPU &#123; public void startup()&#123; System.out.println(\"cpu startup!\"); &#125; public void shutdown()&#123; System.out.println(\"cpu shutdown!\"); &#125; &#125; //Memorypublic class Memory &#123; public void startup()&#123; System.out.println(\"memory startup!\"); &#125; public void shutdown()&#123; System.out.println(\"memory shutdown!\"); &#125; &#125; //Diskpublic class Disk &#123; public void startup()&#123; System.out.println(\"disk startup!\"); &#125; public void shutdown()&#123; System.out.println(\"disk shutdown!\"); &#125; &#125; //Facadepublic class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println(\"start the computer!\"); cpu.startup(); memory.startup(); disk.startup(); System.out.println(\"start computer finished!\"); &#125; public void shutdown()&#123; System.out.println(\"begin to close the computer!\"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(\"computer closed!\"); &#125; &#125; 桥接模式（对象） 把事物和其具体实现分开，使他们可以各自独立的变化。 将抽象化与实现化解耦，使得二者可以独立变化 12345678910111213141516171819202122232425262728293031323334353637383940public interface Sourceable &#123; public void method(); &#125; public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the first sub!\"); &#125; &#125; public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the second sub!\"); &#125; &#125;public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 组合模式（对象） 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，树等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree(\"A\"); TreeNode nodeB = new TreeNode(\"B\"); TreeNode nodeC = new TreeNode(\"C\"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(\"build the tree finished!\"); &#125; &#125; 享元模式（对象） 实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 其中，Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现；ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中；FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。 123456789101112131415161718192021222324public abstract class Flyweight &#123; //内部状态 public String intrinsic; //外部状态 protected final String extrinsic; //要求享元角色必须接受外部状态 public Flyweight(String extrinsic) &#123; this.extrinsic = extrinsic; &#125; //定义业务操作 public abstract void operate(int extrinsic); public String getIntrinsic() &#123; return intrinsic; &#125; public void setIntrinsic(String intrinsic) &#123; this.intrinsic = intrinsic; &#125;&#125; 1234567891011121314public class ConcreteFlyweight extends Flyweight &#123; //接受外部状态 public ConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; //根据外部状态进行逻辑处理 @Override public void operate(int extrinsic) &#123; System.out.println(\"具体Flyweight:\" + extrinsic); &#125;&#125; 123456789101112public class UnsharedConcreteFlyweight extends Flyweight &#123; public UnsharedConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; @Override public void operate(int extrinsic) &#123; System.out.println(\"不共享的具体Flyweight:\" + extrinsic); &#125;&#125; 1234567891011121314151617181920212223public class FlyweightFactory &#123; //定义一个池容器 private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;&gt;(); //享元工厂 public static Flyweight getFlyweight(String extrinsic) &#123; Flyweight flyweight = null; if(pool.containsKey(extrinsic)) &#123; //池中有该对象 flyweight = pool.get(extrinsic); System.out.print(\"已有 \" + extrinsic + \" 直接从池中取----&gt;\"); &#125; else &#123; //根据外部状态创建享元对象 flyweight = new ConcreteFlyweight(extrinsic); //放入池中 pool.put(extrinsic, flyweight); System.out.print(\"创建 \" + extrinsic + \" 并从池中取出----&gt;\"); &#125; return flyweight; &#125;&#125; 行为型模式解析行为型模式主要用于描述类或对象的交互以及职责分配 解释器模式（类） 主要应用在OOP开发中的编译器的开发中 给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子 ​ 模板方法模式（类） 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法中某些特定步骤 策略模式（对象） 定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化 观察者模式（对象） 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 123public interface Observer &#123; public void update(); &#125; 1234567public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer1 has received!\"); &#125; &#125; 12345678public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer2 has received!\"); &#125; &#125; 1234567891011121314public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; 12345678910111213141516171819202122public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; //提醒应当在抽象类中就实现 @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; 123456789public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println(\"update self!\"); notifyObservers(); &#125; &#125; 迭代器模式（对象） 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。 责任链模式（对象） 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求 123public interface Handler &#123; public void operator(); &#125; 12345678910111213public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125; &#125; 12345678910111213141516public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name+\"deal!\"); if(getHandler()!=null)&#123; getHandler().operator(); &#125; &#125; &#125; 命令模式（对象） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 123public interface Command &#123; public void exe(); &#125; 12345678910111213public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125; &#125; 12345public class Receiver &#123; public void action()&#123; System.out.println(\"command received!\"); &#125; &#125; 123456789101112public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.exe(); &#125; &#125; 备忘录模式（对象） 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态 123456789101112131415161718192021222324public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; 12345678910111213141516public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 12345678910111213141516public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; 状态模式（对象） 允许一个对象在其内部状态改变时能够改变它的行为 1234567891011121314151617181920public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println(\"execute the first opt!\"); &#125; public void method2()&#123; System.out.println(\"execute the second opt!\"); &#125; &#125; 123456789101112131415161718192021222324public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; if (state.getValue().equals(\"state1\")) &#123; state.method1(); &#125; else if (state.getValue().equals(\"state2\")) &#123; state.method2(); &#125; &#125; &#125; 访问者模式（对象） 表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 适用于：给一个类添加新功能，但为了兼容性考虑或其他原因不想破坏这个类 123public interface Visitor &#123; public void visit(Subject sub); &#125; 1234567public class MyVisitor implements Visitor &#123; @Override public void visit(Subject sub) &#123; System.out.println(\"visit the subject：\"+sub.getSubject()); &#125; &#125; 1234public interface Subject &#123; public void accept(Visitor visitor); public String getSubject(); &#125; 123456789101112public class MySubject implements Subject &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; @Override public String getSubject() &#123; return \"love\"; &#125; &#125; 中介者模式（对象） 用一个中介对象来封装一系列的对象交互。它使各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 1234public interface Mediator &#123; public void createMediator(); public void workAll(); &#125; 12345678910111213141516171819202122232425public class MyMediator implements Mediator &#123; private User user1; private User user2; public User getUser1() &#123; return user1; &#125; public User getUser2() &#123; return user2; &#125; @Override public void createMediator() &#123; user1 = new User1(this); user2 = new User2(this); &#125; @Override public void workAll() &#123; user1.work(); user2.work(); &#125; &#125; 1234567891011121314public abstract class User &#123; private Mediator mediator; public Mediator getMediator()&#123; return mediator; &#125; public User(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void work(); &#125; 1234567891011public class User1 extends User &#123; public User1(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user1 exe!\"); &#125; &#125; 1234567891011public class User2 extends User &#123; public User2(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user2 exe!\"); &#125; &#125; 12345678public class Test &#123; public static void main(String[] args) &#123; Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); &#125; &#125;","categories":[{"name":"中间件/软件设计","slug":"中间件-软件设计","permalink":"https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.codetool.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"我的博客搬家啦","slug":"hello-world","date":"2019-11-08T09:05:23.000Z","updated":"2019-11-13T12:22:54.725Z","comments":true,"path":"article/hello-world/","link":"","permalink":"https://www.codetool.top/article/hello-world/","excerpt":"","text":"今天弃了wordpress的坑搬来hexo啦。和gitbook差不多的用法，很快就上手了呢。再也不用忍受wordpress一堆不仅没用还加载龟速的资源了奥里给！！！","categories":[{"name":"日常/随笔","slug":"日常-随笔","permalink":"https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"网站日志","slug":"网站日志","permalink":"https://www.codetool.top/tags/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"}]},{"title":"在线运行C++、java、python代码的小项目实现","slug":"在线运行C++、java、python代码的小项目实现","date":"2019-08-13T12:06:57.000Z","updated":"2019-11-13T12:16:20.231Z","comments":true,"path":"article/在线运行C++、java、python代码的小项目实现/","link":"","permalink":"https://www.codetool.top/article/%E5%9C%A8%E7%BA%BF%E8%BF%90%E8%A1%8CC++%E3%80%81java%E3%80%81python%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本网站在2019年8月12日之前用的代码演示功能是借用了 https://tool.lu/coderunner/ 的在线运行代码工具，在此致谢。 有一段时间这个工具突然失效了，我就在想能不能自己模仿着做一个类似的出来，简单分析了一下就想挑战一下自己，然后就开始动手了。 做出来的成果链接：点击此处 做的过程中查阅了很多网络资料，现整理如下： 需求分析：前端为一个实用的代码编辑器，通过ajax请求将写好的代码提交给服务器，服务器编译运行后把输出结果送回客户端显示。 其中使用的代码编辑器：CodeMirror，现在类似的工具使用的应该都是这款功能强大，可以自定样式的代码编辑器，官网： https://codemirror.net/ CodeMirror搭建前端界面先从官网下载下来CodeMirror的压缩包，解压之后得到下图目录 要在html中创建一个CodeMirror编辑器，必须添加的css和js文件是 12&lt;link href=./codemirror-5.48.2/lib/codemirror.css rel=stylesheet/&gt;&lt;script src=./codemirror-5.48.2/lib/codemirror.js&gt;&lt;/script&gt; (5.48.2为版本号，因人而异) 然后需要添加需要编辑的语言相关的js文件，可以在mode目录下找到，这里我用了两个文件： 实现JAVA和C++代码高亮（这个文件可以实现C，C++，JAVA，C#等语言）： 1&lt;script src=./codemirror-5.48.2/mode/clike/clike.js&gt;&lt;/script&gt; 实现python的代码高亮： 1&lt;script src=./codemirror-5.48.2/mode/python/python.js&gt;&lt;/script&gt; 需要更改编辑器主题样式的可以在theme目录下找到对应的主题css文件添加进去，我觉得默认主题就很好看了就没用其他主题。 为了实现括号匹配和代码折叠功能，还要添加的文件有： 123456&lt;link rel=stylesheet href=./codemirror-5.48.2/addon/fold/foldgutter.css/&gt;&lt;script src=./codemirror-5.48.2/addon/fold/foldcode.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/foldgutter.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/brace-fold.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/comment-fold.js&gt;&lt;/script&gt; 创建编辑器的过程： 在html中使用一个textarea占位，配置好id： 1&lt;textarea id=code name=code&gt;&lt;/textarea&gt; 通过对应的js代码创建编辑器： 123456789101112var editor = CodeMirror.fromTextArea(document.getElementById(code), &#123; mode: text/x-java, //实现Java代码高亮 //mode: text/x-c++src, //实现C++代码高亮 //mode: text/x-python, //实现Python代码高亮 indentUnit:4,//以四个空格的长度缩进 indentWithTabs: true,//以tab代替空格缩进 lineNumbers: true, //显示行号 lineWrapping: true, foldGutter: true, //代码折叠 gutters: [CodeMirror-linenumbers, CodeMirror-foldgutter], matchBrackets: true //括号匹配 &#125;); 这里需要什么语言高亮需要在官网找到对应语言的 MIME types ，写在mode参数中 其他相关js函数： 编辑器的大小通过 editor.setSize(width, height) 方法设置 获取编辑器内的代码：editor.getValue() 设置编辑器内的代码：editor.setValue() 设置编辑器的配置选项: editor.setOption() 最终搭配上bootstrap样式做出来的效果是这样的： js实现前端逻辑使用JQuery简化js的写法 关键代码： 切换语言事件 1234567891011121314//选择语言事件$(\"#lang\").on('change', () =&gt; &#123; lang = $(\"#lang\").val() if (lang == 'java') &#123; editor.setOption(\"mode\", \"text/x-java\") editor.setValue(javacode) &#125; else if (lang == \"cpp\") &#123; editor.setOption(\"mode\", \"text/x-c++src\") editor.setValue(cppcode) &#125; else if (lang == \"python\") &#123; editor.setOption(\"mode\", \"text/x-python\") editor.setValue(pythoncode) &#125;&#125;) 发送POST请求 1234567891011121314151617181920212223242526272829$(function()&#123; //点击运行按钮后的事件 $(\"#run\").on(\"click\",()=&gt;&#123; var codesrc = editor.getValue(); //给源代码编码 var codeEncoded = encodeURIComponent(codesrc); $(\"output\").html = 'console&gt;&gt;' + '正在努力执行中...'; //发出post请求 $.post( \"/runcode.php\", &#123; lang:lang,codesrc:codeEncoded &#125;, (data)=&gt;&#123; var outputs = data.output; var status1 = data.status1; var output = ''; //拼接输出结果 if(status1 !== 1)&#123; for(var i in outputs) &#123; output = output + outputs[i] + '&lt;br/&gt;'; &#125;data &#125;else&#123; var outputs1 = data.output1; for(var i in outputs1) &#123; output = output + outputs1[i] + '&lt;br/&gt;'; &#125; &#125; $(\"output\").html = 'console&gt;&gt;' + output; &#125;, \"json\"); &#125;)&#125;); 注： 由于代码中可能出现 + 或 &amp; 等符号，其在post的请求中经过urlencode会分别被解析为空格和参数连接符，需先将代码源码用js的encodeURIComponent()函数编码，传递到php后端后再用rawurldecode()函数进行解码操作。 php实现后端php的任务是在服务器上运行代码，核心的思想是将接收到的代码写入文件，使用各种环境去执行，并返回结果 其中用到了exec函数 具体参阅 【php】php使用exec总结 做的时候遇到了个问题：php在调用exec执行gcc命令时，会出现各种毛病，例如ld链接器找不到，后来发现原因是php不会使用系统设置的环境变量，在php文件开头添加这样一句话就能解决问题： 1putenv(PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin);//设置环境变量","categories":[{"name":"项目总结","slug":"项目总结","permalink":"https://www.codetool.top/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.codetool.top/tags/php/"},{"name":"CodeMirror","slug":"CodeMirror","permalink":"https://www.codetool.top/tags/CodeMirror/"}]}]}