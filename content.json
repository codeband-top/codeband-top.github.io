{"meta":{"title":"代码段小站","subtitle":"CodeBand CodeTool - 个人计算机类练手小博客","description":"","author":"Rhett Peng","url":"https://www.codetool.top","root":"/"},"pages":[{"title":"关于","date":"2019-11-08T13:55:48.722Z","updated":"2019-11-08T13:55:48.722Z","comments":false,"path":"about/index.html","permalink":"https://www.codetool.top/about/index.html","excerpt":"","text":"@column-2{ 很帅的一张图 曾用logo } @column-2{ @card{ 神秘的站长现南昌大学软件学院大三学生，学习作风差，不务正业.喜欢折腾新奇的东西，学习黑科技正在由一只小菜鸡成为一只大菜鸡的转变的路上（其实我也不知道小菜鸡为啥要写博客，反正也没人看） } @card{ 关于小站代码段小站（CodeBand）创建于2018年8月19日，闲时在这里随便写点东西。可能是脑海里的一些闪光点，也可能是某一天的学习内容的记录，更多的是有关编程方面的、我觉得有意义记下来的一些知识。也希望这个网站能伴随我从编程新手小白成长为一个不算太小白的小白? } } @timeline{ 2019@item{ 11月8日抛弃wordpress，使用hexo重新搭建博客，完全搬至国内服务器 } @item{ 9月6日新服务器域名通过备案，使用国内服务器反向代理 } @item{ 8月19日更换wordpress主题 } 2018@item{ 8月19日使用wordpress搭建了第一版博客写下了我的第一篇博客《Java抽象类和接口的区别》 } }"},{"title":"在线写代码","date":"2019-11-08T14:16:45.000Z","updated":"2019-11-12T11:58:05.665Z","comments":true,"path":"runcode/index.html","permalink":"https://www.codetool.top/runcode/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-08T11:01:30.613Z","updated":"2019-11-08T11:01:30.613Z","comments":false,"path":"tags/index.html","permalink":"https://www.codetool.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-08T11:01:26.614Z","updated":"2019-11-08T11:01:26.614Z","comments":false,"path":"categories/index.html","permalink":"https://www.codetool.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"AbstractCollection源码分析","slug":"AbstractCollection源码分析","date":"2019-11-18T13:40:38.000Z","updated":"2019-11-18T14:54:24.316Z","comments":true,"path":"article/AbstractCollection源码分析/","link":"","permalink":"https://www.codetool.top/article/AbstractCollection%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"上次谈到了Collection接口研究 这次来看看其中的一个子类，但也是个抽象类：AbstractCollection。相比Collection接口并没有新增公开方法，但它提供了许多方法的默认实现。 public boolean contains(Object o);提供了一个默认实现： 12345678910111213public boolean contains(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o==null) &#123; while (it.hasNext()) if (it.next()==null) return true; &#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) return true; &#125; return false;&#125; 很容易理解，也很依赖于iterator()和equals()方法的实现 public boolean isEmpty();123public boolean isEmpty() &#123; return size() == 0;&#125; 依赖于size()方法的实现 public Object[] toArray();1234567891011public Object[] toArray() &#123; // Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); &#125; return it.hasNext() ? finishToArray(r, it) : r;&#125; 注意该实现判断了iterator遍历的元素个数可能跟size()的结果不同的情况。并且以iterator遍历的所有元素为准。 private static T[] finishToArray(T[] r, Iterator&lt;?&gt; it);是toArray()函数调用的一个私密静态方法，它将it迭代器遍历的所有元素存入一个数组，并且不依赖size()的实现，可以给传入的数组扩容。 12345678910111213141516private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123; int i = r.length; while (it.hasNext()) &#123; int cap = r.length;//容量capacity的概念 if (i == cap) &#123; int newCap = cap + (cap &gt;&gt; 1) + 1;// n+n/2+1扩容 // overflow-conscious code if (newCap - MAX_ARRAY_SIZE &gt; 0) newCap = hugeCapacity(cap + 1); //新容量等于Integer.MAX_VALUE或MAX_ARRAY_SIZE r = Arrays.copyOf(r, newCap); &#125; r[i++] = (T)it.next(); &#125; // trim if overallocated return (i == r.length) ? r : Arrays.copyOf(r, i);&#125; private static int hugeCapacity(int minCapacity);是finishToArray()函数调用的用于容量逼近Integer.MAX_VALUE给数组扩容的方法 123456789private static int hugeCapacity(int minCapacity) &#123; //超出int范围 if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError (\"Required array size too large\"); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; public boolean add(E e);123public boolean add(E e) &#123; throw new UnsupportedOperationException();&#125; 不允许单个添加元素。 public boolean remove(Object o);12345678910111213141516171819public boolean remove(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o==null) &#123; while (it.hasNext()) &#123; if (it.next()==null) &#123; it.remove(); return true; &#125; &#125; &#125; else &#123; while (it.hasNext()) &#123; if (o.equals(it.next())) &#123; it.remove(); return true; &#125; &#125; &#125; return false;&#125; 注意null要分开来判断，因为null不能被equals()调用删除的方式是通过迭代器的remove()方法 public boolean containsAll(Collection&lt;?&gt; c);123456public boolean containsAll(Collection&lt;?&gt; c) &#123; for (Object e : c) if (!contains(e)) return false; return true;&#125; 循环调用contains()方法判断 public boolean addAll(Collection&lt;? extends E&gt; c)1234567public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified;&#125; 这个操作不能保证所有元素都被添加成功了，这依赖于add()方法的实现，但只要有一个元素被添加成功了，就返回true。 public boolean removeAll(Collection&lt;?&gt; c)123456789101112public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) &#123; if (c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; 同理，该操作也不能保证所有元素都被移除成功了，但只要有一个元素被移除成功了，就返回true。 public boolean retainAll(Collection&lt;?&gt; c)123456789101112public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; if (!c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; 和removeAll()的实现相反，将c中含有的元素保留了下来。 public void clear();1234567public void clear() &#123; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; it.next(); it.remove(); &#125;&#125; 移除所有元素。 public String toString()123456789101112131415public String toString() &#123; Iterator&lt;E&gt; it = iterator(); if (! it.hasNext()) return \"[]\"; StringBuilder sb = new StringBuilder();//sb sb.append('['); for (;;) &#123; E e = it.next(); sb.append(e == this ? \"(this Collection)\" : e); if (! it.hasNext()) return sb.append(']').toString(); sb.append(',').append(' '); &#125;&#125; 以[*,*,*...]的形式输出字符串，还考虑到了元素可能是它本身的情况","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.codetool.top/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.codetool.top/tags/jdk/"},{"name":"源码研究","slug":"源码研究","permalink":"https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"}]},{"title":"leetcode561-数组拆分I","slug":"leetcode561-数组拆分I","date":"2019-11-18T11:59:58.000Z","updated":"2019-11-18T12:12:44.777Z","comments":true,"path":"article/leetcode561-数组拆分I/","link":"","permalink":"https://www.codetool.top/article/leetcode561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/","excerpt":"","text":"原题给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 输入：[1,4,3,2]输出： 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 解法思想通过观察发现，最后总和应该是所有数排完序后偶数下标的元素的值的总和。 代码123456789101112class Solution &#123; public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int i = 0; int sum = 0; while(i&lt;nums.length)&#123; sum+=nums[i]; i+=2; &#125; return sum; &#125;&#125; 还有一种排序方法：因为已知数的范围都是在[-10000, 10000]中，可以利用额外的空间排序。这种方法由于排序更快，时间复杂度较低，但只适用于数值范围已知且对空间复杂度要求不高的情况。 1234567891011121314public class Solution &#123; public int arrayPairSum(int[] nums) &#123; int[] arr = new int[20001]; int lim = 10000; for (int num: nums) arr[num + lim]++; int d = 0, sum = 0; for (int i = -10000; i &lt;= 10000; i++) &#123; sum += (arr[i + lim] + 1 - d) / 2 * i; d = (2 + arr[i + lim] - d) % 2; &#125; return sum; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode344-反转字符串","slug":"leetcode344-反转字符串","date":"2019-11-18T11:57:35.000Z","updated":"2019-11-18T11:58:34.267Z","comments":true,"path":"article/leetcode344-反转字符串/","link":"","permalink":"https://www.codetool.top/article/leetcode344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"原题编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1: 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2: 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 解法思想将第一个元素与末尾进行交换，再向前移动到下一个元素，并不断地交换，直到它到达中间位置。 我们可以同时使用两个指针来完成迭代：一个从第一个元素开始，另一个从最后一个元素开始。持续交换它们所指向的元素，直到这两个指针相遇。 代码1234567891011121314class Solution &#123; public void reverseString(char[] s) &#123; char temp; int i = 0; int j = s.length-1; while(i&lt;=j)&#123; temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针技巧","slug":"双指针技巧","permalink":"https://www.codetool.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"}]},{"title":"leetcode14-最长公共前缀","slug":"leetcode14-最长公共前缀","date":"2019-11-18T11:43:52.000Z","updated":"2019-11-18T11:57:54.843Z","comments":true,"path":"article/leetcode14-最长公共前缀/","link":"","permalink":"https://www.codetool.top/article/leetcode14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"","text":"原题编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl” 示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解法思想以第一个字符串的每一个位置上的字符为基准，依次比对其余字符串对应位置上的字符，如果每个字符串对应的位置上都是这个字符，则将其append到结果上，一旦遇到一个字符不是公有的立刻将结果返回。 代码1234567891011121314151617181920class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int size = strs.length; if(size==0) return \"\"; if(size==1) return strs[0];//一个字符串直接返回本身 StringBuilder str = new StringBuilder();//为了避免java连接字符串的低效率使用StringBuilder for(int i = 0;i &lt; strs[0].length();i++)&#123; char letter = strs[0].charAt(i); for(int j = 1;j &lt; size;j++)&#123; //依次检查其余字符串各个字符是否对应第一个字符串中的字符 //为了避免其他字符串的长度小于第一个字符串，使用try捕获异常 try&#123; if(strs[j].charAt(i)!=letter) return str.toString(); &#125;catch(Exception e)&#123; return str.toString();&#125; &#125; str.append(letter); &#125; return str.toString(); &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode28-实现strStr()","slug":"leetcode28-实现strStr","date":"2019-11-15T10:19:05.000Z","updated":"2019-11-18T11:37:18.692Z","comments":true,"path":"article/leetcode28-实现strStr/","link":"","permalink":"https://www.codetool.top/article/leetcode28-%E5%AE%9E%E7%8E%B0strStr/","excerpt":"","text":"原题实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = “hello”, needle = “ll”输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba”输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解法JDK API在leetcode上，当然可以投机取巧地使用String.indexof()方法，不用重复造轮子： 12345class Solution &#123; public int strStr(String haystack, String needle) &#123; return haystack.indexOf(needle); &#125;&#125; 但这是一个经典的字符串精准模式匹配问题，历史上出现过很多解决这个问题的算法，掌握它们的思想还是有必要的： BF算法（朴素算法）思想这是最直观、最简单的算法。从主串的第start个字符起和模式的第1个字符比较，如果相等继续逐个比较后续字符。比较过程中一旦发现不相等的情况，则回溯至主串中的第start+1个字符位置处，重新与模式P的字符进行比较。该算法效率较低。 代码123456789101112131415class Solution &#123; public int strStr(String haystack, String needle) &#123; int mainLen = haystack.length(); int subLen = needle.length(); if(needle.equals(\"\")) return 0;//注意模式字符串为空的情况 for(int i=0;i&lt;mainLen;i++)&#123; for(int j =0;j&lt;subLen;j++)&#123; if(!(i+j&lt;mainLen)) return -1;//主串下标超出 if(!(haystack.charAt(i+j)==needle.charAt(j))) break; else if(j == subLen-1) return i;//完全匹配，返回主串下标 &#125; &#125; return -1; &#125;&#125; 算法的复杂度为O[(i-j)j] MP算法思路 指针不回溯，利用已得到的“部分匹配”结果，将模式向右“滑动”若干位置后继续比较。 参考下面给出的示例：haystack ：&quot;cdnidnidsm&quot;needle：&quot;nidsm&quot;按照BF算法的思想，在比较haystack[2]和needle[0]时，两个字符相等，然而比较到haystack[5]和needle[3]的时候两个字符不等，于是回溯继续向后比较haystack[3]和needle[0]。可是既然能确定haystack[2]-haystack[4]与needle[0]-needle[2]是完全对应的。那么比较haystack[3]和needle[0]实际上相当于比较needle[1]和needle[0]。并且我们知道needle中前三个字符都是不同的。所以只需要从haystack[5]处继续跟needle[0]比较就行了。并且needle中字符的这些关系完全是一开始就可以确定的。 我们称记录模式字符串中各个字符之间关系的函数为失效函数。失效函数的定义域是模式字符串在“失配”前匹配的字符串个数。取值j属于0~Len(P)-1 获取失效函数的方法： 失效函数的取值k满足P0P1…Pk = Pj-kPj-k+1…Pj。如果不存在这个k值，取-1。 直观的看k就是模式字符串前j个字符是否存在前k+1位等于后k+1位。 nidsm的失效函数为： j 0 1 2 3 4 p(j) n i d s m k -1 -1 -1 -1 -1 再举一个例子，caatcat的失效函数为： j 0 1 2 3 4 5 6 p(j) c a a t c a t k -1 -1 -1 -1 0 1 -1 得到了失效函数后，即可使用MP算法进行匹配。假设在某一轮比较中，失配的情况发生在模式P的第j位，如果j=0，进行下一轮比较时，目标指针向后移动一位，模式的起始比较地址回到P0，其他情况进行下一轮比较时，目标指针不发生回溯，而模式P的起始比较地址为j-1对应的失效函数的值+1。 当然也可以把这个值提前算出来便成为了Next()函数： j 0 1 2 3 4 5 6 7 p(j) c a a t c a t Next(j) -1 0 0 0 0 1 2 0 Next(7)可以用于继续匹配（可能要求找出所有匹配的子字符串）。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; //获取next函数 public int[] next(String needle)&#123; int len = needle.length(); int i = 0; int j = -1; int[] next = new int[len+1]; next[0] = -1; while(i &lt; len)&#123; while( j &gt; -1 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j];//j会有一个传递的效果，必须前一个i对应的j是1，下一个i对应的j才能是2。如果遇到不同的字符则j清零 next[++i] = ++j; &#125; return next; &#125; public int strStr(String haystack, String needle) &#123; int mainLen = haystack.length(); int subLen = needle.length(); if(needle.equals(\"\")) return 0;//注意模式字符串为空的情况 if(mainLen&lt;subLen) return -1; int[] next = next(needle); int i = 0; int j = 0; while(j &lt; mainLen)&#123; while(i&gt;-1 &amp;&amp; needle.charAt(i) != haystack.charAt(j)) i = next[i]; i++; j++; if(i &gt;= subLen)&#123; return j-i; &#125; &#125; return -1; &#125;&#125; KMP算法思路在MP算法的基础上，还要避免最长前缀之后的那个字符不等于原来失配的那个字符。下面在已知mpNext表的情况下，给出建立kmpNext表的规则。这个规则分为四种情况： 如果mpNext[j] = 0且Pj = P0，则令kmpNext[j] = -1。 如果mpNext[j] = 0且Pj ≠ P0，则令kmpNext[j] = 0。 如果mpNext[j] ≠ 0且Pj ≠ PmpNext[j]，则令kmpNext[j] = mpNext[j]。 如果mpNext[j] ≠ 0且Pj = PmpNext[j]，则用mpNext[j]的值替换原来mpNext[j]中的j值，直到情况转换为前3种情况的一种，进而递归地求解kmpNext[j]。 j 0 1 2 3 4 5 6 7 p(j) c a a t c a t mpNext(j) -1 0 0 0 0 1 2 0 kmpNext(j) -1 0 0 0 -1 0 2 0 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; //获取kmpNext数组 public int[] next(String needle)&#123; int len = needle.length(); int i = 0; int j = -1; int[] next = new int[len+1]; next[0] = -1; while(i &lt; len-1)&#123; while( j &gt; -1 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j]; i++; j++; if(needle.charAt(i) == needle.charAt(j)) next[i] = next[j]; else next[i] = j; &#125; return next; &#125; public int strStr(String haystack, String needle) &#123; int mainLen = haystack.length(); int subLen = needle.length(); if(needle.equals(\"\")) return 0;//注意模式字符串为空的情况 if(mainLen&lt;subLen) return -1; int[] next = next(needle); int i = 0; int j = 0; while(j &lt; mainLen)&#123; while(i&gt;-1 &amp;&amp; needle.charAt(i) != haystack.charAt(j)) i = next[i]; i++; j++; if(i &gt;= subLen)&#123; return j-i; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode67-二进制求和","slug":"leetcode67-二进制求和","date":"2019-11-15T09:49:29.000Z","updated":"2019-11-15T10:08:54.588Z","comments":true,"path":"article/leetcode67-二进制求和/","link":"","permalink":"https://www.codetool.top/article/leetcode67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","excerpt":"","text":"原题给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100” 示例 2: 输入: a = “1010”, b = “1011”输出: “10101” 解法思想通过加法规则实现，应注意进位的处理和字符的处理。不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式： 第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转 第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位 代码 copy了@灵魂画师牧码（guanpengchn）的思路： 12345678910111213141516class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder ans = new StringBuilder(); int ca = 0;//进位值 for(int i = a.length() - 1, j = b.length() - 1;i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int sum = ca; //将数组长度不够的情况一般化，负数下标对应的值用0计算。 sum += i &gt;= 0 ? a.charAt(i) - '0' : 0; sum += j &gt;= 0 ? b.charAt(j) - '0' : 0; ans.append(sum % 2); ca = sum / 2;//得到进位 &#125; ans.append(ca == 1 ? ca : \"\");//如果最后进位值还为1则添加一位 return ans.reverse().toString();//反转字符串 &#125;&#125; 自己做的凌乱的思路： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public String addBinary(String a, String b) &#123; //获取两个字符串的长度和最大值最小值 int len_a = a.length(); int len_b = b.length(); int max,min; boolean carry = false;//进位标志 if( len_a &lt;= len_b )&#123; max = len_b; min = len_a; &#125;else&#123; max = len_a; min = len_b; &#125; char[] ret = new char[max]; for( int i = 0 ; i &lt; max ; i++ )&#123; char a_now = i&lt;len_a?a.charAt(len_a-1-i):'0'; char b_now = i&lt;len_b?b.charAt(len_b-1-i):'0'; //列举所有情况手动计算 if(a_now=='1'&amp;&amp;b_now=='1')&#123; ret[max-i-1] = carry?'1':'0'; carry = true; if(i==max-1)&#123; return \"1\"+ String.valueOf(ret);//如果当前为首位则在前面连接一个1 &#125; &#125;else if(a_now=='1'&amp;&amp;b_now=='0'||b_now=='1'&amp;&amp;a_now=='0')&#123; if(carry)&#123; ret[max-i-1] = '0'; if(i==max-1)&#123; return \"1\"+ String.valueOf(ret); &#125; &#125;else&#123; ret[max-i-1] = '1'; &#125; &#125;else if(a_now=='0'&amp;&amp;b_now=='0')&#123; ret[max-i-1] = carry?'1':'0'; carry = false; &#125; &#125; return String.valueOf(ret); &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://www.codetool.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode118-杨辉三角","slug":"leetcode118-杨辉三角","date":"2019-11-15T09:38:00.000Z","updated":"2019-11-15T09:48:01.286Z","comments":true,"path":"article/leetcode118-杨辉三角/","link":"","permalink":"https://www.codetool.top/article/leetcode118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","excerpt":"","text":"原题给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[&nbsp;&nbsp;&nbsp;&nbsp;[1],&nbsp;&nbsp;&nbsp;[1,1],&nbsp;&nbsp;[1,2,1],&nbsp;[1,3,3,1],[1,4,6,4,1]] 解法思想根据上一行生成下一行，避免重复计算 代码12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;Integer&gt; row = new ArrayList(); List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int n = 0;n&lt;numRows;n++)&#123; row = getRow(n+1,row); ret.add(row); &#125; return ret; &#125; //n:第n行，nums：上一行（n-1行）的列表 public List&lt;Integer&gt; getRow(int n,List&lt;Integer&gt; nums)&#123; List&lt;Integer&gt; ret = new ArrayList(); ret.add(1);//第一个1不需要计算 if(n==1)&#123;//第一行直接返回 return ret; &#125; for(int i=1;i&lt;(n+1)/2;i++)&#123;//由上一行的数相加得到结果 ret.add(nums.get(i-1)+nums.get(i)); &#125; int size = n/2; for(int i=0;i&lt;size;i++)&#123;//镜像处理 ret.add(ret.get(size-i-1)); &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode54-螺旋矩阵","slug":"leetcode54-螺旋矩阵","date":"2019-11-15T09:19:53.000Z","updated":"2019-11-15T09:33:18.968Z","comments":true,"path":"article/leetcode54-螺旋矩阵/","link":"","permalink":"https://www.codetool.top/article/leetcode54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/","excerpt":"","text":"原题给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,6,9,8,7,4,5] 解法思想找拐点规律和移动规律： 当横坐标x等于纵坐标y+1时，且之前是向上移动的，拐点向右。 当横坐标x加纵坐标y等于列数减一，且之前是向右移动的，拐点向下。 当行数和横坐标x之差等于列数与纵坐标y之差时，且之前是向下移动的，拐点向左。 当横坐标x加纵坐标y等于行数减一，且之前是向左移动的，拐点向上。 当不满足上述拐点情况时，坐标会随着之前的运动方向继续运动。可以设置代表四个方向运动状态的布尔值来记录运动状态。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; if(matrix==null) return null; int x = matrix.length; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); if(x==0) return ret; int y = matrix[0].length;//获取二维数组的行数和列数，排除null和空情况。 int x_now=0,y_now=0; int size = x*y; //代表向各个方向移动的布尔值。 boolean toRight=true,toLeft=false,toTop=false,toBottom=false; for(int i=0;i&lt;size;i++) &#123; ret.add(matrix[x_now][y_now]); if(x_now==y_now+1&amp;&amp;toTop) &#123;//拐向右 toRight=true; toTop=false; &#125;else if(y_now==y-x_now-1&amp;&amp;toRight) &#123;//拐向下 toBottom=true; toRight=false; &#125;else if(x-x_now==y-y_now&amp;&amp;toBottom)&#123;//拐向左 toLeft=true; toBottom=false; &#125;else if(x_now==x-y_now-1&amp;&amp;toLeft) &#123;//拐向上 toTop=true; toLeft=false; &#125; //移动坐标 if(toRight) y_now++; if(toLeft) y_now--; if(toTop) x_now--; if(toBottom) x_now++; &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode498-对角线遍历","slug":"leetcode498-对角线遍历","date":"2019-11-14T07:49:09.000Z","updated":"2019-11-15T09:20:36.182Z","comments":true,"path":"article/leetcode498-对角线遍历/","link":"","permalink":"https://www.codetool.top/article/leetcode498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/","excerpt":"","text":"这是一个Z字形编排问题，JEPG的编码过程中也会用到。 原题给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,4,7,5,3,6,8,9]解释: 说明: 给定矩阵中的元素总数不会超过 100000 。 解法思想找拐点的规律： 当横坐标x为0，纵坐标y是偶数，且y不是最后一列的时候，拐点向右。 当横坐标x为最后一行，若行数为偶数且纵坐标y为奇数或行数为奇数但纵坐标y为偶数时，拐点向右。 当纵坐标y为0，横坐标x是奇数，且x不是最后一行的时候，拐点向下。 当纵坐标y为最后一列，若列数为偶数且横坐标x为偶数或列数为奇数但横坐标x为奇数时，拐点向右。 其他情况，当横坐标x为偶数且纵坐标y为奇数或x为奇数且y为偶数的时候，拐点向左下 当横坐标x为偶数且纵坐标y为偶数或x为奇数且y为奇数的时候，拐点向右上 代码123456789101112131415161718192021222324252627282930class Solution &#123; public int[] findDiagonalOrder(int[][] matrix) &#123; //获取二维数组的长宽、大小 int x = matrix.length; if(x == 0) return new int[0]; int y = matrix[0].length; int size = x*y; int x_now=0,y_now=0;//落点位置 int[] ret = new int[size];//用于存储并返回的一维数组 int i = 0; while( x_now &lt; x &amp;&amp; y_now &lt; y )&#123; ret[i] = matrix[x_now][y_now]; //存入元素 i++; if((x_now==0&amp;&amp;y_now%2==0&amp;&amp;y_now!=y-1)||(x_now == x-1&amp;&amp;(y_now+x)%2==0))&#123;//向右 y_now += 1; &#125;else if((y_now==0&amp;&amp;x_now%2==1&amp;&amp;x_now!=x-1)||(y_now == y-1&amp;&amp;(x_now+y)%2==1))&#123;//向下 x_now += 1; &#125; else if((x_now+y_now)%2==0)&#123;//向右上 y_now +=1; x_now -=1; &#125;else if((x_now+y_now)%2==1)&#123;//向左下 y_now -=1; x_now +=1; &#125; &#125; return ret; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"leetcode66-加一","slug":"leetcode66-加一","date":"2019-11-14T06:18:26.000Z","updated":"2019-11-15T09:48:36.673Z","comments":true,"path":"article/leetcode66-加一/","link":"","permalink":"https://www.codetool.top/article/leetcode66-%E5%8A%A0%E4%B8%80/","excerpt":"","text":"原题给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 示例 2: 输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字4321。 解法思想根据加法规则进行计算，应注意进位的处理和全是9的特殊情况 代码 迭代 123456789101112131415161718class Solution &#123; public int[] plusOne(int[] digits) &#123; for(int i = digits.length-1;i&gt;=0;i--)&#123; if(digits[i]!=9) &#123;//不需进位 digits[i] += 1; break;//什么时候不需进位即可退出 &#125;else &#123; if (i == 0) &#123;//首位需进位的特殊情况，需分配一个大一位的数组 int[] ret = new int[digits.length+1]; ret[0] = 1; return ret; &#125; digits[i] = 0;//不是首位，需进位 &#125; &#125; return digits; &#125;&#125; 递归 1234567891011121314151617181920class Solution &#123; public int[] plusOne(int[] digits) &#123; return addOneAtPos(digits, digits.length-1); &#125; private int[] addOneAtPos(int[] num, int pos)&#123;//在pos位上加一 if(num[pos]!=9)&#123;//不需进位 num[pos]+=1; return num;//什么时候不需进位即可返回 &#125; else if(pos&gt;0)&#123;//不是首位，需进位 num[pos]=0; return addOneAtPos(num, pos-1); &#125; else &#123;//首位需进位的特殊情况，需分配一个大一位的数组 int length = num.length; int[] newNum = new int[length+1]; newNum[0]=1; return newNum; &#125; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"递归","slug":"递归","permalink":"https://www.codetool.top/tags/%E9%80%92%E5%BD%92/"}]},{"title":"leetcode724-寻找数组的中心索引","slug":"leetcode724-寻找数组的中心索引","date":"2019-11-13T12:15:00.000Z","updated":"2019-11-15T09:20:47.137Z","comments":true,"path":"article/leetcode724-寻找数组的中心索引/","link":"","permalink":"https://www.codetool.top/article/leetcode724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/","excerpt":"","text":"原题给定一个整数类型的数组nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1: 输入:nums = [1, 7, 3, 6, 5, 6]输出: 3解释:索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 示例 2: 输入:nums = [1, 2, 3]输出: -1解释:数组中不存在满足此条件的中心索引。 说明: nums的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 解法思想避免重复计算，先计算完数组所有元素之和，再划分为两数之和的问题。 代码1234567891011121314151617181920212223242526class Solution &#123; public int pivotIndex(int[] nums) &#123; int i; int frontRet = 0, endRet = 0; //计算所有元素总和 for (int k = 0; k &lt; nums.length; k++) &#123; endRet += nums[k]; &#125; //从左向右试探，计算两部分的值 for (i = 0; i &lt; nums.length; i++) &#123; endRet -= nums[i]; if (frontRet == endRet) &#123; break; &#125; frontRet += nums[i]; &#125; if ((i &lt; 0) || (i &gt;= nums.length)) &#123; i = -1; &#125; return i; &#125;&#125;","categories":[{"name":"算法/数据结构","slug":"算法-数据结构","permalink":"https://www.codetool.top/categories/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.codetool.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.codetool.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://www.codetool.top/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Collection接口研究","slug":"Collection接口研究","date":"2019-11-13T11:24:33.000Z","updated":"2019-11-18T14:37:39.715Z","comments":true,"path":"article/Collection接口研究/","link":"","permalink":"https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/","excerpt":"","text":"以下内容基于jdk1.8 接口Collection分析 img 该接口实现了接口Iterable 方法： int size();返回元素的个数 boolean isEmpty();返回是否为空 boolean contains(Object o);返回是否包含某个对象抛出异常： @throws ClassCastException 参数不兼容 @throws NullPointerException 参数是null，并且容器不允许包含null元素 Object[] toArray();返回所有元素组成的一个数组数组是重新分配空间并创建的，它的元素不会由该容器维护，原文： The returned array will be \"safe\" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. T[] toArray(T[] a);将所有元素组成的一个数组返回到给定的特定类型的数组中 12345List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();Integer[] a = new Integer[2];list.add(3);list.add(5);list.toArray(a); // a = &#123;3,5&#125; 抛出异常： @throws ArrayStoreException 给定的数组运行类型不是该容器运行类型的超类 @throws NullPointerException 给定的数组是null boolean add(E e);确保该容器包含该指定的元素，如果因为这个操作改变了容器内的元素返回true，如果该容器已经有了该元素且不允许包含重复的元素则返回false 抛出异常： @throws UnsupportedOperationException 该容器不支持这个操作 @throws ClassCastException 给定的元素不能添加进容器中 @throws NullPointerException 参数是null，并且容器不允许包含null元素 @throws IllegalArgumentException 给定的元素的某些属性决定了它不能被添加进该容器中 @throws IllegalStateException 由于某些限制该时间不能添加该元素 boolean remove(Object o);移除某个元素抛出异常： @throws ClassCastException @throws NullPointerException @throws UnsupportedOperationException boolean containsAll(Collection&lt;?&gt; c)如果该容器包含给定的容器中的所有元素，返回true抛出异常： @throws ClassCastException @throws NullPointerException boolean addAll(Collection&lt;? extends E&gt; c)将给定容器中的所有元素插入到该容器中抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException @throws IllegalArgumentException @throws IllegalStateException boolean removeAll(Collection&lt;?&gt; c)将该容器和给定容器中共有的元素从该容器中删除抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException default boolean removeIf(Predicate&lt;? super E&gt; filter)Predicate是JAVA8新增的一个函数式接口（指如果填写lambda表达式则默认实现Predicate的test方法），这个方法删除所有符合条件的元素，如果成功返回true? super E指的是E或E的父类默认实现： 123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 调用实例： 1234Integer[] nums = &#123;1,2,3,4,5,6&#125;;ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(nums));list.removeIf(num-&gt;num&gt;3?true:false);//删除list中大于3的元素//这里的lambda表达式是简化的写法，将lambda表达式完整的写法是list.removeIf((Integer num)-&gt;&#123;return num&gt;3?true:false;&#125;); 抛出异常： @throws NullPointerException @throws UnsupportedOperationException 这个元素不能被删除 boolean retainAll(Collection&lt;?&gt; c);仅保留给定集合中的元素，删除其他元素。 抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException void clear();移除所有元素。 抛出异常： @throws UnsupportedOperationException default Stream stream();返回一个序列流。默认实现： 123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; default Stream parallelStream();返回一个并行流。默认实现： 123default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.codetool.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.codetool.top/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://www.codetool.top/tags/jdk/"},{"name":"源码研究","slug":"源码研究","permalink":"https://www.codetool.top/tags/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6/"}]},{"title":"23种设计模式归纳","slug":"23种设计模式归纳","date":"2019-11-08T10:05:23.000Z","updated":"2019-11-13T12:15:57.814Z","comments":true,"path":"article/23种设计模式归纳/","link":"","permalink":"https://www.codetool.top/article/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%BA%B3/","excerpt":"","text":"参考文档 23种设计模式全解析 - codeTao - 博客园 设计模式（创建型） - 八一鱼 - 博客园 设计模式（结构型） - 八一鱼 - 博客园 代理模式和装饰者模式的区别 - 夜的第八章 - 博客园 简说设计模式——享元模式 - JAdam - 博客园 设计模式的分类 类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来；对象模式处理对象之间的关系，运行时发生变化，属于动态关系。 创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型模式 策略模式 模板方法模式 观察者模式 迭代器模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 设计模式遵守的设计原则也是类的设计遵守的原则 单一职责原则SRP每个类只做一件事，但该原则也不适用于聚合类。 聚合类需要优先使用对象组合，而不是类继承 里氏替换原则LSP 子类的对象提供了父类的所有行为，且加上子类额外的一些东西（可以是功能，也可以是属性） 当程序基于父类实现时，如果将子类替换父类而程序不需要修改，则说明符合LSP原则 子类必须能替换成它们的父类 依赖倒置原则DIP也叫依赖反转原则。 高层模块不应该直接依赖低层模块，两者都应该依赖抽象层。 抽象不能依赖细节，细节必须依赖抽象。 接口隔离原则ISP 客户端不应该被强迫去依赖它们并不需要的接口 不满足ISP的类应该拆分成多个接口， 通过一个抽象类去实现它们，再去继承这个抽象父类。 开闭原则 对拓展开放，对修改封闭 对使用者修改关闭，对提供者拓展开放 创建型模式解析 在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。 工厂方法模式（类） 创建一个工厂接口和创建多个工厂实现类 抽象工厂模式（对象） 区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 单例模式（对象） 在一个JVM中，该类只有一个对象实例存在。 12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 多线程下的优化： 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 原理： JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕 建造者模式（对象） 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 Director的作用： 隔离客户与生产过程。 负责控制产品的生成过程。 1234567891011121314151617181920public class Meal &#123; private String food; private String drink; public String getFood() &#123; return food; &#125; public void setFood(String food) &#123; this.food = food; &#125; public String getDrink() &#123; return drink; &#125; public void setDrink(String drink) &#123; this.drink = drink; &#125;&#125; 12345678910public abstract class MealBuilder &#123; Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal()&#123; return meal; &#125;&#125; 12345678910public class MealA extends MealBuilder&#123; public void buildDrink() &#123; meal.setDrink(\"可乐\"); &#125; public void buildFood() &#123; meal.setFood(\"薯条\"); &#125;&#125; 123456789101112131415161718public class KFCWaiter &#123; private MealBuilder mealBuilder; public KFCWaiter(MealBuilder mealBuilder) &#123; this.mealBuilder = mealBuilder; &#125; public Meal construct()&#123; //准备食物 mealBuilder.buildFood(); //准备饮料 mealBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return mealBuilder.getMeal(); &#125;&#125; 原型模式（对象） 有些对象是需要频繁创建的，用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的同类型的对象，分为浅克隆和深克隆，浅克隆只复制拷贝的对象，不复制引用的对象，即成员对象不复制；深克隆，引用也同样复制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); /* super.clone()是浅复制 */ return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 结构型模式解析结构型模式主要用于处理类和对象的组合 适配器模式（类和对象） 将一个接口转换成客户希望的另一个接口，从而使接口不兼容的那些类可以在一起工作。 类的适配器模式 通过一个具体的类，将适配者适配到目标接口当中 12345public class Source &#123; public void method1() &#123; System.out.println(\"this is original method!\"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; &#125; 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 对象的适配器模式 一个适配器可以将多个不同的适配者适配到同一目标 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 装饰者模式（对象） 给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例 12345678910111213141516171819202122232425262728//Sourceablepublic interface Sourceable &#123; public void method(); &#125; //Sourcepublic class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; //Decoratorpublic class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println(\"before decorator!\"); source.method(); System.out.println(\"after decorator!\"); &#125; &#125; 我寻思有点像servlet的过滤器 代理模式（对象） 多一个代理类出来，替原对象进行一些操作 12345678910111213141516171819202122232425262728293031public interface Sourceable &#123; public void method(); &#125; public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println(\"after proxy!\"); &#125; private void before() &#123; System.out.println(\"before proxy!\"); &#125; &#125; 装饰者模式和代理模式的区别： 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 外观模式（对象） 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用 外观模式包含如下角色： Facade: 外观角色 SubSystem:子系统角色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//CPUpublic class CPU &#123; public void startup()&#123; System.out.println(\"cpu startup!\"); &#125; public void shutdown()&#123; System.out.println(\"cpu shutdown!\"); &#125; &#125; //Memorypublic class Memory &#123; public void startup()&#123; System.out.println(\"memory startup!\"); &#125; public void shutdown()&#123; System.out.println(\"memory shutdown!\"); &#125; &#125; //Diskpublic class Disk &#123; public void startup()&#123; System.out.println(\"disk startup!\"); &#125; public void shutdown()&#123; System.out.println(\"disk shutdown!\"); &#125; &#125; //Facadepublic class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println(\"start the computer!\"); cpu.startup(); memory.startup(); disk.startup(); System.out.println(\"start computer finished!\"); &#125; public void shutdown()&#123; System.out.println(\"begin to close the computer!\"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(\"computer closed!\"); &#125; &#125; 桥接模式（对象） 把事物和其具体实现分开，使他们可以各自独立的变化。 将抽象化与实现化解耦，使得二者可以独立变化 12345678910111213141516171819202122232425262728293031323334353637383940public interface Sourceable &#123; public void method(); &#125; public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the first sub!\"); &#125; &#125; public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the second sub!\"); &#125; &#125;public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 组合模式（对象） 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，树等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree(\"A\"); TreeNode nodeB = new TreeNode(\"B\"); TreeNode nodeC = new TreeNode(\"C\"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(\"build the tree finished!\"); &#125; &#125; 享元模式（对象） 实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 其中，Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现；ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中；FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。 123456789101112131415161718192021222324public abstract class Flyweight &#123; //内部状态 public String intrinsic; //外部状态 protected final String extrinsic; //要求享元角色必须接受外部状态 public Flyweight(String extrinsic) &#123; this.extrinsic = extrinsic; &#125; //定义业务操作 public abstract void operate(int extrinsic); public String getIntrinsic() &#123; return intrinsic; &#125; public void setIntrinsic(String intrinsic) &#123; this.intrinsic = intrinsic; &#125;&#125; 1234567891011121314public class ConcreteFlyweight extends Flyweight &#123; //接受外部状态 public ConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; //根据外部状态进行逻辑处理 @Override public void operate(int extrinsic) &#123; System.out.println(\"具体Flyweight:\" + extrinsic); &#125;&#125; 123456789101112public class UnsharedConcreteFlyweight extends Flyweight &#123; public UnsharedConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; @Override public void operate(int extrinsic) &#123; System.out.println(\"不共享的具体Flyweight:\" + extrinsic); &#125;&#125; 1234567891011121314151617181920212223public class FlyweightFactory &#123; //定义一个池容器 private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;&gt;(); //享元工厂 public static Flyweight getFlyweight(String extrinsic) &#123; Flyweight flyweight = null; if(pool.containsKey(extrinsic)) &#123; //池中有该对象 flyweight = pool.get(extrinsic); System.out.print(\"已有 \" + extrinsic + \" 直接从池中取----&gt;\"); &#125; else &#123; //根据外部状态创建享元对象 flyweight = new ConcreteFlyweight(extrinsic); //放入池中 pool.put(extrinsic, flyweight); System.out.print(\"创建 \" + extrinsic + \" 并从池中取出----&gt;\"); &#125; return flyweight; &#125;&#125; 行为型模式解析行为型模式主要用于描述类或对象的交互以及职责分配 解释器模式（类） 主要应用在OOP开发中的编译器的开发中 给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子 ​ 模板方法模式（类） 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法中某些特定步骤 策略模式（对象） 定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化 观察者模式（对象） 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 123public interface Observer &#123; public void update(); &#125; 1234567public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer1 has received!\"); &#125; &#125; 12345678public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer2 has received!\"); &#125; &#125; 1234567891011121314public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; 12345678910111213141516171819202122public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; //提醒应当在抽象类中就实现 @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; 123456789public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println(\"update self!\"); notifyObservers(); &#125; &#125; 迭代器模式（对象） 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。 责任链模式（对象） 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求 123public interface Handler &#123; public void operator(); &#125; 12345678910111213public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125; &#125; 12345678910111213141516public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name+\"deal!\"); if(getHandler()!=null)&#123; getHandler().operator(); &#125; &#125; &#125; 命令模式（对象） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 123public interface Command &#123; public void exe(); &#125; 12345678910111213public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125; &#125; 12345public class Receiver &#123; public void action()&#123; System.out.println(\"command received!\"); &#125; &#125; 123456789101112public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.exe(); &#125; &#125; 备忘录模式（对象） 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态 123456789101112131415161718192021222324public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; 12345678910111213141516public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 12345678910111213141516public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; 状态模式（对象） 允许一个对象在其内部状态改变时能够改变它的行为 1234567891011121314151617181920public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println(\"execute the first opt!\"); &#125; public void method2()&#123; System.out.println(\"execute the second opt!\"); &#125; &#125; 123456789101112131415161718192021222324public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; if (state.getValue().equals(\"state1\")) &#123; state.method1(); &#125; else if (state.getValue().equals(\"state2\")) &#123; state.method2(); &#125; &#125; &#125; 访问者模式（对象） 表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 适用于：给一个类添加新功能，但为了兼容性考虑或其他原因不想破坏这个类 123public interface Visitor &#123; public void visit(Subject sub); &#125; 1234567public class MyVisitor implements Visitor &#123; @Override public void visit(Subject sub) &#123; System.out.println(\"visit the subject：\"+sub.getSubject()); &#125; &#125; 1234public interface Subject &#123; public void accept(Visitor visitor); public String getSubject(); &#125; 123456789101112public class MySubject implements Subject &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; @Override public String getSubject() &#123; return \"love\"; &#125; &#125; 中介者模式（对象） 用一个中介对象来封装一系列的对象交互。它使各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 1234public interface Mediator &#123; public void createMediator(); public void workAll(); &#125; 12345678910111213141516171819202122232425public class MyMediator implements Mediator &#123; private User user1; private User user2; public User getUser1() &#123; return user1; &#125; public User getUser2() &#123; return user2; &#125; @Override public void createMediator() &#123; user1 = new User1(this); user2 = new User2(this); &#125; @Override public void workAll() &#123; user1.work(); user2.work(); &#125; &#125; 1234567891011121314public abstract class User &#123; private Mediator mediator; public Mediator getMediator()&#123; return mediator; &#125; public User(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void work(); &#125; 1234567891011public class User1 extends User &#123; public User1(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user1 exe!\"); &#125; &#125; 1234567891011public class User2 extends User &#123; public User2(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user2 exe!\"); &#125; &#125; 12345678public class Test &#123; public static void main(String[] args) &#123; Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); &#125; &#125;","categories":[{"name":"中间件/软件设计","slug":"中间件-软件设计","permalink":"https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.codetool.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"我的博客搬家啦","slug":"hello-world","date":"2019-11-08T09:05:23.000Z","updated":"2019-11-13T12:22:54.725Z","comments":true,"path":"article/hello-world/","link":"","permalink":"https://www.codetool.top/article/hello-world/","excerpt":"","text":"今天弃了wordpress的坑搬来hexo啦。和gitbook差不多的用法，很快就上手了呢。再也不用忍受wordpress一堆不仅没用还加载龟速的资源了奥里给！！！","categories":[{"name":"日常/随笔","slug":"日常-随笔","permalink":"https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"网站日志","slug":"网站日志","permalink":"https://www.codetool.top/tags/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"}]},{"title":"在线运行C++、java、python代码的小项目实现","slug":"在线运行C++、java、python代码的小项目实现","date":"2019-08-13T12:06:57.000Z","updated":"2019-11-13T12:16:20.231Z","comments":true,"path":"article/在线运行C++、java、python代码的小项目实现/","link":"","permalink":"https://www.codetool.top/article/%E5%9C%A8%E7%BA%BF%E8%BF%90%E8%A1%8CC++%E3%80%81java%E3%80%81python%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本网站在2019年8月12日之前用的代码演示功能是借用了 https://tool.lu/coderunner/ 的在线运行代码工具，在此致谢。 有一段时间这个工具突然失效了，我就在想能不能自己模仿着做一个类似的出来，简单分析了一下就想挑战一下自己，然后就开始动手了。 做出来的成果链接：点击此处 做的过程中查阅了很多网络资料，现整理如下： 需求分析：前端为一个实用的代码编辑器，通过ajax请求将写好的代码提交给服务器，服务器编译运行后把输出结果送回客户端显示。 其中使用的代码编辑器：CodeMirror，现在类似的工具使用的应该都是这款功能强大，可以自定样式的代码编辑器，官网： https://codemirror.net/ CodeMirror搭建前端界面先从官网下载下来CodeMirror的压缩包，解压之后得到下图目录 要在html中创建一个CodeMirror编辑器，必须添加的css和js文件是 12&lt;link href=./codemirror-5.48.2/lib/codemirror.css rel=stylesheet/&gt;&lt;script src=./codemirror-5.48.2/lib/codemirror.js&gt;&lt;/script&gt; (5.48.2为版本号，因人而异) 然后需要添加需要编辑的语言相关的js文件，可以在mode目录下找到，这里我用了两个文件： 实现JAVA和C++代码高亮（这个文件可以实现C，C++，JAVA，C#等语言）： 1&lt;script src=./codemirror-5.48.2/mode/clike/clike.js&gt;&lt;/script&gt; 实现python的代码高亮： 1&lt;script src=./codemirror-5.48.2/mode/python/python.js&gt;&lt;/script&gt; 需要更改编辑器主题样式的可以在theme目录下找到对应的主题css文件添加进去，我觉得默认主题就很好看了就没用其他主题。 为了实现括号匹配和代码折叠功能，还要添加的文件有： 123456&lt;link rel=stylesheet href=./codemirror-5.48.2/addon/fold/foldgutter.css/&gt;&lt;script src=./codemirror-5.48.2/addon/fold/foldcode.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/foldgutter.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/brace-fold.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/comment-fold.js&gt;&lt;/script&gt; 创建编辑器的过程： 在html中使用一个textarea占位，配置好id： 1&lt;textarea id=code name=code&gt;&lt;/textarea&gt; 通过对应的js代码创建编辑器： 123456789101112var editor = CodeMirror.fromTextArea(document.getElementById(code), &#123; mode: text/x-java, //实现Java代码高亮 //mode: text/x-c++src, //实现C++代码高亮 //mode: text/x-python, //实现Python代码高亮 indentUnit:4,//以四个空格的长度缩进 indentWithTabs: true,//以tab代替空格缩进 lineNumbers: true, //显示行号 lineWrapping: true, foldGutter: true, //代码折叠 gutters: [CodeMirror-linenumbers, CodeMirror-foldgutter], matchBrackets: true //括号匹配 &#125;); 这里需要什么语言高亮需要在官网找到对应语言的 MIME types ，写在mode参数中 其他相关js函数： 编辑器的大小通过 editor.setSize(width, height) 方法设置 获取编辑器内的代码：editor.getValue() 设置编辑器内的代码：editor.setValue() 设置编辑器的配置选项: editor.setOption() 最终搭配上bootstrap样式做出来的效果是这样的： js实现前端逻辑使用JQuery简化js的写法 关键代码： 切换语言事件 1234567891011121314//选择语言事件$(\"#lang\").on('change', () =&gt; &#123; lang = $(\"#lang\").val() if (lang == 'java') &#123; editor.setOption(\"mode\", \"text/x-java\") editor.setValue(javacode) &#125; else if (lang == \"cpp\") &#123; editor.setOption(\"mode\", \"text/x-c++src\") editor.setValue(cppcode) &#125; else if (lang == \"python\") &#123; editor.setOption(\"mode\", \"text/x-python\") editor.setValue(pythoncode) &#125;&#125;) 发送POST请求 1234567891011121314151617181920212223242526272829$(function()&#123; //点击运行按钮后的事件 $(\"#run\").on(\"click\",()=&gt;&#123; var codesrc = editor.getValue(); //给源代码编码 var codeEncoded = encodeURIComponent(codesrc); $(\"output\").html = 'console&gt;&gt;' + '正在努力执行中...'; //发出post请求 $.post( \"/runcode.php\", &#123; lang:lang,codesrc:codeEncoded &#125;, (data)=&gt;&#123; var outputs = data.output; var status1 = data.status1; var output = ''; //拼接输出结果 if(status1 !== 1)&#123; for(var i in outputs) &#123; output = output + outputs[i] + '&lt;br/&gt;'; &#125;data &#125;else&#123; var outputs1 = data.output1; for(var i in outputs1) &#123; output = output + outputs1[i] + '&lt;br/&gt;'; &#125; &#125; $(\"output\").html = 'console&gt;&gt;' + output; &#125;, \"json\"); &#125;)&#125;); 注： 由于代码中可能出现 + 或 &amp; 等符号，其在post的请求中经过urlencode会分别被解析为空格和参数连接符，需先将代码源码用js的encodeURIComponent()函数编码，传递到php后端后再用rawurldecode()函数进行解码操作。 php实现后端php的任务是在服务器上运行代码，核心的思想是将接收到的代码写入文件，使用各种环境去执行，并返回结果 其中用到了exec函数 具体参阅 【php】php使用exec总结 做的时候遇到了个问题：php在调用exec执行gcc命令时，会出现各种毛病，例如ld链接器找不到，后来发现原因是php不会使用系统设置的环境变量，在php文件开头添加这样一句话就能解决问题： 1putenv(PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin);//设置环境变量","categories":[{"name":"项目总结","slug":"项目总结","permalink":"https://www.codetool.top/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.codetool.top/tags/php/"},{"name":"CodeMirror","slug":"CodeMirror","permalink":"https://www.codetool.top/tags/CodeMirror/"}]}]}