{"meta":{"title":"代码段小站","subtitle":"CodeBand CodeTool - 个人计算机类练手小博客","description":"","author":"Rhett Peng","url":"https://www.codetool.top","root":"/"},"pages":[{"title":"","date":"2019-11-08T11:01:26.614Z","updated":"2019-11-08T11:01:26.614Z","comments":false,"path":"categories/index.html","permalink":"https://www.codetool.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-08T13:55:48.722Z","updated":"2019-11-08T13:55:48.722Z","comments":false,"path":"about/index.html","permalink":"https://www.codetool.top/about/index.html","excerpt":"","text":"@column-2{ 很帅的一张图 曾用logo } @column-2{ @card{ 神秘的站长现南昌大学软件学院大三学生，学习作风差，不务正业.喜欢折腾新奇的东西，学习黑科技正在由一只小菜鸡成为一只大菜鸡的转变的路上（其实我也不知道小菜鸡为啥要写博客，反正也没人看） } @card{ 关于小站代码段小站（CodeBand）创建于2018年8月19日，闲时在这里随便写点东西。可能是脑海里的一些闪光点，也可能是某一天的学习内容的记录，更多的是有关编程方面的、我觉得有意义记下来的一些知识。也希望这个网站能伴随我从编程新手小白成长为一个不算太小白的小白? } } @timeline{ 2019@item{ 11月8日抛弃wordpress，使用hexo重新搭建博客，完全搬至国内服务器 } @item{ 9月6日新服务器域名通过备案，使用国内服务器反向代理 } @item{ 8月19日更换wordpress主题 } 2018@item{ 8月19日使用wordpress搭建了第一版博客写下了我的第一篇博客《Java抽象类和接口的区别》 } }"},{"title":"在线写代码","date":"2019-11-08T14:16:45.000Z","updated":"2019-11-12T11:58:05.665Z","comments":true,"path":"runcode/index.html","permalink":"https://www.codetool.top/runcode/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-08T11:01:30.613Z","updated":"2019-11-08T11:01:30.613Z","comments":false,"path":"tags/index.html","permalink":"https://www.codetool.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Colleciton接口研究","slug":"Collection接口研究","date":"2019-11-13T11:24:33.000Z","updated":"2019-11-13T11:29:22.229Z","comments":true,"path":"article/Collection接口研究/","link":"","permalink":"https://www.codetool.top/article/Collection%E6%8E%A5%E5%8F%A3%E7%A0%94%E7%A9%B6/","excerpt":"","text":"以下内容基于jdk1.8 接口Collection分析 img 该接口实现了接口Iterable 方法： int size();返回元素的个数 boolean isEmpty();返回是否为空 boolean contains(Object o);返回是否包含某个对象抛出异常： @throws ClassCastException 参数不兼容 @throws NullPointerException 参数是null，并且容器不允许包含null元素 Object[] toArray();返回所有元素组成的一个数组数组是重新分配空间并创建的，它的元素不会由该容器维护，原文： * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this collection. (In other words, this method must * allocate a new array even if this collection is backed by an array). * The caller is thus free to modify the returned array. T[] toArray(T[] a);将所有元素组成的一个数组返回到给定的特定类型的数组中 12345List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();Integer[] a = new Integer[2];list.add(3);list.add(5);list.toArray(a); // a = &#123;3,5&#125; 抛出异常： @throws ArrayStoreException 给定的数组运行类型不是该容器运行类型的超类 @throws NullPointerException 给定的数组是null boolean add(E e);确保该容器包含该指定的元素，如果因为这个操作改变了容器内的元素返回true，如果该容器已经有了该元素且不允许包含重复的元素则返回false 抛出异常： @throws UnsupportedOperationException 该容器不支持这个操作 @throws ClassCastException 给定的元素不能添加进容器中 @throws NullPointerException 参数是null，并且容器不允许包含null元素 @throws IllegalArgumentException 给定的元素的某些属性决定了它不能被添加进该容器中 @throws IllegalStateException 由于某些限制该时间不能添加该元素 boolean remove(Object o);移除某个元素抛出异常： @throws ClassCastException @throws NullPointerException @throws UnsupportedOperationException boolean containsAll(Collection&lt;?&gt; c)如果该容器包含给定的容器中的所有元素，返回true抛出异常： @throws ClassCastException @throws NullPointerException boolean addAll(Collection&lt;? extends E&gt; c)将给定容器中的所有元素插入到该容器中抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException @throws IllegalArgumentException @throws IllegalStateException boolean removeAll(Collection&lt;?&gt; c)将该容器和给定容器中共有的元素从该容器中删除抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException default boolean removeIf(Predicate&lt;? super E&gt; filter)Predicate是JAVA8新增的一个函数式接口（指如果填写lambda表达式则默认实现Predicate的test方法），这个方法删除所有符合条件的元素，如果成功返回true? super E指的是E或E的父类默认实现： 123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 调用实例： 1234Integer[] nums = &#123;1,2,3,4,5,6&#125;;ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(nums));list.removeIf(num-&gt;num&gt;3?true:false);//删除list中大于3的元素//这里的lambda表达式是简化的写法，将lambda表达式完整的写法是list.removeIf((Integer num)-&gt;&#123;return num&gt;3?true:false;&#125;); 抛出异常： @throws NullPointerException @throws UnsupportedOperationException 这个元素不能被删除 boolean retainAll(Collection&lt;?&gt; c);仅保留给定集合中的元素，删除其他元素。 抛出异常： @throws UnsupportedOperationException @throws ClassCastException @throws NullPointerException void clear();移除所有元素。 抛出异常： @throws UnsupportedOperationException default Stream stream();返回一个序列流。默认实现： 123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; default Stream parallelStream();返回一个并行流。默认实现： 123default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true);&#125;","categories":[],"tags":[]},{"title":"23种设计模式归纳","slug":"23种设计模式归纳","date":"2019-11-08T10:05:23.000Z","updated":"2019-11-08T11:58:30.619Z","comments":true,"path":"article/23种设计模式归纳/","link":"","permalink":"https://www.codetool.top/article/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%BA%B3/","excerpt":"","text":"参考文档 23种设计模式全解析 - codeTao - 博客园 设计模式（创建型） - 八一鱼 - 博客园 设计模式（结构型） - 八一鱼 - 博客园 代理模式和装饰者模式的区别 - 夜的第八章 - 博客园 简说设计模式——享元模式 - JAdam - 博客园 设计模式的分类 类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来；对象模式处理对象之间的关系，运行时发生变化，属于动态关系。 创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型模式 策略模式 模板方法模式 观察者模式 迭代器模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 设计模式遵守的设计原则也是类的设计遵守的原则 单一职责原则SRP每个类只做一件事，但该原则也不适用于聚合类。 聚合类需要优先使用对象组合，而不是类继承 里氏替换原则LSP 子类的对象提供了父类的所有行为，且加上子类额外的一些东西（可以是功能，也可以是属性） 当程序基于父类实现时，如果将子类替换父类而程序不需要修改，则说明符合LSP原则 子类必须能替换成它们的父类 依赖倒置原则DIP也叫依赖反转原则。 高层模块不应该直接依赖低层模块，两者都应该依赖抽象层。 抽象不能依赖细节，细节必须依赖抽象。 接口隔离原则ISP 客户端不应该被强迫去依赖它们并不需要的接口 不满足ISP的类应该拆分成多个接口， 通过一个抽象类去实现它们，再去继承这个抽象父类。 开闭原则 对拓展开放，对修改封闭 对使用者修改关闭，对提供者拓展开放 创建型模式解析 在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。 工厂方法模式（类） 创建一个工厂接口和创建多个工厂实现类 抽象工厂模式（对象） 区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 单例模式（对象） 在一个JVM中，该类只有一个对象实例存在。 12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 多线程下的优化： 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 原理： JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕 建造者模式（对象） 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 Director的作用： 隔离客户与生产过程。 负责控制产品的生成过程。 1234567891011121314151617181920public class Meal &#123; private String food; private String drink; public String getFood() &#123; return food; &#125; public void setFood(String food) &#123; this.food = food; &#125; public String getDrink() &#123; return drink; &#125; public void setDrink(String drink) &#123; this.drink = drink; &#125;&#125; 12345678910public abstract class MealBuilder &#123; Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal()&#123; return meal; &#125;&#125; 12345678910public class MealA extends MealBuilder&#123; public void buildDrink() &#123; meal.setDrink(\"可乐\"); &#125; public void buildFood() &#123; meal.setFood(\"薯条\"); &#125;&#125; 123456789101112131415161718public class KFCWaiter &#123; private MealBuilder mealBuilder; public KFCWaiter(MealBuilder mealBuilder) &#123; this.mealBuilder = mealBuilder; &#125; public Meal construct()&#123; //准备食物 mealBuilder.buildFood(); //准备饮料 mealBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return mealBuilder.getMeal(); &#125;&#125; 原型模式（对象） 有些对象是需要频繁创建的，用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的同类型的对象，分为浅克隆和深克隆，浅克隆只复制拷贝的对象，不复制引用的对象，即成员对象不复制；深克隆，引用也同样复制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); /* super.clone()是浅复制 */ return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 结构型模式解析结构型模式主要用于处理类和对象的组合 适配器模式（类和对象） 将一个接口转换成客户希望的另一个接口，从而使接口不兼容的那些类可以在一起工作。 类的适配器模式 通过一个具体的类，将适配者适配到目标接口当中 12345public class Source &#123; public void method1() &#123; System.out.println(\"this is original method!\"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; &#125; 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 对象的适配器模式 一个适配器可以将多个不同的适配者适配到同一目标 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 装饰者模式（对象） 给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例 12345678910111213141516171819202122232425262728//Sourceablepublic interface Sourceable &#123; public void method(); &#125; //Sourcepublic class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; //Decoratorpublic class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println(\"before decorator!\"); source.method(); System.out.println(\"after decorator!\"); &#125; &#125; 我寻思有点像servlet的过滤器 代理模式（对象） 多一个代理类出来，替原对象进行一些操作 12345678910111213141516171819202122232425262728293031public interface Sourceable &#123; public void method(); &#125; public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println(\"after proxy!\"); &#125; private void before() &#123; System.out.println(\"before proxy!\"); &#125; &#125; 装饰者模式和代理模式的区别： 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 外观模式（对象） 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用 外观模式包含如下角色： Facade: 外观角色 SubSystem:子系统角色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//CPUpublic class CPU &#123; public void startup()&#123; System.out.println(\"cpu startup!\"); &#125; public void shutdown()&#123; System.out.println(\"cpu shutdown!\"); &#125; &#125; //Memorypublic class Memory &#123; public void startup()&#123; System.out.println(\"memory startup!\"); &#125; public void shutdown()&#123; System.out.println(\"memory shutdown!\"); &#125; &#125; //Diskpublic class Disk &#123; public void startup()&#123; System.out.println(\"disk startup!\"); &#125; public void shutdown()&#123; System.out.println(\"disk shutdown!\"); &#125; &#125; //Facadepublic class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println(\"start the computer!\"); cpu.startup(); memory.startup(); disk.startup(); System.out.println(\"start computer finished!\"); &#125; public void shutdown()&#123; System.out.println(\"begin to close the computer!\"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(\"computer closed!\"); &#125; &#125; 桥接模式（对象） 把事物和其具体实现分开，使他们可以各自独立的变化。 将抽象化与实现化解耦，使得二者可以独立变化 12345678910111213141516171819202122232425262728293031323334353637383940public interface Sourceable &#123; public void method(); &#125; public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the first sub!\"); &#125; &#125; public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the second sub!\"); &#125; &#125;public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 组合模式（对象） 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，树等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree(\"A\"); TreeNode nodeB = new TreeNode(\"B\"); TreeNode nodeC = new TreeNode(\"C\"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(\"build the tree finished!\"); &#125; &#125; 享元模式（对象） 实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 其中，Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现；ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中；FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。 123456789101112131415161718192021222324public abstract class Flyweight &#123; //内部状态 public String intrinsic; //外部状态 protected final String extrinsic; //要求享元角色必须接受外部状态 public Flyweight(String extrinsic) &#123; this.extrinsic = extrinsic; &#125; //定义业务操作 public abstract void operate(int extrinsic); public String getIntrinsic() &#123; return intrinsic; &#125; public void setIntrinsic(String intrinsic) &#123; this.intrinsic = intrinsic; &#125;&#125; 1234567891011121314public class ConcreteFlyweight extends Flyweight &#123; //接受外部状态 public ConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; //根据外部状态进行逻辑处理 @Override public void operate(int extrinsic) &#123; System.out.println(\"具体Flyweight:\" + extrinsic); &#125;&#125; 123456789101112public class UnsharedConcreteFlyweight extends Flyweight &#123; public UnsharedConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; @Override public void operate(int extrinsic) &#123; System.out.println(\"不共享的具体Flyweight:\" + extrinsic); &#125;&#125; 1234567891011121314151617181920212223public class FlyweightFactory &#123; //定义一个池容器 private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;&gt;(); //享元工厂 public static Flyweight getFlyweight(String extrinsic) &#123; Flyweight flyweight = null; if(pool.containsKey(extrinsic)) &#123; //池中有该对象 flyweight = pool.get(extrinsic); System.out.print(\"已有 \" + extrinsic + \" 直接从池中取----&gt;\"); &#125; else &#123; //根据外部状态创建享元对象 flyweight = new ConcreteFlyweight(extrinsic); //放入池中 pool.put(extrinsic, flyweight); System.out.print(\"创建 \" + extrinsic + \" 并从池中取出----&gt;\"); &#125; return flyweight; &#125;&#125; 行为型模式解析行为型模式主要用于描述类或对象的交互以及职责分配 解释器模式（类） 主要应用在OOP开发中的编译器的开发中 给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子 ​ 模板方法模式（类） 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法中某些特定步骤 策略模式（对象） 定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化 观察者模式（对象） 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 123public interface Observer &#123; public void update(); &#125; 1234567public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer1 has received!\"); &#125; &#125; 12345678public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer2 has received!\"); &#125; &#125; 1234567891011121314public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; 12345678910111213141516171819202122public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; //提醒应当在抽象类中就实现 @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; 123456789public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println(\"update self!\"); notifyObservers(); &#125; &#125; 迭代器模式（对象） 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。 责任链模式（对象） 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求 123public interface Handler &#123; public void operator(); &#125; 12345678910111213public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125; &#125; 12345678910111213141516public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name+\"deal!\"); if(getHandler()!=null)&#123; getHandler().operator(); &#125; &#125; &#125; 命令模式（对象） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 123public interface Command &#123; public void exe(); &#125; 12345678910111213public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125; &#125; 12345public class Receiver &#123; public void action()&#123; System.out.println(\"command received!\"); &#125; &#125; 123456789101112public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.exe(); &#125; &#125; 备忘录模式（对象） 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态 123456789101112131415161718192021222324public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; 12345678910111213141516public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 12345678910111213141516public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; 状态模式（对象） 允许一个对象在其内部状态改变时能够改变它的行为 1234567891011121314151617181920public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println(\"execute the first opt!\"); &#125; public void method2()&#123; System.out.println(\"execute the second opt!\"); &#125; &#125; 123456789101112131415161718192021222324public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; if (state.getValue().equals(\"state1\")) &#123; state.method1(); &#125; else if (state.getValue().equals(\"state2\")) &#123; state.method2(); &#125; &#125; &#125; 访问者模式（对象） 表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 适用于：给一个类添加新功能，但为了兼容性考虑或其他原因不想破坏这个类 123public interface Visitor &#123; public void visit(Subject sub); &#125; 1234567public class MyVisitor implements Visitor &#123; @Override public void visit(Subject sub) &#123; System.out.println(\"visit the subject：\"+sub.getSubject()); &#125; &#125; 1234public interface Subject &#123; public void accept(Visitor visitor); public String getSubject(); &#125; 123456789101112public class MySubject implements Subject &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; @Override public String getSubject() &#123; return \"love\"; &#125; &#125; 中介者模式（对象） 用一个中介对象来封装一系列的对象交互。它使各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 1234public interface Mediator &#123; public void createMediator(); public void workAll(); &#125; 12345678910111213141516171819202122232425public class MyMediator implements Mediator &#123; private User user1; private User user2; public User getUser1() &#123; return user1; &#125; public User getUser2() &#123; return user2; &#125; @Override public void createMediator() &#123; user1 = new User1(this); user2 = new User2(this); &#125; @Override public void workAll() &#123; user1.work(); user2.work(); &#125; &#125; 1234567891011121314public abstract class User &#123; private Mediator mediator; public Mediator getMediator()&#123; return mediator; &#125; public User(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void work(); &#125; 1234567891011public class User1 extends User &#123; public User1(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user1 exe!\"); &#125; &#125; 1234567891011public class User2 extends User &#123; public User2(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user2 exe!\"); &#125; &#125; 12345678public class Test &#123; public static void main(String[] args) &#123; Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); &#125; &#125;","categories":[{"name":"中间件/软件设计","slug":"中间件-软件设计","permalink":"https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.codetool.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"我的博客搬家啦","slug":"hello-world","date":"2019-11-08T09:05:23.000Z","updated":"2019-11-08T11:49:11.083Z","comments":true,"path":"article/hello-world/","link":"","permalink":"https://www.codetool.top/article/hello-world/","excerpt":"","text":"今天弃了wordpress的坑搬来hexo啦。和gitbook差不多的用法，很快就上手了呢。再也不用忍受wordpress一堆不仅没用还加载龟速的资源了奥里给！！！","categories":[{"name":"日常/随笔","slug":"日常-随笔","permalink":"https://www.codetool.top/categories/%E6%97%A5%E5%B8%B8-%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"网站日志","slug":"网站日志","permalink":"https://www.codetool.top/tags/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"}]},{"title":"在线运行C++、java、python代码的小项目实现","slug":"在线运行C++、java、python代码的小项目实现","date":"2019-08-13T12:06:57.000Z","updated":"2019-11-12T12:44:43.694Z","comments":true,"path":"article/在线运行C++、java、python代码的小项目实现/","link":"","permalink":"https://www.codetool.top/article/%E5%9C%A8%E7%BA%BF%E8%BF%90%E8%A1%8CC++%E3%80%81java%E3%80%81python%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本网站在2019年8月12日之前用的代码演示功能是借用了 https://tool.lu/coderunner/ 的在线运行代码工具，在此致谢。 有一段时间这个工具突然失效了，我就在想能不能自己模仿着做一个类似的出来，简单分析了一下就想挑战一下自己，然后就开始动手了。 做出来的成果链接：点击此处 做的过程中查阅了很多网络资料，现整理如下： 需求分析：前端为一个实用的代码编辑器，通过ajax请求将写好的代码提交给服务器，服务器编译运行后把输出结果送回客户端显示。 其中使用的代码编辑器：CodeMirror，现在类似的工具使用的应该都是这款功能强大，可以自定样式的代码编辑器，官网： https://codemirror.net/ CodeMirror搭建前端界面先从官网下载下来CodeMirror的压缩包，解压之后得到下图目录 要在html中创建一个CodeMirror编辑器，必须添加的css和js文件是 12&lt;link href=./codemirror-5.48.2/lib/codemirror.css rel=stylesheet/&gt;&lt;script src=./codemirror-5.48.2/lib/codemirror.js&gt;&lt;/script&gt; (5.48.2为版本号，因人而异) 然后需要添加需要编辑的语言相关的js文件，可以在mode目录下找到，这里我用了两个文件： 实现JAVA和C++代码高亮（这个文件可以实现C，C++，JAVA，C#等语言）： 1&lt;script src=./codemirror-5.48.2/mode/clike/clike.js&gt;&lt;/script&gt; 实现python的代码高亮： 1&lt;script src=./codemirror-5.48.2/mode/python/python.js&gt;&lt;/script&gt; 需要更改编辑器主题样式的可以在theme目录下找到对应的主题css文件添加进去，我觉得默认主题就很好看了就没用其他主题。 为了实现括号匹配和代码折叠功能，还要添加的文件有： 123456&lt;link rel=stylesheet href=./codemirror-5.48.2/addon/fold/foldgutter.css/&gt;&lt;script src=./codemirror-5.48.2/addon/fold/foldcode.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/foldgutter.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/brace-fold.js&gt;&lt;/script&gt;&lt;script src=./codemirror-5.48.2/addon/fold/comment-fold.js&gt;&lt;/script&gt; 创建编辑器的过程： 在html中使用一个textarea占位，配置好id： 1&lt;textarea id=code name=code&gt;&lt;/textarea&gt; 通过对应的js代码创建编辑器： 123456789101112var editor = CodeMirror.fromTextArea(document.getElementById(code), &#123; mode: text/x-java, //实现Java代码高亮 //mode: text/x-c++src, //实现C++代码高亮 //mode: text/x-python, //实现Python代码高亮 indentUnit:4,//以四个空格的长度缩进 indentWithTabs: true,//以tab代替空格缩进 lineNumbers: true, //显示行号 lineWrapping: true, foldGutter: true, //代码折叠 gutters: [CodeMirror-linenumbers, CodeMirror-foldgutter], matchBrackets: true //括号匹配 &#125;); 这里需要什么语言高亮需要在官网找到对应语言的 MIME types ，写在mode参数中 其他相关js函数： 编辑器的大小通过 editor.setSize(width, height) 方法设置 获取编辑器内的代码：editor.getValue() 设置编辑器内的代码：editor.setValue() 设置编辑器的配置选项: editor.setOption() 最终搭配上bootstrap样式做出来的效果是这样的： js实现前端逻辑使用JQuery简化js的写法 关键代码： 切换语言事件 1234567891011121314//选择语言事件$(\"#lang\").on('change', () =&gt; &#123; lang = $(\"#lang\").val() if (lang == 'java') &#123; editor.setOption(\"mode\", \"text/x-java\") editor.setValue(javacode) &#125; else if (lang == \"cpp\") &#123; editor.setOption(\"mode\", \"text/x-c++src\") editor.setValue(cppcode) &#125; else if (lang == \"python\") &#123; editor.setOption(\"mode\", \"text/x-python\") editor.setValue(pythoncode) &#125;&#125;) 发送POST请求 1234567891011121314151617181920212223242526272829$(function()&#123; //点击运行按钮后的事件 $(\"#run\").on(\"click\",()=&gt;&#123; var codesrc = editor.getValue(); //给源代码编码 var codeEncoded = encodeURIComponent(codesrc); $(\"output\").html = 'console&gt;&gt;' + '正在努力执行中...'; //发出post请求 $.post( \"/runcode.php\", &#123; lang:lang,codesrc:codeEncoded &#125;, (data)=&gt;&#123; var outputs = data.output; var status1 = data.status1; var output = ''; //拼接输出结果 if(status1 !== 1)&#123; for(var i in outputs) &#123; output = output + outputs[i] + '&lt;br/&gt;'; &#125;data &#125;else&#123; var outputs1 = data.output1; for(var i in outputs1) &#123; output = output + outputs1[i] + '&lt;br/&gt;'; &#125; &#125; $(\"output\").html = 'console&gt;&gt;' + output; &#125;, \"json\"); &#125;)&#125;); 注： 由于代码中可能出现 + 或 &amp; 等符号，其在post的请求中经过urlencode会分别被解析为空格和参数连接符，需先将代码源码用js的encodeURIComponent()函数编码，传递到php后端后再用rawurldecode()函数进行解码操作。 php实现后端php的任务是在服务器上运行代码，核心的思想是将接收到的代码写入文件，使用各种环境去执行，并返回结果 其中用到了exec函数 具体参阅 【php】php使用exec总结 做的时候遇到了个问题：php在调用exec执行gcc命令时，会出现各种毛病，例如ld链接器找不到，后来发现原因是php不会使用系统设置的环境变量，在php文件开头添加这样一句话就能解决问题： 1putenv(PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin);//设置环境变量","categories":[{"name":"项目总结","slug":"项目总结","permalink":"https://www.codetool.top/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.codetool.top/tags/php/"},{"name":"CodeMirror","slug":"CodeMirror","permalink":"https://www.codetool.top/tags/CodeMirror/"}]}]}