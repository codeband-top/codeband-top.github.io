{"meta":{"title":"代码段小站","subtitle":"CodeBand CodeTool - 个人计算机类练手小博客","description":"","author":"Rhett Peng","url":"https://www.codetool.top","root":"/"},"pages":[{"title":"categories","date":"2019-11-08T08:52:52.000Z","updated":"2019-11-08T08:52:52.318Z","comments":true,"path":"categories/index.html","permalink":"https://www.codetool.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-08T08:52:44.000Z","updated":"2019-11-08T08:52:44.442Z","comments":true,"path":"tags/index.html","permalink":"https://www.codetool.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"23种设计模式归纳","slug":"23种设计模式归纳","date":"2019-11-08T10:05:23.000Z","updated":"2019-11-08T10:49:51.954Z","comments":true,"path":"2019/11/08/23种设计模式归纳/","link":"","permalink":"https://www.codetool.top/2019/11/08/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%BA%B3/","excerpt":"","text":"1 参考文档 23种设计模式全解析 - codeTao - 博客园 设计模式（创建型） - 八一鱼 - 博客园 设计模式（结构型） - 八一鱼 - 博客园 代理模式和装饰者模式的区别 - 夜的第八章 - 博客园 简说设计模式——享元模式 - JAdam - 博客园 2 设计模式的分类 类模式处理类与子类的关系，通过处理这些关系来建立继承，属于静态关系，在编译时候确定下来；对象模式处理对象之间的关系，运行时发生变化，属于动态关系。 2.1 创建型模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 2.2 结构型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 2.3 行为型模式 策略模式 模板方法模式 观察者模式 迭代器模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 3 设计模式遵守的设计原则也是类的设计遵守的原则 3.1 单一职责原则SRP每个类只做一件事，但该原则也不适用于聚合类。 聚合类需要优先使用对象组合，而不是类继承 3.2 里氏替换原则LSP 子类的对象提供了父类的所有行为，且加上子类额外的一些东西（可以是功能，也可以是属性） 当程序基于父类实现时，如果将子类替换父类而程序不需要修改，则说明符合LSP原则 子类必须能替换成它们的父类 3.3 依赖倒置原则DIP也叫依赖反转原则。 高层模块不应该直接依赖低层模块，两者都应该依赖抽象层。 抽象不能依赖细节，细节必须依赖抽象。 3.4 接口隔离原则ISP 客户端不应该被强迫去依赖它们并不需要的接口 不满足ISP的类应该拆分成多个接口， 通过一个抽象类去实现它们，再去继承这个抽象父类。 3.5 开闭原则 对拓展开放，对修改封闭 对使用者修改关闭，对提供者拓展开放 4 创建型模式解析 在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。 4.1 工厂方法模式（类） 创建一个工厂接口和创建多个工厂实现类 4.2 抽象工厂模式（对象） 区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 4.3 单例模式（对象） 在一个JVM中，该类只有一个对象实例存在。 12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 多线程下的优化： 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 原理： JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕 4.4 建造者模式（对象） 在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 Director的作用： 隔离客户与生产过程。 负责控制产品的生成过程。 1234567891011121314151617181920public class Meal &#123; private String food; private String drink; public String getFood() &#123; return food; &#125; public void setFood(String food) &#123; this.food = food; &#125; public String getDrink() &#123; return drink; &#125; public void setDrink(String drink) &#123; this.drink = drink; &#125;&#125; 12345678910public abstract class MealBuilder &#123; Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal()&#123; return meal; &#125;&#125; 12345678910public class MealA extends MealBuilder&#123; public void buildDrink() &#123; meal.setDrink(\"可乐\"); &#125; public void buildFood() &#123; meal.setFood(\"薯条\"); &#125;&#125; 123456789101112131415161718public class KFCWaiter &#123; private MealBuilder mealBuilder; public KFCWaiter(MealBuilder mealBuilder) &#123; this.mealBuilder = mealBuilder; &#125; public Meal construct()&#123; //准备食物 mealBuilder.buildFood(); //准备饮料 mealBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return mealBuilder.getMeal(); &#125;&#125; 4.5 原型模式（对象） 有些对象是需要频繁创建的，用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的同类型的对象，分为浅克隆和深克隆，浅克隆只复制拷贝的对象，不复制引用的对象，即成员对象不复制；深克隆，引用也同样复制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); /* super.clone()是浅复制 */ return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 5 结构型模式解析结构型模式主要用于处理类和对象的组合 5.1 适配器模式（类和对象） 将一个接口转换成客户希望的另一个接口，从而使接口不兼容的那些类可以在一起工作。 5.1.1 类的适配器模式 通过一个具体的类，将适配者适配到目标接口当中 12345public class Source &#123; public void method1() &#123; System.out.println(\"this is original method!\"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; &#125; 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 5.1.2 对象的适配器模式 一个适配器可以将多个不同的适配者适配到同一目标 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 5.2 装饰者模式（对象） 给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例 12345678910111213141516171819202122232425262728//Sourceablepublic interface Sourceable &#123; public void method(); &#125; //Sourcepublic class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; //Decoratorpublic class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println(\"before decorator!\"); source.method(); System.out.println(\"after decorator!\"); &#125; &#125; 我寻思有点像servlet的过滤器 5.3 代理模式（对象） 多一个代理类出来，替原对象进行一些操作 12345678910111213141516171819202122232425262728293031public interface Sourceable &#123; public void method(); &#125; public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; &#125; public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println(\"after proxy!\"); &#125; private void before() &#123; System.out.println(\"before proxy!\"); &#125; &#125; 装饰者模式和代理模式的区别： 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 5.4 外观模式（对象） 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用 外观模式包含如下角色： Facade: 外观角色 SubSystem:子系统角色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//CPUpublic class CPU &#123; public void startup()&#123; System.out.println(\"cpu startup!\"); &#125; public void shutdown()&#123; System.out.println(\"cpu shutdown!\"); &#125; &#125; //Memorypublic class Memory &#123; public void startup()&#123; System.out.println(\"memory startup!\"); &#125; public void shutdown()&#123; System.out.println(\"memory shutdown!\"); &#125; &#125; //Diskpublic class Disk &#123; public void startup()&#123; System.out.println(\"disk startup!\"); &#125; public void shutdown()&#123; System.out.println(\"disk shutdown!\"); &#125; &#125; //Facadepublic class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println(\"start the computer!\"); cpu.startup(); memory.startup(); disk.startup(); System.out.println(\"start computer finished!\"); &#125; public void shutdown()&#123; System.out.println(\"begin to close the computer!\"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(\"computer closed!\"); &#125; &#125; 5.5 桥接模式（对象） 把事物和其具体实现分开，使他们可以各自独立的变化。 将抽象化与实现化解耦，使得二者可以独立变化 12345678910111213141516171819202122232425262728293031323334353637383940public interface Sourceable &#123; public void method(); &#125; public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the first sub!\"); &#125; &#125; public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the second sub!\"); &#125; &#125;public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 5.6 组合模式（对象） 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，树等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree(\"A\"); TreeNode nodeB = new TreeNode(\"B\"); TreeNode nodeC = new TreeNode(\"C\"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(\"build the tree finished!\"); &#125; &#125; 5.7 享元模式（对象） 实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 其中，Flyweight是抽象享元角色。它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现；ConcreteFlyweight是具体享元角色，是具体的产品类，实现抽象角色定义的业务；UnsharedConcreteFlyweight是不可共享的享元角色，一般不会出现在享元工厂中；FlyweightFactory是享元工厂，它用于构造一个池容器，同时提供从池中获得对象的方法。 123456789101112131415161718192021222324public abstract class Flyweight &#123; //内部状态 public String intrinsic; //外部状态 protected final String extrinsic; //要求享元角色必须接受外部状态 public Flyweight(String extrinsic) &#123; this.extrinsic = extrinsic; &#125; //定义业务操作 public abstract void operate(int extrinsic); public String getIntrinsic() &#123; return intrinsic; &#125; public void setIntrinsic(String intrinsic) &#123; this.intrinsic = intrinsic; &#125;&#125; 1234567891011121314public class ConcreteFlyweight extends Flyweight &#123; //接受外部状态 public ConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; //根据外部状态进行逻辑处理 @Override public void operate(int extrinsic) &#123; System.out.println(\"具体Flyweight:\" + extrinsic); &#125;&#125; 123456789101112public class UnsharedConcreteFlyweight extends Flyweight &#123; public UnsharedConcreteFlyweight(String extrinsic) &#123; super(extrinsic); &#125; @Override public void operate(int extrinsic) &#123; System.out.println(\"不共享的具体Flyweight:\" + extrinsic); &#125;&#125; 1234567891011121314151617181920212223public class FlyweightFactory &#123; //定义一个池容器 private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;&gt;(); //享元工厂 public static Flyweight getFlyweight(String extrinsic) &#123; Flyweight flyweight = null; if(pool.containsKey(extrinsic)) &#123; //池中有该对象 flyweight = pool.get(extrinsic); System.out.print(\"已有 \" + extrinsic + \" 直接从池中取----&gt;\"); &#125; else &#123; //根据外部状态创建享元对象 flyweight = new ConcreteFlyweight(extrinsic); //放入池中 pool.put(extrinsic, flyweight); System.out.print(\"创建 \" + extrinsic + \" 并从池中取出----&gt;\"); &#125; return flyweight; &#125;&#125; 6 行为型模式解析行为型模式主要用于描述类或对象的交互以及职责分配 6.1 解释器模式（类） 主要应用在OOP开发中的编译器的开发中 给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子 ​ 6.2 模板方法模式（类） 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法中某些特定步骤 6.3 策略模式（对象） 定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化 6.4 观察者模式（对象） 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 123public interface Observer &#123; public void update(); &#125; 1234567public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer1 has received!\"); &#125; &#125; 12345678public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer2 has received!\"); &#125; &#125; 1234567891011121314public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; 12345678910111213141516171819202122public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; //提醒应当在抽象类中就实现 @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; 123456789public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println(\"update self!\"); notifyObservers(); &#125; &#125; 6.5 迭代器模式（对象） 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。 6.6 责任链模式（对象） 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求 123public interface Handler &#123; public void operator(); &#125; 12345678910111213public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125; &#125; 12345678910111213141516public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name+\"deal!\"); if(getHandler()!=null)&#123; getHandler().operator(); &#125; &#125; &#125; 6.7 命令模式（对象） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 123public interface Command &#123; public void exe(); &#125; 12345678910111213public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125; &#125; 12345public class Receiver &#123; public void action()&#123; System.out.println(\"command received!\"); &#125; &#125; 123456789101112public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.exe(); &#125; &#125; 6.8 备忘录模式（对象） 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态 123456789101112131415161718192021222324public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; 12345678910111213141516public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 12345678910111213141516public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; 6.9 状态模式（对象） 允许一个对象在其内部状态改变时能够改变它的行为 1234567891011121314151617181920public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println(\"execute the first opt!\"); &#125; public void method2()&#123; System.out.println(\"execute the second opt!\"); &#125; &#125; 123456789101112131415161718192021222324public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; if (state.getValue().equals(\"state1\")) &#123; state.method1(); &#125; else if (state.getValue().equals(\"state2\")) &#123; state.method2(); &#125; &#125; &#125; 6.10 访问者模式（对象） 表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 适用于：给一个类添加新功能，但为了兼容性考虑或其他原因不想破坏这个类 123public interface Visitor &#123; public void visit(Subject sub); &#125; 1234567public class MyVisitor implements Visitor &#123; @Override public void visit(Subject sub) &#123; System.out.println(\"visit the subject：\"+sub.getSubject()); &#125; &#125; 1234public interface Subject &#123; public void accept(Visitor visitor); public String getSubject(); &#125; 123456789101112public class MySubject implements Subject &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; @Override public String getSubject() &#123; return \"love\"; &#125; &#125; 6.11 中介者模式（对象） 用一个中介对象来封装一系列的对象交互。它使各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 1234public interface Mediator &#123; public void createMediator(); public void workAll(); &#125; 12345678910111213141516171819202122232425public class MyMediator implements Mediator &#123; private User user1; private User user2; public User getUser1() &#123; return user1; &#125; public User getUser2() &#123; return user2; &#125; @Override public void createMediator() &#123; user1 = new User1(this); user2 = new User2(this); &#125; @Override public void workAll() &#123; user1.work(); user2.work(); &#125; &#125; 1234567891011121314public abstract class User &#123; private Mediator mediator; public Mediator getMediator()&#123; return mediator; &#125; public User(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void work(); &#125; 1234567891011public class User1 extends User &#123; public User1(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user1 exe!\"); &#125; &#125; 1234567891011public class User2 extends User &#123; public User2(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println(\"user2 exe!\"); &#125; &#125; 12345678public class Test &#123; public static void main(String[] args) &#123; Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); &#125; &#125;","categories":[{"name":"中间件/软件设计","slug":"中间件-软件设计","permalink":"https://www.codetool.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.codetool.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-08T07:45:35.488Z","updated":"2019-11-08T07:45:35.488Z","comments":true,"path":"2019/11/08/hello-world/","link":"","permalink":"https://www.codetool.top/2019/11/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 0.1 Quick Start0.1.1 Create a new post1$ hexo new \"My New Post\" More info: Writing 0.1.2 Run server1$ hexo server More info: Server 0.1.3 Generate static files1$ hexo generate More info: Generating 0.1.4 Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}